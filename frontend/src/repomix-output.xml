This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
app/app.component.html
app/app.component.scss
app/app.component.spec.ts
app/app.component.ts
app/app.config.server.ts
app/app.config.ts
app/app.routes.server.ts
app/app.routes.ts
app/auth/admin.guard.ts
app/auth/auth.guard.ts
app/auth/auth.interceptor.ts
app/auth/auth.service.ts
app/auth/inactivity.service.ts
app/auth/token-storage.service.ts
app/auth/user.guard.ts
app/enviornments/environment.prod.ts
app/enviornments/environment.ts
app/features/admin-dashboard/admin-dashboard.component.html
app/features/admin-dashboard/admin-dashboard.component.scss
app/features/admin-dashboard/admin-dashboard.component.ts
app/features/admin/admin-categories/admin-category-form/admin-category-form.component.html
app/features/admin/admin-categories/admin-category-form/admin-category-form.component.scss
app/features/admin/admin-categories/admin-category-form/admin-category-form.component.ts
app/features/admin/admin-categories/admin-category-list/admin-category-list.component.html
app/features/admin/admin-categories/admin-category-list/admin-category-list.component.scss
app/features/admin/admin-categories/admin-category-list/admin-category-list.component.ts
app/features/admin/admin-orders/admin-order-detail/admin-order-detail.component.html
app/features/admin/admin-orders/admin-order-detail/admin-order-detail.component.scss
app/features/admin/admin-orders/admin-order-detail/admin-order-detail.component.ts
app/features/admin/admin-orders/admin-order-list/admin-order-list.component.html
app/features/admin/admin-orders/admin-order-list/admin-order-list.component.scss
app/features/admin/admin-orders/admin-order-list/admin-order-list.component.ts
app/features/admin/admin-specifications/admin-spec-def-form/admin-spec-def-form.component.html
app/features/admin/admin-specifications/admin-spec-def-form/admin-spec-def-form.component.scss
app/features/admin/admin-specifications/admin-spec-def-form/admin-spec-def-form.component.ts
app/features/admin/admin-specifications/admin-spec-def-list/admin-spec-def-list.component.html
app/features/admin/admin-specifications/admin-spec-def-list/admin-spec-def-list.component.scss
app/features/admin/admin-specifications/admin-spec-def-list/admin-spec-def-list.component.ts
app/features/admin/admin-users/admin-user-form/admin-user-form.component.html
app/features/admin/admin-users/admin-user-form/admin-user-form.component.scss
app/features/admin/admin-users/admin-user-form/admin-user-form.component.ts
app/features/admin/admin-users/admin-user-list/admin-user-list.component.html
app/features/admin/admin-users/admin-user-list/admin-user-list.component.scss
app/features/admin/admin-users/admin-user-list/admin-user-list.component.ts
app/features/admin/reports/reports.component.html
app/features/admin/reports/reports.component.scss
app/features/admin/reports/reports.component.ts
app/features/admin/services/category.admin.service.ts
app/features/admin/services/order.admin.service.ts
app/features/admin/services/report.service.ts
app/features/admin/services/specification-admin.service.ts
app/features/admin/services/user-admin.service.ts
app/features/checkout/checkout.component.html
app/features/checkout/checkout.component.scss
app/features/checkout/checkout.component.ts
app/features/home/home-page/home-page.component.html
app/features/home/home-page/home-page.component.scss
app/features/home/home-page/home-page.component.spec.ts
app/features/home/home-page/home-page.component.ts
app/features/products/product-detail/product-detail.component.html
app/features/products/product-detail/product-detail.component.scss
app/features/products/product-detail/product-detail.component.ts
app/features/products/product-form/product-form.component.html
app/features/products/product-form/product-form.component.scss
app/features/products/product-form/product-form.component.ts
app/features/products/product-list/product-list.component.html
app/features/products/product-list/product-list.component.scss
app/features/products/product-list/product-list.component.ts
app/features/products/product.service.ts
app/features/products/products.module.ts
app/features/products/user-product-list/user-product-list.component.html
app/features/products/user-product-list/user-product-list.component.scss
app/features/products/user-product-list/user-product-list.component.spec.ts
app/features/products/user-product-list/user-product-list.component.ts
app/features/reviews/review-form-dialog/review-form-dialog.component.ts
app/features/reviews/review-list/review-list.component.html
app/features/reviews/review-list/review-list.component.scss
app/features/reviews/review-list/review-list.component.ts
app/features/reviews/review.service.ts
app/features/shopping-cart/cart.service.ts
app/features/shopping-cart/shopping-cart.component.html
app/features/shopping-cart/shopping-cart.component.scss
app/features/shopping-cart/shopping-cart.component.ts
app/features/user-dashboard/services/client-order.service.ts
app/features/user-dashboard/user-dashboard.component.html
app/features/user-dashboard/user-dashboard.component.scss
app/features/user-dashboard/user-dashboard.component.ts
app/features/user-dashboard/user-order-history/user-order-history.component.html
app/features/user-dashboard/user-order-history/user-order-history.component.scss
app/features/user-dashboard/user-order-history/user-order-history.component.ts
app/features/user-profile/user-profile.component.html
app/features/user-profile/user-profile.component.scss
app/features/user-profile/user-profile.component.ts
app/features/user-profile/user-profile.service.ts
app/login/login.component.html
app/login/login.component.scss
app/login/login.component.ts
app/shared/components/star-rating/star-rating.component.ts
app/shared/in-memory-data.service.ts
app/shared/material.module.ts
app/shared/models/cart.model.ts
app/shared/models/category.model.ts
app/shared/models/order-item.model.ts
app/shared/models/order-status-update.model.ts
app/shared/models/order.model.ts
app/shared/models/product.model.ts
app/shared/models/report.model.ts
app/shared/models/review.model.ts
app/shared/models/specification-definition.model.ts
app/shared/models/specification-value.model.ts
app/shared/models/user.model.ts
app/shared/pipes/nl2br.pipe.ts
app/signup/signup.component.html
app/signup/signup.component.scss
app/signup/signup.component.ts
index.html
main.server.ts
main.ts
server.ts
styles.scss
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="app/app.component.html">
<mat-toolbar color="primary" class="app-toolbar" *ngIf="!hideToolbar">
  <button mat-icon-button routerLink="/" aria-label="Pagina principală">
    <mat-icon>storefront</mat-icon>
  </button>
  <span class="app-title" routerLink="/">{{ title }}</span>

  <span class="toolbar-spacer"></span>

  <button mat-button (click)="navigateToProducts()">
    <mat-icon>list_alt</mat-icon> Produse
  </button>

  <button mat-icon-button routerLink="/cart" aria-label="Coș de cumpărături">
    <mat-icon>shopping_cart</mat-icon>
  </button>

  <ng-container *ngIf="!isLoggedIn">
    <button mat-stroked-button routerLink="/login" class="auth-button">
      <mat-icon>login</mat-icon> Autentificare
    </button>
  </ng-container>

  <ng-container *ngIf="isLoggedIn">
    <button mat-button [matMenuTriggerFor]="userMenu" class="user-menu-button">
      <mat-icon>account_circle</mat-icon>
      <span>{{ username || 'Cont' }}</span>
      <mat-icon>arrow_drop_down</mat-icon>
    </button>
    <mat-menu #userMenu="matMenu">
      <button mat-menu-item routerLink="/my-profile" *ngIf="userRole === 'user'">
        <mat-icon>manage_accounts</mat-icon> Profilul Meu
      </button>
      <button mat-menu-item routerLink="/my-orders" *ngIf="userRole === 'user'">
        <mat-icon>history</mat-icon> Comenzile Mele
      </button>
      <button mat-menu-item routerLink="/admin" *ngIf="userRole === 'admin'">
        <mat-icon>admin_panel_settings</mat-icon> Panou Admin
      </button>
      <mat-divider></mat-divider>
      <button mat-menu-item (click)="logout()">
        <mat-icon>logout</mat-icon> Deconectare
      </button>
    </mat-menu>
  </ng-container>
</mat-toolbar>

<div class="main-content">
  <router-outlet></router-outlet>
</div>
</file>

<file path="app/app.component.scss">
.app-toolbar {
  position: sticky;
  top: 0;
  z-index: 1000;
  
  .app-title {
    margin-left: 8px;
    cursor: pointer;
    font-size: 1.25em;
  }

  .toolbar-spacer {
    flex: 1 1 auto;
  }

  button[mat-button], button[mat-stroked-button], button[mat-icon-button] {
    margin: 0 4px;
  }
}

.main-content {
  min-height: calc(100vh - 64px);
}
</file>

<file path="app/app.component.spec.ts">
import { TestBed } from '@angular/core/testing';
import { AppComponent } from './app.component';

describe('AppComponent', () => {
  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [AppComponent],
    }).compileComponents();
  });

  it('should create the app', () => {
    const fixture = TestBed.createComponent(AppComponent);
    const app = fixture.componentInstance;
    expect(app).toBeTruthy();
  });

  it(`should have the 'magazin-calculatoare' title`, () => {
    const fixture = TestBed.createComponent(AppComponent);
    const app = fixture.componentInstance;
    expect(app.title).toEqual('magazin-calculatoare');
  });

  it('should render title', () => {
    const fixture = TestBed.createComponent(AppComponent);
    fixture.detectChanges();
    const compiled = fixture.nativeElement as HTMLElement;
    expect(compiled.querySelector('h1')?.textContent).toContain('Hello, magazin-calculatoare');
  });
});
</file>

<file path="app/app.component.ts">
// frontend/src/app/app.component.ts
import { Component, inject, OnInit, OnDestroy } from '@angular/core';
import { CommonModule } from '@angular/common';
import { RouterOutlet, RouterModule, Router, NavigationEnd } from '@angular/router';
import { MatToolbarModule } from '@angular/material/toolbar';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatMenuModule } from '@angular/material/menu';
import { MatBadgeModule } from '@angular/material/badge';
import { MatDividerModule } from '@angular/material/divider';
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar';
import { InactivityService } from './auth/inactivity.service';
import { AuthService } from './auth/auth.service';
import { Subscription } from 'rxjs';
import { filter } from 'rxjs/operators';

@Component({
  selector: 'app-root',
  standalone: true,
  imports: [
    CommonModule,
    RouterOutlet,
    RouterModule,
    MatToolbarModule,
    MatButtonModule,
    MatIconModule,
    MatMenuModule,
    MatBadgeModule,
    MatDividerModule,
    MatSnackBarModule
  ],
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.scss']
})
export class AppComponent implements OnInit, OnDestroy {
  title = 'Magazin Calculatoare';
  isLoggedIn = false;
  username: string | null = null;
  userRole: string | null = null;

  private authSubscription!: Subscription;
  private routerSubscription!: Subscription;

  public authService = inject(AuthService);
  private router = inject(Router);
  private inactivityService = inject(InactivityService);
  private snackBar = inject(MatSnackBar);

  hideToolbar = false;

  ngOnInit(): void {
    this.authSubscription = this.authService.user$.subscribe(user => {
      this.isLoggedIn = !!user;
      this.username = user ? user.username : null;
      this.userRole = this.authService.role;
      
      if (this.isLoggedIn) {
        this.inactivityService.startWatching();
      } else {
        this.inactivityService.stopWatching();
      }
    });

    this.isLoggedIn = this.authService.isLoggedIn();
    if (this.isLoggedIn) {
      const currentUser = this.authService.getCurrentUser();
      this.username = currentUser ? currentUser.username : null;
      this.userRole = this.authService.role;
    }

    this.routerSubscription = this.router.events.pipe(
      filter(event => event instanceof NavigationEnd)
    ).subscribe(event => {
      if (event instanceof NavigationEnd) {
        this.hideToolbar = event.urlAfterRedirects === '/login' || event.urlAfterRedirects.startsWith('/signup');
      }
    });
  }

  navigateToProducts(): void {
    if (!this.authService.isLoggedIn()) {
      this.snackBar.open('Trebuie să fii autentificat pentru a vedea produsele.', 'Login', {
        duration: 5000,
      }).onAction().subscribe(() => {
        this.router.navigate(['/login'], { queryParams: { returnUrl: '/products-list' } });
      });
    } else {
      this.router.navigate(['/products-list']);
    }
  }

  private clearNonPersistentAuth(): void {
    if (!this.authService.isLoggedIn()) {
      this.authService.logout();
    }
  }

  logout(): void {
    this.authService.logout();
  }

  ngOnDestroy(): void {
    if (this.authSubscription) {
      this.authSubscription.unsubscribe();
    }
    if (this.routerSubscription) {
      this.routerSubscription.unsubscribe();
    }
    this.inactivityService.stopWatching();
  }
}
</file>

<file path="app/app.config.server.ts">
import { mergeApplicationConfig, ApplicationConfig } from '@angular/core';
import { provideServerRendering }                     from '@angular/platform-server';
import { provideServerRouting }                      from '@angular/ssr';
import { appConfig }                                 from './app.config';
import { serverRoutes }                              from './app.routes.server';

const serverConfig: ApplicationConfig = {
  providers: [
    provideServerRendering(),
    provideServerRouting(serverRoutes)
    // **nu** importa InMemoryWebApi aici!
  ]
};

export const config = mergeApplicationConfig(appConfig, serverConfig);
</file>

<file path="app/app.config.ts">
// src/app/app.config.ts
import { ApplicationConfig, importProvidersFrom } from '@angular/core';
import { provideRouter, withComponentInputBinding, withInMemoryScrolling, withViewTransitions } from '@angular/router';
import { provideHttpClient, withFetch, withInterceptors, withInterceptorsFromDi, HTTP_INTERCEPTORS } from '@angular/common/http';
import { provideAnimations } from '@angular/platform-browser/animations';

// Comentează sau elimină HttpClientInMemoryWebApiModule pentru a folosi backend-ul real
// import { HttpClientInMemoryWebApiModule } from 'angular-in-memory-web-api';
// import { InMemoryDataService } from './shared/in-memory-data.service'; // Comentat

import { routes } from './app.routes';
import { AuthInterceptor } from './auth/auth.interceptor'; // <<<--- CALE CORECTATĂ

export const appConfig: ApplicationConfig = {
  providers: [
    provideRouter(
      routes,
      withComponentInputBinding(),
      withInMemoryScrolling({
        scrollPositionRestoration: 'enabled',
        anchorScrolling: 'enabled',
      }),
      withViewTransitions()
    ),

    provideAnimations(),

    provideHttpClient(
      withFetch(),
      withInterceptorsFromDi()
    ),

    { provide: HTTP_INTERCEPTORS, useClass: AuthInterceptor, multi: true },

    /*
    importProvidersFrom(
      HttpClientInMemoryWebApiModule.forRoot(InMemoryDataService, {
        dataEncapsulation: false,
        passThruUnknownUrl: true,
        delay: 300
      })
    )
    */
  ]
};
</file>

<file path="app/app.routes.server.ts">
import { RenderMode, ServerRoute } from '@angular/ssr';

export const serverRoutes: ServerRoute[] = [
  {
    path: '**',
    renderMode: RenderMode.Prerender
  }
];
</file>

<file path="app/app.routes.ts">
import { Routes } from '@angular/router';

// Componenta noua pentru pagina principala
import { HomePageComponent } from './features/home/home-page/home-page.component';

// Componente pentru autentificare si dashboard-uri
import { LoginComponent } from './login/login.component';
import { AdminDashboardComponent } from './features/admin-dashboard/admin-dashboard.component';

// Componente publice
import { ProductListComponent } from './features/products/product-list/product-list.component';
import { ProductDetailComponent } from './features/products/product-detail/product-detail.component';

// Componente pentru sectiuni specifice (Admin & User)
import { AdminCategoryListComponent } from './features/admin/admin-categories/admin-category-list/admin-category-list.component';
import { AdminCategoryFormComponent } from './features/admin/admin-categories/admin-category-form/admin-category-form.component';
import { AdminOrderListComponent } from './features/admin/admin-orders/admin-order-list/admin-order-list.component';
import { AdminOrderDetailComponent } from './features/admin/admin-orders/admin-order-detail/admin-order-detail.component';
import { AdminSpecDefListComponent } from './features/admin/admin-specifications/admin-spec-def-list/admin-spec-def-list.component';
import { AdminSpecDefFormComponent } from './features/admin/admin-specifications/admin-spec-def-form/admin-spec-def-form.component';
import { AdminUserListComponent } from './features/admin/admin-users/admin-user-list/admin-user-list.component';
import { AdminUserFormComponent } from './features/admin/admin-users/admin-user-form/admin-user-form.component';
import { ProductFormComponent } from './features/products/product-form/product-form.component';
import { UserOrderHistoryComponent } from './features/user-dashboard/user-order-history/user-order-history.component';
import { SignupComponent } from './signup/signup.component';
import { ReportsComponent } from './features/admin/reports/reports.component';


// Guards pentru securizarea rutelor
import { userGuard } from './auth/user.guard';
import { adminGuard } from './auth/admin.guard';

import { ShoppingCartComponent } from './features/shopping-cart/shopping-cart.component';
import { CheckoutComponent } from './features/checkout/checkout.component';
import { UserProductListComponent } from './features/products/user-product-list/user-product-list.component';
import { UserProfileComponent } from './features/user-profile/user-profile.component';

export const routes: Routes = [
  // Pagina principala (default), publica
  { path: '', component: HomePageComponent, title: 'VipeX Technology' },

  // Ruta de autentificare
  { path: 'login', component: LoginComponent, title: 'Autentificare' },
  
  // Rutele de detalii produs și catalog rămân publice
  { path: 'products-list', component: UserProductListComponent, title: 'Catalog Produse' }, // Ruta pentru tabelul vechi
  { path: 'products/:id', component: ProductDetailComponent, title: 'Detalii Produs' },

   // Ruta pentru coșul de cumpărături
  { path: 'cart', component: ShoppingCartComponent, canActivate: [userGuard], title: 'Coș de Cumpărături' },
  // Ruta pentru finalizarea comenzii
  { path: 'checkout', component: CheckoutComponent, canActivate: [userGuard], title: 'Finalizare Comandă' },
  
  // Rute protejate pentru Utilizator (fără un dashboard-wrapper)
  { path: 'my-orders', component: UserOrderHistoryComponent, canActivate: [userGuard], title: 'Comenzile Mele' },
  // { path: 'my-profile', component: UserProfileComponent, canActivate: [userGuard], title: 'Profilul Meu' },
  { path: 'signup', component: SignupComponent, title: 'Înregistrare' },
 { path: 'my-profile', component: UserProfileComponent, canActivate: [userGuard], title: 'Profilul Meu' },

  // Rute protejate pentru Administrator
  {
    path: 'admin',
    component: AdminDashboardComponent,
    canActivate: [adminGuard],
    children: [
      { path: '', redirectTo: 'products', pathMatch: 'full' },
      { path: 'products', children: [
          { path: '', component: ProductListComponent, title: 'Administrare Produse' },
          { path: 'new', component: ProductFormComponent, title: 'Adaugă Produs' },
          { path: 'edit/:id', component: ProductFormComponent, title: 'Editează Produs' },
      ]},
      { path: 'categories', children: [
          { path: '', component: AdminCategoryListComponent, title: 'Administrare Categorii' },
          { path: 'new', component: AdminCategoryFormComponent, title: 'Adaugă Categorie' },
          { path: 'edit/:id', component: AdminCategoryFormComponent, title: 'Editează Categorie' },
      ]},
      { path: 'orders', children: [
          { path: '', component: AdminOrderListComponent, title: 'Administrare Comenzi' },
          { path: ':id', component: AdminOrderDetailComponent, title: 'Detalii Comandă' },
      ]},
      { path: 'specification-definitions', children: [
          { path: '', component: AdminSpecDefListComponent, title: 'Definiții Specificații' },
          { path: 'new', component: AdminSpecDefFormComponent, title: 'Adaugă Definiție' },
          { path: 'edit/:id', component: AdminSpecDefFormComponent, title: 'Editează Definiție' },
      ]},
      { path: 'users', children: [
          { path: '', component: AdminUserListComponent, title: 'Administrare Utilizatori' },
          { path: 'edit/:id', component: AdminUserFormComponent, title: 'Editează Utilizator' },
      ]},
       { path: 'reports', component: ReportsComponent, title: 'Rapoarte' },
    ]
  },

  // Orice altceva redirecționează la pagina principală
  { path: '**', redirectTo: '', pathMatch: 'full' }
];
</file>

<file path="app/auth/admin.guard.ts">
// src/app/auth/admin.guard.ts
import { inject } from '@angular/core';
import { CanActivateFn, Router, UrlTree, ActivatedRouteSnapshot, RouterStateSnapshot } from '@angular/router';
import { AuthService } from './auth.service';

export const adminGuard: CanActivateFn = (route: ActivatedRouteSnapshot, state: RouterStateSnapshot): boolean | UrlTree => {
  const authService = inject(AuthService);
  const router = inject(Router);

  if (authService.isLoggedIn() && authService.role === 'admin') {
    return true;
  } else if (authService.isLoggedIn() && authService.role !== 'admin') {
    // Utilizator logat dar nu e admin, redirecționează la pagina lui de user
    console.warn('AdminGuard: User is logged in but not an admin. Redirecting to /user');
    return router.createUrlTree(['/user']); // Sau o pagină 'unauthorized' dedicată
  } else {
    // Utilizator nelogat
    console.warn('AdminGuard: User not logged in. Redirecting to /login with returnUrl:', state.url);
    return router.createUrlTree(['/login'], { queryParams: { returnUrl: state.url } });
  }
};
</file>

<file path="app/auth/auth.guard.ts">
// src/app/auth/auth.guard.ts
import { inject } from '@angular/core';
import { CanActivateFn, Router, UrlTree, ActivatedRouteSnapshot, RouterStateSnapshot } from '@angular/router';
import { AuthService } from './auth.service';
// Nu mai este nevoie de Observable, map, tap dacă nu facem operații asincrone complexe aici

export const authGuard: CanActivateFn = (route: ActivatedRouteSnapshot, state: RouterStateSnapshot): boolean | UrlTree => {
  const authService = inject(AuthService);
  const router = inject(Router);

  if (authService.isLoggedIn()) {
    return true;
  } else {
    // Redirecționează la pagina de login, salvând URL-ul curent pentru redirectare după login
    console.warn('AuthGuard: User not logged in. Redirecting to /login with returnUrl:', state.url);
    return router.createUrlTree(['/login'], { queryParams: { returnUrl: state.url } });
  }
};
</file>

<file path="app/auth/auth.interceptor.ts">
import { Injectable, inject } from '@angular/core';
import {
  HttpEvent,
  HttpInterceptor,
  HttpHandler,
  HttpRequest,
  HttpErrorResponse
} from '@angular/common/http';
import { Observable, throwError } from 'rxjs';
import { catchError } from 'rxjs/operators';
import { AuthService } from './auth.service';
import { Router } from '@angular/router';

@Injectable()
export class AuthInterceptor implements HttpInterceptor {
  private authService = inject(AuthService);
  private router = inject(Router);

  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    const authToken = this.authService.getToken();

    if (authToken && req.url.startsWith('/api')) {
      // Check token expiration
      if (this.isTokenExpired(authToken)) {
        this.authService.logout();
        this.router.navigate(['/login'], { queryParams: { sessionExpired: 'true' } });
        return throwError(() => new Error('Token expired'));
      }

      const authReq = req.clone({
        headers: req.headers.set('Authorization', `Bearer ${authToken}`)
      });

      return next.handle(authReq).pipe(
        catchError((error: HttpErrorResponse) => {
          if (error.status === 401) {
            this.authService.logout();
            this.router.navigate(['/login'], { queryParams: { sessionExpired: 'true' } });
            console.error('AuthInterceptor: Unauthorized request (401). Logging out.');
          }
          return throwError(() => error);
        })
      );
    }

    return next.handle(req);
  }

  private isTokenExpired(token: string): boolean {
    try {
      const payload = JSON.parse(atob(token.split('.')[1]));
      const expiry = payload.exp;
      return Math.floor(new Date().getTime() / 1000) >= expiry;
    } catch (e) {
      return true;
    }
  }
}
</file>

<file path="app/auth/auth.service.ts">
import { Injectable, Inject, PLATFORM_ID, inject } from '@angular/core';
import { isPlatformBrowser } from '@angular/common';
import { Router } from '@angular/router';
import { HttpClient, HttpErrorResponse } from '@angular/common/http';
import { Observable, BehaviorSubject, throwError, of } from 'rxjs';
import { catchError, map, tap } from 'rxjs/operators';
import { User, JwtResponse, LoginRequest, SignupRequest } from '../shared/models/user.model';

export type Role = 'admin' | 'user';

interface StoredUser extends User {
  token?: string;
}

@Injectable({ providedIn: 'root' })
export class AuthService {
  private apiUrl = '/api/auth';
  private currentUserSubject: BehaviorSubject<StoredUser | null>;
  public user$: Observable<StoredUser | null>;

  private readonly TOKEN_KEY = 'authToken';
  private readonly USER_KEY = 'currentUserDetails';
  private readonly REMEMBER_KEY = 'rememberMe';

  constructor(
    private router: Router,
    private http: HttpClient,
    @Inject(PLATFORM_ID) private platformId: Object
  ) {
    let initialUser: StoredUser | null = null;
    if (isPlatformBrowser(this.platformId)) {
      // Check if user chose to be remembered
      const rememberMe = localStorage.getItem(this.REMEMBER_KEY) === 'true';
      const storage = rememberMe ? localStorage : sessionStorage;
      
      const storedToken = storage.getItem(this.TOKEN_KEY);
      const storedUserJson = storage.getItem(this.USER_KEY);
      
      if (storedToken && storedUserJson) {
        try {
          // Check token expiration
          if (!this.isTokenExpired(storedToken)) {
            initialUser = JSON.parse(storedUserJson) as StoredUser;
            initialUser.token = storedToken;
          } else {
            // Token expired, clear storage
            this.clearStorage();
          }
        } catch (e) {
          console.error('Eroare la parsarea datelor utilizatorului din storage', e);
          this.clearStorage();
        }
      }
    }
    this.currentUserSubject = new BehaviorSubject<StoredUser | null>(initialUser);
    this.user$ = this.currentUserSubject.asObservable();
  }

  private isTokenExpired(token: string): boolean {
    try {
      const payload = JSON.parse(atob(token.split('.')[1]));
      const expiry = payload.exp;
      return Math.floor(new Date().getTime() / 1000) >= expiry;
    } catch (e) {
      return true;
    }
  }

  private clearStorage(): void {
    if (isPlatformBrowser(this.platformId)) {
      // Clear from both storages
      localStorage.removeItem(this.TOKEN_KEY);
      localStorage.removeItem(this.USER_KEY);
      localStorage.removeItem(this.REMEMBER_KEY);
      sessionStorage.removeItem(this.TOKEN_KEY);
      sessionStorage.removeItem(this.USER_KEY);
    }
  }

  login(username: string, password: string, rememberMe: boolean = false): Observable<boolean> {
    const loginRequest: LoginRequest = { username, password };
    return this.http.post<JwtResponse>(`${this.apiUrl}/login`, loginRequest)
      .pipe(
        tap(response => {
          if (response && response.token && response.username) {
            const userDetails: StoredUser = {
              id: response.id,
              username: response.username,
              email: response.email,
              roles: response.roles,
              token: response.token
            };
            if (isPlatformBrowser(this.platformId)) {
              const storage = rememberMe ? localStorage : sessionStorage;
              storage.setItem(this.TOKEN_KEY, response.token);
              storage.setItem(this.USER_KEY, JSON.stringify(userDetails));
              
              // Store remember me preference
              if (rememberMe) {
                localStorage.setItem(this.REMEMBER_KEY, 'true');
              } else {
                localStorage.removeItem(this.REMEMBER_KEY);
              }
            }
            this.currentUserSubject.next(userDetails);
          } else {
            this.handleLoginError(new Error('Răspuns invalid de la server la login.'));
          }
        }),
        map(response => !!(response && response.token)),
        catchError(error => {
          this.handleLoginError(error);
          return of(false);
        })
      );
  }

  signup(signupData: SignupRequest): Observable<any> {
    return this.http.post<any>(`${this.apiUrl}/signup`, signupData)
      .pipe(catchError(this.handleError));
  }

  logout(): void {
    this.clearStorage();
    this.currentUserSubject.next(null);
    this.router.navigate(['/login']);
  }

  isLoggedIn(): boolean {
    return !!this.currentUserSubject.value && !this.isTokenExpired(this.getToken() || '');
  }

  get role(): Role | null {
    const user = this.currentUserSubject.value;
    if (user && user.roles && user.roles.length > 0) {
      if (user.roles.includes('ROLE_ADMIN')) {
        return 'admin';
      }
      if (user.roles.includes('ROLE_USER')) {
        return 'user';
      }
    }
    return null;
  }

  getCurrentUser(): StoredUser | null {
    return this.currentUserSubject.value;
  }

  getToken(): string | null {
    if (isPlatformBrowser(this.platformId)) {
      // Check both storages
      return localStorage.getItem(this.TOKEN_KEY) || sessionStorage.getItem(this.TOKEN_KEY);
    }
    return null;
  }

  private handleLoginError(error: HttpErrorResponse | Error): void {
    let detailedErrorMessage = 'Eroare necunoscută la login.';
    let userFriendlyMessage = 'Autentificare eșuată. Verificați credențialele sau încercați mai târziu.';

    if (error instanceof HttpErrorResponse) {
        if (error.error && typeof error.error === 'object' && error.error !== null) {
            detailedErrorMessage = (error.error as any).message || JSON.stringify(error.error);
            if ((error.error as any).message) {
                userFriendlyMessage = (error.error as any).message;
            }
        } else if (typeof error.error === 'string') {
            detailedErrorMessage = error.error;
            userFriendlyMessage = error.error;
        } else {
            detailedErrorMessage = `Status: ${error.status}, Mesaj: ${error.message}`;
        }
         if (error.status === 401) {
            userFriendlyMessage = 'Nume de utilizator sau parolă incorectă.';
        } else if (error.status === 0 || error.status === -1) {
            userFriendlyMessage = 'Eroare de conexiune cu serverul de autentificare.';
        }

    } else if (error instanceof Error) {
        detailedErrorMessage = error.message;
        userFriendlyMessage = error.message;
    }

    console.error('------------------------------------');
    console.error('[LOGIN ERROR] Mesaj detaliat:', detailedErrorMessage);
    console.error('Obiect eroare complet:', error);
    console.error('------------------------------------');

    this.clearStorage();
    this.currentUserSubject.next(null);
  }

  private handleError(error: HttpErrorResponse) {
    let userFriendlyErrorMessage = 'A apărut o problemă. Vă rugăm încercați din nou mai târziu.';
    let detailedErrorMessage = 'Eroare necunoscută.';

    if (error.error && typeof error.error === 'object' && error.error !== null) {
      detailedErrorMessage = 
          (error.error as any).message ||
          (error.error as any).detail ||
          (error.error as any).error?.message ||
          JSON.stringify(error.error);

      if ((error.error as any).message && typeof (error.error as any).message === 'string') {
        userFriendlyErrorMessage = (error.error as any).message;
      }
    } else if (typeof error.error === 'string') {
      detailedErrorMessage = error.error;
      userFriendlyErrorMessage = error.error; 
    } else if (error.message) {
      detailedErrorMessage = error.message;
      if (error.status === 0 || error.status === -1) {
          userFriendlyErrorMessage = 'Eroare de conexiune cu serverul. Verificați rețeaua sau dacă serverul backend rulează.';
      } else {
          userFriendlyErrorMessage = `A apărut o eroare (${error.status}): ${error.statusText}`;
      }
    } else {
      detailedErrorMessage = `Cod eroare server: ${error.status}, status text: ${error.statusText || 'Necunoscut'}`;
      userFriendlyErrorMessage = `A apărut o eroare (${error.status}). Vă rugăm încercați mai târziu.`;
    }

    console.error('------------------------------------');
    console.error(`[SERVICE ERROR ENCOUNTERED]`);
    console.error(`URL: ${error.url}`);
    console.error(`Status: ${error.status} - ${error.statusText}`);
    console.error(`User-Friendly Message: ${userFriendlyErrorMessage}`);
    console.error(`Detailed Error Message/Body: ${detailedErrorMessage}`);
    console.error('Full HttpErrorResponse Object:', error);
    console.error('------------------------------------');

    return throwError(() => new Error(userFriendlyErrorMessage));
  }
}
</file>

<file path="app/auth/inactivity.service.ts">
import { Injectable, inject } from '@angular/core';
import { AuthService } from './auth.service';
import { Router } from '@angular/router';
import { Subject, fromEvent, merge, timer } from 'rxjs';
import { debounceTime, takeUntil } from 'rxjs/operators';

@Injectable({
  providedIn: 'root'
})
export class InactivityService {
  private authService = inject(AuthService);
  private router = inject(Router);
  
  private inactivityTime = 30 * 60 * 1000; // 30 minutes
  private destroy$ = new Subject<void>();
  private timer$ = new Subject<void>();

  startWatching(): void {
    if (!this.authService.isLoggedIn()) {
      return;
    }

    // Events to track user activity
    const activityEvents$ = merge(
      fromEvent(document, 'mousemove'),
      fromEvent(document, 'click'),
      fromEvent(document, 'keypress'),
      fromEvent(document, 'scroll'),
      fromEvent(document, 'touchstart')
    );

    // Reset timer on any activity
    activityEvents$
      .pipe(
        debounceTime(1000),
        takeUntil(this.destroy$)
      )
      .subscribe(() => {
        this.resetTimer();
      });

    this.resetTimer();
  }

  stopWatching(): void {
    this.destroy$.next();
    this.destroy$.complete();
    this.timer$.next();
    this.timer$.complete();
  }

  private resetTimer(): void {
    this.timer$.next();

    timer(this.inactivityTime)
      .pipe(takeUntil(this.timer$), takeUntil(this.destroy$))
      .subscribe(() => {
        console.log('User inactive for 30 minutes, logging out...');
        this.authService.logout();
        this.router.navigate(['/login'], { 
          queryParams: { reason: 'inactivity' } 
        });
      });
  }
}
</file>

<file path="app/auth/token-storage.service.ts">
// Cale: frontend/src/app/auth/token-storage.service.ts
import { Injectable } from '@angular/core';

const TOKEN_KEY = 'auth-token';
const USER_KEY = 'auth-user';

@Injectable({
  providedIn: 'root'
})
export class TokenStorageService {

  constructor() { }

  signOut(): void {
    window.sessionStorage.clear();
  }

  public saveToken(token: string): void {
    window.sessionStorage.removeItem(TOKEN_KEY);
    window.sessionStorage.setItem(TOKEN_KEY, token);
  }

  public getToken(): string | null {
    return window.sessionStorage.getItem(TOKEN_KEY);
  }

  public saveUser(user: any): void {
    window.sessionStorage.removeItem(USER_KEY);
    window.sessionStorage.setItem(USER_KEY, JSON.stringify(user));
  }

  public getUser(): any {
    const user = window.sessionStorage.getItem(USER_KEY);
    if (user) {
      return JSON.parse(user);
    }
    // Returnează null dacă nu există utilizator
    return null; 
  }
}
</file>

<file path="app/auth/user.guard.ts">
// src/app/auth/user.guard.ts
import { inject } from '@angular/core';
import { CanActivateFn, Router, UrlTree, ActivatedRouteSnapshot, RouterStateSnapshot } from '@angular/router';
import { AuthService } from './auth.service';

export const userGuard: CanActivateFn = (route: ActivatedRouteSnapshot, state: RouterStateSnapshot): boolean | UrlTree => {
  const authService = inject(AuthService);
  const router = inject(Router);

  if (authService.isLoggedIn() && authService.role === 'user') {
    return true;
  } else if (authService.isLoggedIn() && authService.role !== 'user') {
    // Utilizator logat dar nu e 'user' (ex: admin)
    console.warn('UserGuard: User is logged in but not a regular user. Role:', authService.role);
    if (authService.role === 'admin') {
      // Poți decide să permiți adminilor accesul sau să îi redirecționezi
      // return true; // Permite adminului să acceseze și paginile de user
      return router.createUrlTree(['/admin']); // Redirecționează adminul la panoul său
    }
    // Alt rol necunoscut, redirecționează la login
    return router.createUrlTree(['/login'], { queryParams: { returnUrl: state.url } });
  } else {
    // Utilizator nelogat
    console.warn('UserGuard: User not logged in. Redirecting to /login with returnUrl:', state.url);
    return router.createUrlTree(['/login'], { queryParams: { returnUrl: state.url } });
  }
};
</file>

<file path="app/enviornments/environment.prod.ts">
export const environment = {
  production: true,
  apiUrl: '/api'
};
</file>

<file path="app/enviornments/environment.ts">
export const environment = {
  production: false,
  apiUrl: 'http://localhost:8080/api'
};
</file>

<file path="app/features/admin-dashboard/admin-dashboard.component.html">
<mat-sidenav-container class="admin-dashboard-container">
  <mat-sidenav #sidenav mode="side" opened class="admin-sidenav">
    <div class="sidenav-header">
      <h3>Panou Admin</h3>
    </div>
    <mat-nav-list>
      <a mat-list-item routerLink="/admin/products" routerLinkActive="active-link">
        <mat-icon matListItemIcon>inventory_2</mat-icon>
        <span matListItemTitle>Produse</span>
      </a>
      <a mat-list-item routerLink="/admin/categories" routerLinkActive="active-link">
        <mat-icon matListItemIcon>category</mat-icon>
        <span matListItemTitle>Categorii</span>
      </a>
      <a mat-list-item routerLink="/admin/orders" routerLinkActive="active-link">
        <mat-icon matListItemIcon>shopping_cart</mat-icon>
        <span matListItemTitle>Comenzi</span>
      </a>
      <a mat-list-item routerLink="/admin/specification-definitions" routerLinkActive="active-link">
        <mat-icon matListItemIcon>tune</mat-icon>
        <span matListItemTitle>Def. Specificații</span>
      </a>
      <a mat-list-item routerLink="/admin/users" routerLinkActive="active-link"> <mat-icon matListItemIcon>people</mat-icon>
        <span matListItemTitle>Utilizatori</span>
      </a>
      <a mat-list-item routerLink="/admin/reports" routerLinkActive="active-link">
        <mat-icon matListItemIcon>assessment</mat-icon>
         <span matListItemTitle>Rapoarte</span>
      </a>
      <mat-divider></mat-divider>
      <a mat-list-item (click)="auth.logout()">
        <mat-icon matListItemIcon>logout</mat-icon>
        <span matListItemTitle>Deconectare</span>
      </a>
    </mat-nav-list>
  </mat-sidenav>

  <mat-sidenav-content class="admin-content">
    <router-outlet></router-outlet>
  </mat-sidenav-content>
</mat-sidenav-container>
</file>

<file path="app/features/admin-dashboard/admin-dashboard.component.scss">
.admin-dashboard-container {
  height: 100vh;
  display: flex;
}

.admin-sidenav {
  width: 250px;
  border-right: 1px solid rgba(0, 0, 0, 0.12);

  .sidenav-header {
    padding: 16px;
    text-align: center;
    border-bottom: 1px solid rgba(0, 0, 0, 0.12);
    
    h3 {
      margin: 0;
      font-size: 1.2em;
    }
  }

  mat-nav-list {
    padding-top: 8px;
  }

  a[mat-list-item] {
    border-left: 4px solid transparent;
    transition: background-color 0.3s, border-left-color 0.3s;

    &:hover {
      background-color: rgba(0, 0, 0, 0.04);
    }

    &.active-link {
      background-color: rgba(0, 0, 0, 0.08);
      border-left-color: var(--mdc-theme-primary, #673ab7);
      font-weight: 500;

      mat-icon {
        color: var(--mdc-theme-primary, #673ab7);
      }
    }

    mat-icon[matListItemIcon] {
      margin-right: 16px;
      opacity: 0.7;
    }
  }

  mat-divider {
    margin: 8px 0;
  }
}

.admin-content {
  flex-grow: 1;
  padding: 20px;
  overflow-y: auto;
  background-color: rgba(0, 0, 0, 0.02);
}
</file>

<file path="app/features/admin-dashboard/admin-dashboard.component.ts">
// src/app/features/admin-dashboard/admin-dashboard.component.ts
import { Component }      from '@angular/core';
import { CommonModule }   from '@angular/common';
import { RouterModule }   from '@angular/router';
import { MaterialModule } from '../../shared/material.module';
import { AuthService }    from '../../auth/auth.service';

@Component({
  selector: 'app-admin-dashboard',
  standalone: true,
  imports: [CommonModule, RouterModule, MaterialModule],
  templateUrl: './admin-dashboard.component.html',
  styleUrls: ['./admin-dashboard.component.scss']
})
export class AdminDashboardComponent {
  constructor(public auth: AuthService) {}
}
</file>

<file path="app/features/admin/admin-categories/admin-category-form/admin-category-form.component.html">
<div class="admin-category-form-container">
  <mat-card>
    <mat-card-header>
      <mat-card-title>{{ pageTitle }}</mat-card-title>
    </mat-card-header>
    <mat-card-content>
      <div *ngIf="isLoading" class="spinner-container">
        <mat-spinner diameter="50"></mat-spinner>
      </div>

      <form [formGroup]="categoryForm" (ngSubmit)="onSubmit()" *ngIf="!isLoading">
        <mat-form-field appearance="outline" class="full-width">
          <mat-label>Nume Categorie</mat-label>
          <input matInput formControlName="name" placeholder="Ex: Procesoare" required>
          <mat-error *ngIf="f['name'].hasError('required')">
            Numele este obligatoriu.
          </mat-error>
          <mat-error *ngIf="f['name'].hasError('minlength')">
            Numele trebuie să aibă cel puțin 2 caractere.
          </mat-error>
          <mat-error *ngIf="f['name'].hasError('maxlength')">
            Numele nu poate depăși 100 de caractere.
          </mat-error>
        </mat-form-field>

        <mat-form-field appearance="outline" class="full-width">
          <mat-label>Descriere</mat-label>
          <textarea matInput formControlName="description" placeholder="O scurtă descriere a categoriei (opțional)" rows="3"></textarea>
          <mat-error *ngIf="f['description'].hasError('maxlength')">
            Descrierea nu poate depăși 1000 de caractere.
          </mat-error>
        </mat-form-field>

        <div class="form-actions">
          <button mat-stroked-button color="warn" type="button" routerLink="/admin/categories" [disabled]="isLoading">
            <mat-icon>cancel</mat-icon> Anulează
          </button>
          <button mat-raised-button color="primary" type="submit" [disabled]="isLoading || categoryForm.invalid">
            <mat-icon>save</mat-icon> {{ submitButtonText }}
          </button>
        </div>
      </form>
    </mat-card-content>
  </mat-card>
</div>
</file>

<file path="app/features/admin/admin-categories/admin-category-form/admin-category-form.component.scss">
.admin-category-form-container {
  padding: 20px;
  max-width: 600px;
  margin: 20px auto;
}

mat-card-header {
  padding-bottom: 16px;
}

.full-width {
  width: 100%;
  margin-bottom: 16px;
}

.spinner-container {
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 200px;
}

.form-actions {
  display: flex;
  justify-content: flex-end;
  gap: 10px;
  margin-top: 20px;

  button {
    min-width: 120px;
    mat-icon {
      margin-right: 8px;
    }
  }
}

mat-error {
  font-size: 0.85em;
}
</file>

<file path="app/features/admin/admin-categories/admin-category-form/admin-category-form.component.ts">
// src/app/features/admin/admin-categories/admin-category-form/admin-category-form.component.ts
import { Component, OnInit, inject } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ReactiveFormsModule, FormBuilder, FormGroup, Validators } from '@angular/forms';
import { ActivatedRoute, Router, RouterModule } from '@angular/router';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { MatButtonModule } from '@angular/material/button';
import { MatCardModule } from '@angular/material/card';
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { MatIconModule } from '@angular/material/icon';
import { HttpErrorResponse } from '@angular/common/http'; // Import HttpErrorResponse

import { Category } from '../../../../shared/models/category.model';
// Calea corectă și numele fișierului serviciului
import { CategoryAdminService } from '../../services/category.admin.service'; // <<<--- CALE ȘI NUME FIȘIER CORECTATE

@Component({
  selector: 'app-admin-category-form',
  standalone: true,
  imports: [
    CommonModule,
    RouterModule,
    ReactiveFormsModule,
    MatFormFieldModule,
    MatInputModule,
    MatButtonModule,
    MatCardModule,
    MatSnackBarModule,
    MatProgressSpinnerModule,
    MatIconModule
  ],
  templateUrl: './admin-category-form.component.html',
  styleUrls: ['./admin-category-form.component.scss']
})
export class AdminCategoryFormComponent implements OnInit {
  categoryForm!: FormGroup;
  isEditMode = false;
  categoryId?: number;
  isLoading = false;
  pageTitle = 'Adaugă Categorie Nouă';
  submitButtonText = 'Salvează';
  error: string | null = null; // Adăugat pentru a stoca mesajul de eroare

  private fb = inject(FormBuilder);
  private categoryService = inject(CategoryAdminService);
  private route = inject(ActivatedRoute);
  private router = inject(Router);
  private snackBar = inject(MatSnackBar);

  ngOnInit(): void {
    this.categoryForm = this.fb.group({
      name: ['', [Validators.required, Validators.minLength(2), Validators.maxLength(100)]],
      description: ['', [Validators.maxLength(1000)]]
    });

    const idFromRoute = this.route.snapshot.paramMap.get('id');
    if (idFromRoute) {
      this.categoryId = +idFromRoute;
      if (!isNaN(this.categoryId) && this.categoryId > 0) {
        this.isEditMode = true;
        this.pageTitle = 'Editează Categorie';
        this.submitButtonText = 'Actualizează';
        this.loadCategoryData(this.categoryId);
      } else {
        this.handleInvalidId('ID categorie invalid din rută.');
      }
    }
  }

  loadCategoryData(id: number): void {
    this.isLoading = true;
    this.categoryService.getById(id).subscribe({
      next: (category: Category) => { // <<<--- TIPARE EXPLICITĂ PENTRU 'category'
        this.categoryForm.patchValue(category);
        this.isLoading = false;
      },
      error: (err: HttpErrorResponse) => this.handleLoadError('Eroare la încărcarea datelor categoriei.', err) // <<<--- TIPARE EXPLICITĂ ȘI REFACUT
    });
  }

  onSubmit(): void {
    if (this.categoryForm.invalid) {
      this.snackBar.open('Formular invalid. Vă rugăm corectați erorile.', 'OK', { duration: 3000 });
      this.categoryForm.markAllAsTouched();
      return;
    }

    this.isLoading = true;
    const categoryData: Category = this.categoryForm.value;

    if (this.isEditMode && this.categoryId) {
      this.categoryService.update(this.categoryId, categoryData).subscribe({
        next: () => {
          this.isLoading = false;
          this.snackBar.open('Categorie actualizată cu succes!', 'OK', { duration: 3000 });
          this.router.navigate(['/admin/categories']);
        },
        error: (err: HttpErrorResponse) => this.handleSubmitError('Eroare la actualizarea categoriei.', err) // <<<--- TIPARE EXPLICITĂ ȘI REFACUT
      });
    } else {
      this.categoryService.create(categoryData).subscribe({
        next: () => {
          this.isLoading = false;
          this.snackBar.open('Categorie creată cu succes!', 'OK', { duration: 3000 });
          this.router.navigate(['/admin/categories']);
        },
        error: (err: HttpErrorResponse) => this.handleSubmitError('Eroare la crearea categoriei.', err) // <<<--- TIPARE EXPLICITĂ ȘI REFACUT
      });
    }
  }

  private handleInvalidId(message: string): void {
    this.isLoading = false;
    this.error = message; // Setează mesajul de eroare
    this.snackBar.open(this.error, 'Închide', { duration: 3000 });
    this.router.navigate(['/admin/categories']);
  }

  private handleLoadError(message: string, err: HttpErrorResponse): void {
    this.isLoading = false;
    // Extrage mesajul de eroare din răspunsul backend-ului dacă există
    const serverErrorMessage = err.error?.message || err.message || 'Eroare necunoscută de la server.';
    this.error = `${message} ${serverErrorMessage}`;
    this.snackBar.open(this.error, 'Închide', { duration: 5000 });
    console.error('Eroare la încărcare:', err);
    this.router.navigate(['/admin/categories']);
  }

  private handleSubmitError(message: string, err: HttpErrorResponse): void {
    this.isLoading = false;
    const serverErrorMessage = err.error?.message || err.message || 'Eroare necunoscută de la server.';
    this.snackBar.open(`${message} ${serverErrorMessage}`, 'Închide', { duration: 5000 });
    console.error('Eroare la submit:', err);
  }


  get f() { return this.categoryForm.controls; }
}
</file>

<file path="app/features/admin/admin-categories/admin-category-list/admin-category-list.component.html">
<!-- src/app/features/admin/admin-categories/admin-category-list/admin-category-list.component.html -->
<div class="admin-category-list-container">
  <div class="header">
    <h2>Administrare Categorii</h2>
    <button mat-raised-button color="primary" routerLink="/admin/categories/new">
      <mat-icon>add</mat-icon> Adaugă Categorie Nouă
    </button>
  </div>

  <div *ngIf="isLoading" class="loading-indicator">
    <p>Se încarcă categoriile...</p>
    <!-- Poți adăuga un spinner Angular Material aici -->
    <!-- <mat-spinner diameter="40"></mat-spinner> -->
  </div>

  <div *ngIf="error && !isLoading" class="error-message">
    <p>{{ error }}</p>
    <button mat-stroked-button color="warn" (click)="loadCategories()">Reîncearcă</button>
  </div>

  <div *ngIf="!isLoading && !error && categories.length === 0" class="no-data">
    <p>Nu există categorii definite.</p>
  </div>

  <mat-list *ngIf="!isLoading && !error && categories.length > 0" role="list">
    <h3 mat-subheader>Categorii Existente</h3>
    <mat-list-item *ngFor="let category of categories" role="listitem" class="category-item">
      <mat-icon matListItemIcon>folder_open</mat-icon>
      <span matListItemTitle>{{ category.name }}</span>
      <span matListItemLine class="description">{{ category.description || 'Fără descriere' }}</span>
      <span matListItemMeta class="actions">
        <button mat-icon-button color="primary" [routerLink]="['/admin/categories/edit', category.id]" aria-label="Editează categoria">
          <mat-icon>edit</mat-icon>
        </button>
        <button mat-icon-button color="warn" (click)="deleteCategory(category.id!)" [disabled]="isLoading" aria-label="Șterge categoria">
          <mat-icon>delete</mat-icon>
        </button>
      </span>
    </mat-list-item>
  </mat-list>
</div>
</file>

<file path="app/features/admin/admin-categories/admin-category-list/admin-category-list.component.scss">
.admin-category-list-container {
  padding: 20px;
  max-width: 800px;
  margin: 20px auto;
  border-radius: 8px;
  box-shadow: 0 2px 10px rgba(0,0,0,0.1);
}

.header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 24px;
  padding-bottom: 16px;
  border-bottom: 1px solid rgba(0,0,0,0.12);

  h2 {
    margin: 0;
    font-size: 1.6em;
  }
  button[mat-raised-button] mat-icon {
    margin-right: 8px;
  }
}

.loading-indicator,
.error-message,
.no-data {
  text-align: center;
  padding: 30px 20px;
  margin-top: 20px;
  font-size: 1.1em;

  mat-spinner {
    margin: 0 auto 15px auto;
  }
}

.error-message {
  color: #d32f2f;
  background-color: #ffebee;
  border: 1px solid #ffcdd2;
  border-radius: 4px;
  p {
    margin-bottom: 10px;
  }
}

mat-list {
  padding-top: 0;
}

h3[mat-subheader] {
  font-size: 1.2em;
  font-weight: 500;
  opacity: 0.87;
  margin-bottom: 8px;
}

.category-item {
  border-bottom: 1px solid rgba(0,0,0,0.08);
  padding: 12px 0;

  &:last-child {
    border-bottom: none;
  }

  &:hover {
    background-color: rgba(0,0,0,0.02);
  }

  mat-icon[matListItemIcon] {
    opacity: 0.54;
  }

  .description {
    font-size: 0.9em;
    opacity: 0.7;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 400px;
    padding-left: 16px;
  }

  .actions {
    button[mat-icon-button] {
      margin-left: 8px;
    }
  }
}
</file>

<file path="app/features/admin/admin-categories/admin-category-list/admin-category-list.component.ts">
// src/app/features/admin/admin-categories/admin-category-list/admin-category-list.component.ts
import { Component, OnInit, inject } from '@angular/core';
import { CommonModule } from '@angular/common';
import { RouterModule } from '@angular/router';
import { MatListModule } from '@angular/material/list';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar';
import { MatDialog, MatDialogModule } from '@angular/material/dialog';
// Importă un dialog de confirmare generic dacă ai unul, sau creează unul simplu.
// import { ConfirmDialogComponent } from '../../../../shared/components/confirm-dialog/confirm-dialog.component';


import { Category } from '../../../../shared/models/category.model';
import { CategoryAdminService } from '../../services/category.admin.service'; // Asigură-te că numele serviciului este corect

@Component({
  selector: 'app-admin-category-list',
  standalone: true,
  imports: [
    CommonModule,
    RouterModule,
    MatListModule,
    MatButtonModule,
    MatIconModule,
    MatSnackBarModule,
    MatDialogModule
  ],
  templateUrl: './admin-category-list.component.html',
  styleUrls: ['./admin-category-list.component.scss']
})
export class AdminCategoryListComponent implements OnInit {
  categories: Category[] = [];
  isLoading = true;
  error: string | null = null;

  private categoryService = inject(CategoryAdminService);
  private snackBar = inject(MatSnackBar);
  // private dialog = inject(MatDialog); // Decomentează dacă folosești MatDialog

  ngOnInit(): void {
    this.loadCategories();
  }

  /**
   * Încarcă lista de categorii de la server.
   */
  loadCategories(): void {
    this.isLoading = true;
    this.error = null;
    this.categoryService.getAll().subscribe({
      next: (data) => {
        this.categories = data;
        this.isLoading = false;
      },
      error: (err) => {
        this.error = 'Nu s-au putut încărca categoriile.';
        const errMsg = err.error?.message || err.message || 'Eroare necunoscută.';
        console.error('Eroare la încărcarea categoriilor:', err);
        this.isLoading = false;
        this.snackBar.open(`${this.error} ${errMsg}`, 'Închide', { duration: 5000 });
      }
    });
  }

  /**
   * Șterge o categorie după o confirmare.
   * @param categoryId ID-ul categoriei de șters.
   */
  deleteCategory(categoryId: number): void {
    // TODO: Implementează un dialog de confirmare (MatDialog) înainte de ștergere.
    // Exemplu simplu cu window.confirm, dar MatDialog e preferat:
    const confirmation = window.confirm('Sunteți sigur că doriți să ștergeți această categorie? Această acțiune nu poate fi anulată.');
    if (confirmation) {
      this.isLoading = true; // Indică începerea operației
      this.categoryService.delete(categoryId).subscribe({
        next: () => {
          this.isLoading = false;
          this.snackBar.open('Categorie ștearsă cu succes!', 'OK', { duration: 3000 });
          this.loadCategories(); // Reîncarcă lista pentru a reflecta ștergerea
        },
        error: (err) => {
          this.isLoading = false;
          const errMsg = err.error?.message || err.message || 'Eroare la ștergerea categoriei.';
          this.snackBar.open(errMsg, 'Închide', { duration: 5000 });
          console.error('Eroare la ștergerea categoriei:', err);
        }
      });
    }
  }
}
</file>

<file path="app/features/admin/admin-orders/admin-order-detail/admin-order-detail.component.html">
<div class="admin-order-detail-container">
  <button mat-stroked-button routerLink="/admin/orders" class="back-button">
    <mat-icon>arrow_back</mat-icon> Înapoi la Listă Comenzi
  </button>

  <div *ngIf="isLoading" class="loading-indicator">
    <mat-spinner diameter="50"></mat-spinner>
    <p>Se încarcă detaliile comenzii...</p>
  </div>

  <div *ngIf="error && !isLoading" class="error-message">
    <p>{{ error }}</p>
    <button mat-stroked-button color="warn" (click)="loadOrderDetails()">Reîncearcă</button>
  </div>

  <div *ngIf="order && !isLoading" class="order-details">
    <mat-card class="order-summary-card">
      <mat-card-header>
        <mat-card-title>Comanda #{{ order.id }}</mat-card-title>
        <mat-card-subtitle>Plasată la: {{ order.orderDate | date:'dd/MM/yyyy HH:mm:ss' }}</mat-card-subtitle>
      </mat-card-header>
      <mat-card-content>
        <div class="info-grid">
          <div><strong>Client:</strong> {{ order.customerName }}</div>
          <div><strong>Email:</strong> {{ order.customerEmail }}</div>
          <div><strong>Telefon:</strong> {{ order.customerPhone }}</div>
          <div><strong>Utilizator (ID):</strong> {{ order.userId || 'N/A (Guest)' }}</div>
          <div class="full-width"><strong>Adresă Livrare:</strong> {{ order.shippingAddress }}</div>
        </div>
        <mat-divider></mat-divider>
        <div class="status-total">
            <mat-chip-listbox aria-label="Status comandă">
                <mat-chip selected [ngClass]="'status-chip-' + order.status.toLowerCase()">
                    Status: {{ formatStatus(order.status) }}
                </mat-chip>
            </mat-chip-listbox>
          <h3>Total Comandă: {{ order.totalAmount | currency:'RON':'symbol':'1.2-2' }}</h3>
        </div>
      </mat-card-content>
    </mat-card>

    <mat-card class="order-items-card">
      <mat-card-header>
        <mat-card-title>Articole Comandate</mat-card-title>
      </mat-card-header>
      <mat-card-content>
        <mat-list role="list" class="order-items-list">
          <mat-list-item *ngFor="let item of order.orderItems" role="listitem" class="order-item-detail">
            <!-- Secțiunea Imagine Articol - COMENTATĂ TEMPORAR -->
            <!--
            <img matListItemAvatar *ngIf="item.productImageBase64Snapshot" [src]="item.productImageBase64Snapshot" [alt]="item.productNameSnapshot || 'Imagine produs'" class="item-image-small">
            <mat-icon matListItemAvatar *ngIf="!item.productImageBase64Snapshot">inventory_2</mat-icon>
            -->
            <mat-icon matListItemAvatar>inventory_2</mat-icon> <!-- Placeholder generic -->

            <span matListItemTitle>{{ item.productNameSnapshot }} (ID: {{ item.productId }})</span>
            <span matListItemLine>
              Cantitate: {{ item.quantity }} x {{ item.priceAtPurchase | currency:'RON':'symbol':'1.2-2' }}
            </span>
            <span matListItemMeta class="item-subtotal-small">
              Subtotal: {{ calculateItemSubtotal(item) | currency:'RON':'symbol':'1.2-2' }}
            </span>
          </mat-list-item>
        </mat-list>
      </mat-card-content>
    </mat-card>

    <mat-card class="status-update-card">
      <mat-card-header>
        <mat-card-title>Actualizează Status Comandă</mat-card-title>
      </mat-card-header>
      <mat-card-content>
        <form [formGroup]="statusUpdateForm" (ngSubmit)="onUpdateStatus()">
          <mat-form-field appearance="outline" class="full-width">
            <mat-label>Status Nou</mat-label>
            <mat-select formControlName="newStatus" required>
              <mat-option *ngFor="let status of availableStatuses" [value]="status">
                {{ formatStatus(status) }}
              </mat-option>
            </mat-select>
            <mat-error *ngIf="statusUpdateForm.get('newStatus')?.hasError('required')">
              Selectați un status.
            </mat-error>
          </mat-form-field>
          <button mat-raised-button color="primary" type="submit" [disabled]="statusUpdateForm.invalid || isUpdatingStatus">
            <mat-icon *ngIf="!isUpdatingStatus">update</mat-icon>
            <mat-progress-spinner *ngIf="isUpdatingStatus" diameter="20" mode="indeterminate" style="margin-right: 8px;"></mat-progress-spinner>
            {{ isUpdatingStatus ? 'Se actualizează...' : 'Actualizează Status' }}
          </button>
        </form>
      </mat-card-content>
    </mat-card>
  </div>
</div>
</file>

<file path="app/features/admin/admin-orders/admin-order-detail/admin-order-detail.component.scss">
.admin-order-detail-container {
  padding: 20px;
  max-width: 900px;
  margin: 20px auto;
}

.back-button {
  margin-bottom: 20px;
  mat-icon {
    margin-right: 8px;
  }
}

.loading-indicator,
.error-message {
  text-align: center;
  padding: 20px;
  mat-spinner {
    margin: 0 auto 10px auto;
  }
}

.order-details {
  display: grid;
  gap: 20px;
}

mat-card {
  width: 100%;
}

mat-card-header {
  padding-bottom: 16px;
}

.info-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: 10px 20px;
  margin-bottom: 16px;

  .full-width {
    grid-column: 1 / -1;
  }

  strong {
    font-weight: 500;
  }
}

.status-total {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-top: 16px;

  h3 {
    margin: 0;
    font-size: 1.1em;
    font-weight: 500;
  }
}

.status-chip-pending_confirmation { 
  background-color: #FFECB3 !important; 
  color: #795548 !important; 
}
.status-chip-approved { 
  background-color: #C8E6C9 !important; 
  color: #2E7D32 !important; 
}
.status-chip-processing { 
  background-color: #BBDEFB !important; 
  color: #1565C0 !important; 
}
.status-chip-shipped { 
  background-color: #B2EBF2 !important; 
  color: #006064 !important; 
}
.status-chip-delivered { 
  background-color: #DCEDC8 !important; 
  color: #558B2F !important; 
}
.status-chip-canceled { 
  background-color: #FFCDD2 !important; 
  color: #C62828 !important; 
}

.order-items-card {
  .order-item {
    border-bottom: 1px solid rgba(0,0,0,0.08);
    &:last-child {
      border-bottom: none;
    }
  }
  .item-subtotal {
    font-weight: 500;
  }
}

.status-update-card {
  .full-width {
    width: 100%;
    margin-bottom: 16px;
  }
  button[mat-raised-button] {
    display: inline-flex;
    align-items: center;
  }
}
</file>

<file path="app/features/admin/admin-orders/admin-order-detail/admin-order-detail.component.ts">
// src/app/features/admin/admin-orders/admin-order-detail/admin-order-detail.component.ts
import { Component, OnInit, inject } from '@angular/core';
import { CommonModule, DatePipe, CurrencyPipe } from '@angular/common';
import { ActivatedRoute, Router, RouterModule } from '@angular/router';
import { ReactiveFormsModule, FormBuilder, FormGroup, Validators } from '@angular/forms';

import { MatCardModule } from '@angular/material/card';
import { MatListModule } from '@angular/material/list';
import { MatDividerModule } from '@angular/material/divider';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatSelectModule } from '@angular/material/select';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar';
import { MatChipsModule } from '@angular/material/chips';
import { HttpErrorResponse } from '@angular/common/http';


import { Order } from '../../../../shared/models/order.model';
import { OrderItem } from '../../../../shared/models/order-item.model'; // <<< CORECTAT
import { OrderStatusUpdate } from '../../../../shared/models/order-status-update.model'; // <<< CORECTAT
import { OrderAdminService } from '../../services/order.admin.service';

@Component({
  selector: 'app-admin-order-detail',
  standalone: true,
  imports: [
    CommonModule,
    RouterModule,
    ReactiveFormsModule,
    MatCardModule,
    MatListModule,
    MatDividerModule,
    MatFormFieldModule,
    MatSelectModule,
    MatButtonModule,
    MatIconModule,
    MatProgressSpinnerModule,
    MatSnackBarModule,
    MatChipsModule,
    DatePipe,
    CurrencyPipe
  ],
  templateUrl: './admin-order-detail.component.html',
  styleUrls: ['./admin-order-detail.component.scss']
})
export class AdminOrderDetailComponent implements OnInit {
  order: Order | null = null;
  isLoading = true;
  error: string | null = null;
  orderId!: number;

  statusUpdateForm!: FormGroup;
  availableStatuses: string[] = ['PENDING_CONFIRMATION', 'APPROVED', 'PROCESSING', 'SHIPPED', 'DELIVERED', 'CANCELED'];
  isUpdatingStatus = false;

  private route = inject(ActivatedRoute);
  private router = inject(Router);
  private orderService = inject(OrderAdminService);
  private snackBar = inject(MatSnackBar);
  private fb = inject(FormBuilder);

  ngOnInit(): void {
    const idFromRoute = this.route.snapshot.paramMap.get('id');
    if (idFromRoute) {
      this.orderId = +idFromRoute;
      if (!isNaN(this.orderId) && this.orderId > 0) {
        this.loadOrderDetails();
        this.statusUpdateForm = this.fb.group({
          newStatus: ['', Validators.required]
        });
      } else {
        this.handleInvalidId();
      }
    } else {
      this.handleInvalidId();
    }
  }

  private handleInvalidId(): void {
    this.isLoading = false;
    this.error = 'ID comandă invalid.';
    this.snackBar.open(this.error, 'Închide', { duration: 3000 });
    this.router.navigate(['/admin/orders']);
  }

  loadOrderDetails(): void {
    this.isLoading = true;
    this.error = null;
    this.orderService.getOrderById(this.orderId).subscribe({
      next: (data: Order) => { // Tipare explicită
        this.order = data;
        this.statusUpdateForm.patchValue({ newStatus: this.order.status });
        this.isLoading = false;
      },
      error: (err: HttpErrorResponse) => { // Tipare explicită
        this.error = 'Nu s-au putut încărca detaliile comenzii.';
        const errMsg = err.error?.message || err.message || 'Eroare necunoscută.';
        console.error('Eroare la încărcarea detaliilor comenzii:', err);
        this.isLoading = false;
        this.snackBar.open(`${this.error} ${errMsg}`, 'Închide', { duration: 5000 });
      }
    });
  }

  onUpdateStatus(): void {
    if (this.statusUpdateForm.invalid || !this.order) {
      this.snackBar.open('Vă rugăm selectați un status valid.', 'OK', { duration: 3000 });
      return;
    }

    this.isUpdatingStatus = true;
    const statusUpdate: OrderStatusUpdate = this.statusUpdateForm.value;

    this.orderService.updateOrderStatus(this.orderId, statusUpdate).subscribe({
      next: (updatedOrder: Order) => { // Tipare explicită
        this.order = updatedOrder;
        this.statusUpdateForm.patchValue({ newStatus: updatedOrder.status });
        this.isUpdatingStatus = false;
        this.snackBar.open('Statusul comenzii a fost actualizat cu succes!', 'OK', { duration: 3000 });
      },
      error: (err: HttpErrorResponse) => { // Tipare explicită
        this.isUpdatingStatus = false;
        const errorMessage = err.error?.message || err.message || 'Eroare la actualizarea statusului comenzii.';
        this.snackBar.open(errorMessage, 'Închide', { duration: 5000 });
        console.error(err);
      }
    });
  }

  formatStatus(status: string): string {
    if (!status) return '';
    return status.replace(/_/g, ' ').toLowerCase().replace(/\b\w/g, l => l.toUpperCase());
  }

  calculateItemSubtotal(item: OrderItem): number {
    return (item.priceAtPurchase || 0) * item.quantity;
  }
}
</file>

<file path="app/features/admin/admin-orders/admin-order-list/admin-order-list.component.html">
<!-- src/app/features/admin/admin-orders/admin-order-list/admin-order-list.component.html -->
<div class="admin-order-list-container">
  <div class="header">
    <h2>Administrare Comenzi</h2>
  </div>

  <div class="filters-container">
    <mat-form-field appearance="outline" class="filter-field">
      <mat-label>Filtrează comenzi (ex: nume client, ID)</mat-label>
      <input matInput (keyup)="applyFilter($event)" placeholder="Caută...">
      <mat-icon matSuffix>search</mat-icon>
    </mat-form-field>

    <mat-form-field appearance="outline" class="status-filter-field">
      <mat-label>Filtrează după Status</mat-label>
      <mat-select [(ngModel)]="statusFilter" (selectionChange)="onStatusFilterChange()">
        <mat-option value="ALL">Toate Statusurile</mat-option>
        <!-- Se iterează peste getter-ul statusesForFilterDropdown -->
        <mat-option *ngFor="let status of statusesForFilterDropdown" [value]="status">
          {{ formatStatus(status) }}
        </mat-option>
      </mat-select>
    </mat-form-field>
  </div>

  <div *ngIf="isLoading" class="loading-indicator">
    <mat-spinner diameter="50"></mat-spinner>
    <p>Se încarcă comenzile...</p>
  </div>

  <div *ngIf="error && !isLoading" class="error-message">
    <p>{{ error }}</p>
    <button mat-stroked-button color="warn" (click)="loadOrders()">Reîncearcă</button>
  </div>

  <div *ngIf="!isLoading && !error && dataSource.data.length === 0" class="no-data">
    <p>Nu există comenzi care să corespundă filtrelor selectate sau nu există comenzi înregistrate.</p>
  </div>

  <div class="table-container" *ngIf="!isLoading && !error && dataSource.data.length > 0">
    <table mat-table [dataSource]="dataSource" matSort class="mat-elevation-z8">

      <!-- ID Column -->
      <ng-container matColumnDef="id">
        <th mat-header-cell *matHeaderCellDef mat-sort-header> ID Comandă </th>
        <td mat-cell *matCellDef="let order"> #{{order.id}} </td>
      </ng-container>

      <!-- Customer Name Column -->
      <ng-container matColumnDef="customerName">
        <th mat-header-cell *matHeaderCellDef mat-sort-header> Nume Client </th>
        <td mat-cell *matCellDef="let order"> {{order.customerName}} </td>
      </ng-container>

      <!-- Order Date Column -->
      <ng-container matColumnDef="orderDate">
        <th mat-header-cell *matHeaderCellDef mat-sort-header> Data Comenzii </th>
        <td mat-cell *matCellDef="let order"> {{order.orderDate | date:'dd/MM/yyyy HH:mm'}} </td>
      </ng-container>

      <!-- Total Amount Column -->
      <ng-container matColumnDef="totalAmount">
        <th mat-header-cell *matHeaderCellDef mat-sort-header> Suma Totală </th>
        <td mat-cell *matCellDef="let order"> {{order.totalAmount | currency:'RON':'symbol':'1.2-2'}} </td>
      </ng-container>

      <!-- Status Column -->
      <ng-container matColumnDef="status">
        <th mat-header-cell *matHeaderCellDef mat-sort-header> Status </th>
        <td mat-cell *matCellDef="let order" [ngClass]="'status-' + order.status.toLowerCase().replace('_', '-')">
          {{ formatStatus(order.status) }}
        </td>
      </ng-container>

      <!-- Actions Column -->
      <ng-container matColumnDef="actions">
        <th mat-header-cell *matHeaderCellDef> Acțiuni </th>
        <td mat-cell *matCellDef="let order">
          <button mat-icon-button color="primary" [routerLink]="['/admin/orders', order.id]" aria-label="Vezi detalii comandă">
            <mat-icon>visibility</mat-icon>
          </button>
        </td>
      </ng-container>

      <tr mat-header-row *matHeaderRowDef="displayedColumns"></tr>
      <tr mat-row *matRowDef="let row; columns: displayedColumns;"></tr>

      <tr class="mat-row" *matNoDataRow>
        <td class="mat-cell" [attr.colspan]="displayedColumns.length">
          Nu s-au găsit comenzi care să corespundă filtrului text "{{dataSource.filter}}".
        </td>
      </tr>
    </table>

    <mat-paginator [pageSizeOptions]="[5, 10, 25, 100]" showFirstLastButtons aria-label="Selectează pagina de comenzi"></mat-paginator>
  </div>
</div>
</file>

<file path="app/features/admin/admin-orders/admin-order-list/admin-order-list.component.scss">
.admin-order-list-container {
  padding: 20px;
  max-width: 1200px;
  margin: auto;
}

.header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;

  h2 {
    margin: 0;
  }
}

.filter-field, .status-filter-field {
  width: 100%;
  max-width: 400px;
  margin-right: 16px;
  margin-bottom: 16px;
}

.status-filter-field {
   min-width: 200px;
}

.loading-indicator,
.error-message,
.no-data {
  text-align: center;
  padding: 20px;
  mat-spinner {
    margin: 0 auto 10px auto;
  }
}

.table-container {
  overflow-x: auto;
  margin-top: 20px;
}

table {
  width: 100%;
}

.mat-column-actions {
  width: 120px;
  text-align: right;
}

.mat-column-id {
  width: 100px;
}
.mat-column-totalAmount {
  width: 150px;
  text-align: right;
}
.mat-column-status {
  width: 200px;
  font-weight: 500;
}

.status-pending_confirmation { color: #FFC107; }
.status-approved { color: #4CAF50; }
.status-processing { color: #2196F3; }
.status-shipped { color: #00BCD4; }
.status-delivered { color: #8BC34A; }
.status-canceled { color: #F44336; }

.mat-row:hover {
  background-color: rgba(0,0,0,0.04);
}
</file>

<file path="app/features/admin/admin-orders/admin-order-list/admin-order-list.component.ts">
// src/app/features/admin/admin-orders/admin-order-list/admin-order-list.component.ts
import { Component, OnInit, inject, ViewChild, AfterViewInit } from '@angular/core';
import { CommonModule, DatePipe } from '@angular/common';
import { RouterModule } from '@angular/router';
import { MatTableDataSource, MatTableModule } from '@angular/material/table';
import { MatPaginator, MatPaginatorModule } from '@angular/material/paginator';
import { MatSort, MatSortModule } from '@angular/material/sort';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { MatSelectModule } from '@angular/material/select';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar';
import { FormsModule } from '@angular/forms'; // Pentru ngModel

import { Order } from '../../../../shared/models/order.model';
import { OrderAdminService } from '../../services/order.admin.service';

@Component({
  selector: 'app-admin-order-list',
  standalone: true,
  imports: [
    CommonModule,
    RouterModule,
    FormsModule, // Adăugat FormsModule pentru ngModel
    MatTableModule,
    MatPaginatorModule,
    MatSortModule,
    MatFormFieldModule,
    MatInputModule,
    MatSelectModule,
    MatButtonModule,
    MatIconModule,
    MatProgressSpinnerModule,
    MatSnackBarModule,
    DatePipe
  ],
  templateUrl: './admin-order-list.component.html',
  styleUrls: ['./admin-order-list.component.scss']
})
export class AdminOrderListComponent implements OnInit, AfterViewInit {
  displayedColumns: string[] = ['id', 'customerName', 'orderDate', 'totalAmount', 'status', 'actions'];
  dataSource: MatTableDataSource<Order> = new MatTableDataSource();
  isLoading = true;
  error: string | null = null;

  statusFilter: string = ''; // Inițializat cu string gol sau 'ALL'
  // Lista completă de statusuri, inclusiv 'ALL' pentru a reseta filtrul
  readonly availableStatuses: string[] = ['PENDING_CONFIRMATION', 'APPROVED', 'PROCESSING', 'SHIPPED', 'DELIVERED', 'CANCELED', 'ALL'];

  @ViewChild(MatPaginator) paginator!: MatPaginator;
  @ViewChild(MatSort) sort!: MatSort;

  private orderService = inject(OrderAdminService);
  private snackBar = inject(MatSnackBar);

  ngOnInit(): void {
    this.loadOrders();
  }

  ngAfterViewInit(): void {
    this.dataSource.paginator = this.paginator;
    this.dataSource.sort = this.sort;
    // Custom sort pentru data și status (dacă este necesar pentru stringuri complexe)
    this.dataSource.sortingDataAccessor = (item, property) => {
      switch (property) {
        case 'orderDate': return new Date(item.orderDate || 0).getTime();
        case 'status': return this.formatStatus(item.status); // Sortează după statusul formatat
        default: return (item as any)[property];
      }
    };
  }

  /**
   * Getter pentru lista de statusuri care vor fi afișate în dropdown-ul de filtrare.
   * Exclude opțiunea 'ALL' din iterația directă, deoarece este gestionată separat.
   */
  get statusesForFilterDropdown(): string[] {
    return this.availableStatuses.filter(s => s !== 'ALL');
  }

  loadOrders(): void {
    this.isLoading = true;
    this.error = null;
    // Dacă statusFilter este 'ALL', trimitem undefined sau string gol la serviciu
    // pentru a prelua toate comenzile, în funcție de cum este implementat backend-ul/serviciul.
    const filterToSend = (this.statusFilter === 'ALL' || this.statusFilter === '') ? undefined : this.statusFilter;

    this.orderService.getAllOrders(filterToSend).subscribe({
      next: (data) => {
        this.dataSource.data = data;
        // Paginatorul și sortarea sunt deja setate în ngAfterViewInit
        // this.dataSource.paginator = this.paginator; // Nu este nevoie aici dacă e în ngAfterViewInit
        // this.dataSource.sort = this.sort;         // Nu este nevoie aici
        this.isLoading = false;
      },
      error: (err) => {
        this.error = 'Nu s-au putut încărca comenzile.';
        const errMsg = err.error?.message || err.message || 'Eroare necunoscută.';
        console.error('Eroare la încărcarea comenzilor:', err);
        this.isLoading = false;
        this.snackBar.open(`${this.error} ${errMsg}`, 'Închide', { duration: 5000 });
      }
    });
  }

  applyFilter(event: Event): void {
    const filterValue = (event.target as HTMLInputElement).value;
    this.dataSource.filter = filterValue.trim().toLowerCase();

    if (this.dataSource.paginator) {
      this.dataSource.paginator.firstPage();
    }
  }

  onStatusFilterChange(): void {
    this.loadOrders();
    if (this.dataSource.paginator) {
      this.dataSource.paginator.firstPage(); // Resetează paginatorul la schimbarea filtrului
    }
  }

  formatStatus(status: string): string {
    if (!status) return '';
    return status.replace(/_/g, ' ').toLowerCase().replace(/\b\w/g, l => l.toUpperCase());
  }
}
</file>

<file path="app/features/admin/admin-specifications/admin-spec-def-form/admin-spec-def-form.component.html">
<div class="admin-spec-def-form-container">
  <mat-card>
    <mat-card-header>
      <mat-card-title>{{ pageTitle }}</mat-card-title>
    </mat-card-header>
    <mat-card-content>
      <div *ngIf="isLoading && isEditMode" class="spinner-container">
        <mat-progress-spinner diameter="50" mode="indeterminate"></mat-progress-spinner>
        <p>Se încarcă datele...</p>
      </div>

      <form [formGroup]="specDefForm" (ngSubmit)="onSubmit()" *ngIf="!isLoading || !isEditMode">
        <mat-form-field appearance="outline" class="full-width">
          <mat-label>Nume Specificație</mat-label>
          <input matInput formControlName="name" placeholder="Ex: Procesor, Memorie RAM, Culoare" required>
          <mat-error *ngIf="f['name'].hasError('required')">Numele este obligatoriu.</mat-error>
          <mat-error *ngIf="f['name'].hasError('minlength')">Minim 2 caractere.</mat-error>
          <mat-error *ngIf="f['name'].hasError('maxlength')">Maxim 100 caractere.</mat-error>
        </mat-form-field>

        <mat-form-field appearance="outline" class="full-width">
          <mat-label>Unitate de Măsură (Opțional)</mat-label>
          <input matInput formControlName="unit" placeholder="Ex: GB, MHz, cm, kg">
           <mat-error *ngIf="f['unit'].hasError('maxlength')">Maxim 50 caractere.</mat-error>
        </mat-form-field>

        <div class="form-actions">
          <button mat-stroked-button color="warn" type="button" routerLink="/admin/specification-definitions" [disabled]="isLoading">
            <mat-icon>cancel</mat-icon> Anulează
          </button>
          <button mat-raised-button color="primary" type="submit" [disabled]="isLoading || specDefForm.invalid">
            <mat-icon *ngIf="!isLoading">save</mat-icon>
            <mat-progress-spinner *ngIf="isLoading" diameter="20" mode="indeterminate" style="margin-right: 8px; display: inline-block;"></mat-progress-spinner>
            {{ isLoading ? 'Se salvează...' : submitButtonText }}
          </button>
        </div>
      </form>
    </mat-card-content>
  </mat-card>
</div>
</file>

<file path="app/features/admin/admin-specifications/admin-spec-def-form/admin-spec-def-form.component.scss">
.admin-spec-def-form-container {
  padding: 20px;
  max-width: 600px;
  margin: 20px auto;
}

mat-card-header {
  padding-bottom: 16px;
}

.full-width {
  width: 100%;
  margin-bottom: 16px;
}

.spinner-container {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  min-height: 150px;
  p {
    margin-top: 10px;
    opacity: 0.7;
  }
}

.form-actions {
  display: flex;
  justify-content: flex-end;
  gap: 10px;
  margin-top: 20px;
  button {
    min-width: 120px;
    mat-icon {
      margin-right: 8px;
    }
  }
}

mat-error {
  font-size: 0.85em;
}
</file>

<file path="app/features/admin/admin-specifications/admin-spec-def-form/admin-spec-def-form.component.ts">
// src/app/features/admin/admin-specifications/admin-spec-def-form/admin-spec-def-form.component.ts
import { Component, OnInit, inject } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ReactiveFormsModule, FormBuilder, FormGroup, Validators } from '@angular/forms';
import { ActivatedRoute, Router, RouterModule } from '@angular/router';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { MatButtonModule } from '@angular/material/button';
import { MatCardModule } from '@angular/material/card';
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { MatIconModule } from '@angular/material/icon';

import { SpecificationDefinition } from '../../../../shared/models/specification-definition.model';
import { SpecificationAdminService } from '../../services/specification-admin.service';

@Component({
  selector: 'app-admin-spec-def-form',
  standalone: true,
  imports: [
    CommonModule,
    RouterModule,
    ReactiveFormsModule,
    MatFormFieldModule,
    MatInputModule,
    MatButtonModule,
    MatCardModule,
    MatSnackBarModule,
    MatProgressSpinnerModule,
    MatIconModule
  ],
  templateUrl: './admin-spec-def-form.component.html',
  styleUrls: ['./admin-spec-def-form.component.scss']
})
export class AdminSpecDefFormComponent implements OnInit {
  specDefForm!: FormGroup;
  isEditMode = false;
  specDefId?: number;
  isLoading = false;
  pageTitle = 'Adaugă Definiție Specificație';
  submitButtonText = 'Salvează Definiție';

  private fb = inject(FormBuilder);
  private specAdminService = inject(SpecificationAdminService);
  private route = inject(ActivatedRoute);
  private router = inject(Router);
  private snackBar = inject(MatSnackBar);

  ngOnInit(): void {
    this.specDefForm = this.fb.group({
      name: ['', [Validators.required, Validators.minLength(2), Validators.maxLength(100)]],
      unit: ['', [Validators.maxLength(50)]] // Unitatea este opțională
    });

    const idFromRoute = this.route.snapshot.paramMap.get('id');
    if (idFromRoute) {
      this.specDefId = +idFromRoute;
      if (!isNaN(this.specDefId) && this.specDefId > 0) {
        this.isEditMode = true;
        this.pageTitle = 'Editează Definiție Specificație';
        this.submitButtonText = 'Actualizează Definiție';
        this.loadSpecDefData(this.specDefId);
      } else {
        this.handleInvalidId('ID definiție specificație invalid din rută.');
      }
    }
  }

  loadSpecDefData(id: number): void {
    this.isLoading = true;
    this.specAdminService.getDefinitionById(id).subscribe({
      next: (specDef) => {
        this.specDefForm.patchValue(specDef);
        this.isLoading = false;
      },
      error: (err) => this.handleLoadError('Eroare la încărcarea datelor definiției.', err)
    });
  }

  onSubmit(): void {
    if (this.specDefForm.invalid) {
      this.snackBar.open('Formular invalid. Verificați câmpurile.', 'OK', { duration: 3000 });
      this.specDefForm.markAllAsTouched();
      return;
    }
    this.isLoading = true;
    const specDefData: SpecificationDefinition = this.specDefForm.value;

    const operation = this.isEditMode && this.specDefId
      ? this.specAdminService.updateDefinition(this.specDefId, { ...specDefData, id: this.specDefId })
      : this.specAdminService.createDefinition(specDefData as Omit<SpecificationDefinition, 'id'>);

    operation.subscribe({
      next: () => {
        this.isLoading = false;
        this.snackBar.open(`Definiție specificație ${this.isEditMode ? 'actualizată' : 'creată'} cu succes!`, 'OK', { duration: 3000 });
        this.router.navigate(['/admin/specification-definitions']);
      },
      error: (err) => this.handleSubmitError(`Eroare la ${this.isEditMode ? 'actualizarea' : 'crearea'} definiției.`, err)
    });
  }
  
  private handleInvalidId(message: string): void {
    this.isLoading = false;
    this.snackBar.open(message, 'Închide', { duration: 3000 });
    this.router.navigate(['/admin/specification-definitions']);
  }

  private handleLoadError(message: string, err: any): void {
    this.isLoading = false;
    const errMsg = err.error?.message || err.message || 'Eroare necunoscută.';
    this.snackBar.open(`${message} ${errMsg}`, 'Închide', { duration: 5000 });
    console.error(err);
    this.router.navigate(['/admin/specification-definitions']);
  }

  private handleSubmitError(message: string, err: any): void {
    this.isLoading = false;
    const errMsg = err.error?.message || err.message || 'Eroare necunoscută.';
    this.snackBar.open(`${message} ${errMsg}`, 'Închide', { duration: 5000 });
    console.error(err);
  }

  get f() { return this.specDefForm.controls; }
}
</file>

<file path="app/features/admin/admin-specifications/admin-spec-def-list/admin-spec-def-list.component.html">
<div class="admin-spec-def-list-container">
  <div class="header">
    <h2>Administrare Definiții Specificații</h2>
    <button mat-raised-button color="primary" routerLink="/admin/specification-definitions/new">
      <mat-icon>add_circle_outline</mat-icon> Adaugă Definiție Nouă
    </button>
  </div>

  <mat-form-field appearance="outline" class="filter-field">
    <mat-label>Filtrează definiții</mat-label>
    <input matInput (keyup)="applyFilter($event)" placeholder="Caută după nume, unitate...">
    <mat-icon matSuffix>search</mat-icon>
  </mat-form-field>

  <div *ngIf="isLoading" class="loading-indicator">
    <mat-spinner diameter="50"></mat-spinner>
    <p>Se încarcă definițiile specificațiilor...</p>
  </div>

  <div *ngIf="error && !isLoading" class="error-message">
    <p>{{ error }}</p>
    <button mat-stroked-button color="warn" (click)="loadSpecDefinitions()">Reîncearcă</button>
  </div>

  <div *ngIf="!isLoading && !error && dataSource.data.length === 0" class="no-data">
    <p>Nu există definiții de specificații.</p>
  </div>

  <div class="table-container" *ngIf="!isLoading && !error && dataSource.data.length > 0">
    <table mat-table [dataSource]="dataSource" matSort class="mat-elevation-z8">

      <ng-container matColumnDef="id">
        <th mat-header-cell *matHeaderCellDef mat-sort-header> ID </th>
        <td mat-cell *matCellDef="let specDef"> {{specDef.id}} </td>
      </ng-container>

      <ng-container matColumnDef="name">
        <th mat-header-cell *matHeaderCellDef mat-sort-header> Nume Specificație </th>
        <td mat-cell *matCellDef="let specDef"> {{specDef.name}} </td>
      </ng-container>

      <ng-container matColumnDef="unit">
        <th mat-header-cell *matHeaderCellDef mat-sort-header> Unitate </th>
        <td mat-cell *matCellDef="let specDef"> {{specDef.unit || 'N/A'}} </td>
      </ng-container>

      <ng-container matColumnDef="actions">
        <th mat-header-cell *matHeaderCellDef> Acțiuni </th>
        <td mat-cell *matCellDef="let specDef">
          <button mat-icon-button color="primary" [routerLink]="['/admin/specification-definitions/edit', specDef.id]" aria-label="Editează definiția">
            <mat-icon>edit</mat-icon>
          </button>
          <button mat-icon-button color="warn" (click)="deleteSpecDefinition(specDef.id!)" aria-label="Șterge definiția">
            <mat-icon>delete</mat-icon>
          </button>
        </td>
      </ng-container>

      <tr mat-header-row *matHeaderRowDef="displayedColumns"></tr>
      <tr mat-row *matRowDef="let row; columns: displayedColumns;"></tr>

      <tr class="mat-row" *matNoDataRow>
        <td class="mat-cell" [attr.colspan]="displayedColumns.length">
          Nu s-au găsit definiții care să corespundă filtrului "{{dataSource.filter}}".
        </td>
      </tr>
    </table>
    <mat-paginator [pageSizeOptions]="[5, 10, 25, 50]" showFirstLastButtons aria-label="Selectează pagina de definiții"></mat-paginator>
  </div>
</div>
</file>

<file path="app/features/admin/admin-specifications/admin-spec-def-list/admin-spec-def-list.component.scss">
// src/app/features/admin/admin-specifications/admin-spec-def-list/admin-spec-def-list.component.scss
.admin-spec-def-list-container {
  padding: 20px;
  max-width: 900px; // Lățime adecvată pentru tabel
  margin: auto;
}

.header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
  h2 {
    margin: 0;
  }
  button mat-icon {
    margin-right: 8px;
  }
}

.filter-field {
  width: 100%;
  max-width: 400px;
  margin-bottom: 20px;
}

.loading-indicator,
.error-message,
.no-data {
  text-align: center;
  padding: 20px;
  color: #757575;
  mat-spinner {
    margin: 0 auto 10px auto;
  }
}

.error-message {
  color: #f44336; // Material Red
}

.table-container {
  overflow-x: auto;
  margin-top: 10px;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

table {
  width: 100%;
}

.mat-column-actions {
  width: 120px;
  text-align: right;
}

.mat-column-id {
  max-width: 80px;
}
.mat-column-unit {
  max-width: 150px;
}

.mat-header-cell {
  font-weight: 500;
  color: rgba(0,0,0,0.67);
}

.mat-row:hover {
  background-color: rgba(0,0,0,0.03);
}

.mat-cell, .mat-header-cell {
  padding: 8px 16px;
}
</file>

<file path="app/features/admin/admin-specifications/admin-spec-def-list/admin-spec-def-list.component.ts">
// src/app/features/admin/admin-specifications/admin-spec-def-list/admin-spec-def-list.component.ts
import { Component, OnInit, inject, ViewChild, AfterViewInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { RouterModule } from '@angular/router';
import { MatTableDataSource, MatTableModule } from '@angular/material/table';
import { MatPaginator, MatPaginatorModule } from '@angular/material/paginator';
import { MatSort, MatSortModule } from '@angular/material/sort';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar';
import { MatDialog } from '@angular/material/dialog'; // Pentru confirmare ștergere

import { SpecificationDefinition } from '../../../../shared/models/specification-definition.model';
import { SpecificationAdminService } from '../../services/specification-admin.service';
// import { ConfirmDialogComponent } from '../../../../shared/components/confirm-dialog/confirm-dialog.component'; // Dialog de confirmare

@Component({
  selector: 'app-admin-spec-def-list',
  standalone: true,
  imports: [
    CommonModule,
    RouterModule,
    MatTableModule,
    MatPaginatorModule,
    MatSortModule,
    MatFormFieldModule,
    MatInputModule,
    MatButtonModule,
    MatIconModule,
    MatProgressSpinnerModule,
    MatSnackBarModule
  ],
  templateUrl: './admin-spec-def-list.component.html',
  styleUrls: ['./admin-spec-def-list.component.scss']
})
export class AdminSpecDefListComponent implements OnInit, AfterViewInit {
  displayedColumns: string[] = ['id', 'name', 'unit', 'actions'];
  dataSource: MatTableDataSource<SpecificationDefinition> = new MatTableDataSource();
  isLoading = true;
  error: string | null = null;

  @ViewChild(MatPaginator) paginator!: MatPaginator;
  @ViewChild(MatSort) sort!: MatSort;

  private specAdminService = inject(SpecificationAdminService);
  private snackBar = inject(MatSnackBar);
  // private dialog = inject(MatDialog); // Decomentează dacă folosești MatDialog

  ngOnInit(): void {
    this.loadSpecDefinitions();
  }

  ngAfterViewInit(): void {
    this.dataSource.paginator = this.paginator;
    this.dataSource.sort = this.sort;
  }

  loadSpecDefinitions(): void {
    this.isLoading = true;
    this.error = null;
    this.specAdminService.getAllDefinitions().subscribe({
      next: (data) => {
        this.dataSource.data = data;
        this.isLoading = false;
      },
      error: (err) => {
        this.error = 'Nu s-au putut încărca definițiile specificațiilor.';
        console.error(err);
        this.isLoading = false;
        this.snackBar.open(this.error, 'Închide', { duration: 5000 });
      }
    });
  }

  applyFilter(event: Event): void {
    const filterValue = (event.target as HTMLInputElement).value;
    this.dataSource.filter = filterValue.trim().toLowerCase();
    if (this.dataSource.paginator) {
      this.dataSource.paginator.firstPage();
    }
  }

  deleteSpecDefinition(specDefId: number): void {
    // TODO: Implementează un dialog de confirmare (MatDialog)
    const confirmation = window.confirm('Sunteți sigur că doriți să ștergeți această definiție de specificație? Aceasta ar putea afecta produsele existente.');
    if (confirmation) {
      this.specAdminService.deleteDefinition(specDefId).subscribe({
        next: () => {
          this.snackBar.open('Definiție specificație ștearsă cu succes!', 'OK', { duration: 3000 });
          this.loadSpecDefinitions(); // Reîncarcă lista
        },
        error: (err) => {
          const errMsg = err.error?.message || err.message || 'Eroare la ștergerea definiției specificației.';
          this.snackBar.open(errMsg, 'Închide', { duration: 5000 });
          console.error(err);
        }
      });
    }
  }
}
</file>

<file path="app/features/admin/admin-users/admin-user-form/admin-user-form.component.html">
<!-- src/app/features/admin/admin-users/admin-user-form/admin-user-form.component.html -->
<div class="admin-user-form-container">
  <mat-card>
    <mat-card-header>
      <mat-card-title>{{ pageTitle }}</mat-card-title>
      <!-- Corectat: userToEdit.username deoarece *ngIf="userToEdit" este prezent -->
      <mat-card-subtitle *ngIf="userToEdit">Modifici datele pentru: {{ userToEdit.username }}</mat-card-subtitle>
    </mat-card-header>
    <mat-card-content>
      <div *ngIf="isLoading && userId" class="spinner-container">
        <mat-progress-spinner diameter="50" mode="indeterminate"></mat-progress-spinner>
        <p>Se încarcă datele utilizatorului...</p>
      </div>

      <form [formGroup]="userForm" (ngSubmit)="onSubmit()" *ngIf="!isLoading || !userId">
        <mat-form-field appearance="outline" class="full-width">
          <mat-label>Username</mat-label>
          <input matInput formControlName="username" readonly>
          <mat-icon matSuffix>person_outline</mat-icon>
          <mat-hint>Username-ul nu poate fi modificat.</mat-hint>
        </mat-form-field>

        <mat-form-field appearance="outline" class="full-width">
          <mat-label>Adresă Email</mat-label>
          <input matInput type="email" formControlName="email" required>
          <mat-icon matSuffix>email</mat-icon>
          <mat-error *ngIf="userForm.get('email')?.hasError('required')">Email-ul este obligatoriu.</mat-error>
          <mat-error *ngIf="userForm.get('email')?.hasError('email')">Format email invalid.</mat-error>
          <mat-error *ngIf="userForm.get('email')?.hasError('maxlength')">Email-ul nu poate depăși 100 de caractere.</mat-error>
        </mat-form-field>

        <mat-form-field appearance="outline" class="full-width">
          <mat-label>Roluri Utilizator</mat-label>
          <mat-select formControlName="selectedRoles" multiple>
            <mat-option *ngFor="let role of availableRoles" [value]="role">
              {{ role.replace('ROLE_', '') }}
            </mat-option>
          </mat-select>
          <mat-error *ngIf="userForm.get('selectedRoles')?.hasError('required') && (userForm.get('selectedRoles')?.touched || userForm.get('selectedRoles')?.dirty)">
            Cel puțin un rol trebuie selectat.
          </mat-error>
           <mat-hint *ngIf="userId === currentUserId">Atenție: Nu vă puteți elimina propriul rol de Administrator.</mat-hint>
        </mat-form-field>

        <div class="form-actions">
          <button mat-stroked-button color="warn" type="button" routerLink="/admin/users" [disabled]="isLoading">
            <mat-icon>cancel</mat-icon> Anulează
          </button>
          <button mat-raised-button color="primary" type="submit" [disabled]="isLoading || userForm.invalid">
            <mat-icon *ngIf="!isLoading">save</mat-icon>
            <mat-progress-spinner *ngIf="isLoading" diameter="20" mode="indeterminate" style="margin-right: 8px; display: inline-block;"></mat-progress-spinner>
            {{ isLoading ? 'Se actualizează...' : submitButtonText }}
          </button>
        </div>
      </form>
    </mat-card-content>
  </mat-card>
</div>
</file>

<file path="app/features/admin/admin-users/admin-user-form/admin-user-form.component.scss">
.admin-user-form-container {
  padding: 20px;
  max-width: 700px;
  margin: 20px auto;
}

mat-card-header {
  padding-bottom: 16px;
}

.full-width {
  width: 100%;
  margin-bottom: 16px;
}

.spinner-container {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  min-height: 150px;
  p {
    margin-top: 10px;
    opacity: 0.7;
  }
}

.roles-checkbox-group {
  margin-bottom: 16px;
  .roles-label {
    display: block;
    margin-bottom: 8px;
    font-weight: 500;
    opacity: 0.7;
  }
  .role-checkbox {
    margin-right: 16px;
  }
}

.form-actions {
  display: flex;
  justify-content: flex-end;
  gap: 10px;
  margin-top: 20px;
  button {
    min-width: 120px;
    mat-icon {
      margin-right: 8px;
    }
  }
}

mat-error {
  font-size: 0.85em;
}
</file>

<file path="app/features/admin/admin-users/admin-user-form/admin-user-form.component.ts">
// src/app/features/admin/admin-users/admin-user-form/admin-user-form.component.ts
import { Component, OnInit, inject } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ReactiveFormsModule, FormBuilder, FormGroup, Validators, FormControl } from '@angular/forms'; // Import FormControl
import { ActivatedRoute, Router, RouterModule } from '@angular/router';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { MatButtonModule } from '@angular/material/button';
import { MatCardModule } from '@angular/material/card';
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { MatIconModule } from '@angular/material/icon';
import { MatSelectModule } from '@angular/material/select';
import { MatCheckboxModule } from '@angular/material/checkbox';
import { HttpErrorResponse } from '@angular/common/http';


import { User, UserUpdateDto } from '../../../../shared/models/user.model';
import { UserAdminService } from '../../services/user-admin.service';
import { AuthService } from '../../../../auth/auth.service';

@Component({
  selector: 'app-admin-user-form',
  standalone: true,
  imports: [
    CommonModule,
    RouterModule,
    ReactiveFormsModule,
    MatFormFieldModule,
    MatInputModule,
    MatButtonModule,
    MatCardModule,
    MatSnackBarModule,
    MatProgressSpinnerModule,
    MatIconModule,
    MatSelectModule,
    MatCheckboxModule
  ],
  templateUrl: './admin-user-form.component.html',
  styleUrls: ['./admin-user-form.component.scss']
})
export class AdminUserFormComponent implements OnInit {
  userForm!: FormGroup;
  userId!: number;
  isLoading = false;
  pageTitle = 'Editează Utilizator';
  submitButtonText = 'Actualizează Utilizator';
  userToEdit: User | null = null;
  error: string | null = null; // Adăugat pentru a stoca mesajul de eroare

  availableRoles: string[] = ['ROLE_USER', 'ROLE_ADMIN'];
  currentUserId: number | null = null;

  private fb = inject(FormBuilder);
  private userAdminService = inject(UserAdminService);
  private route = inject(ActivatedRoute);
  private router = inject(Router);
  private snackBar = inject(MatSnackBar);
  private authService = inject(AuthService);

  ngOnInit(): void {
    this.userForm = this.fb.group({
      username: [{ value: '', disabled: true }],
      email: ['', [Validators.required, Validators.email, Validators.maxLength(100)]],
      // Folosim un FormControl care va ține un array de string-uri pentru MatSelect multiple
      selectedRoles: new FormControl([] as string[], Validators.required) // <<< CORECTAT
    });

    const idFromRoute = this.route.snapshot.paramMap.get('id');
    if (idFromRoute) {
      this.userId = +idFromRoute;
      if (!isNaN(this.userId) && this.userId > 0) {
        this.loadUserData(this.userId);
      } else {
        this.handleInvalidId('ID utilizator invalid din rută.');
      }
    } else {
      this.handleInvalidId('ID utilizator lipsă din rută.');
    }

    const currentUser = this.authService.getCurrentUser();
     if (currentUser && currentUser.id) {
        this.currentUserId = currentUser.id;
    }
  }

  loadUserData(id: number): void {
    this.isLoading = true;
    this.userAdminService.getUserById(id).subscribe({
      next: (user: User) => { // Tipare explicită
        this.userToEdit = user;
        this.userForm.patchValue({
          username: user.username,
          email: user.email,
          // Setează valoarea pentru FormControl-ul de roluri
          selectedRoles: user.roles || [] // <<< CORECTAT
        });
        this.isLoading = false;
      },
      error: (err: HttpErrorResponse) => this.handleLoadError('Eroare la încărcarea datelor utilizatorului.', err) // Tipare explicită
    });
  }

  onSubmit(): void {
    if (this.userForm.invalid) {
      this.snackBar.open('Formular invalid. Verificați câmpurile.', 'OK', { duration: 3000 });
      this.userForm.markAllAsTouched();
      return;
    }

    const selectedRolesValue = this.userForm.get('selectedRoles')?.value as string[];

    if (this.userId === this.currentUserId) {
        if (!selectedRolesValue.includes('ROLE_ADMIN')) {
            this.snackBar.open('Nu vă puteți elimina propriul rol de Administrator.', 'OK', {duration: 5000});
            return;
        }
    }

    this.isLoading = true;
    const userData: UserUpdateDto = {
      email: this.userForm.get('email')?.value,
      roles: selectedRolesValue
    };

    // Log the data being sent
    console.log('Sending update data:', JSON.stringify(userData));
    console.log('User ID:', this.userId);

    this.userAdminService.updateUser(this.userId, userData).subscribe({
      next: () => {
        this.isLoading = false;
        this.snackBar.open('Utilizator actualizat cu succes!', 'OK', { duration: 3000 });
        this.router.navigate(['/admin/users']);
      },
      error: (err: HttpErrorResponse) => this.handleSubmitError('Eroare la actualizarea utilizatorului.', err)
    });
  }
  
  private handleInvalidId(message: string): void {
    this.isLoading = false;
    this.error = message;
    this.snackBar.open(this.error, 'Închide', { duration: 3000 });
    this.router.navigate(['/admin/users']);
  }

  private handleLoadError(message: string, err: HttpErrorResponse): void {
    this.isLoading = false;
    const serverErrorMessage = err.error?.message || err.message || 'Eroare necunoscută.';
    this.error = `${message} ${serverErrorMessage}`;
    this.snackBar.open(this.error, 'Închide', { duration: 5000 });
    console.error(err);
    this.router.navigate(['/admin/users']);
  }

  private handleSubmitError(message: string, err: HttpErrorResponse): void {
    this.isLoading = false;
    const serverErrorMessage = err.error?.message || err.message || 'Eroare necunoscută.';
    this.snackBar.open(`${message} ${serverErrorMessage}`, 'Închide', { duration: 5000 });
    console.error(err);
  }

  get f() { return this.userForm.controls; }
}
</file>

<file path="app/features/admin/admin-users/admin-user-list/admin-user-list.component.html">
<div class="admin-user-list-container">
  <div class="header">
    <h2>Administrare Utilizatori</h2>
    <!-- <button mat-raised-button color="primary" routerLink="/admin/users/new">
      <mat-icon>person_add</mat-icon> Adaugă Utilizator Nou
    </button> -->
  </div>

  <mat-form-field appearance="outline" class="filter-field">
    <mat-label>Filtrează utilizatori</mat-label>
    <input matInput (keyup)="applyFilter($event)" placeholder="Caută după username, email...">
    <mat-icon matSuffix>search</mat-icon>
  </mat-form-field>

  <div *ngIf="isLoading" class="loading-indicator">
    <mat-spinner diameter="50"></mat-spinner>
    <p>Se încarcă utilizatorii...</p>
  </div>

  <div *ngIf="error && !isLoading" class="error-message">
    <p>{{ error }}</p>
    <button mat-stroked-button color="warn" (click)="loadUsers()">Reîncearcă</button>
  </div>

  <div *ngIf="!isLoading && !error && dataSource.data.length === 0" class="no-data">
    <p>Nu există utilizatori înregistrați sau care să corespundă filtrului.</p>
  </div>

  <div class="table-container" *ngIf="!isLoading && !error && dataSource.data.length > 0">
    <table mat-table [dataSource]="dataSource" matSort class="mat-elevation-z8">

      <ng-container matColumnDef="id">
        <th mat-header-cell *matHeaderCellDef mat-sort-header> ID </th>
        <td mat-cell *matCellDef="let user"> {{user.id}} </td>
      </ng-container>

      <ng-container matColumnDef="username">
        <th mat-header-cell *matHeaderCellDef mat-sort-header> Username </th>
        <td mat-cell *matCellDef="let user"> {{user.username}} </td>
      </ng-container>

      <ng-container matColumnDef="email">
        <th mat-header-cell *matHeaderCellDef mat-sort-header> Email </th>
        <td mat-cell *matCellDef="let user"> {{user.email}} </td>
      </ng-container>

      <ng-container matColumnDef="roles">
        <th mat-header-cell *matHeaderCellDef mat-sort-header> Roluri </th>
        <td mat-cell *matCellDef="let user">
          <mat-chip-set aria-label="Roluri utilizator">
            <mat-chip *ngFor="let role of user.roles" [color]="role === 'ROLE_ADMIN' ? 'accent' : 'primary'" selected>
              {{ role.replace('ROLE_', '') }}
            </mat-chip>
          </mat-chip-set>
        </td>
      </ng-container>

      <ng-container matColumnDef="actions">
        <th mat-header-cell *matHeaderCellDef> Acțiuni </th>
        <td mat-cell *matCellDef="let user">
          <button mat-icon-button color="primary" [routerLink]="['/admin/users/edit', user.id]" aria-label="Editează utilizatorul">
            <mat-icon>edit</mat-icon>
          </button>
          <button mat-icon-button color="warn" (click)="deleteUser(user.id!, user.username)" [disabled]="user.id === currentUserId" aria-label="Șterge utilizatorul">
            <mat-icon>delete</mat-icon>
          </button>
        </td>
      </ng-container>

      <tr mat-header-row *matHeaderRowDef="displayedColumns"></tr>
      <tr mat-row *matRowDef="let row; columns: displayedColumns;"></tr>

      <tr class="mat-row" *matNoDataRow>
        <td class="mat-cell" [attr.colspan]="displayedColumns.length">
          Nu s-au găsit utilizatori care să corespundă filtrului "{{dataSource.filter}}".
        </td>
      </tr>
    </table>
    <mat-paginator [pageSizeOptions]="[5, 10, 25, 50]" showFirstLastButtons aria-label="Selectează pagina de utilizatori"></mat-paginator>
  </div>
</div>
</file>

<file path="app/features/admin/admin-users/admin-user-list/admin-user-list.component.scss">
.admin-user-list-container {
  padding: 20px;
  max-width: 1000px;
  margin: auto;
}

.header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
  h2 {
    margin: 0;
  }
}

.filter-field {
  width: 100%;
  max-width: 400px;
  margin-bottom: 20px;
}

.loading-indicator,
.error-message,
.no-data {
  text-align: center;
  padding: 20px;
  mat-spinner {
    margin: 0 auto 10px auto;
  }
}

.error-message {
  color: #f44336;
}

.table-container {
  overflow-x: auto;
  margin-top: 10px;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

table {
  width: 100%;
}

.mat-column-actions {
  width: 120px;
  text-align: right;
}

.mat-column-id {
  max-width: 80px;
}
.mat-column-roles {
  min-width: 150px;
  mat-chip {
    margin-right: 4px;
    margin-bottom: 4px;
    font-size: 0.85em;
    padding: 4px 8px;
    height: 24px;
  }
}

.mat-header-cell {
  font-weight: 500;
  opacity: 0.87;
}

.mat-row:hover {
  background-color: rgba(0,0,0,0.03);
}

.mat-cell, .mat-header-cell {
  padding: 8px 16px;
}
</file>

<file path="app/features/admin/admin-users/admin-user-list/admin-user-list.component.ts">
// src/app/features/admin/admin-users/admin-user-list/admin-user-list.component.ts
import { Component, OnInit, inject, ViewChild, AfterViewInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { RouterModule } from '@angular/router';
import { MatTableDataSource, MatTableModule } from '@angular/material/table';
import { MatPaginator, MatPaginatorModule } from '@angular/material/paginator';
import { MatSort, MatSortModule } from '@angular/material/sort';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar';
import { MatChipsModule } from '@angular/material/chips'; // Pentru afișarea rolurilor
import { MatDialog } from '@angular/material/dialog';
// import { ConfirmDialogComponent } from '../../../../shared/components/confirm-dialog/confirm-dialog.component';

import { User } from '../../../../shared/models/user.model';
import { UserAdminService } from '../../services/user-admin.service';
import { AuthService } from '../../../../auth/auth.service'; // Pentru a nu permite ștergerea userului curent

@Component({
  selector: 'app-admin-user-list',
  standalone: true,
  imports: [
    CommonModule,
    RouterModule,
    MatTableModule,
    MatPaginatorModule,
    MatSortModule,
    MatFormFieldModule,
    MatInputModule,
    MatButtonModule,
    MatIconModule,
    MatProgressSpinnerModule,
    MatSnackBarModule,
    MatChipsModule
  ],
  templateUrl: './admin-user-list.component.html',
  styleUrls: ['./admin-user-list.component.scss']
})
export class AdminUserListComponent implements OnInit, AfterViewInit {
  displayedColumns: string[] = ['id', 'username', 'email', 'roles', 'actions'];
  dataSource: MatTableDataSource<User> = new MatTableDataSource();
  isLoading = true;
  error: string | null = null;
  currentUserId: number | null = null;

  @ViewChild(MatPaginator) paginator!: MatPaginator;
  @ViewChild(MatSort) sort!: MatSort;

  private userAdminService = inject(UserAdminService);
  private snackBar = inject(MatSnackBar);
  private authService = inject(AuthService); // Injectează AuthService
  // private dialog = inject(MatDialog);

  ngOnInit(): void {
    this.loadUsers();
    // Obține ID-ul utilizatorului curent pentru a preveni auto-ștergerea
    const currentUser = this.authService.getCurrentUser(); // Presupunând că AuthService are această metodă
    if (currentUser && currentUser.id) {
        this.currentUserId = currentUser.id;
    }
  }

  ngAfterViewInit(): void {
    this.dataSource.paginator = this.paginator;
    this.dataSource.sort = this.sort;
    // Custom sort pentru roluri (array de string-uri)
    this.dataSource.sortingDataAccessor = (item, property) => {
      switch (property) {
        case 'roles': return item.roles.join(', ');
        default: return (item as any)[property];
      }
    };
  }

  loadUsers(): void {
    this.isLoading = true;
    this.error = null;
    this.userAdminService.getAllUsers().subscribe({
      next: (data) => {
        this.dataSource.data = data;
        this.isLoading = false;
      },
      error: (err) => {
        this.error = 'Nu s-au putut încărca utilizatorii.';
        console.error(err);
        this.isLoading = false;
        this.snackBar.open(this.error, 'Închide', { duration: 5000 });
      }
    });
  }

  applyFilter(event: Event): void {
    const filterValue = (event.target as HTMLInputElement).value;
    this.dataSource.filter = filterValue.trim().toLowerCase();
    if (this.dataSource.paginator) {
      this.dataSource.paginator.firstPage();
    }
  }

  deleteUser(userId: number, username: string): void {
    if (userId === this.currentUserId) {
      this.snackBar.open('Nu vă puteți șterge propriul cont de administrator.', 'OK', { duration: 5000 });
      return;
    }

    // TODO: Implementează un dialog de confirmare (MatDialog)
    const confirmation = window.confirm(`Sunteți sigur că doriți să ștergeți utilizatorul "${username}"?`);
    if (confirmation) {
      this.userAdminService.deleteUser(userId).subscribe({
        next: () => {
          this.snackBar.open(`Utilizatorul "${username}" a fost șters cu succes!`, 'OK', { duration: 3000 });
          this.loadUsers(); // Reîncarcă lista
        },
        error: (err) => {
          const errMsg = err.error?.message || err.message || `Eroare la ștergerea utilizatorului "${username}".`;
          this.snackBar.open(errMsg, 'Închide', { duration: 5000 });
          console.error(err);
        }
      });
    }
  }

  formatRoles(roles: string[]): string {
    return roles.map(role => role.replace('ROLE_', '')).join(', ');
  }
}
</file>

<file path="app/features/admin/reports/reports.component.html">
<div class="reports-container">
  <mat-card class="reports-header">
    <mat-card-header>
      <mat-card-title>
        <mat-icon>assessment</mat-icon>
        Generare Rapoarte
      </mat-card-title>
    </mat-card-header>
    <mat-card-content>
      <form [formGroup]="reportForm" class="report-form">
        <mat-form-field appearance="outline">
          <mat-label>Data început</mat-label>
          <input matInput [matDatepicker]="startPicker" formControlName="startDate">
          <mat-datepicker-toggle matIconSuffix [for]="startPicker"></mat-datepicker-toggle>
          <mat-datepicker #startPicker></mat-datepicker>
        </mat-form-field>

        <mat-form-field appearance="outline">
          <mat-label>Data sfârșit</mat-label>
          <input matInput [matDatepicker]="endPicker" formControlName="endDate">
          <mat-datepicker-toggle matIconSuffix [for]="endPicker"></mat-datepicker-toggle>
          <mat-datepicker #endPicker></mat-datepicker>
        </mat-form-field>

        <button mat-raised-button color="primary" (click)="generateReport()" [disabled]="isLoading">
          <mat-icon>play_arrow</mat-icon>
          Generează Raport
        </button>

        <div class="download-buttons" *ngIf="generalReport">
          <button mat-stroked-button color="warn" (click)="downloadReport('pdf')" [disabled]="isLoading">
            <mat-icon>picture_as_pdf</mat-icon>
            Descarcă PDF
          </button>
          <button mat-stroked-button color="accent" (click)="downloadReport('excel')" [disabled]="isLoading">
            <mat-icon>table_chart</mat-icon>
            Descarcă Excel
          </button>
        </div>
      </form>
    </mat-card-content>
  </mat-card>

  <div class="loading-container" *ngIf="isLoading">
    <mat-spinner></mat-spinner>
    <p>Se generează raportul...</p>
  </div>

  <div class="report-content" *ngIf="generalReport && !isLoading">
    <!-- Rezumat General -->
    <div class="summary-cards">
      <mat-card class="summary-card">
        <mat-card-content>
          <div class="summary-icon sales">
            <mat-icon>shopping_cart</mat-icon>
          </div>
          <div class="summary-info">
            <h3>Vânzări Totale</h3>
            <p class="summary-value">{{ generalReport.salesReport.totalSales }}</p>
            <p class="summary-label">comenzi</p>
          </div>
        </mat-card-content>
      </mat-card>

      <mat-card class="summary-card">
        <mat-card-content>
          <div class="summary-icon revenue">
            <mat-icon>attach_money</mat-icon>
          </div>
          <div class="summary-info">
            <h3>Venituri Totale</h3>
            <p class="summary-value">{{ generalReport.salesReport.totalRevenue | currency:'RON':'symbol':'1.2-2' }}</p>
            <p class="summary-label">în perioada selectată</p>
          </div>
        </mat-card-content>
      </mat-card>

      <mat-card class="summary-card">
        <mat-card-content>
          <div class="summary-icon stock">
            <mat-icon>inventory</mat-icon>
          </div>
          <div class="summary-info">
            <h3>Produse în Stoc</h3>
            <p class="summary-value">{{ generalReport.stockReport.totalProducts }}</p>
            <p class="summary-label">produse disponibile</p>
          </div>
        </mat-card-content>
      </mat-card>

      <mat-card class="summary-card">
        <mat-card-content>
          <div class="summary-icon users">
            <mat-icon>people</mat-icon>
          </div>
          <div class="summary-info">
            <h3>Utilizatori Activi</h3>
            <p class="summary-value">{{ generalReport.userReport.activeUsers }}</p>
            <p class="summary-label">din {{ generalReport.userReport.totalUsers }} total</p>
          </div>
        </mat-card-content>
      </mat-card>
    </div>

    <!-- Tabs pentru diferite secțiuni -->
    <mat-tab-group animationDuration="0ms" class="report-tabs">
      <!-- Tab Vânzări -->
      <mat-tab label="Vânzări">
        <div class="tab-content">
          <mat-card>
            <mat-card-header>
              <mat-card-title>Evoluție Vânzări</mat-card-title>
            </mat-card-header>
            <mat-card-content>
              <div class="chart-container">
                <canvas id="salesChart"></canvas>
              </div>
            </mat-card-content>
          </mat-card>

          <mat-card class="mt-3">
            <mat-card-header>
              <mat-card-title>Top Produse Vândute</mat-card-title>
            </mat-card-header>
            <mat-card-content>
              <table mat-table [dataSource]="generalReport.salesReport.topSellingProducts" class="full-width">
                <ng-container matColumnDef="productName">
                  <th mat-header-cell *matHeaderCellDef>Produs</th>
                  <td mat-cell *matCellDef="let product">{{ product.productName }}</td>
                </ng-container>

                <ng-container matColumnDef="category">
                  <th mat-header-cell *matHeaderCellDef>Categorie</th>
                  <td mat-cell *matCellDef="let product">{{ product.category }}</td>
                </ng-container>

                <ng-container matColumnDef="quantitySold">
                  <th mat-header-cell *matHeaderCellDef>Cantitate Vândută</th>
                  <td mat-cell *matCellDef="let product">{{ product.quantitySold }}</td>
                </ng-container>

                <ng-container matColumnDef="revenue">
                  <th mat-header-cell *matHeaderCellDef>Venituri</th>
                  <td mat-cell *matCellDef="let product">{{ product.revenue | currency:'RON' }}</td>
                </ng-container>

                <ng-container matColumnDef="currentStock">
                  <th mat-header-cell *matHeaderCellDef>Stoc Curent</th>
                  <td mat-cell *matCellDef="let product">
                    <mat-chip [color]="getStockStatusColor(product.currentStock)">
                      {{ product.currentStock }}
                    </mat-chip>
                  </td>
                </ng-container>

                <tr mat-header-row *matHeaderRowDef="displayedProductColumns"></tr>
                <tr mat-row *matRowDef="let row; columns: displayedProductColumns;"></tr>
              </table>
            </mat-card-content>
          </mat-card>
        </div>
      </mat-tab>

      <!-- Tab Stoc -->
      <mat-tab label="Stoc">
        <div class="tab-content">
          <div class="stock-overview">
            <mat-card>
              <mat-card-header>
                <mat-card-title>Distribuție Stoc pe Categorii</mat-card-title>
              </mat-card-header>
              <mat-card-content>
                <div class="chart-container">
                  <canvas id="stockChart"></canvas>
                </div>
              </mat-card-content>
            </mat-card>

            <mat-card>
              <mat-card-header>
                <mat-card-title>Rezumat Stoc</mat-card-title>
              </mat-card-header>
              <mat-card-content>
                <div class="stock-stats">
                  <div class="stat-item">
                    <mat-icon color="warn">warning</mat-icon>
                    <div>
                      <p class="stat-value">{{ generalReport.stockReport.outOfStockProducts.length }}</p>
                      <p class="stat-label">Produse Epuizate</p>
                    </div>
                  </div>
                  <div class="stat-item">
                    <mat-icon color="accent">info</mat-icon>
                    <div>
                      <p class="stat-value">{{ generalReport.stockReport.lowStockProducts.length }}</p>
                      <p class="stat-label">Stoc Redus</p>
                    </div>
                  </div>
                  <div class="stat-item">
                    <mat-icon color="primary">attach_money</mat-icon>
                    <div>
                      <p class="stat-value">{{ generalReport.stockReport.totalStockValue | currency:'RON' }}</p>
                      <p class="stat-label">Valoare Totală Stoc</p>
                    </div>
                  </div>
                </div>
              </mat-card-content>
            </mat-card>
          </div>

          <mat-card class="mt-3" *ngIf="generalReport.stockReport.lowStockProducts.length > 0">
            <mat-card-header>
              <mat-card-title>Produse cu Stoc Redus</mat-card-title>
            </mat-card-header>
            <mat-card-content>
              <table mat-table [dataSource]="generalReport.stockReport.lowStockProducts" class="full-width">
                <ng-container matColumnDef="productName">
                  <th mat-header-cell *matHeaderCellDef>Produs</th>
                  <td mat-cell *matCellDef="let product">{{ product.productName }}</td>
                </ng-container>

                <ng-container matColumnDef="category">
                  <th mat-header-cell *matHeaderCellDef>Categorie</th>
                  <td mat-cell *matCellDef="let product">{{ product.category }}</td>
                </ng-container>

                <ng-container matColumnDef="currentStock">
                  <th mat-header-cell *matHeaderCellDef>Stoc Curent</th>
                  <td mat-cell *matCellDef="let product">
                    <mat-chip color="accent">{{ product.currentStock }}</mat-chip>
                  </td>
                </ng-container>

                <ng-container matColumnDef="stockValue">
                  <th mat-header-cell *matHeaderCellDef>Valoare Stoc</th>
                  <td mat-cell *matCellDef="let product">{{ product.stockValue | currency:'RON' }}</td>
                </ng-container>

                <tr mat-header-row *matHeaderRowDef="displayedStockColumns"></tr>
                <tr mat-row *matRowDef="let row; columns: displayedStockColumns;"></tr>
              </table>
            </mat-card-content>
          </mat-card>
        </div>
      </mat-tab>

      <!-- Tab Utilizatori -->
      <mat-tab label="Utilizatori">
        <div class="tab-content">
          <div class="user-stats">
            <mat-card>
              <mat-card-header>
                <mat-card-title>Statistici Utilizatori</mat-card-title>
              </mat-card-header>
              <mat-card-content>
                <div class="user-metrics">
                  <div class="metric">
                    <h4>Total Utilizatori</h4>
                    <p class="metric-value">{{ generalReport.userReport.totalUsers }}</p>
                  </div>
                  <div class="metric">
                    <h4>Utilizatori Activi</h4>
                    <p class="metric-value">{{ generalReport.userReport.activeUsers }}</p>
                  </div>
                  <div class="metric">
                    <h4>Înregistrări Luna Aceasta</h4>
                    <p class="metric-value">{{ generalReport.userReport.newUsersThisMonth }}</p>
                  </div>
                </div>

                <mat-divider class="my-3"></mat-divider>

                <h4>Distribuție pe Roluri</h4>
                <div class="role-distribution">
                  <div *ngFor="let role of generalReport.userReport.usersByRole" class="role-item">
                    <mat-chip [color]="role.role === 'ADMIN' ? 'warn' : 'primary'">
                      {{ role.role === 'ROLE_ADMIN' ? 'Administrator' : 'Utilizator' }}
                    </mat-chip>
                    <span class="role-count">{{ role.count }} utilizatori</span>
                  </div>
                </div>
              </mat-card-content>
            </mat-card>

            <mat-card class="mt-3">
              <mat-card-header>
                <mat-card-title>Înregistrări Recente</mat-card-title>
              </mat-card-header>
              <mat-card-content>
                <table mat-table [dataSource]="generalReport.userReport.recentRegistrations" class="full-width">
                  <ng-container matColumnDef="username">
                    <th mat-header-cell *matHeaderCellDef>Utilizator</th>
                    <td mat-cell *matCellDef="let user">{{ user.username }}</td>
                  </ng-container>

                  <ng-container matColumnDef="email">
                    <th mat-header-cell *matHeaderCellDef>Email</th>
                    <td mat-cell *matCellDef="let user">{{ user.email }}</td>
                  </ng-container>

                  <ng-container matColumnDef="registrationDate">
                    <th mat-header-cell *matHeaderCellDef>Data Înregistrării</th>
                    <td mat-cell *matCellDef="let user">{{ user.registrationDate | date:'dd/MM/yyyy' }}</td>
                  </ng-container>

                  <ng-container matColumnDef="isActive">
                    <th mat-header-cell *matHeaderCellDef>Status</th>
                    <td mat-cell *matCellDef="let user">
                      <mat-chip [color]="user.isActive ? 'primary' : 'warn'">
                        {{ user.isActive ? 'Activ' : 'Inactiv' }}
                      </mat-chip>
                    </td>
                  </ng-container>

                  <tr mat-header-row *matHeaderRowDef="displayedUserColumns"></tr>
                  <tr mat-row *matRowDef="let row; columns: displayedUserColumns;"></tr>
                </table>
              </mat-card-content>
            </mat-card>
          </div>
        </div>
      </mat-tab>
    </mat-tab-group>
  </div>
</div>
</file>

<file path="app/features/admin/reports/reports.component.scss">
.reports-container {
  padding: 20px;
  max-width: 1400px;
  margin: 0 auto;
}

.reports-header {
  margin-bottom: 24px;

  mat-card-header {
    mat-card-title {
      display: flex;
      align-items: center;
      gap: 12px;
      font-size: 1.5em;

      mat-icon {
        font-size: 1.2em;
      }
    }
  }
}

.report-form {
  display: flex;
  gap: 16px;
  align-items: center;
  flex-wrap: wrap;

  mat-form-field {
    flex: 1;
    min-width: 200px;
  }

  button {
    height: 56px;
  }

  .download-buttons {
    display: flex;
    gap: 12px;
    margin-left: auto;
  }
}

.loading-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 400px;

  p {
    margin-top: 16px;
    font-size: 1.1em;
    opacity: 0.7;
  }
}

.summary-cards {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: 20px;
  margin-bottom: 24px;

  .summary-card {
    transition: transform 0.2s;

    &:hover {
      transform: translateY(-4px);
    }

    mat-card-content {
      display: flex;
      align-items: center;
      gap: 20px;
      padding: 24px;
    }

    .summary-icon {
      width: 64px;
      height: 64px;
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;

      mat-icon {
        font-size: 32px;
        color: white;
      }

      &.sales {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      }

      &.revenue {
        background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
      }

      &.stock {
        background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
      }

      &.users {
        background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
      }
    }

    .summary-info {
      flex: 1;

      h3 {
        margin: 0 0 8px 0;
        font-size: 0.9em;
        opacity: 0.7;
        font-weight: 400;
      }

      .summary-value {
        margin: 0;
        font-size: 2em;
        font-weight: 500;
      }

      .summary-label {
        margin: 0;
        font-size: 0.85em;
        opacity: 0.6;
      }
    }
  }
}

.report-tabs {
  background-color: transparent;
}

.tab-content {
  padding: 24px 0;
}

.chart-container {
  position: relative;
  height: 300px;
  margin: 20px 0;
}

.full-width {
  width: 100%;
}

.mt-3 {
  margin-top: 24px;
}

.my-3 {
  margin: 24px 0;
}

.stock-overview {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 20px;

  @media (max-width: 1024px) {
    grid-template-columns: 1fr;
  }
}

.stock-stats {
  display: flex;
  flex-direction: column;
  gap: 16px;

  .stat-item {
    display: flex;
    align-items: center;
    gap: 16px;
    padding: 16px;
    background: rgba(0, 0, 0, 0.02);
    border-radius: 8px;

    mat-icon {
      font-size: 32px;
    }

    .stat-value {
      margin: 0;
      font-size: 1.5em;
      font-weight: 500;
    }

    .stat-label {
      margin: 0;
      font-size: 0.9em;
      opacity: 0.7;
    }
  }
}

.user-metrics {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 20px;
  margin-bottom: 24px;

  .metric {
    text-align: center;
    padding: 20px;
    background: rgba(0, 0, 0, 0.02);
    border-radius: 8px;

    h4 {
      margin: 0 0 12px 0;
      opacity: 0.7;
      font-weight: 400;
    }

    .metric-value {
      margin: 0;
      font-size: 2.5em;
      font-weight: 500;
    }
  }
}

.role-distribution {
  display: flex;
  flex-direction: column;
  gap: 12px;
  margin-top: 16px;

  .role-item {
    display: flex;
    align-items: center;
    gap: 12px;

    .role-count {
      opacity: 0.7;
      font-size: 0.9em;
    }
  }
}

table {
  background-color: transparent;

  th {
    font-weight: 500;
    opacity: 0.7;
    font-size: 0.9em;
  }

  tr:hover {
    background-color: rgba(0, 0, 0, 0.02);
  }
}

mat-chip {
  font-size: 0.85em;
}

// Responsive
@media (max-width: 768px) {
  .report-form {
    flex-direction: column;

    mat-form-field,
    button {
      width: 100%;
    }

    .download-buttons {
      width: 100%;
      margin-left: 0;
      margin-top: 12px;

      button {
        flex: 1;
      }
    }
  }

  .summary-cards {
    grid-template-columns: 1fr;
  }

  .user-metrics {
    grid-template-columns: 1fr;
  }
}
</file>

<file path="app/features/admin/reports/reports.component.ts">
import { Component, OnInit, inject } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ReactiveFormsModule, FormBuilder, FormGroup, Validators } from '@angular/forms';
import { MatCardModule } from '@angular/material/card';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatDatepickerModule } from '@angular/material/datepicker';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { MatSelectModule } from '@angular/material/select';
import { MatTabsModule } from '@angular/material/tabs';
import { MatTableModule } from '@angular/material/table';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar';
import { MatNativeDateModule } from '@angular/material/core';
import { MatDividerModule } from '@angular/material/divider';
import { MatChipsModule } from '@angular/material/chips';

import { ReportService } from '../../admin/services/report.service';
import { GeneralReport } from '../../../shared/models/report.model';
import { Chart, registerables } from 'chart.js';

Chart.register(...registerables);

@Component({
  selector: 'app-reports',
  standalone: true,
  imports: [
    CommonModule,
    ReactiveFormsModule,
    MatCardModule,
    MatButtonModule,
    MatIconModule,
    MatDatepickerModule,
    MatNativeDateModule,
    MatFormFieldModule,
    MatInputModule,
    MatSelectModule,
    MatTabsModule,
    MatTableModule,
    MatProgressSpinnerModule,
    MatSnackBarModule,
    MatDividerModule,
    MatChipsModule
  ],
  templateUrl: './reports.component.html',
  styleUrls: ['./reports.component.scss']
})
export class ReportsComponent implements OnInit {
  reportForm!: FormGroup;
  generalReport: GeneralReport | null = null;
  isLoading = false;
  
  // Variabile pentru grafice
  salesChart: Chart | null = null;
  stockChart: Chart | null = null;
  
  // Configurări pentru tabel
  displayedProductColumns = ['productName', 'category', 'quantitySold', 'revenue', 'currentStock'];
  displayedStockColumns = ['productName', 'category', 'currentStock', 'stockValue'];
  displayedUserColumns = ['username', 'email', 'registrationDate', 'isActive'];

  private fb = inject(FormBuilder);
  private reportService = inject(ReportService);
  private snackBar = inject(MatSnackBar);

  ngOnInit(): void {
    const today = new Date();
    const lastMonth = new Date(today.getFullYear(), today.getMonth() - 1, today.getDate());

    this.reportForm = this.fb.group({
      startDate: [lastMonth, Validators.required],
      endDate: [today, Validators.required],
      reportType: ['general', Validators.required]
    });
  }

  generateReport(): void {
    if (this.reportForm.invalid) {
      this.snackBar.open('Selectați perioada pentru raport', 'OK', { duration: 3000 });
      return;
    }

    this.isLoading = true;
    const { startDate, endDate } = this.reportForm.value;

    this.reportService.generateGeneralReport(startDate, endDate).subscribe({
      next: (report) => {
        this.generalReport = report;
        this.isLoading = false;
        this.snackBar.open('Raport generat cu succes!', 'OK', { duration: 3000 });
        
        // Actualizează graficele după primirea datelor
        setTimeout(() => {
          this.updateCharts();
        }, 100);
      },
      error: (err) => {
        this.isLoading = false;
        this.snackBar.open('Eroare la generarea raportului', 'Închide', { duration: 5000 });
        console.error('Report generation error:', err);
      }
    });
  }

  updateCharts(): void {
    if (!this.generalReport) return;

    // Grafic vânzări
    this.createSalesChart();
    
    // Grafic stoc pe categorii
    this.createStockChart();
  }

  createSalesChart(): void {
    const canvas = document.getElementById('salesChart') as HTMLCanvasElement;
    if (!canvas || !this.generalReport) return;

    if (this.salesChart) {
      this.salesChart.destroy();
    }

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    const salesData = this.generalReport.salesReport.dailySales;
    
    this.salesChart = new Chart(ctx, {
      type: 'line',
      data: {
        labels: salesData.map(d => new Date(d.date).toLocaleDateString('ro-RO')),
        datasets: [{
          label: 'Vânzări zilnice (RON)',
          data: salesData.map(d => d.revenue),
          borderColor: '#448AFF',
          backgroundColor: 'rgba(68, 138, 255, 0.1)',
          tension: 0.4
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: {
            display: true,
            labels: {
              color: '#ccc'
            }
          }
        },
        scales: {
          x: {
            grid: {
              color: '#333'
            },
            ticks: {
              color: '#ccc'
            }
          },
          y: {
            grid: {
              color: '#333'
            },
            ticks: {
              color: '#ccc',
              callback: function(value) {
                return value + ' RON';
              }
            }
          }
        }
      }
    });
  }

  createStockChart(): void {
    const canvas = document.getElementById('stockChart') as HTMLCanvasElement;
    if (!canvas || !this.generalReport) return;

    if (this.stockChart) {
      this.stockChart.destroy();
    }

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    const stockData = this.generalReport.stockReport.categoryStock;
    
    this.stockChart = new Chart(ctx, {
      type: 'doughnut',
      data: {
        labels: stockData.map(c => c.category),
        datasets: [{
          data: stockData.map(c => c.totalStock),
          backgroundColor: [
            '#448AFF',
            '#FF6B6B',
            '#4ECDC4',
            '#45B7D1',
            '#F7DC6F',
            '#BB8FCE'
          ]
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: {
            position: 'right',
            labels: {
              color: '#ccc'
            }
          }
        }
      }
    });
  }

  downloadReport(format: 'pdf' | 'excel'): void {
    if (!this.reportForm.valid) {
      this.snackBar.open('Selectați perioada pentru raport', 'OK', { duration: 3000 });
      return;
    }

    this.isLoading = true;
    const { startDate, endDate } = this.reportForm.value;

    this.reportService.downloadReport(format, startDate, endDate).subscribe({
      next: (blob) => {
        const url = window.URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `raport_${new Date().toISOString().split('T')[0]}.${format}`;
        link.click();
        window.URL.revokeObjectURL(url);
        this.isLoading = false;
        this.snackBar.open(`Raport ${format.toUpperCase()} descărcat!`, 'OK', { duration: 3000 });
      },
      error: (err) => {
        this.isLoading = false;
        this.snackBar.open('Eroare la descărcarea raportului', 'Închide', { duration: 5000 });
        console.error('Download error:', err);
      }
    });
  }

  getStockStatusColor(stock: number): string {
    if (stock === 0) return 'warn';
    if (stock < 10) return 'accent';
    return 'primary';
  }

  ngOnDestroy(): void {
    if (this.salesChart) {
      this.salesChart.destroy();
    }
    if (this.stockChart) {
      this.stockChart.destroy();
    }
  }
}
</file>

<file path="app/features/admin/services/category.admin.service.ts">
// src/app/features/admin/services/category.admin.service.ts
import { Injectable } from '@angular/core';
import { HttpClient, HttpErrorResponse } from '@angular/common/http';
import { Observable, throwError } from 'rxjs';
import { catchError } from 'rxjs/operators';
import { Category } from '../../../shared/models/category.model';


@Injectable({
  providedIn: 'root'
})
export class CategoryAdminService {
  private apiUrl = '/api/categories';

  constructor(private http: HttpClient) {}

  getAll(): Observable<Category[]> {
    return this.http.get<Category[]>(this.apiUrl)
      .pipe(catchError(this.handleError));
  }

  getById(id: number): Observable<Category> {
    return this.http.get<Category>(`${this.apiUrl}/${id}`)
      .pipe(catchError(this.handleError));
  }

  create(category: Category): Observable<Category> {
    return this.http.post<Category>(this.apiUrl, category)
      .pipe(catchError(this.handleError));
  }

  update(id: number, category: Category): Observable<Category> {
    return this.http.put<Category>(`${this.apiUrl}/${id}`, category)
      .pipe(catchError(this.handleError));
  }

  delete(id: number): Observable<void> {
    return this.http.delete<void>(`${this.apiUrl}/${id}`)
      .pipe(catchError(this.handleError));
  }

  private handleError(error: HttpErrorResponse) {
  let userFriendlyErrorMessage = 'A apărut o problemă. Vă rugăm încercați din nou mai târziu.';
  let detailedErrorMessage = 'Eroare necunoscută.';

  // Verificăm mai întâi dacă 'error.error' există și este un obiect (răspuns JSON de la server)
  if (error.error && typeof error.error === 'object' && error.error !== null) {
    // Încercăm să extragem un mesaj specific din corpul erorii trimis de backend
    // Acesta ar putea fi error.error.message, error.error.error, error.error.detail etc.
    // Ajustează în funcție de structura răspunsurilor de eroare de la API-ul tău Spring Boot
    detailedErrorMessage = 
        (error.error as any).message ||         // Cel mai comun (ex: MessageResponse din Spring)
        (error.error as any).detail ||          // Alt câmp comun pentru detalii eroare
        (error.error as any).error?.message ||  // Uneori eroarea e imbricată
        JSON.stringify(error.error);            // Fallback la JSON string dacă e un obiect complex

    // Poți încerca să faci mesajul user-friendly mai specific dacă backend-ul trimite un mesaj clar
    if ((error.error as any).message && typeof (error.error as any).message === 'string') {
      userFriendlyErrorMessage = (error.error as any).message;
    }
  } else if (typeof error.error === 'string') {
    // Corpul erorii de la server este un simplu string
    detailedErrorMessage = error.error;
    userFriendlyErrorMessage = error.error; 
  } else if (error.message) {
    // Eroare client-side sau de rețea (ex: HttpErrorResponse fără error.error, dar cu error.message)
    detailedErrorMessage = error.message;
    if (error.status === 0 || error.status === -1) { // Tipic pentru erori de rețea, CORS, sau server oprit
        userFriendlyErrorMessage = 'Eroare de conexiune cu serverul. Verificați rețeaua sau dacă serverul backend rulează.';
    } else {
        userFriendlyErrorMessage = `A apărut o eroare (${error.status}): ${error.statusText}`;
    }
  } else {
    // Fallback dacă structura erorii nu este cea așteptată
    detailedErrorMessage = `Cod eroare server: ${error.status}, status text: ${error.statusText || 'Necunoscut'}`;
    userFriendlyErrorMessage = `A apărut o eroare (${error.status}). Vă rugăm încercați mai târziu.`;
  }

  console.error('------------------------------------');
  console.error(`[SERVICE ERROR ENCOUNTERED]`);
  console.error(`URL: ${error.url}`);
  console.error(`Status: ${error.status} - ${error.statusText}`);
  console.error(`User-Friendly Message: ${userFriendlyErrorMessage}`);
  console.error(`Detailed Error Message/Body: ${detailedErrorMessage}`);
  console.error('Full HttpErrorResponse Object:', error);
  console.error('------------------------------------');

  // Aruncă o eroare care va fi propagată și poate fi prinsă în componentă
  // sau de un error handler global, dacă există.
  // Pentru utilizator, mesajele sunt de obicei afișate prin MatSnackBar în componentă/serviciu.
  return throwError(() => new Error(userFriendlyErrorMessage));
}
}
</file>

<file path="app/features/admin/services/order.admin.service.ts">
// src/app/features/admin/services/order.admin.service.ts
import { Injectable, inject } from '@angular/core';
import { HttpClient, HttpErrorResponse, HttpParams } from '@angular/common/http';
import { Observable, throwError } from 'rxjs';
import { catchError } from 'rxjs/operators';
import { Order } from '../../../shared/models/order.model';
import { OrderStatusUpdate } from '../../../shared/models/order-status-update.model'; // <<< CORECTAT

@Injectable({
  providedIn: 'root'
})
export class OrderAdminService {
  private apiUrl = '/api/orders';

  private http = inject(HttpClient);

  getAllOrders(statusFilter?: string): Observable<Order[]> {
    let params = new HttpParams();
    if (statusFilter && statusFilter.trim() !== '') {
      params = params.set('status', statusFilter);
    }
    return this.http.get<Order[]>(this.apiUrl, { params })
      .pipe(catchError(this.handleError));
  }

  getOrderById(orderId: number): Observable<Order> {
    return this.http.get<Order>(`${this.apiUrl}/${orderId}`)
      .pipe(catchError(this.handleError));
  }

  updateOrderStatus(orderId: number, statusUpdate: OrderStatusUpdate): Observable<Order> {
    return this.http.put<Order>(`${this.apiUrl}/${orderId}/status`, statusUpdate)
      .pipe(catchError(this.handleError));
  }

private handleError(error: HttpErrorResponse) {
  let userFriendlyErrorMessage = 'A apărut o problemă. Vă rugăm încercați din nou mai târziu.';
  let detailedErrorMessage = 'Eroare necunoscută.';

  // Verificăm mai întâi dacă 'error.error' există și este un obiect (răspuns JSON de la server)
  if (error.error && typeof error.error === 'object' && error.error !== null) {
    // Încercăm să extragem un mesaj specific din corpul erorii trimis de backend
    // Acesta ar putea fi error.error.message, error.error.error, error.error.detail etc.
    // Ajustează în funcție de structura răspunsurilor de eroare de la API-ul tău Spring Boot
    detailedErrorMessage = 
        (error.error as any).message ||         // Cel mai comun (ex: MessageResponse din Spring)
        (error.error as any).detail ||          // Alt câmp comun pentru detalii eroare
        (error.error as any).error?.message ||  // Uneori eroarea e imbricată
        JSON.stringify(error.error);            // Fallback la JSON string dacă e un obiect complex

    // Poți încerca să faci mesajul user-friendly mai specific dacă backend-ul trimite un mesaj clar
    if ((error.error as any).message && typeof (error.error as any).message === 'string') {
      userFriendlyErrorMessage = (error.error as any).message;
    }
  } else if (typeof error.error === 'string') {
    // Corpul erorii de la server este un simplu string
    detailedErrorMessage = error.error;
    userFriendlyErrorMessage = error.error; 
  } else if (error.message) {
    // Eroare client-side sau de rețea (ex: HttpErrorResponse fără error.error, dar cu error.message)
    detailedErrorMessage = error.message;
    if (error.status === 0 || error.status === -1) { // Tipic pentru erori de rețea, CORS, sau server oprit
        userFriendlyErrorMessage = 'Eroare de conexiune cu serverul. Verificați rețeaua sau dacă serverul backend rulează.';
    } else {
        userFriendlyErrorMessage = `A apărut o eroare (${error.status}): ${error.statusText}`;
    }
  } else {
    // Fallback dacă structura erorii nu este cea așteptată
    detailedErrorMessage = `Cod eroare server: ${error.status}, status text: ${error.statusText || 'Necunoscut'}`;
    userFriendlyErrorMessage = `A apărut o eroare (${error.status}). Vă rugăm încercați mai târziu.`;
  }

  console.error('------------------------------------');
  console.error(`[SERVICE ERROR ENCOUNTERED]`);
  console.error(`URL: ${error.url}`);
  console.error(`Status: ${error.status} - ${error.statusText}`);
  console.error(`User-Friendly Message: ${userFriendlyErrorMessage}`);
  console.error(`Detailed Error Message/Body: ${detailedErrorMessage}`);
  console.error('Full HttpErrorResponse Object:', error);
  console.error('------------------------------------');

  // Aruncă o eroare care va fi propagată și poate fi prinsă în componentă
  // sau de un error handler global, dacă există.
  // Pentru utilizator, mesajele sunt de obicei afișate prin MatSnackBar în componentă/serviciu.
  return throwError(() => new Error(userFriendlyErrorMessage));
}
}
</file>

<file path="app/features/admin/services/report.service.ts">
import { Injectable, inject } from '@angular/core';
import { HttpClient, HttpParams, HttpErrorResponse } from '@angular/common/http';
import { Observable, throwError } from 'rxjs';
import { catchError } from 'rxjs/operators';
import { GeneralReport, SalesReport, StockReport, UserReport } from '../../../shared/models/report.model';

@Injectable({
  providedIn: 'root'
})
export class ReportService {
  private apiUrl = '/api/admin/reports';
  private http = inject(HttpClient);

  generateGeneralReport(startDate: Date, endDate: Date): Observable<GeneralReport> {
    const params = new HttpParams()
      .set('startDate', this.formatDate(startDate))
      .set('endDate', this.formatDate(endDate));
    
    return this.http.get<GeneralReport>(`${this.apiUrl}/general`, { params })
      .pipe(catchError(this.handleError));
  }

  getSalesReport(startDate: Date, endDate: Date): Observable<SalesReport> {
    const params = new HttpParams()
      .set('startDate', this.formatDate(startDate))
      .set('endDate', this.formatDate(endDate));
    
    return this.http.get<SalesReport>(`${this.apiUrl}/sales`, { params })
      .pipe(catchError(this.handleError));
  }

  getStockReport(): Observable<StockReport> {
    return this.http.get<StockReport>(`${this.apiUrl}/stock`)
      .pipe(catchError(this.handleError));
  }

  getUserReport(): Observable<UserReport> {
    return this.http.get<UserReport>(`${this.apiUrl}/users`)
      .pipe(catchError(this.handleError));
  }

  downloadReport(reportType: 'pdf' | 'excel', startDate: Date, endDate: Date): Observable<Blob> {
    const params = new HttpParams()
      .set('startDate', this.formatDate(startDate))
      .set('endDate', this.formatDate(endDate))
      .set('format', reportType);
    
    return this.http.get(`${this.apiUrl}/download`, { 
      params, 
      responseType: 'blob' 
    }).pipe(catchError(this.handleError));
  }

  private formatDate(date: Date): string {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
  }

  private handleError(error: HttpErrorResponse) {
    let errorMessage = 'A apărut o eroare la generarea raportului.';
    if (error.error instanceof ErrorEvent) {
      errorMessage = `Eroare: ${error.error.message}`;
    } else {
      errorMessage = error.error?.message || `Cod eroare: ${error.status}`;
    }
    console.error('Report service error:', error);
    return throwError(() => new Error(errorMessage));
  }
}
</file>

<file path="app/features/admin/services/specification-admin.service.ts">
// src/app/features/admin/services/specification-admin.service.ts
import { Injectable, inject } from '@angular/core';
import { HttpClient, HttpErrorResponse } from '@angular/common/http';
import { Observable, throwError } from 'rxjs';
import { catchError } from 'rxjs/operators';
import { SpecificationDefinition } from '../../../shared/models/specification-definition.model';

@Injectable({
  providedIn: 'root'
})
export class SpecificationAdminService {
  private apiUrl = '/api/specifications/definitions';

  private http = inject(HttpClient);

  getAllDefinitions(): Observable<SpecificationDefinition[]> {
    return this.http.get<SpecificationDefinition[]>(this.apiUrl)
      .pipe(catchError(this.handleError));
  }

  getDefinitionById(id: number): Observable<SpecificationDefinition> {
    return this.http.get<SpecificationDefinition>(`${this.apiUrl}/${id}`)
      .pipe(catchError(this.handleError));
  }

  createDefinition(definition: Omit<SpecificationDefinition, 'id'>): Observable<SpecificationDefinition> {
    return this.http.post<SpecificationDefinition>(this.apiUrl, definition)
      .pipe(catchError(this.handleError));
  }

  updateDefinition(id: number, definition: SpecificationDefinition): Observable<SpecificationDefinition> {
    return this.http.put<SpecificationDefinition>(`${this.apiUrl}/${id}`, definition)
      .pipe(catchError(this.handleError));
  }

  deleteDefinition(id: number): Observable<void> {
    return this.http.delete<void>(`${this.apiUrl}/${id}`)
      .pipe(catchError(this.handleError));
  }

private handleError(error: HttpErrorResponse) {
  let userFriendlyErrorMessage = 'A apărut o problemă. Vă rugăm încercați din nou mai târziu.';
  let detailedErrorMessage = 'Eroare necunoscută.';

  // Verificăm mai întâi dacă 'error.error' există și este un obiect (răspuns JSON de la server)
  if (error.error && typeof error.error === 'object' && error.error !== null) {
    // Încercăm să extragem un mesaj specific din corpul erorii trimis de backend
    // Acesta ar putea fi error.error.message, error.error.error, error.error.detail etc.
    // Ajustează în funcție de structura răspunsurilor de eroare de la API-ul tău Spring Boot
    detailedErrorMessage = 
        (error.error as any).message ||         // Cel mai comun (ex: MessageResponse din Spring)
        (error.error as any).detail ||          // Alt câmp comun pentru detalii eroare
        (error.error as any).error?.message ||  // Uneori eroarea e imbricată
        JSON.stringify(error.error);            // Fallback la JSON string dacă e un obiect complex

    // Poți încerca să faci mesajul user-friendly mai specific dacă backend-ul trimite un mesaj clar
    if ((error.error as any).message && typeof (error.error as any).message === 'string') {
      userFriendlyErrorMessage = (error.error as any).message;
    }
  } else if (typeof error.error === 'string') {
    // Corpul erorii de la server este un simplu string
    detailedErrorMessage = error.error;
    userFriendlyErrorMessage = error.error; 
  } else if (error.message) {
    // Eroare client-side sau de rețea (ex: HttpErrorResponse fără error.error, dar cu error.message)
    detailedErrorMessage = error.message;
    if (error.status === 0 || error.status === -1) { // Tipic pentru erori de rețea, CORS, sau server oprit
        userFriendlyErrorMessage = 'Eroare de conexiune cu serverul. Verificați rețeaua sau dacă serverul backend rulează.';
    } else {
        userFriendlyErrorMessage = `A apărut o eroare (${error.status}): ${error.statusText}`;
    }
  } else {
    // Fallback dacă structura erorii nu este cea așteptată
    detailedErrorMessage = `Cod eroare server: ${error.status}, status text: ${error.statusText || 'Necunoscut'}`;
    userFriendlyErrorMessage = `A apărut o eroare (${error.status}). Vă rugăm încercați mai târziu.`;
  }

  console.error('------------------------------------');
  console.error(`[SERVICE ERROR ENCOUNTERED]`);
  console.error(`URL: ${error.url}`);
  console.error(`Status: ${error.status} - ${error.statusText}`);
  console.error(`User-Friendly Message: ${userFriendlyErrorMessage}`);
  console.error(`Detailed Error Message/Body: ${detailedErrorMessage}`);
  console.error('Full HttpErrorResponse Object:', error);
  console.error('------------------------------------');

  // Aruncă o eroare care va fi propagată și poate fi prinsă în componentă
  // sau de un error handler global, dacă există.
  // Pentru utilizator, mesajele sunt de obicei afișate prin MatSnackBar în componentă/serviciu.
  return throwError(() => new Error(userFriendlyErrorMessage));
}
}
</file>

<file path="app/features/admin/services/user-admin.service.ts">
import { Injectable, inject } from '@angular/core';
import { HttpClient, HttpErrorResponse } from '@angular/common/http';
import { Observable, throwError } from 'rxjs';
import { catchError } from 'rxjs/operators';
import { User, UserUpdateDto } from '../../../shared/models/user.model';

@Injectable({
  providedIn: 'root'
})
export class UserAdminService {
  private apiUrl = '/api/users'; // This will be proxied to localhost:8080

  private http = inject(HttpClient);

  getAllUsers(): Observable<User[]> {
    return this.http.get<User[]>(this.apiUrl)
      .pipe(catchError(this.handleError));
  }

  getUserById(userId: number): Observable<User> {
    return this.http.get<User>(`${this.apiUrl}/${userId}`)
      .pipe(catchError(this.handleError));
  }

  updateUser(userId: number, userData: UserUpdateDto): Observable<User> {
    // Log the data being sent for debugging
    console.log('Updating user with data:', userData);
    
    return this.http.put<User>(`${this.apiUrl}/${userId}`, userData)
      .pipe(catchError(this.handleError));
  }

  deleteUser(userId: number): Observable<void> {
    return this.http.delete<void>(`${this.apiUrl}/${userId}`)
      .pipe(catchError(this.handleError));
  }

  private handleError(error: HttpErrorResponse) {
    let userFriendlyErrorMessage = 'A apărut o problemă. Vă rugăm încercați din nou mai târziu.';
    let detailedErrorMessage = 'Eroare necunoscută.';

    if (error.error && typeof error.error === 'object' && error.error !== null) {
      // Check for validation errors structure
      if (error.error.fieldErrors) {
        // Spring Boot validation error response
        const fieldErrors = error.error.fieldErrors;
        const errorMessages = Object.entries(fieldErrors)
          .map(([field, message]) => `${field}: ${message}`)
          .join(', ');
        userFriendlyErrorMessage = `Erori de validare: ${errorMessages}`;
        detailedErrorMessage = errorMessages;
      } else {
        detailedErrorMessage = 
            (error.error as any).message ||
            (error.error as any).detail ||
            (error.error as any).error?.message ||
            JSON.stringify(error.error);

        if ((error.error as any).message && typeof (error.error as any).message === 'string') {
          userFriendlyErrorMessage = (error.error as any).message;
        }
      }
    } else if (typeof error.error === 'string') {
      detailedErrorMessage = error.error;
      userFriendlyErrorMessage = error.error; 
    } else if (error.message) {
      detailedErrorMessage = error.message;
      if (error.status === 0 || error.status === -1) {
        userFriendlyErrorMessage = 'Eroare de conexiune cu serverul. Verificați rețeaua sau dacă serverul backend rulează.';
      } else {
        userFriendlyErrorMessage = `A apărut o eroare (${error.status}): ${error.statusText}`;
      }
    } else {
      detailedErrorMessage = `Cod eroare server: ${error.status}, status text: ${error.statusText || 'Necunoscut'}`;
      userFriendlyErrorMessage = `A apărut o eroare (${error.status}). Vă rugăm încercați mai târziu.`;
    }

    console.error('------------------------------------');
    console.error(`[SERVICE ERROR ENCOUNTERED]`);
    console.error(`URL: ${error.url}`);
    console.error(`Status: ${error.status} - ${error.statusText}`);
    console.error(`User-Friendly Message: ${userFriendlyErrorMessage}`);
    console.error(`Detailed Error Message/Body: ${detailedErrorMessage}`);
    console.error('Full HttpErrorResponse Object:', error);
    console.error('------------------------------------');

    return throwError(() => new Error(userFriendlyErrorMessage));
  }
}
</file>

<file path="app/features/checkout/checkout.component.html">
<!-- frontend/src/app/features/checkout/checkout.component.html -->
<div class="checkout-container">
  <h1 class="page-title">Finalizare comandă</h1>

  <div *ngIf="isLoading" class="loading-indicator">
    <mat-spinner diameter="50"></mat-spinner>
    <p>Se încarcă...</p>
  </div>

  <div *ngIf="!isLoading && cart" class="checkout-content">
    <form [formGroup]="checkoutForm" (ngSubmit)="onSubmit()">
      <div class="checkout-grid">
        <!-- Left column - Form sections -->
        <div class="checkout-form">
          <!-- Contact Information -->
          <mat-card formGroupName="contactInfo">
            <mat-card-header>
              <mat-card-title>
                <mat-icon>person</mat-icon>
                Informații contact
              </mat-card-title>
              <mat-card-subtitle>Vă vom trimite confirmarea comenzii pe email</mat-card-subtitle>
            </mat-card-header>
            <mat-card-content>
              <mat-form-field appearance="outline" class="full-width">
                <mat-label>Nume complet</mat-label>
                <input matInput formControlName="fullName" placeholder="Ion Popescu">
                <mat-error>{{ getErrorMessage('contactInfo.fullName') }}</mat-error>
              </mat-form-field>

              <div class="form-row">
                <mat-form-field appearance="outline" class="half-width">
                  <mat-label>Email</mat-label>
                  <input matInput type="email" formControlName="email" placeholder="email@example.com">
                  <mat-error>{{ getErrorMessage('contactInfo.email') }}</mat-error>
                </mat-form-field>

                <mat-form-field appearance="outline" class="half-width">
                  <mat-label>Telefon</mat-label>
                  <input matInput formControlName="phone" placeholder="0712345678">
                  <mat-error>{{ getErrorMessage('contactInfo.phone') }}</mat-error>
                </mat-form-field>
              </div>
            </mat-card-content>
          </mat-card>

          <!-- Billing Address -->
          <mat-card formGroupName="billingAddress">
            <mat-card-header>
              <mat-card-title>
                <mat-icon>home</mat-icon>
                Adresă de facturare
              </mat-card-title>
            </mat-card-header>
            <mat-card-content>
              <mat-form-field appearance="outline" class="full-width">
                <mat-label>Adresă</mat-label>
                <textarea matInput formControlName="address" rows="2" 
                          placeholder="Str. Exemplu, Nr. 123, Bl. A, Sc. 1, Ap. 10"></textarea>
                <mat-error>{{ getErrorMessage('billingAddress.address') }}</mat-error>
              </mat-form-field>

              <div class="form-row">
                <mat-form-field appearance="outline" class="half-width">
                  <mat-label>Oraș</mat-label>
                  <input matInput formControlName="city" placeholder="București">
                  <mat-error>{{ getErrorMessage('billingAddress.city') }}</mat-error>
                </mat-form-field>

                <mat-form-field appearance="outline" class="half-width">
                  <mat-label>Cod poștal</mat-label>
                  <input matInput formControlName="postalCode" placeholder="123456">
                  <mat-error>{{ getErrorMessage('billingAddress.postalCode') }}</mat-error>
                </mat-form-field>
              </div>
            </mat-card-content>
          </mat-card>

          <!-- Shipping Address -->
          <mat-card formGroupName="shippingAddress">
            <mat-card-header>
              <mat-card-title>
                <mat-icon>local_shipping</mat-icon>
                Adresă de livrare
              </mat-card-title>
            </mat-card-header>
            <mat-card-content>
              <mat-checkbox formControlName="sameAsBilling">
                Aceeași cu adresa de facturare
              </mat-checkbox>

              <div *ngIf="differentShippingAddress" class="shipping-fields">
                <mat-form-field appearance="outline" class="full-width">
                  <mat-label>Adresă livrare</mat-label>
                  <textarea matInput formControlName="address" rows="2"></textarea>
                  <mat-error>{{ getErrorMessage('shippingAddress.address') }}</mat-error>
                </mat-form-field>

                <div class="form-row">
                  <mat-form-field appearance="outline" class="half-width">
                    <mat-label>Oraș</mat-label>
                    <input matInput formControlName="city">
                    <mat-error>{{ getErrorMessage('shippingAddress.city') }}</mat-error>
                  </mat-form-field>

                  <mat-form-field appearance="outline" class="half-width">
                    <mat-label>Cod poștal</mat-label>
                    <input matInput formControlName="postalCode">
                    <mat-error>{{ getErrorMessage('shippingAddress.postalCode') }}</mat-error>
                  </mat-form-field>
                </div>
              </div>
            </mat-card-content>
          </mat-card>

          <!-- Payment Method -->
          <mat-card formGroupName="payment">
            <mat-card-header>
              <mat-card-title>
                <mat-icon>payment</mat-icon>
                Metodă de plată
              </mat-card-title>
            </mat-card-header>
            <mat-card-content>
              <mat-radio-group formControlName="paymentMethod" class="payment-options">
                <mat-radio-button value="CASH_ON_DELIVERY">
                  <mat-icon>local_shipping</mat-icon>
                  Plata la livrare (Cash on Delivery)
                  <span class="payment-note">Plătești cash când primești comanda</span>
                </mat-radio-button>
                
                <mat-radio-button value="BANK_TRANSFER">
                  <mat-icon>account_balance</mat-icon>
                  Transfer bancar
                  <span class="payment-note">Vei primi detaliile după plasarea comenzii</span>
                </mat-radio-button>
                
                <mat-radio-button value="CARD" disabled>
                  <mat-icon>credit_card</mat-icon>
                  Card bancar (În curând)
                  <span class="payment-note">Opțiune disponibilă în curând</span>
                </mat-radio-button>
              </mat-radio-group>

              <mat-form-field appearance="outline" class="full-width notes-field">
                <mat-label>Note comandă (opțional)</mat-label>
                <textarea matInput formControlName="orderNotes" rows="3" 
                          placeholder="Adaugă orice informații suplimentare despre comandă..."></textarea>
              </mat-form-field>
            </mat-card-content>
          </mat-card>

          <!-- Terms and Conditions -->
          <mat-card class="terms-card">
            <mat-card-content>
              <mat-checkbox formControlName="agreeToTerms" required>
                Am citit și sunt de acord cu 
                <a href="/terms" target="_blank">Termenii și Condițiile</a> și 
                <a href="/privacy" target="_blank">Politica de Confidențialitate</a>
              </mat-checkbox>
            </mat-card-content>
          </mat-card>
        </div>

        <!-- Right column - Order Summary -->
        <div class="order-summary">
          <mat-card>
            <mat-card-header>
              <mat-card-title>Sumar comandă</mat-card-title>
            </mat-card-header>
            <mat-card-content>
              <div class="summary-items">
                <div *ngFor="let item of cart.items" class="summary-item">
                  <span class="item-name">{{ item.productName }} × {{ item.quantity }}</span>
                  <span class="item-price">{{ item.subtotal | currency:'RON':'symbol':'1.2-2' }}</span>
                </div>
              </div>
              
              <mat-divider></mat-divider>
              
              <div class="summary-totals">
                <div class="summary-row">
                  <span>Subtotal</span>
                  <span>{{ cart.totalAmount | currency:'RON':'symbol':'1.2-2' }}</span>
                </div>
                <div class="summary-row">
                  <span>Transport</span>
                  <span class="free-shipping">GRATUIT</span>
                </div>
                <div class="summary-row total">
                  <span>Total</span>
                  <span>{{ cart.totalAmount | currency:'RON':'symbol':'1.2-2' }}</span>
                </div>
              </div>
              
              <div class="secure-payment">
                <mat-icon>lock</mat-icon>
                <span>Plată securizată</span>
              </div>
            </mat-card-content>
            <mat-card-actions>
              <button mat-raised-button 
                      color="primary" 
                      type="submit" 
                      class="place-order-button"
                      [disabled]="isProcessing || checkoutForm.invalid">
                <mat-spinner *ngIf="isProcessing" diameter="20"></mat-spinner>
                <span *ngIf="!isProcessing">
                  <mat-icon>check_circle</mat-icon>
                  Plasează comanda
                </span>
              </button>
              
              <button mat-stroked-button 
                      type="button" 
                      routerLink="/cart"
                      [disabled]="isProcessing">
                <mat-icon>arrow_back</mat-icon>
                Înapoi la coș
              </button>
            </mat-card-actions>
          </mat-card>
        </div>
      </div>
    </form>
  </div>
</div>
</file>

<file path="app/features/checkout/checkout.component.scss">
.checkout-container {
  max-width: 1200px;
  margin: 0 auto;
  padding: 20px;
}

.page-title {
  margin-bottom: 30px;
  font-size: 2em;
}

.loading-indicator {
  text-align: center;
  padding: 60px 20px;
  
  mat-spinner {
    margin: 0 auto 20px;
  }
}

.checkout-grid {
  display: grid;
  grid-template-columns: 1fr 400px;
  gap: 20px;
  align-items: start;
  
  @media (max-width: 968px) {
    grid-template-columns: 1fr;
  }
}

.checkout-form {
  mat-card {
    margin-bottom: 20px;
    
    mat-card-header {
      margin-bottom: 20px;
      
      mat-card-title {
        display: flex;
        align-items: center;
        gap: 10px;
        
        mat-icon {
          opacity: 0.7;
        }
      }
      
      mat-card-subtitle {
        margin-top: 5px;
        opacity: 0.7;
      }
    }
  }
  
  .full-width {
    width: 100%;
    margin-bottom: 16px;
  }
  
  .half-width {
    width: calc(50% - 8px);
  }
  
  .form-row {
    display: flex;
    gap: 16px;
    
    @media (max-width: 600px) {
      flex-direction: column;
      
      .half-width {
        width: 100%;
      }
    }
  }
  
  .shipping-fields {
    margin-top: 20px;
  }
  
  .payment-options {
    display: flex;
    flex-direction: column;
    gap: 15px;
    margin-bottom: 20px;
    
    mat-radio-button {
      display: flex;
      align-items: center;
      padding: 15px;
      border: 1px solid rgba(0,0,0,0.12);
      border-radius: 8px;
      
      &:hover:not([disabled]) {
        background: rgba(0,0,0,0.04);
      }
      
      &.mat-mdc-radio-checked {
        border-color: var(--mdc-theme-primary, #673ab7);
        background: rgba(103, 58, 183, 0.08);
      }
      
      mat-icon {
        margin-right: 10px;
        opacity: 0.7;
      }
      
      .payment-note {
        display: block;
        font-size: 0.85em;
        opacity: 0.7;
        margin-top: 5px;
        margin-left: 34px;
      }
    }
  }
  
  .notes-field {
    margin-top: 20px;
  }
  
  .terms-card {
    mat-checkbox {
      font-size: 0.95em;
      
      a {
        color: var(--mdc-theme-primary, #673ab7);
        text-decoration: none;
        
        &:hover {
          text-decoration: underline;
        }
      }
    }
  }
}

.order-summary {
  position: sticky;
  top: 80px;
  
  mat-card-header {
    padding-bottom: 16px;
    border-bottom: 1px solid rgba(0,0,0,0.12);
  }
  
  .summary-items {
    padding: 16px 0;
    
    .summary-item {
      display: flex;
      justify-content: space-between;
      margin-bottom: 10px;
      font-size: 0.9em;
      
      .item-name {
        flex: 1;
        margin-right: 10px;
        opacity: 0.8;
      }
      
      .item-price {
        white-space: nowrap;
      }
    }
  }
  
  mat-divider {
    margin: 16px 0;
  }
  
  .summary-totals {
    padding: 16px 0;
    
    .summary-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 10px;
      
      &.total {
        margin-top: 16px;
        padding-top: 16px;
        border-top: 1px solid rgba(0,0,0,0.12);
        font-size: 1.2em;
        font-weight: 500;
      }
      
      .free-shipping {
        color: #4CAF50;
        font-weight: 500;
      }
    }
  }
  
  .secure-payment {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    padding: 16px;
    background: rgba(103, 58, 183, 0.08);
    border-radius: 4px;
    margin-top: 16px;
    
    mat-icon {
      font-size: 20px;
    }
    
    span {
      font-size: 0.9em;
    }
  }
  
  mat-card-actions {
    flex-direction: column;
    padding: 16px;
    
    button {
      width: 100%;
      margin-bottom: 10px !important;
      
      &.place-order-button {
        padding: 12px;
        font-size: 1.1em;
        
        mat-spinner {
          display: inline-block;
          margin-right: 8px;
        }
        
        mat-icon {
          margin-right: 8px;
        }
      }
    }
  }
}
</file>

<file path="app/features/checkout/checkout.component.ts">
// frontend/src/app/features/checkout/checkout.component.ts
import { Component, OnInit, inject } from '@angular/core';
import { CommonModule, CurrencyPipe } from '@angular/common';
import { Router, RouterModule } from '@angular/router';
import { ReactiveFormsModule, FormBuilder, FormGroup, Validators } from '@angular/forms';
import { MatCardModule } from '@angular/material/card';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { MatSelectModule } from '@angular/material/select';
import { MatCheckboxModule } from '@angular/material/checkbox';
import { MatDividerModule } from '@angular/material/divider';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar';
import { MatRadioModule } from '@angular/material/radio';
import { MatStepperModule } from '@angular/material/stepper';

import { Cart } from '../../shared/models/cart.model';
import { CartService } from '../shopping-cart/cart.service';
import { AuthService } from '../../auth/auth.service';

@Component({
  selector: 'app-checkout',
  standalone: true,
  imports: [
    CommonModule,
    RouterModule,
    ReactiveFormsModule,
    CurrencyPipe,
    MatCardModule,
    MatButtonModule,
    MatIconModule,
    MatFormFieldModule,
    MatInputModule,
    MatSelectModule,
    MatCheckboxModule,
    MatDividerModule,
    MatProgressSpinnerModule,
    MatSnackBarModule,
    MatRadioModule,
    MatStepperModule
  ],
  templateUrl: './checkout.component.html',
  styleUrls: ['./checkout.component.scss']
})
export class CheckoutComponent implements OnInit {
  checkoutForm!: FormGroup;
  cart: Cart | null = null;
  isLoading = true;
  isProcessing = false;
  differentShippingAddress = false;

  private fb = inject(FormBuilder);
  private cartService = inject(CartService);
  private authService = inject(AuthService);
  private router = inject(Router);
  private snackBar = inject(MatSnackBar);

  ngOnInit(): void {
    if (!this.authService.isLoggedIn()) {
      this.router.navigate(['/login'], { queryParams: { returnUrl: '/checkout' } });
      return;
    }

    this.initializeForm();
    this.loadCart();
    this.prefillUserData();
  }

  initializeForm(): void {
    this.checkoutForm = this.fb.group({
      contactInfo: this.fb.group({
        fullName: ['', [Validators.required, Validators.minLength(3)]],
        email: ['', [Validators.required, Validators.email]],
        phone: ['', [Validators.required, Validators.pattern('^[0-9]{10,15}$')]]
      }),
      billingAddress: this.fb.group({
        address: ['', [Validators.required, Validators.minLength(10)]],
        city: ['', Validators.required],
        postalCode: ['', [Validators.required, Validators.pattern('^[0-9]{6}$')]]
      }),
      shippingAddress: this.fb.group({
        sameAsBilling: [true],
        address: [''],
        city: [''],
        postalCode: ['']
      }),
      payment: this.fb.group({
        paymentMethod: ['CASH_ON_DELIVERY', Validators.required],
        orderNotes: ['']
      }),
      agreeToTerms: [false, Validators.requiredTrue]
    });

    // Watch for shipping address changes
    this.checkoutForm.get('shippingAddress.sameAsBilling')?.valueChanges.subscribe(same => {
      this.differentShippingAddress = !same;
      const shippingGroup = this.checkoutForm.get('shippingAddress');
      
      if (!same) {
        shippingGroup?.get('address')?.setValidators([Validators.required, Validators.minLength(10)]);
        shippingGroup?.get('city')?.setValidators(Validators.required);
        shippingGroup?.get('postalCode')?.setValidators([Validators.required, Validators.pattern('^[0-9]{6}$')]);
      } else {
        shippingGroup?.get('address')?.clearValidators();
        shippingGroup?.get('city')?.clearValidators();
        shippingGroup?.get('postalCode')?.clearValidators();
      }
      
      shippingGroup?.get('address')?.updateValueAndValidity();
      shippingGroup?.get('city')?.updateValueAndValidity();
      shippingGroup?.get('postalCode')?.updateValueAndValidity();
    });
  }

  prefillUserData(): void {
    const currentUser = this.authService.getCurrentUser();
    if (currentUser) {
      this.checkoutForm.patchValue({
        contactInfo: {
          email: currentUser.email,
          fullName: currentUser.username // You might want to store full name separately
        }
      });
    }
  }

  loadCart(): void {
    this.isLoading = true;
    this.cartService.loadCart().subscribe({
      next: (cart) => {
        this.cart = cart;
        if (!cart || cart.items.length === 0) {
          this.router.navigate(['/cart']);
          this.snackBar.open('Coșul este gol', 'OK', { duration: 3000 });
        }
        this.isLoading = false;
      },
      error: (err) => {
        this.isLoading = false;
        this.snackBar.open('Eroare la încărcarea coșului', 'Închide', { duration: 3000 });
        this.router.navigate(['/cart']);
      }
    });
  }

  onSubmit(): void {
    if (this.checkoutForm.invalid) {
      this.checkoutForm.markAllAsTouched();
      this.snackBar.open('Vă rugăm completați toate câmpurile obligatorii', 'OK', { duration: 3000 });
      return;
    }

    if (!this.cart || this.cart.items.length === 0) {
      this.snackBar.open('Coșul este gol', 'OK', { duration: 3000 });
      return;
    }

    this.isProcessing = true;
    const formValue = this.checkoutForm.value;
    
    const checkoutData = {
      fullName: formValue.contactInfo.fullName,
      email: formValue.contactInfo.email,
      phone: formValue.contactInfo.phone,
      billingAddress: `${formValue.billingAddress.address}, ${formValue.billingAddress.city}, ${formValue.billingAddress.postalCode}`,
      shippingAddress: formValue.shippingAddress.sameAsBilling ? 
        undefined : 
        `${formValue.shippingAddress.address}, ${formValue.shippingAddress.city}, ${formValue.shippingAddress.postalCode}`,
      paymentMethod: formValue.payment.paymentMethod,
      orderNotes: formValue.payment.orderNotes,
      agreeToTerms: formValue.agreeToTerms
    };

    this.cartService.checkout(checkoutData).subscribe({
      next: (order) => {
        this.isProcessing = false;
        this.snackBar.open('Comandă plasată cu succes!', 'OK', { duration: 3000 });
        this.router.navigate(['/order-success', order.id]);
      },
      error: (err) => {
        this.isProcessing = false;
        this.snackBar.open(err.message || 'Eroare la plasarea comenzii', 'Închide', { duration: 5000 });
      }
    });
  }

  getErrorMessage(fieldPath: string): string {
    const control = this.checkoutForm.get(fieldPath);
    if (control?.hasError('required')) {
      return 'Acest câmp este obligatoriu';
    }
    if (control?.hasError('email')) {
      return 'Email invalid';
    }
    if (control?.hasError('pattern')) {
      if (fieldPath.includes('phone')) {
        return 'Număr de telefon invalid (10-15 cifre)';
      }
      if (fieldPath.includes('postalCode')) {
        return 'Cod poștal invalid (6 cifre)';
      }
    }
    if (control?.hasError('minlength')) {
      const minLength = control.errors?.['minlength'].requiredLength;
      return `Minim ${minLength} caractere`;
    }
    return '';
  }
}
</file>

<file path="app/features/home/home-page/home-page.component.html">
<div class="home-container">

  <section class="hero-section">
    <div class="hero-overlay"></div>
    <div class="hero-content">
      <div class="text-content">
        <h1>Dive into immersive gaming</h1>
        <p>Feel every explosion, every step, and every sound detail with the new VipeX gaming headsets.</p>
        <button mat-flat-button color="primary">Vezi oferta</button>
      </div>
    </div>
  </section>

  <main class="selection-section">
    <h2 class="section-title">Our selection</h2>

    <div *ngIf="isLoading" class="loading-indicator">
      <mat-spinner diameter="60"></mat-spinner>
    </div>

    <div class="product-grid" *ngIf="!isLoading && products.length > 0">
      <mat-card *ngFor="let product of products" class="product-card" [routerLink]="['/products', product.id]">
        <div class="product-image-container">
           <mat-icon>inventory_2</mat-icon>
        </div>
        <mat-card-header>
          <mat-card-title>{{ product.name }}</mat-card-title>
        </mat-card-header>
        <mat-card-content>
          <p class="product-price">{{ product.price | currency:'RON' }}</p>
        </mat-card-content>
        <mat-card-actions>
          <button mat-stroked-button color="primary">Add to cart</button>
        </mat-card-actions>
      </mat-card>
    </div>
  </main>

  <section class="social-section">
    <h2 class="section-title">Be connected. Be VipeX.</h2>
    <div class="social-icons">
      <a href="#" class="social-icon-box">X</a>
      <a href="#" class="social-icon-box">O</a>
      <a href="#" class="social-icon-box">f</a>
    </div>
  </section>

</div>
</file>

<file path="app/features/home/home-page/home-page.component.scss">
:host {
  display: block;
}

.home-container {
  width: 100%;
}

.section-title {
  font-size: 2.5rem;
  font-weight: bold;
  text-align: center;
  margin-bottom: 40px;
}

/* Hero Section */
.hero-section {
  min-height: 80vh;
  padding: 40px;
  display: flex;
  align-items: center;
  justify-content: center;
  position: relative;
  text-align: center;
  background: linear-gradient(135deg, rgba(0,0,0,0.05) 0%, rgba(0,0,0,0.1) 100%);

  .hero-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(to top, rgba(255,255,255,0.05) 5%, transparent 60%);
  }
  
  .hero-content {
    position: relative;
    z-index: 1;
    
    h1 {
      font-size: 3.5rem;
      font-weight: bold;
      margin-bottom: 1rem;
    }
    
    p {
      font-size: 1.2rem;
      margin: 20px 0 30px;
      opacity: 0.9;
    }
    
    button {
      padding: 12px 35px;
      font-size: 1.1rem;
      font-weight: bold;
    }
  }
}

/* Products Section */
.selection-section {
  padding: 60px 40px;
  max-width: 1400px;
  margin: 0 auto;
}

.loading-indicator {
  display: flex;
  justify-content: center;
  padding: 40px;
}

.product-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
  gap: 30px;
}

.product-card {
  cursor: pointer;
  transition: transform 0.3s ease, box-shadow 0.3s ease;
  // Remove dark background - let Material theme handle it
  
  &:hover {
    transform: translateY(-5px);
    box-shadow: 0 8px 16px rgba(0,0,0,0.2);
  }
  
  .product-image-container {
    height: 220px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(0,0,0,0.05);
    
    mat-icon {
      font-size: 70px;
      width: 70px;
      height: 70px;
      opacity: 0.3;
    }
  }
  
  mat-card-header {
    justify-content: center;
    text-align: center;
  }
  
  mat-card-content {
    text-align: center;
    
    .product-price {
      font-size: 1.2rem;
      font-weight: 500;
      margin: 10px 0;
    }
  }
  
  mat-card-actions {
    justify-content: center;
    padding-bottom: 16px;
  }
}

/* Social Section */
.social-section {
  padding: 60px 40px;
  background: rgba(0,0,0,0.02);
  
  .social-icons {
    display: flex;
    justify-content: center;
    gap: 20px;
    
    .social-icon-box {
      width: 120px;
      height: 120px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 4rem;
      font-weight: bold;
      text-decoration: none;
      border: 2px solid currentColor;
      border-radius: 8px;
      transition: transform 0.2s;
      
      &:hover {
        transform: scale(1.05);
      }
    }
  }
}
</file>

<file path="app/features/home/home-page/home-page.component.spec.ts">
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { HomePageComponent } from './home-page.component';

describe('HomePageComponent', () => {
  let component: HomePageComponent;
  let fixture: ComponentFixture<HomePageComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [HomePageComponent]
    })
    .compileComponents();

    fixture = TestBed.createComponent(HomePageComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});
</file>

<file path="app/features/home/home-page/home-page.component.ts">
import { Component, OnInit, inject } from '@angular/core';
import { CommonModule, CurrencyPipe } from '@angular/common';
import { RouterModule } from '@angular/router';
import { MatCardModule } from '@angular/material/card';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';

import { Product } from '../../../shared/models/product.model';
import { ProductService } from '../../products/product.service';

@Component({
  selector: 'app-home-page',
  standalone: true,
  imports: [
    CommonModule,
    RouterModule,
    CurrencyPipe,
    MatCardModule,
    MatButtonModule,
    MatIconModule,
    MatProgressSpinnerModule
  ],
  templateUrl: './home-page.component.html',
  styleUrls: ['./home-page.component.scss']
})
export class HomePageComponent implements OnInit {
  products: Product[] = [];
  isLoading = true;
  error: string | null = null;

  private productService = inject(ProductService);

  ngOnInit(): void {
    this.loadProducts();
  }

  loadProducts(): void {
    this.isLoading = true;
    this.error = null;
    this.productService.getAll().subscribe({
      next: (data) => {
        this.products = data;
        this.isLoading = false;
      },
      error: (err) => {
        this.error = 'Nu s-au putut încărca produsele.';
        console.error(err);
        this.isLoading = false;
      }
    });
  }
}
</file>

<file path="app/features/products/product-detail/product-detail.component.html">
<!-- src/app/features/products/product-detail/product-detail.component.html -->
<div class="product-detail-container">
  <button mat-stroked-button routerLink="/admin/products" *ngIf="isAdminView && authService.role === 'admin'" class="back-button">
    <mat-icon>arrow_back</mat-icon> Înapoi la Listă Produse (Admin)
  </button>
  <button mat-stroked-button routerLink="/products" *ngIf="!isAdminView" class="back-button">
    <mat-icon>arrow_back</mat-icon> Înapoi la Produse
  </button>

  <div *ngIf="isLoading" class="loading-indicator">
    <mat-spinner diameter="60"></mat-spinner>
    <p>Se încarcă detaliile produsului...</p>
  </div>

  <div *ngIf="error && !isLoading" class="error-message">
    <p>{{ error }}</p>
    <button mat-stroked-button color="warn" (click)="loadProductDetails()">Reîncearcă</button>
  </div>

  <div *ngIf="product && !isLoading" class="product-content">
    <mat-card class="product-card">
      <mat-card-header class="product-header">
        <div class="header-text">
          <mat-card-title>{{ product.name | titlecase }}</mat-card-title>
          <mat-card-subtitle *ngIf="product.categoryName">Categorie: {{ product.categoryName }}</mat-card-subtitle>
        </div>
        <div class="header-actions" *ngIf="isAdminView && authService.role === 'admin'">
          <button mat-flat-button color="primary" [routerLink]="['/admin/products/edit', product.id]">
            <mat-icon>edit</mat-icon> Editează
          </button>
          <button mat-flat-button color="warn" (click)="deleteProduct()">
            <mat-icon>delete</mat-icon> Șterge
          </button>
        </div>
      </mat-card-header>

      <div class="product-main-info">
        <!-- Secțiunea Imagine - COMENTATĂ TEMPORAR -->
        <!--
        <div class="image-container">
          <img *ngIf="product.imageBase64" [src]="product.imageBase64" [alt]="product.name" class="product-image">
          <div *ngIf="!product.imageBase64" class="no-image-placeholder">
            <mat-icon>photo_camera</mat-icon>
            <span>Imagine indisponibilă</span>
          </div>
        </div>
        -->
        <div class="details-container">
          <p class="price">{{ product.price | currency:'RON':'symbol':'1.2-2' }}</p>
          <p class="stock" [ngClass]="{'in-stock': product.stockQuantity > 0, 'out-of-stock': product.stockQuantity === 0}">
            Stoc: {{ product.stockQuantity > 0 ? product.stockQuantity + ' buc.' : 'Indisponibil' }}
          </p>
          <div class="description" *ngIf="product.description">
            <h4>Descriere:</h4>
            <p [innerHTML]="product.description | nl2br"></p>
          </div>
          <button *ngIf="!isAdminView" mat-raised-button color="accent" class="add-to-cart-button" 
                  [disabled]="product.stockQuantity === 0 || isLoading"
                  (click)="addToCart()">
            <mat-icon>add_shopping_cart</mat-icon> Adaugă în Coș
          </button>
        </div>
      </div>
      <div class="rating-info" *ngIf="product.averageRating !== undefined">
  <app-star-rating 
    [rating]="product.averageRating" 
    [readonly]="true"
    [showText]="true"
    [reviewCount]="product.reviewCount">
  </app-star-rating>
</div>
      <mat-card-content *ngIf="product.specifications && product.specifications.length > 0" class="specifications-section">
        <mat-divider></mat-divider>
        <h3>Specificații Tehnice</h3>
        <mat-list role="list">
          <mat-list-item *ngFor="let spec of product.specifications" role="listitem" class="specification-item">
            <span matListItemTitle class="spec-name">{{ spec.name || 'Specificație' }}:</span>
            <span matListItemLine class="spec-value">{{ spec.value }} {{ spec.unit || '' }}</span>
          </mat-list-item>
        </mat-list>
      </mat-card-content>
    </mat-card>
  </div>
</div>
<app-review-list [productId]="productId"></app-review-list>
</file>

<file path="app/features/products/product-detail/product-detail.component.scss">
.product-detail-container {
  padding: 20px;
  max-width: 900px;
  margin: 20px auto;
}

.back-button {
  margin-bottom: 20px;
  mat-icon {
    margin-right: 8px;
  }
}

.loading-indicator,
.error-message {
  text-align: center;
  padding: 40px 20px;
  mat-spinner {
    margin: 0 auto 15px auto;
  }
}

.product-card {
  width: 100%;
}

.product-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  padding-bottom: 16px;

  .header-text {
    flex-grow: 1;
  }
  .header-actions {
    display: flex;
    gap: 10px;
    flex-shrink: 0;
  }
}

.product-main-info {
  display: flex;
  gap: 24px;
  margin-top: 16px;
  margin-bottom: 24px;

  @media (max-width: 768px) {
    flex-direction: column;
  }

  .details-container {
    flex: 1 1 60%;
    display: flex;
    flex-direction: column;

    .price {
      font-size: 2em;
      font-weight: bold;
      margin-bottom: 8px;
    }
    
    .stock {
      font-size: 1em;
      margin-bottom: 16px;
      &.in-stock { color: #4CAF50; }
      &.out-of-stock { color: #F44336; }
    }
    
    .description {
      margin-bottom: 20px;
      h4 {
        margin-bottom: 8px;
        font-size: 1.1em;
        font-weight: 500;
      }
      p {
        line-height: 1.6;
        opacity: 0.87;
        white-space: pre-wrap;
      }
    }
    
    .add-to-cart-button {
      margin-top: auto;
      width: 100%;
      max-width: 250px;
      padding: 10px 0;
      font-size: 1em;
      mat-icon {
        margin-right: 8px;
      }
    }
  }
}

.rating-info {
  margin: 20px 0;
}

.specifications-section {
  padding-top: 16px;
  h3 {
    margin-bottom: 12px;
    font-size: 1.2em;
    font-weight: 500;
    opacity: 0.87;
  }
  .specification-item {
    border-bottom: 1px dotted rgba(0,0,0,0.12);
    padding: 8px 0;
    &:last-child {
      border-bottom: none;
    }
    .spec-name {
      font-weight: 500;
      display: inline-block;
      min-width: 150px;
    }
    .spec-value {
      opacity: 0.87;
    }
  }
}
</file>

<file path="app/features/products/product-detail/product-detail.component.ts">
import { Component, OnInit, inject, Pipe, PipeTransform } from '@angular/core';
import { CommonModule, CurrencyPipe, TitleCasePipe } from '@angular/common';
import { ActivatedRoute, Router, RouterModule } from '@angular/router';
import { MatCardModule } from '@angular/material/card';
import { MatListModule } from '@angular/material/list';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar';
import { MatChipsModule } from '@angular/material/chips';
import { MatDividerModule } from '@angular/material/divider';
import { DomSanitizer, SafeHtml } from '@angular/platform-browser';

import { Product } from '../../../shared/models/product.model';
import { ProductService } from '../product.service';
import { AuthService } from '../../../auth/auth.service';
import { CartService } from '../../shopping-cart/cart.service';
import { AddToCartRequest } from '../../../shared/models/cart.model';
import { ReviewListComponent } from '../../reviews/review-list/review-list.component';
import { StarRatingComponent } from '../../../shared/components/star-rating/star-rating.component';

// Pipe custom pentru nl2br
@Pipe({
  name: 'nl2br',
  standalone: true
})
export class Nl2brPipe implements PipeTransform {
  constructor(private sanitizer: DomSanitizer) {}
  transform(value: string | null | undefined): SafeHtml {
    if (!value) return '';
    return this.sanitizer.bypassSecurityTrustHtml(value.replace(/\n/g, '<br/>'));
  }
}

@Component({
  selector: 'app-product-detail',
  standalone: true,
  imports: [
    CommonModule,
    RouterModule,
    MatCardModule,
    MatListModule,
    MatButtonModule,
    MatIconModule,
    MatProgressSpinnerModule,
    MatSnackBarModule,
    MatChipsModule,
    MatDividerModule,
    CurrencyPipe,
    TitleCasePipe,
    Nl2brPipe,
    ReviewListComponent,
    StarRatingComponent
  ],
  templateUrl: './product-detail.component.html',
  styleUrls: ['./product-detail.component.scss']
})
export class ProductDetailComponent implements OnInit {
  product: Product | null = null;
  isLoading = true;
  error: string | null = null;
  productId!: number;
  isAdminView = false;

  private route = inject(ActivatedRoute);
  private router = inject(Router);
  private productService = inject(ProductService);
  private snackBar = inject(MatSnackBar);
  public authService = inject(AuthService);
  private cartService = inject(CartService);

  ngOnInit(): void {
    const idFromRoute = this.route.snapshot.paramMap.get('id');
    if (idFromRoute) {
      this.productId = +idFromRoute;
      if (!isNaN(this.productId) && this.productId > 0) {
        this.loadProductDetails();
        this.isAdminView = this.router.url.includes('/admin/');
      } else {
        this.handleInvalidId();
      }
    } else {
      this.handleInvalidId();
    }
  }

  private handleInvalidId(): void {
    this.isLoading = false;
    this.error = 'ID produs invalid.';
    this.snackBar.open(this.error, 'Închide', { duration: 3000 });
    this.router.navigate(['/']);
  }

  loadProductDetails(): void {
    this.isLoading = true;
    this.error = null;
    this.productService.getById(this.productId).subscribe({
      next: (data) => {
        this.product = data;
        this.isLoading = false;
      },
      error: (err) => {
        this.isLoading = false;
        this.error = 'Nu s-au putut încărca detaliile produsului.';
        const errMsg = err.error?.message || err.message || 'Eroare necunoscută.';
        this.snackBar.open(`${this.error} ${errMsg}`, 'Închide', { duration: 5000 });
        console.error(err);
        this.router.navigate(['/']);
      }
    });
  }

  deleteProduct(): void {
    if (!this.product || typeof this.product.id === 'undefined') return;
    const confirmation = window.confirm('Sunteți sigur că doriți să ștergeți acest produs?');
    if (confirmation) {
      this.isLoading = true;
      this.productService.delete(this.product.id).subscribe({
        next: () => {
          this.isLoading = false;
          this.snackBar.open('Produs șters cu succes!', 'OK', { duration: 3000 });
          this.router.navigate(['/admin/products']);
        },
        error: (err) => {
          this.isLoading = false;
          this.snackBar.open('Eroare la ștergerea produsului.', 'Închide', { duration: 5000 });
          console.error(err);
        }
      });
    }
  }

  addToCart(): void {
    if (!this.authService.isLoggedIn()) {
      this.snackBar.open('Trebuie să fii autentificat pentru a adăuga produse în coș.', 'Login', {
        duration: 5000,
      }).onAction().subscribe(() => {
        this.router.navigate(['/login'], { queryParams: { returnUrl: this.router.url } });
      });
      return;
    }

    // AICI ESTE CORECȚIA: Verificăm și dacă produsul are un ID.
    if (!this.product || typeof this.product.id === 'undefined') {
      this.snackBar.open('Detaliile produsului sunt incomplete. Vă rugăm reîncercați.', 'Închide', { duration: 3000 });
      return;
    }

    const request: AddToCartRequest = {
      productId: this.product.id, // Acum TypeScript știe sigur că `this.product.id` este un număr.
      quantity: 1
    };

    this.isLoading = true;
    this.cartService.addToCart(request).subscribe({
      next: () => {
        this.isLoading = false;
        this.snackBar.open(`"${this.product?.name}" a fost adăugat în coș!`, 'OK', {
          duration: 3000,
        });
      },
      error: (err) => {
        this.isLoading = false;
        const errorMessage = err.error?.message || 'A apărut o eroare la adăugarea produsului în coș.';
        this.snackBar.open(errorMessage, 'Închide', {
          duration: 5000
        });
        console.error('Error adding to cart:', err);
      }
    });
  }
}
</file>

<file path="app/features/products/product-form/product-form.component.html">
<div class="admin-product-form-container">
  <mat-card>
    <mat-card-header>
      <mat-card-title>{{ pageTitle }}</mat-card-title>
    </mat-card-header>
    <mat-card-content>
      <div *ngIf="isLoading" class="spinner-container">
        <mat-progress-spinner diameter="50" mode="indeterminate"></mat-progress-spinner>
        <p>Se încarcă datele...</p>
      </div>

      <form [formGroup]="productForm" (ngSubmit)="onSubmit()" *ngIf="!isLoading">
        <mat-form-field appearance="outline" class="full-width">
          <mat-label>Nume Produs</mat-label>
          <input matInput formControlName="name" required>
          <mat-error *ngIf="f['name'].hasError('required')">Numele este obligatoriu.</mat-error>
          <mat-error *ngIf="f['name'].hasError('minlength')">Minim 3 caractere.</mat-error>
        </mat-form-field>

        <mat-form-field appearance="outline" class="full-width">
          <mat-label>Descriere</mat-label>
          <textarea matInput formControlName="description" rows="4"></textarea>
        </mat-form-field>

        <div class="form-row">
          <mat-form-field appearance="outline" class="form-row-item">
            <mat-label>Preț (RON)</mat-label>
            <input matInput type="number" formControlName="price" required min="0.01">
            <mat-error *ngIf="f['price'].hasError('required')">Prețul este obligatoriu.</mat-error>
            <mat-error *ngIf="f['price'].hasError('min')">Prețul trebuie să fie pozitiv.</mat-error>
          </mat-form-field>

          <mat-form-field appearance="outline" class="form-row-item">
            <mat-label>Cantitate Stoc</mat-label>
            <input matInput type="number" formControlName="stockQuantity" required min="0">
            <mat-error *ngIf="f['stockQuantity'].hasError('required')">Stocul este obligatoriu.</mat-error>
            <mat-error *ngIf="f['stockQuantity'].hasError('min')">Stocul nu poate fi negativ.</mat-error>
             <mat-error *ngIf="f['stockQuantity'].hasError('pattern')">Stocul trebuie să fie un număr întreg.</mat-error>
          </mat-form-field>
        </div>

        <mat-form-field appearance="outline" class="full-width">
          <mat-label>Categorie</mat-label>
          <mat-select formControlName="categoryId" required>
            <!-- MODIFICARE: Iterăm peste array-ul simplu 'categories' -->
            <mat-option *ngFor="let category of categories" [value]="category.id">
              {{ category.name }}
            </mat-option>
          </mat-select>
          <mat-error *ngIf="f['categoryId'].hasError('required')">Categoria este obligatorie.</mat-error>
        </mat-form-field>

        <div formArrayName="specifications" class="specifications-section">
          <h3>Specificații Produs</h3>
          <div *ngFor="let specGroup of specificationsFormArray.controls; let i = index" [formGroupName]="i" class="specification-item">
            <mat-form-field appearance="outline" class="spec-name-select">
              <mat-label>Specificație</mat-label>
              <!-- MODIFICARE: Iterăm peste array-ul simplu 'specDefinitions' -->
              <mat-select formControlName="definitionId" required>
                <mat-option *ngFor="let def of specDefinitions" [value]="def.id">
                  {{ def.name }} {{ def.unit ? '(' + def.unit + ')' : '' }}
                </mat-option>
              </mat-select>
               <mat-error *ngIf="specGroup.get('definitionId')?.hasError('required')">Selectați o specificație.</mat-error>
            </mat-form-field>

            <mat-form-field appearance="outline" class="spec-value-input">
              <mat-label>Valoare</mat-label>
              <input matInput formControlName="value" required>
              <mat-error *ngIf="specGroup.get('value')?.hasError('required')">Valoarea este obligatorie.</mat-error>
            </mat-form-field>

            <button mat-icon-button color="warn" type="button" (click)="removeSpecification(i)" aria-label="Șterge specificația">
              <mat-icon>remove_circle_outline</mat-icon>
            </button>
          </div>
          <button mat-stroked-button color="accent" type="button" (click)="addSpecification()" class="add-spec-button">
            <mat-icon>add</mat-icon> Adaugă Specificație
          </button>
        </div>

        <mat-divider></mat-divider>
        <div class="form-actions">
          <button mat-stroked-button color="warn" type="button" routerLink="/admin/products" [disabled]="isLoading">
            <mat-icon>cancel</mat-icon> Anulează
          </button>
          <!-- MODIFICARE: Am reintrodus verificarea pentru 'pristine' în modul de editare -->
          <button mat-raised-button color="primary" type="submit" [disabled]="isLoading || productForm.invalid || (isEditMode && productForm.pristine)">
             <mat-icon *ngIf="!isLoading">save</mat-icon>
             <mat-progress-spinner *ngIf="isLoading" diameter="20" mode="indeterminate" style="margin-right: 8px; display: inline-block;"></mat-progress-spinner>
            {{ isLoading ? 'Se salvează...' : submitButtonText }}
          </button>
        </div>
      </form>
    </mat-card-content>
  </mat-card>
</div>
</file>

<file path="app/features/products/product-form/product-form.component.scss">
.admin-product-form-container {
  padding: 20px;
  max-width: 800px;
  margin: 20px auto;
}

mat-card-header {
  padding-bottom: 16px;
}

.full-width {
  width: 100%;
  margin-bottom: 16px;
}

.form-row {
  display: flex;
  gap: 16px;
  margin-bottom: 16px;
  .form-row-item {
    flex: 1;
  }
}

.spinner-container {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  min-height: 200px;
  p {
    margin-top: 10px;
    opacity: 0.7;
  }
}

.specifications-section {
  margin-top: 20px;
  margin-bottom: 20px;
  padding: 16px;
  border: 1px solid rgba(0,0,0,0.12);
  border-radius: 8px;
  background-color: rgba(0,0,0,0.02);

  h3 {
    margin-top: 0;
    margin-bottom: 16px;
    font-size: 1.1em;
    opacity: 0.87;
  }
  
  .specification-item {
    display: flex;
    align-items: flex-start;
    gap: 10px;
    margin-bottom: 12px;
    padding-bottom: 12px;
    border-bottom: 1px dotted rgba(0,0,0,0.12);

    &:last-child {
      margin-bottom: 0;
      padding-bottom: 0;
      border-bottom: none;
    }

    .spec-name-select {
      flex: 2;
    }
    .spec-value-input {
      flex: 3;
    }
    button[mat-icon-button] {
      flex-shrink: 0;
      margin-top: 8px;
    }
  }
  
  .add-spec-button {
    margin-top: 10px;
    mat-icon {
      margin-right: 8px;
    }
  }
}

.form-actions {
 display: flex;
 justify-content: flex-end;
 gap: 10px;
 margin-top: 24px;
 button {
   min-width: 120px;
   mat-icon {
     margin-right: 8px;
   }
 }
}

mat-error {
 font-size: 0.85em;
}
</file>

<file path="app/features/products/product-form/product-form.component.ts">
import { Component, OnInit, inject } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ReactiveFormsModule, FormBuilder, FormGroup, Validators, FormArray } from '@angular/forms';
import { ActivatedRoute, Router, RouterModule } from '@angular/router';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { MatButtonModule } from '@angular/material/button';
import { MatCardModule } from '@angular/material/card';
import { MatSelectModule } from '@angular/material/select';
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { MatIconModule } from '@angular/material/icon';
import { MatDividerModule } from '@angular/material/divider';
import { HttpErrorResponse } from '@angular/common/http';

import { Product, SpecificationValue } from '../../../shared/models/product.model';
import { Category } from '../../../shared/models/category.model';
import { SpecificationDefinition } from '../../../shared/models/specification-definition.model';

import { ProductService } from '../product.service';
import { CategoryAdminService } from '../../admin/services/category.admin.service';
import { SpecificationAdminService } from '../../admin/services/specification-admin.service';
import { Observable, of, forkJoin } from 'rxjs';
import { catchError } from 'rxjs/operators';

@Component({
  selector: 'app-product-form',
  standalone: true,
  imports: [
    CommonModule, RouterModule, ReactiveFormsModule, MatFormFieldModule, MatInputModule,
    MatButtonModule, MatCardModule, MatSelectModule, MatSnackBarModule,
    MatProgressSpinnerModule, MatIconModule, MatDividerModule
  ],
  templateUrl: './product-form.component.html',
  styleUrls: ['./product-form.component.scss']
})
export class ProductFormComponent implements OnInit {
  productForm!: FormGroup;
  isEditMode = false;
  productId?: number;
  isLoading = true;
  pageTitle = 'Adaugă Produs Nou';
  submitButtonText = 'Salvează Produs';
  error: string | null = null;

  // Vom popula aceste array-uri pentru o gestionare mai sigură
  categories: Category[] = [];
  specDefinitions: SpecificationDefinition[] = [];

  private fb = inject(FormBuilder);
  private productService = inject(ProductService);
  private categoryAdminService = inject(CategoryAdminService);
  private specAdminService = inject(SpecificationAdminService);
  private route = inject(ActivatedRoute);
  private router = inject(Router);
  private snackBar = inject(MatSnackBar);

  ngOnInit(): void {
    this.productForm = this.fb.group({
      name: ['', [Validators.required, Validators.minLength(3), Validators.maxLength(255)]],
      description: ['', [Validators.maxLength(5000)]],
      // AICI ESTE PRIMA MODIFICARE CHEIE: Am eliminat validatorul de pattern
      price: [null, [Validators.required, Validators.min(0.01)]],
      stockQuantity: [0, [Validators.required, Validators.min(0), Validators.pattern(/^[0-9]*$/)]],
      categoryId: [null, Validators.required],
      specifications: this.fb.array([])
    });

    this.loadInitialData();
  }

  // A DOUA MODIFICARE CHEIE: Folosim forkJoin pentru a încărca totul sincronizat
  loadInitialData(): void {
    this.isLoading = true;
    const idFromRoute = this.route.snapshot.paramMap.get('id');
    this.isEditMode = !!idFromRoute;
    this.productId = idFromRoute ? +idFromRoute : undefined;

    // Definim sursele de date
    const categories$ = this.categoryAdminService.getAll();
    const specDefinitions$ = this.specAdminService.getAllDefinitions();
    const product$ = this.isEditMode && this.productId
      ? this.productService.getById(this.productId)
      : of(null);

    forkJoin({
      categories: categories$,
      specDefinitions: specDefinitions$,
      product: product$
    }).pipe(
      catchError(err => {
        this.handleLoadError('Eroare la încărcarea datelor necesare pentru formular.', err);
        return of(null);
      })
    ).subscribe(result => {
      if (result) {
        this.categories = result.categories;
        this.specDefinitions = result.specDefinitions;
        
        if (this.isEditMode) {
          this.pageTitle = 'Editează Produs';
          this.submitButtonText = 'Actualizează Produs';
          if (result.product) {
            this.populateForm(result.product);
          } else {
             this.handleInvalidId('Produsul nu a putut fi încărcat.');
          }
        }
      }
      this.isLoading = false;
    });
  }

  populateForm(product: Product): void {
    this.productForm.patchValue({
      name: product.name,
      description: product.description,
      price: product.price,
      stockQuantity: product.stockQuantity,
      categoryId: product.categoryId,
    });
    
    this.specificationsFormArray.clear();
    product.specifications?.forEach(spec => this.addSpecification(spec));
  }

  get specificationsFormArray(): FormArray {
    return this.productForm.get('specifications') as FormArray;
  }

  createSpecificationGroup(spec?: SpecificationValue): FormGroup {
    return this.fb.group({
      definitionId: [spec?.definitionId || null, Validators.required],
      value: [spec?.value || '', Validators.required],
    });
  }

  addSpecification(spec?: SpecificationValue): void {
    this.specificationsFormArray.push(this.createSpecificationGroup(spec));
  }

  removeSpecification(index: number): void {
    this.specificationsFormArray.removeAt(index);
  }

  onSubmit(): void {
    if (this.isEditMode && this.productForm.pristine) {
      this.snackBar.open('Nu ați făcut nicio modificare pentru a salva.', 'OK', { duration: 3000 });
      return;
    }
      
    if (this.productForm.invalid) {
      this.snackBar.open('Formular invalid. Verificați câmpurile marcate cu roșu.', 'OK', { duration: 4000 });
      this.productForm.markAllAsTouched();
      return;
    }

    this.isLoading = true;
    const formValue = this.productForm.getRawValue();
    const productData: Omit<Product, 'id'> = {
        ...formValue,
        specifications: formValue.specifications.map((spec: any) => ({
            definitionId: spec.definitionId,
            value: spec.value
        }))
    };
    
    const operation = this.isEditMode && this.productId
      ? this.productService.update(this.productId, productData as Product)
      : this.productService.create(productData as Product);

    operation.subscribe({
      next: () => {
        this.isLoading = false;
        this.snackBar.open(`Produs ${this.isEditMode ? 'actualizat' : 'creat'} cu succes!`, 'OK', { duration: 3000 });
        this.router.navigate(['/admin/products']);
      },
      error: (err: HttpErrorResponse) => this.handleSubmitError(`Eroare la ${this.isEditMode ? 'actualizarea' : 'crearea'} produsului.`, err)
    });
  }
  
  private handleInvalidId(message: string): void {
    this.isLoading = false;
    this.error = message;
    this.snackBar.open(this.error, 'Închide', { duration: 3000 });
    this.router.navigate(['/admin/products']);
  }

  private handleLoadError(message: string, err: HttpErrorResponse): void {
    this.isLoading = false;
    const serverErrorMessage = err.error?.message || err.message || 'Eroare necunoscută.';
    this.error = `${message} ${serverErrorMessage}`;
    this.snackBar.open(this.error, 'Închide', { duration: 5000 });
    console.error(err);
    this.router.navigate(['/admin/products']);
  }

  private handleSubmitError(message: string, err: HttpErrorResponse): void {
    this.isLoading = false;
    const serverErrorMessage = err.error?.message || err.message || 'Eroare necunoscută.';
    this.snackBar.open(`${message} ${serverErrorMessage}`, 'Închide', { duration: 5000 });
    console.error(err);
  }

  get f() { return this.productForm.controls; }
}
</file>

<file path="app/features/products/product-list/product-list.component.html">
<div class="admin-product-list-container">
  <div class="header">
    <h2>Administrare Produse</h2>
    <button mat-raised-button color="primary" routerLink="/admin/products/new">
      <mat-icon>add_circle_outline</mat-icon> Adaugă Produs Nou
    </button>
  </div>

  <mat-form-field appearance="outline" class="filter-field">
    <mat-label>Filtrează produse</mat-label>
    <input matInput (keyup)="applyFilter($event)" placeholder="Caută după nume, categorie...">
    <mat-icon matSuffix>search</mat-icon>
  </mat-form-field>

  <div *ngIf="isLoading" class="loading-indicator">
    <mat-spinner diameter="50"></mat-spinner>
    <p>Se încarcă produsele...</p>
  </div>

  <div *ngIf="error && !isLoading" class="error-message">
    <p>{{ error }}</p>
    <button mat-stroked-button color="warn" (click)="loadProducts()">Reîncearcă</button>
  </div>

  <div *ngIf="!isLoading && !error && dataSource.data.length === 0" class="no-data">
    <p>Nu există produse definite sau care să corespundă filtrului.</p>
  </div>

  <div class="table-container" *ngIf="!isLoading && !error && dataSource.data.length > 0">
    <table mat-table [dataSource]="dataSource" matSort class="mat-elevation-z8">

      <ng-container matColumnDef="id">
        <th mat-header-cell *matHeaderCellDef mat-sort-header> ID </th>
        <td mat-cell *matCellDef="let product"> {{product.id}} </td>
      </ng-container>

      <ng-container matColumnDef="name">
        <th mat-header-cell *matHeaderCellDef mat-sort-header> Nume Produs </th>
        <td mat-cell *matCellDef="let product"> {{product.name}} </td>
      </ng-container>

      <ng-container matColumnDef="categoryName">
        <th mat-header-cell *matHeaderCellDef mat-sort-header> Categorie </th>
        <td mat-cell *matCellDef="let product"> {{product.categoryName || 'N/A'}} </td>
      </ng-container>

      <ng-container matColumnDef="price">
        <th mat-header-cell *matHeaderCellDef mat-sort-header> Preț </th>
        <td mat-cell *matCellDef="let product"> {{product.price | currency:'RON':'symbol':'1.2-2'}} </td>
      </ng-container>

      <ng-container matColumnDef="stockQuantity">
        <th mat-header-cell *matHeaderCellDef mat-sort-header> Stoc </th>
        <td mat-cell *matCellDef="let product"> {{product.stockQuantity}} buc. </td>
      </ng-container>

      <ng-container matColumnDef="actions">
        <th mat-header-cell *matHeaderCellDef> Acțiuni </th>
        <td mat-cell *matCellDef="let product">
          <button mat-icon-button color="primary" [routerLink]="['/admin/products/edit', product.id]" aria-label="Editează produsul">
            <mat-icon>edit</mat-icon>
          </button>
          <button mat-icon-button routerLink="/products/{{product.id}}" aria-label="Vezi detalii publice produs">
             <mat-icon>visibility</mat-icon>
          </button>
          <button mat-icon-button color="warn" (click)="deleteProduct(product.id!)" aria-label="Șterge produsul">
            <mat-icon>delete</mat-icon>
          </button>
        </td>
      </ng-container>

      <tr mat-header-row *matHeaderRowDef="displayedColumns"></tr>
      <tr mat-row *matRowDef="let row; columns: displayedColumns;"></tr>

      <tr class="mat-row" *matNoDataRow>
        <td class="mat-cell" [attr.colspan]="displayedColumns.length">
          Nu s-au găsit produse care să corespundă filtrului "{{dataSource.filter}}".
        </td>
      </tr>
    </table>
    <mat-paginator [pageSizeOptions]="[5, 10, 20, 50]" showFirstLastButtons aria-label="Selectează pagina de produse"></mat-paginator>
  </div>
</div>
</file>

<file path="app/features/products/product-list/product-list.component.scss">
.admin-product-list-container {
  padding: 20px;
  max-width: 1200px;
  margin: auto;
}

.header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
  h2 {
    margin: 0;
  }
  button mat-icon {
    margin-right: 8px;
  }
}

.filter-field {
  width: 100%;
  max-width: 500px;
  margin-bottom: 20px;
}

.loading-indicator,
.error-message,
.no-data {
  text-align: center;
  padding: 20px;
  mat-spinner {
    margin: 0 auto 10px auto;
  }
}

.table-container {
  overflow-x: auto;
  margin-top: 10px;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

table {
  width: 100%;
}

.mat-column-actions {
  width: 150px;
  text-align: right;
}

.mat-column-id {
  max-width: 80px;
}
.mat-column-price, .mat-column-stockQuantity {
  max-width: 120px;
  text-align: right;
}
.mat-header-cell {
  font-weight: 500;
  opacity: 0.87;
}

.mat-row:hover {
  background-color: rgba(0,0,0,0.04);
}

.mat-cell, .mat-header-cell {
  padding: 8px 16px;
}
</file>

<file path="app/features/products/product-list/product-list.component.ts">
// src/app/features/products/product-list/product-list.component.ts
import { Component, OnInit, inject, ViewChild, AfterViewInit } from '@angular/core';
import { CommonModule, CurrencyPipe } from '@angular/common';
import { RouterModule } from '@angular/router';
import { MatTableDataSource, MatTableModule } from '@angular/material/table';
import { MatPaginator, MatPaginatorModule } from '@angular/material/paginator';
import { MatSort, MatSortModule } from '@angular/material/sort';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar';
import { MatDialog } from '@angular/material/dialog';

import { Product } from '../../../shared/models/product.model';
import { ProductService } from '../product.service';

@Component({
  selector: 'app-product-list',
  standalone: true,
  imports: [
    CommonModule,
    RouterModule,
    MatTableModule,
    MatPaginatorModule,
    MatSortModule,
    MatFormFieldModule,
    MatInputModule,
    MatButtonModule,
    MatIconModule,
    MatProgressSpinnerModule,
    MatSnackBarModule,
    CurrencyPipe
  ],
  templateUrl: './product-list.component.html',
  styleUrls: ['./product-list.component.scss']
})
export class ProductListComponent implements OnInit, AfterViewInit {
  displayedColumns: string[] = ['id', 'name', 'categoryName', 'price', 'stockQuantity', 'actions'];
  dataSource: MatTableDataSource<Product> = new MatTableDataSource();
  isLoading = true;
  error: string | null = null;

  @ViewChild(MatPaginator) paginator!: MatPaginator;
  @ViewChild(MatSort) sort!: MatSort;

  private productService = inject(ProductService);
  private snackBar = inject(MatSnackBar);

  ngOnInit(): void {
    this.loadProducts();
  }

  ngAfterViewInit(): void {
    this.dataSource.paginator = this.paginator;
    this.dataSource.sort = this.sort;
     // Custom sort pentru categoryName, care e un string
    this.dataSource.sortingDataAccessor = (item, property) => {
      switch (property) {
        case 'categoryName': return item.categoryName || '';
        default: return (item as any)[property];
      }
    };
  }

  loadProducts(): void {
    this.isLoading = true;
    this.error = null;
    this.productService.getAll().subscribe({
      next: (data) => {
        this.dataSource.data = data;
        this.isLoading = false;
      },
      error: (err) => {
        this.error = 'Nu s-au putut încărca produsele.';
        console.error(err);
        this.isLoading = false;
        this.snackBar.open(this.error, 'Închide', { duration: 5000 });
      }
    });
  }

  applyFilter(event: Event): void {
    const filterValue = (event.target as HTMLInputElement).value;
    this.dataSource.filter = filterValue.trim().toLowerCase();
    if (this.dataSource.paginator) {
      this.dataSource.paginator.firstPage();
    }
  }

  deleteProduct(productId: number): void {
    const confirmation = window.confirm('Sunteți sigur că doriți să ștergeți acest produs?');
    if (confirmation) {
      this.productService.delete(productId).subscribe({
        next: () => {
          this.snackBar.open('Produs șters cu succes!', 'OK', { duration: 3000 });
          this.loadProducts();
        },
        error: (err) => {
          this.snackBar.open('Eroare la ștergerea produsului.', 'Închide', { duration: 5000 });
          console.error(err);
        }
      });
    }
  }
}
</file>

<file path="app/features/products/product.service.ts">
// src/app/features/products/product.service.ts
import { Injectable, inject } from '@angular/core';
import { HttpClient, HttpErrorResponse } from '@angular/common/http';
import { Observable, throwError } from 'rxjs';
import { catchError } from 'rxjs/operators';
import { Product } from '../../shared/models/product.model';

@Injectable({
  providedIn: 'root'
})
export class ProductService {
  private apiUrl = '/api/products';

  private http = inject(HttpClient);

  getAll(): Observable<Product[]> {
    return this.http.get<Product[]>(this.apiUrl)
      .pipe(catchError(this.handleError));
  }

  getById(id: number): Observable<Product> {
    return this.http.get<Product>(`${this.apiUrl}/${id}`)
      .pipe(catchError(this.handleError));
  }

  create(product: Product): Observable<Product> {
    return this.http.post<Product>(this.apiUrl, product)
      .pipe(catchError(this.handleError));
  }

  update(id: number, product: Product): Observable<Product> {
    return this.http.put<Product>(`${this.apiUrl}/${id}`, product)
      .pipe(catchError(this.handleError));
  }

  delete(id: number): Observable<void> {
    return this.http.delete<void>(`${this.apiUrl}/${id}`)
      .pipe(catchError(this.handleError));
  }

 private handleError(error: HttpErrorResponse) {
  let userFriendlyErrorMessage = 'A apărut o problemă. Vă rugăm încercați din nou mai târziu.';
  let detailedErrorMessage = 'Eroare necunoscută.';

  if (error.error) {
    // Caz 1: Eroare este un HttpErrorResponse cu un obiect 'error'
    if (typeof error.error === 'object' && error.error !== null) {
      // Încercăm să extragem un mesaj specific din corpul erorii trimis de backend
      // Acesta ar putea fi error.error.message, error.error.error, error.error.detail, etc.
      // Ajustează în funcție de structura răspunsurilor de eroare de la API-ul tău Spring Boot
      detailedErrorMessage = (error.error as any).message ||  // Cel mai comun
                             (error.error as any).error?.message || // Uneori e imbricat
                             (error.error as any).detail ||
                             JSON.stringify(error.error); // Fallback la JSON string dacă e un obiect complex

      // Poți încerca să faci mesajul user-friendly mai specific dacă backend-ul trimite un mesaj clar
      if ((error.error as any).message && typeof (error.error as any).message === 'string') {
        userFriendlyErrorMessage = (error.error as any).message;
      }

    } else if (typeof error.error === 'string') {
      // Caz 2: Corpul erorii este un simplu string
      detailedErrorMessage = error.error;
      userFriendlyErrorMessage = error.error; // Poate fi afișat direct dacă e relevant
    }
  } else if (error.message) {
    // Caz 3: Eroare client-side sau de rețea (ex: HttpErrorResponse fără error.error, dar cu error.message)
    detailedErrorMessage = error.message;
    if (error.status === 0 || error.status === -1) { // Tipic pentru erori de rețea sau CORS
        userFriendlyErrorMessage = 'Eroare de conexiune cu serverul. Verificați rețeaua.';
    } else {
        userFriendlyErrorMessage = 'A apărut o eroare la procesarea cererii.';
    }
  }

  // Logare detaliată în consola dezvoltatorului
  console.error('------------------------------------');
  console.error(`[SERVICE ERROR] Status: ${error.status} - URL: ${error.url}`);
  console.error('Mesaj detaliat:', detailedErrorMessage);
  console.error('Obiect eroare complet:', error);
  console.error('------------------------------------');

  // Aruncă o eroare care va fi propagată și poate fi prinsă în componentă
  // sau de un error handler global, dacă există.
  // Pentru utilizator, mesajele sunt de obicei afișate prin MatSnackBar în componentă/serviciu.
  return throwError(() => new Error(userFriendlyErrorMessage)); // Trimite un mesaj mai general către UI
}
}
</file>

<file path="app/features/products/products.module.ts">
// src/app/features/products/products.module.ts
import { NgModule }            from '@angular/core';
import { CommonModule }        from '@angular/common';
import { RouterModule }        from '@angular/router';
import { ReactiveFormsModule } from '@angular/forms';

import { ProductListComponent }   from './product-list/product-list.component';
import { ProductDetailComponent } from './product-detail/product-detail.component';
import { ProductFormComponent }   from './product-form/product-form.component';

@NgModule({
  // elimină complet `declarations`
  imports: [
    CommonModule,
    RouterModule,            // pentru directivele routerLink, outlet etc.
    ReactiveFormsModule,

    // importă aici componentele standalone
    ProductListComponent,
    ProductDetailComponent,
    ProductFormComponent
  ]
})
export class ProductsModule {}
</file>

<file path="app/features/products/user-product-list/user-product-list.component.html">
<!-- frontend/src/app/features/products/user-product-list/user-product-list.component.html -->
<div class="user-product-list-container">
  <div class="header">
    <h2>Produsele Noastre</h2>
    <div class="filters-container">
      <mat-form-field appearance="outline" class="filter-field search-field">
        <mat-label>Caută produse</mat-label>
        <input matInput (keyup)="applyFilter($event)" placeholder="Caută după nume, categorie...">
        <mat-icon matSuffix>search</mat-icon>
      </mat-form-field>
      
      <mat-form-field appearance="outline" class="filter-field category-field">
        <mat-label>Filtrează după categorie</mat-label>
        <mat-select [(ngModel)]="selectedCategoryId" (selectionChange)="applyCategoryFilter()">
          <mat-option [value]="null">Toate categoriile</mat-option>
          <mat-option *ngFor="let category of categories" [value]="category.id">
            {{ category.name }}
          </mat-option>
        </mat-select>
      </mat-form-field>
    </div>
  </div>

  <div *ngIf="isLoading" class="loading-indicator">
    <mat-spinner diameter="50"></mat-spinner>
    <p>Se încarcă produsele...</p>
  </div>

  <div *ngIf="error && !isLoading" class="error-message">
    <p>{{ error }}</p>
    <button mat-stroked-button color="warn" (click)="loadProducts()">Reîncearcă</button>
  </div>

  <div *ngIf="!isLoading && !error && filteredProducts.length === 0" class="no-data">
    <p>Nu există produse disponibile momentan.</p>
  </div>

  <!-- Grid View for Products -->
  <div class="products-grid" *ngIf="!isLoading && !error && filteredProducts.length > 0">
    <mat-card *ngFor="let product of getPaginatedProducts()" class="product-card">
      <div class="product-image" [routerLink]="['/products', product.id]">
        <mat-icon>inventory_2</mat-icon>
      </div>
      
      <mat-card-header [routerLink]="['/products', product.id]">
        <mat-card-title>{{ product.name }}</mat-card-title>
        <mat-card-subtitle>{{ product.categoryName }}</mat-card-subtitle>
      </mat-card-header>
      
      <mat-card-content>
        <div class="product-info">
          <p class="price">{{ product.price | currency:'RON':'symbol':'1.2-2' }}</p>
          <p class="stock" [class.in-stock]="product.stockQuantity > 0" [class.out-of-stock]="product.stockQuantity === 0">
            {{ product.stockQuantity > 0 ? 'În stoc: ' + product.stockQuantity + ' buc.' : 'Stoc epuizat' }}
          </p>
        </div>
        
        <div class="product-description" *ngIf="product.description">
          <p>{{ product.description | slice:0:100 }}{{ product.description.length > 100 ? '...' : '' }}</p>
        </div>
      </mat-card-content>
      
      <mat-card-actions>
        <button mat-button color="primary" [routerLink]="['/products', product.id]">
          <mat-icon>visibility</mat-icon>
          Vezi detalii
        </button>
        <button mat-raised-button color="accent" 
                (click)="addToCart(product)" 
                [disabled]="product.stockQuantity === 0 || isAddingToCart[product.id!]">
          <mat-spinner *ngIf="isAddingToCart[product.id!]" diameter="20" style="display: inline-block; margin-right: 5px;"></mat-spinner>
          <mat-icon *ngIf="!isAddingToCart[product.id!]">add_shopping_cart</mat-icon>
          {{ product.stockQuantity === 0 ? 'Stoc epuizat' : 'Adaugă în coș' }}
        </button>
      </mat-card-actions>
    </mat-card>
  </div>

  <!-- Pagination -->
  <div class="pagination-container" *ngIf="!isLoading && !error && filteredProducts.length > 0">
    <mat-paginator [length]="filteredProducts.length"
                   [pageSize]="pageSize"
                   [pageSizeOptions]="[6, 12, 24, 48]"
                   [pageIndex]="pageIndex"
                   (page)="onPageChange($event)"
                   showFirstLastButtons>
    </mat-paginator>
  </div>
</div>
</file>

<file path="app/features/products/user-product-list/user-product-list.component.scss">
.user-product-list-container {
  padding: 20px;
  max-width: 1400px;
  margin: 0 auto;
  min-height: calc(100vh - 64px);
}

.header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: 30px;
  flex-wrap: wrap;
  gap: 20px;

  h2 {
    margin: 0;
    font-size: 2em;
    flex-shrink: 0;
  }

  .filters-container {
    display: flex;
    gap: 16px;
    align-items: center;
    flex-wrap: wrap;
    flex: 1;
    justify-content: flex-end;

    .filter-field {
      &.search-field {
        min-width: 250px;
        max-width: 400px;
      }
      
      &.category-field {
        min-width: 200px;
        max-width: 300px;
      }
    }
  }
}

.loading-indicator,
.error-message,
.no-data {
  text-align: center;
  padding: 40px 20px;

  mat-spinner {
    margin: 0 auto 20px;
  }
}

.products-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
  gap: 24px;
  margin-bottom: 30px;
}

.product-card {
  transition: all 0.3s ease;
  display: flex;
  flex-direction: column;
  height: 100%;
  // Remove dark background

  &:hover {
    transform: translateY(-4px);
    box-shadow: 0 8px 16px rgba(0,0,0,0.2);
  }

  .product-image {
    height: 200px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    background: rgba(0,0,0,0.05);
    border-bottom: 1px solid rgba(0,0,0,0.1);

    mat-icon {
      font-size: 80px;
      width: 80px;
      height: 80px;
      opacity: 0.3;
    }
  }

  mat-card-header {
    cursor: pointer;
    padding: 16px;

    mat-card-title {
      font-size: 1.2em;
      margin-bottom: 4px;
    }

    mat-card-subtitle {
      opacity: 0.7;
      font-size: 0.9em;
    }
  }

  mat-card-content {
    flex: 1;
    padding: 0 16px 16px;

    .product-info {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;

      .price {
        font-size: 1.5em;
        font-weight: 500;
        margin: 0;
      }

      .stock {
        font-size: 0.9em;
        padding: 4px 8px;
        border-radius: 4px;
        
        &.in-stock {
          background-color: rgba(76, 175, 80, 0.1);
          color: #4CAF50;
        }
        
        &.out-of-stock {
          background-color: rgba(244, 67, 54, 0.1);
          color: #f44336;
        }
      }
    }

    .product-description {
      p {
        margin: 0;
        font-size: 0.9em;
        line-height: 1.5;
        opacity: 0.8;
      }
    }
  }

  mat-card-actions {
    padding: 16px;
    display: flex;
    justify-content: space-between;
    gap: 8px;
    border-top: 1px solid rgba(0,0,0,0.1);

    button {
      flex: 1;
    }
  }
}

.pagination-container {
  display: flex;
  justify-content: center;
  margin-top: 30px;
}

/* Responsive styles */
@media (max-width: 1024px) {
  .header {
    flex-direction: column;
    align-items: stretch;
    
    .filters-container {
      justify-content: stretch;
      
      .filter-field {
        flex: 1;
      }
    }
  }
}

@media (max-width: 768px) {
  .filters-container {
    flex-direction: column;
    
    .filter-field {
      width: 100%;
      max-width: unset !important;
      
      &.search-field,
      &.category-field {
        min-width: unset;
      }
    }
  }
  
  .products-grid {
    grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
    gap: 16px;
  }
}

@media (max-width: 480px) {
  .products-grid {
    grid-template-columns: 1fr;
  }
}
</file>

<file path="app/features/products/user-product-list/user-product-list.component.spec.ts">
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { UserProductListComponent } from './user-product-list.component';

describe('UserProductListComponent', () => {
  let component: UserProductListComponent;
  let fixture: ComponentFixture<UserProductListComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [UserProductListComponent]
    })
    .compileComponents();

    fixture = TestBed.createComponent(UserProductListComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});
</file>

<file path="app/features/products/user-product-list/user-product-list.component.ts">
// frontend/src/app/features/products/user-product-list/user-product-list.component.ts
import { Component, OnInit, inject, ViewChild } from '@angular/core';
import { CommonModule, CurrencyPipe, SlicePipe } from '@angular/common';
import { RouterModule } from '@angular/router';
import { FormsModule } from '@angular/forms';
import { MatCardModule } from '@angular/material/card';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { MatSelectModule } from '@angular/material/select'; // Add this import
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar';
import { MatPaginator, MatPaginatorModule, PageEvent } from '@angular/material/paginator';

import { Product } from '../../../shared/models/product.model';
import { Category } from '../../../shared/models/category.model'; // Add this import
import { ProductService } from '../product.service';
import { CartService } from '../../shopping-cart/cart.service';
import { CategoryAdminService } from '../../admin/services/category.admin.service'; // Add this import
import { AddToCartRequest } from '../../../shared/models/cart.model';

@Component({
  selector: 'app-user-product-list',
  standalone: true,
  imports: [
    CommonModule,
    RouterModule,
    FormsModule,
    MatCardModule,
    MatButtonModule,
    MatIconModule,
    MatFormFieldModule,
    MatInputModule,
    MatSelectModule, // Add this import
    MatProgressSpinnerModule,
    MatSnackBarModule,
    MatPaginatorModule,
    CurrencyPipe,
    SlicePipe
  ],
  templateUrl: './user-product-list.component.html',
  styleUrls: ['./user-product-list.component.scss']
})
export class UserProductListComponent implements OnInit {
  products: Product[] = [];
  filteredProducts: Product[] = [];
  categories: Category[] = []; // Add categories array
  selectedCategoryId: number | null = null; // Add selected category tracking
  searchText: string = ''; // Add search text tracking
  isLoading = true;
  error: string | null = null;
  isAddingToCart: { [key: number]: boolean } = {};
  
  // Pagination
  pageSize = 12;
  pageIndex = 0;

  @ViewChild(MatPaginator) paginator!: MatPaginator;

  private productService = inject(ProductService);
  private cartService = inject(CartService);
  private categoryService = inject(CategoryAdminService); // Inject category service
  private snackBar = inject(MatSnackBar);

  ngOnInit(): void {
    this.loadCategories(); // Load categories first
    this.loadProducts();
  }

  loadCategories(): void {
    this.categoryService.getAll().subscribe({
      next: (data) => {
        this.categories = data;
      },
      error: (err) => {
        console.error('Failed to load categories:', err);
        // Don't show error to user as categories are optional for filtering
      }
    });
  }

  loadProducts(): void {
    this.isLoading = true;
    this.error = null;
    this.productService.getAll().subscribe({
      next: (data) => {
        this.products = data;
        this.applyFilters(); // Apply filters after loading
        this.isLoading = false;
      },
      error: (err) => {
        this.error = 'Nu s-au putut încărca produsele.';
        console.error(err);
        this.isLoading = false;
        this.snackBar.open(this.error, 'Închide', { duration: 5000 });
      }
    });
  }

  applyFilter(event: Event): void {
    const filterValue = (event.target as HTMLInputElement).value.trim().toLowerCase();
    this.searchText = filterValue;
    this.applyFilters();
  }

  applyCategoryFilter(): void {
    this.applyFilters();
  }

  applyFilters(): void {
    let filtered = this.products;

    // Apply text filter
    if (this.searchText) {
      filtered = filtered.filter(product => 
        product.name.toLowerCase().includes(this.searchText) ||
        product.categoryName?.toLowerCase().includes(this.searchText) ||
        product.description?.toLowerCase().includes(this.searchText)
      );
    }

    // Apply category filter
    if (this.selectedCategoryId !== null) {
      filtered = filtered.filter(product => 
        product.categoryId === this.selectedCategoryId
      );
    }

    this.filteredProducts = filtered;

    // Reset to first page when filtering
    this.pageIndex = 0;
    if (this.paginator) {
      this.paginator.firstPage();
    }
  }

  onPageChange(event: PageEvent): void {
    this.pageSize = event.pageSize;
    this.pageIndex = event.pageIndex;
  }

  getPaginatedProducts(): Product[] {
    const startIndex = this.pageIndex * this.pageSize;
    const endIndex = startIndex + this.pageSize;
    return this.filteredProducts.slice(startIndex, endIndex);
  }

  addToCart(product: Product): void {
    if (!product || typeof product.id === 'undefined') {
      this.snackBar.open('Detaliile produsului sunt incomplete.', 'Închide', { duration: 3000 });
      return;
    }

    this.isAddingToCart[product.id] = true;

    const request: AddToCartRequest = {
      productId: product.id,
      quantity: 1
    };

    this.cartService.addToCart(request).subscribe({
      next: () => {
        this.isAddingToCart[product.id!] = false;
        this.snackBar.open(`"${product.name}" a fost adăugat în coș!`, 'OK', {
          duration: 3000,
        });
      },
      error: (err) => {
        this.isAddingToCart[product.id!] = false;
        const errorMessage = err.error?.message || 'A apărut o eroare la adăugarea produsului în coș.';
        this.snackBar.open(errorMessage, 'Închide', {
          duration: 5000
        });
        console.error('Error adding to cart:', err);
      }
    });
  }
}
</file>

<file path="app/features/reviews/review-form-dialog/review-form-dialog.component.ts">
// frontend/src/app/features/reviews/review-form-dialog/review-form-dialog.component.ts
import { Component, Inject, OnInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ReactiveFormsModule, FormBuilder, FormGroup, Validators } from '@angular/forms';
import { MAT_DIALOG_DATA, MatDialogRef, MatDialogModule } from '@angular/material/dialog';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar';

import { Review, CreateReviewRequest } from '../../../shared/models/review.model';
import { ReviewService } from '../review.service';
import { StarRatingComponent } from '../../../shared/components/star-rating/star-rating.component';

@Component({
  selector: 'app-review-form-dialog',
  standalone: true,
  imports: [
    CommonModule,
    ReactiveFormsModule,
    MatDialogModule,
    MatFormFieldModule,
    MatInputModule,
    MatButtonModule,
    MatIconModule,
    MatSnackBarModule,
    StarRatingComponent
  ],
  template: `
    <h2 mat-dialog-title>{{ data.review ? 'Editează recenzia' : 'Scrie o recenzie' }}</h2>
    <mat-dialog-content>
      <form [formGroup]="reviewForm">
        <div class="rating-section">
          <label>Evaluarea ta:</label>
          <app-star-rating 
            [rating]="reviewForm.get('rating')?.value || 0"
            (ratingChange)="onRatingChange($event)">
          </app-star-rating>
          <mat-error *ngIf="reviewForm.get('rating')?.touched && reviewForm.get('rating')?.errors?.['required']">
            Te rugăm să selectezi o evaluare
          </mat-error>
        </div>

        <mat-form-field appearance="outline" class="full-width">
          <mat-label>Titlu recenzie (opțional)</mat-label>
          <input matInput formControlName="title" placeholder="Rezumă experiența ta">
          <mat-error *ngIf="reviewForm.get('title')?.errors?.['maxlength']">
            Titlul nu poate depăși 100 de caractere
          </mat-error>
        </mat-form-field>

        <mat-form-field appearance="outline" class="full-width">
          <mat-label>Comentariu (opțional)</mat-label>
          <textarea matInput formControlName="comment" rows="5" 
                    placeholder="Descrie experiența ta cu acest produs"></textarea>
          <mat-error *ngIf="reviewForm.get('comment')?.errors?.['maxlength']">
            Comentariul nu poate depăși 1000 de caractere
          </mat-error>
        </mat-form-field>
      </form>
    </mat-dialog-content>
    <mat-dialog-actions align="end">
      <button mat-button (click)="onCancel()">Anulează</button>
      <button mat-raised-button color="primary" 
              (click)="onSubmit()" 
              [disabled]="reviewForm.invalid || isSubmitting">
        {{ isSubmitting ? 'Se salvează...' : 'Salvează' }}
      </button>
    </mat-dialog-actions>
  `,
  styles: [`
    mat-dialog-content {
      min-width: 500px;
      
      @media (max-width: 600px) {
        min-width: auto;
      }
    }
    
    .rating-section {
      margin-bottom: 20px;
      
      label {
        display: block;
        margin-bottom: 10px;
        font-weight: 500;
      }
      
      mat-error {
        display: block;
        margin-top: 5px;
      }
    }
    
    .full-width {
      width: 100%;
      margin-bottom: 16px;
    }
  `]
})
export class ReviewFormDialogComponent implements OnInit {
  reviewForm!: FormGroup;
  isSubmitting = false;

  constructor(
    private fb: FormBuilder,
    private reviewService: ReviewService,
    private snackBar: MatSnackBar,
    public dialogRef: MatDialogRef<ReviewFormDialogComponent>,
    @Inject(MAT_DIALOG_DATA) public data: { productId: number; review: Review | null }
  ) {}

  ngOnInit(): void {
    this.reviewForm = this.fb.group({
      rating: [this.data.review?.rating || null, Validators.required],
      title: [this.data.review?.title || '', Validators.maxLength(100)],
      comment: [this.data.review?.comment || '', Validators.maxLength(1000)]
    });
  }

  onRatingChange(rating: number): void {
    this.reviewForm.patchValue({ rating });
  }

  onCancel(): void {
    this.dialogRef.close();
  }

  onSubmit(): void {
    if (this.reviewForm.invalid) return;

    this.isSubmitting = true;
    const reviewData: CreateReviewRequest = {
      productId: this.data.productId,
      ...this.reviewForm.value
    };

    const operation = this.data.review
      ? this.reviewService.updateReview(this.data.review.id!, reviewData)
      : this.reviewService.createReview(reviewData);

    operation.subscribe({
      next: () => {
        this.snackBar.open(
          this.data.review ? 'Recenzie actualizată cu succes!' : 'Recenzie adăugată cu succes!',
          'OK',
          { duration: 3000 }
        );
        this.dialogRef.close(true);
      },
      error: (err) => {
        this.isSubmitting = false;
        const errorMessage = err.error?.message || 'A apărut o eroare. Te rugăm să încerci din nou.';
        this.snackBar.open(errorMessage, 'Închide', { duration: 5000 });
      }
    });
  }
}
</file>

<file path="app/features/reviews/review-list/review-list.component.html">
<!-- frontend/src/app/features/reviews/review-list/review-list.component.html -->
<div class="review-section">
  <h3 class="section-title">Recenzii și Evaluări</h3>

  <!-- Review Summary -->
  <div class="review-summary" *ngIf="summary">
    <mat-card>
      <mat-card-content>
        <div class="summary-content">
          <div class="average-rating">
            <div class="rating-number">{{ summary.averageRating.toFixed(1) }}</div>
            <app-star-rating 
              [rating]="summary.averageRating" 
              [readonly]="true"
              [showHalf]="true">
            </app-star-rating>
            <div class="total-reviews">{{ summary.totalReviews }} recenzii</div>
          </div>
          
          <div class="rating-distribution">
            <div *ngFor="let rating of [5, 4, 3, 2, 1]" class="rating-bar">
              <span class="rating-label">{{ rating }} stele</span>
              <div class="bar-container">
                <div class="bar-fill" [style.width.%]="getRatingPercentage(rating)"></div>
              </div>
              <span class="rating-count">{{ summary.ratingDistribution[rating] || 0 }}</span>
            </div>
          </div>
        </div>
      </mat-card-content>
    </mat-card>
  </div>

  <!-- Write Review Button -->
  <div class="review-actions" *ngIf="authService.isLoggedIn()">
    <button mat-raised-button color="primary" (click)="openReviewDialog()">
      <mat-icon>{{ myReview ? 'edit' : 'rate_review' }}</mat-icon>
      {{ myReview ? 'Editează recenzia ta' : 'Scrie o recenzie' }}
    </button>
  </div>

  <div class="login-prompt" *ngIf="!authService.isLoggedIn()">
    <p>Trebuie să fii autentificat pentru a scrie o recenzie.</p>
    <button mat-stroked-button color="primary" routerLink="/login">Autentifică-te</button>
  </div>

  <!-- Reviews List -->
  <div class="reviews-list">
    <div *ngIf="isLoading" class="loading-indicator">
      <mat-spinner diameter="40"></mat-spinner>
    </div>

    <div *ngIf="!isLoading && reviews.length === 0" class="no-reviews">
      <p>Nu există recenzii pentru acest produs încă.</p>
      <p *ngIf="authService.isLoggedIn()">Fii primul care scrie o recenzie!</p>
    </div>

    <mat-card *ngFor="let review of reviews" class="review-card">
      <mat-card-header>
        <div class="review-header">
          <div class="review-info">
            <h4 class="reviewer-name">{{ review.username }}</h4>
            <app-star-rating [rating]="review.rating" [readonly]="true"></app-star-rating>
            <span class="review-date">{{ formatDate(review.createdAt) }}</span>
          </div>
          <div class="review-actions" *ngIf="canEditReview(review)">
            <button mat-icon-button (click)="openReviewDialog()" *ngIf="review.userId === authService.getCurrentUser()?.id">
              <mat-icon>edit</mat-icon>
            </button>
            <button mat-icon-button color="warn" (click)="deleteReview(review)">
              <mat-icon>delete</mat-icon>
            </button>
          </div>
        </div>
      </mat-card-header>
      <mat-card-content>
        <h5 class="review-title" *ngIf="review.title">{{ review.title }}</h5>
        <p class="review-comment">{{ review.comment }}</p>
      </mat-card-content>
    </mat-card>

    <!-- Pagination -->
    <mat-paginator *ngIf="totalReviews > pageSize"
      [length]="totalReviews"
      [pageSize]="pageSize"
      [pageSizeOptions]="[5, 10, 25]"
      [pageIndex]="pageIndex"
      (page)="onPageChange($event)">
    </mat-paginator>
  </div>
</div>
</file>

<file path="app/features/reviews/review-list/review-list.component.scss">
.review-section {
  margin-top: 40px;
  
  .section-title {
    font-size: 1.5em;
    margin-bottom: 20px;
  }
}

.review-summary {
  margin-bottom: 30px;
  
  .summary-content {
    display: grid;
    grid-template-columns: 1fr 2fr;
    gap: 40px;
    
    @media (max-width: 768px) {
      grid-template-columns: 1fr;
      gap: 20px;
    }
  }
  
  .average-rating {
    text-align: center;
    
    .rating-number {
      font-size: 3em;
      font-weight: 500;
      margin-bottom: 10px;
    }
    
    .total-reviews {
      margin-top: 10px;
      opacity: 0.7;
    }
  }
  
  .rating-distribution {
    .rating-bar {
      display: grid;
      grid-template-columns: 60px 1fr 40px;
      align-items: center;
      gap: 10px;
      margin-bottom: 8px;
      
      .rating-label {
        text-align: right;
        font-size: 0.9em;
        opacity: 0.7;
      }
      
      .bar-container {
        background-color: rgba(0,0,0,0.1);
        height: 8px;
        border-radius: 4px;
        overflow: hidden;
        
        .bar-fill {
          height: 100%;
          background-color: #ffc107;
          transition: width 0.3s;
        }
      }
      
      .rating-count {
        text-align: left;
        font-size: 0.9em;
        opacity: 0.7;
      }
    }
  }
}

.review-actions {
  margin: 20px 0;
  text-align: center;
}

.login-prompt {
  text-align: center;
  padding: 20px;
  background-color: rgba(0,0,0,0.02);
  border-radius: 8px;
  margin: 20px 0;
  
  p {
    margin-bottom: 10px;
    opacity: 0.7;
  }
}

.loading-indicator {
  text-align: center;
  padding: 40px;
}

.no-reviews {
  text-align: center;
  padding: 40px;
  opacity: 0.7;
  
  p {
    margin-bottom: 10px;
  }
}

.reviews-list {
  margin-top: 30px;
}

.review-card {
  margin-bottom: 20px;
  
  .review-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    width: 100%;
    
    .review-info {
      display: flex;
      flex-direction: column;
      gap: 5px;
      
      .reviewer-name {
        margin: 0;
        font-size: 1.1em;
        font-weight: 500;
      }
      
      .review-date {
        font-size: 0.85em;
        opacity: 0.7;
      }
    }
  }
  
  .review-title {
    font-size: 1.1em;
    font-weight: 500;
    margin-bottom: 10px;
  }
  
  .review-comment {
    line-height: 1.6;
    opacity: 0.87;
  }
}
</file>

<file path="app/features/reviews/review-list/review-list.component.ts">
// frontend/src/app/features/reviews/review-list/review-list.component.ts
import { Component, Input, OnInit, inject } from '@angular/core';
import { CommonModule } from '@angular/common';
import { MatCardModule } from '@angular/material/card';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { MatPaginatorModule, PageEvent } from '@angular/material/paginator';
import { MatDividerModule } from '@angular/material/divider';
import { MatDialog, MatDialogModule } from '@angular/material/dialog';
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar';

import { Review, ProductReviewSummary } from '../../../shared/models/review.model';
import { ReviewService } from '../review.service';
import { AuthService } from '../../../auth/auth.service';
import { StarRatingComponent } from '../../../shared/components/star-rating/star-rating.component';
import { ReviewFormDialogComponent } from '../review-form-dialog/review-form-dialog.component';

@Component({
  selector: 'app-review-list',
  standalone: true,
  imports: [
    CommonModule,
    MatCardModule,
    MatButtonModule,
    MatIconModule,
    MatProgressSpinnerModule,
    MatPaginatorModule,
    MatDividerModule,
    MatDialogModule,
    MatSnackBarModule,
    StarRatingComponent
  ],
  templateUrl: './review-list.component.html',
  styleUrls: ['./review-list.component.scss']
})
export class ReviewListComponent implements OnInit {
  @Input() productId!: number;
  
  reviews: Review[] = [];
  summary: ProductReviewSummary | null = null;
  myReview: Review | null = null;
  isLoading = true;
  
  // Pagination
  totalReviews = 0;
  pageSize = 10;
  pageIndex = 0;
  
  private reviewService = inject(ReviewService);
  public authService = inject(AuthService);
  private dialog = inject(MatDialog);
  private snackBar = inject(MatSnackBar);

  ngOnInit(): void {
    this.loadReviewSummary();
    this.loadReviews();
    if (this.authService.isLoggedIn()) {
      this.loadMyReview();
    }
  }

  loadReviewSummary(): void {
    this.reviewService.getProductReviewSummary(this.productId).subscribe({
      next: (summary) => {
        this.summary = summary;
      },
      error: (err) => {
        console.error('Error loading review summary:', err);
      }
    });
  }

  loadReviews(): void {
    this.isLoading = true;
    this.reviewService.getProductReviews(this.productId, this.pageIndex, this.pageSize).subscribe({
      next: (page) => {
        this.reviews = page.content;
        this.totalReviews = page.totalElements;
        this.isLoading = false;
      },
      error: (err) => {
        this.isLoading = false;
        console.error('Error loading reviews:', err);
      }
    });
  }

  loadMyReview(): void {
    this.reviewService.getMyReviewForProduct(this.productId).subscribe({
      next: (review) => {
        this.myReview = review;
      },
      error: (err) => {
        console.error('Error loading my review:', err);
      }
    });
  }

  openReviewDialog(): void {
    const dialogRef = this.dialog.open(ReviewFormDialogComponent, {
      width: '600px',
      data: {
        productId: this.productId,
        review: this.myReview
      }
    });

    dialogRef.afterClosed().subscribe(result => {
      if (result) {
        this.loadReviewSummary();
        this.loadReviews();
        this.loadMyReview();
      }
    });
  }

  deleteReview(review: Review): void {
    if (confirm('Sigur dorești să ștergi această recenzie?')) {
      this.reviewService.deleteReview(review.id!).subscribe({
        next: () => {
          this.snackBar.open('Recenzie ștearsă cu succes!', 'OK', { duration: 3000 });
          this.loadReviewSummary();
          this.loadReviews();
          if (review.userId === this.authService.getCurrentUser()?.id) {
            this.myReview = null;
          }
        },
        error: (err) => {
          this.snackBar.open('Eroare la ștergerea recenziei', 'Închide', { duration: 3000 });
        }
      });
    }
  }

  onPageChange(event: PageEvent): void {
    this.pageIndex = event.pageIndex;
    this.pageSize = event.pageSize;
    this.loadReviews();
  }

  canEditReview(review: Review): boolean {
    const currentUser = this.authService.getCurrentUser();
    return currentUser !== null && (review.userId === currentUser.id || this.authService.role === 'admin');
  }

  formatDate(dateString: string): string {
    return new Date(dateString).toLocaleDateString('ro-RO');
  }

  getRatingPercentage(rating: number): number {
    if (!this.summary || this.summary.totalReviews === 0) return 0;
    return (this.summary.ratingDistribution[rating] / this.summary.totalReviews) * 100;
  }
}
</file>

<file path="app/features/reviews/review.service.ts">
// frontend/src/app/features/reviews/review.service.ts
import { Injectable, inject } from '@angular/core';
import { HttpClient, HttpParams } from '@angular/common/http';
import { Observable } from 'rxjs';
import { Review, CreateReviewRequest, ProductReviewSummary, ReviewPage } from '../../shared/models/review.model';

@Injectable({
  providedIn: 'root'
})
export class ReviewService {
  private apiUrl = '/api/reviews';
  private http = inject(HttpClient);

  createReview(review: CreateReviewRequest): Observable<Review> {
    return this.http.post<Review>(this.apiUrl, review);
  }

  updateReview(reviewId: number, review: CreateReviewRequest): Observable<Review> {
    return this.http.put<Review>(`${this.apiUrl}/${reviewId}`, review);
  }

  deleteReview(reviewId: number): Observable<void> {
    return this.http.delete<void>(`${this.apiUrl}/${reviewId}`);
  }

  getProductReviews(productId: number, page: number = 0, size: number = 10): Observable<ReviewPage> {
    const params = new HttpParams()
      .set('page', page.toString())
      .set('size', size.toString());
    return this.http.get<ReviewPage>(`${this.apiUrl}/product/${productId}`, { params });
  }

  getProductReviewSummary(productId: number): Observable<ProductReviewSummary> {
    return this.http.get<ProductReviewSummary>(`${this.apiUrl}/product/${productId}/summary`);
  }

  getMyReviewForProduct(productId: number): Observable<Review | null> {
    return this.http.get<Review | null>(`${this.apiUrl}/product/${productId}/my-review`);
  }
  getUserReviews(): Observable<Review[]> {
  return this.http.get<Review[]>(`${this.apiUrl}/user/my-reviews`);
}
}
</file>

<file path="app/features/shopping-cart/cart.service.ts">
// frontend/src/app/features/shopping-cart/cart.service.ts
import { Injectable, inject } from '@angular/core';
import { HttpClient, HttpErrorResponse } from '@angular/common/http';
import { Observable, BehaviorSubject, throwError, of } from 'rxjs';
import { catchError, tap, map } from 'rxjs/operators';
import { Cart, CartItem, AddToCartRequest, UpdateCartItemRequest, CheckoutRequest } from '../../shared/models/cart.model';
import { Order } from '../../shared/models/order.model';

@Injectable({
  providedIn: 'root'
})
export class CartService {
  private apiUrl = '/api/cart';
  private cartSubject = new BehaviorSubject<Cart | null>(null);
  public cart$ = this.cartSubject.asObservable();

  private http = inject(HttpClient);

  loadCart(): Observable<Cart> {
    return this.http.get<Cart>(this.apiUrl).pipe(
      tap(cart => this.cartSubject.next(cart)),
      catchError(this.handleError)
    );
  }

  addToCart(request: AddToCartRequest): Observable<Cart> {
    return this.http.post<Cart>(`${this.apiUrl}/items`, request).pipe(
      tap(cart => this.cartSubject.next(cart)),
      catchError(this.handleError)
    );
  }

  updateCartItem(productId: number, request: UpdateCartItemRequest): Observable<Cart> {
    return this.http.put<Cart>(`${this.apiUrl}/items/${productId}`, request).pipe(
      tap(cart => this.cartSubject.next(cart)),
      catchError(this.handleError)
    );
  }

  removeFromCart(productId: number): Observable<Cart> {
    return this.http.delete<Cart>(`${this.apiUrl}/items/${productId}`).pipe(
      tap(cart => this.cartSubject.next(cart)),
      catchError(this.handleError)
    );
  }

  clearCart(): Observable<void> {
    return this.http.delete<void>(`${this.apiUrl}/clear`).pipe(
      tap(() => this.cartSubject.next(null)),
      catchError(this.handleError)
    );
  }

  checkout(request: CheckoutRequest): Observable<Order> {
    return this.http.post<Order>(`${this.apiUrl}/checkout`, request).pipe(
      tap(() => this.cartSubject.next(null)), // Clear local cart after checkout
      catchError(this.handleError)
    );
  }

  getCartItemCount(): Observable<number> {
    return this.cart$.pipe(
      map(cart => cart ? cart.totalItems : 0)
    );
  }

  getCartTotal(): Observable<number> {
    return this.cart$.pipe(
      map(cart => cart ? cart.totalAmount : 0)
    );
  }

  private handleError(error: HttpErrorResponse) {
    let errorMessage = 'A apărut o eroare la procesarea coșului.';
    if (error.error instanceof ErrorEvent) {
      errorMessage = `Eroare: ${error.error.message}`;
    } else {
      errorMessage = error.error?.message || `Cod eroare: ${error.status}`;
    }
    console.error('Cart service error:', error);
    return throwError(() => new Error(errorMessage));
  }
}
</file>

<file path="app/features/shopping-cart/shopping-cart.component.html">
<!-- frontend/src/app/features/shopping-cart/shopping-cart.component.html -->
<div class="shopping-cart-container">
  <h1 class="page-title">
    <mat-icon>shopping_cart</mat-icon>
    Coșul tău de cumpărături
  </h1>

  <div *ngIf="isLoading" class="loading-indicator">
    <mat-spinner diameter="50"></mat-spinner>
    <p>Se încarcă coșul...</p>
  </div>

  <div *ngIf="!isLoading && (!cart || cart.items.length === 0)" class="empty-cart">
    <mat-card>
      <mat-card-content>
        <mat-icon class="empty-icon">shopping_cart</mat-icon>
        <h2>Coșul tău este gol</h2>
        <p>Adaugă produse pentru a continua cumpărăturile.</p>
        <button mat-raised-button color="primary" (click)="continueShopping()">
          <mat-icon>storefront</mat-icon>
          Vezi produsele
        </button>
      </mat-card-content>
    </mat-card>
  </div>

  <div *ngIf="!isLoading && cart && cart.items.length > 0" class="cart-content">
    <div class="cart-items">
      <mat-card>
        <mat-card-header>
          <mat-card-title>Produse în coș ({{ cart.totalItems }})</mat-card-title>
          <button mat-button color="warn" (click)="clearCart()" [disabled]="isUpdating">
            <mat-icon>delete_sweep</mat-icon>
            Golește coșul
          </button>
        </mat-card-header>
        <mat-card-content>
          <div class="item-list">
            <div *ngFor="let item of cart.items" class="cart-item">
              <div class="item-image">
                <mat-icon *ngIf="!item.productImageBase64">inventory_2</mat-icon>
                <img *ngIf="item.productImageBase64" [src]="item.productImageBase64" [alt]="item.productName">
              </div>
              
              <div class="item-details">
                <h3>{{ item.productName }}</h3>
                <p class="item-description">{{ item.productDescription }}</p>
                <p class="item-stock" [class.low-stock]="item.productStock < 5">
                  Stoc disponibil: {{ item.productStock }} buc.
                </p>
              </div>

              <div class="item-quantity">
                <mat-form-field appearance="outline">
                  <mat-label>Cantitate</mat-label>
                  <input matInput type="number" 
                         [(ngModel)]="item.quantity" 
                         (blur)="updateQuantity(item, item.quantity)"
                         [disabled]="isUpdating && updatingItemId === item.productId"
                         min="1" 
                         [max]="item.productStock">
                </mat-form-field>
              </div>

              <div class="item-price">
                <p class="unit-price">{{ item.productPrice | currency:'RON':'symbol':'1.2-2' }}/buc</p>
                <p class="subtotal">{{ item.subtotal | currency:'RON':'symbol':'1.2-2' }}</p>
              </div>

              <div class="item-actions">
                <button mat-icon-button color="warn" 
                        (click)="removeItem(item.productId)"
                        [disabled]="isUpdating">
                  <mat-icon>delete</mat-icon>
                </button>
              </div>
            </div>
          </div>
        </mat-card-content>
      </mat-card>
    </div>

    <div class="cart-summary">
      <mat-card>
        <mat-card-header>
          <mat-card-title>Sumar comandă</mat-card-title>
        </mat-card-header>
        <mat-card-content>
          <div class="summary-row">
            <span>Subtotal ({{ cart.totalItems }} produse)</span>
            <span>{{ cart.totalAmount | currency:'RON':'symbol':'1.2-2' }}</span>
          </div>
          <div class="summary-row">
            <span>Transport</span>
            <span class="free-shipping">GRATUIT</span>
          </div>
          <mat-divider></mat-divider>
          <div class="summary-row total">
            <span>Total</span>
            <span>{{ cart.totalAmount | currency:'RON':'symbol':'1.2-2' }}</span>
          </div>
        </mat-card-content>
        <mat-card-actions>
          <button mat-raised-button color="primary" class="checkout-button" 
                  (click)="proceedToCheckout()"
                  [disabled]="isUpdating">
            <mat-icon>payment</mat-icon>
            Finalizează comanda
          </button>
          <button mat-stroked-button (click)="continueShopping()">
            <mat-icon>arrow_back</mat-icon>
            Continuă cumpărăturile
          </button>
        </mat-card-actions>
      </mat-card>
    </div>
  </div>
</div>
</file>

<file path="app/features/shopping-cart/shopping-cart.component.scss">
.shopping-cart-container {
  max-width: 1200px;
  margin: 0 auto;
  padding: 20px;
}

.page-title {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 30px;
  
  mat-icon {
    font-size: 32px;
    width: 32px;
    height: 32px;
  }
}

.loading-indicator {
  text-align: center;
  padding: 40px;
  
  mat-spinner {
    margin: 0 auto 20px;
  }
}

.empty-cart {
  mat-card {
    max-width: 500px;
    margin: 40px auto;
    text-align: center;
    padding: 40px;
  }
  
  .empty-icon {
    font-size: 80px;
    width: 80px;
    height: 80px;
    margin: 0 auto 20px;
    opacity: 0.3;
  }
  
  h2 {
    margin-bottom: 10px;
  }
  
  p {
    margin-bottom: 30px;
    opacity: 0.7;
  }
}

.cart-content {
  display: grid;
  grid-template-columns: 1fr 350px;
  gap: 20px;
  
  @media (max-width: 768px) {
    grid-template-columns: 1fr;
  }
}

.cart-items {
  mat-card-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
  }
}

.item-list {
  display: flex;
  flex-direction: column;
  gap: 20px;
}

.cart-item {
  display: grid;
  grid-template-columns: 100px 1fr 120px 150px 50px;
  gap: 15px;
  padding: 20px;
  border: 1px solid rgba(0,0,0,0.12);
  border-radius: 8px;
  background: rgba(0,0,0,0.02);
  align-items: center;
  
  @media (max-width: 768px) {
    grid-template-columns: 80px 1fr;
    gap: 10px;
    
    .item-quantity,
    .item-price,
    .item-actions {
      grid-column: 1 / -1;
    }
  }
  
  .item-image {
    width: 100px;
    height: 100px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: white;
    border: 1px solid rgba(0,0,0,0.12);
    border-radius: 4px;
    overflow: hidden;
    
    mat-icon {
      font-size: 40px;
      width: 40px;
      height: 40px;
      opacity: 0.3;
    }
    
    img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
  }
  
  .item-details {
    h3 {
      margin: 0 0 5px;
      font-size: 1.1em;
    }
    
    .item-description {
      margin: 0 0 5px;
      font-size: 0.9em;
      opacity: 0.7;
      overflow: hidden;
      text-overflow: ellipsis;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
    }
    
    .item-stock {
      margin: 0;
      font-size: 0.85em;
      color: #4CAF50;
      
      &.low-stock {
        color: #f44336;
      }
    }
  }
  
  .item-quantity {
    mat-form-field {
      width: 100px;
    }
  }
  
  .item-price {
    text-align: right;
    
    .unit-price {
      margin: 0 0 5px;
      font-size: 0.9em;
      opacity: 0.7;
    }
    
    .subtotal {
      margin: 0;
      font-size: 1.1em;
      font-weight: 500;
    }
  }
}

.cart-summary {
  position: sticky;
  top: 80px;
  
  mat-card-header {
    padding-bottom: 16px;
  }
  
  .summary-row {
    display: flex;
    justify-content: space-between;
    margin-bottom: 10px;
    
    &.total {
      margin-top: 16px;
      font-size: 1.2em;
      font-weight: 500;
    }
    
    .free-shipping {
      color: #4CAF50;
      font-weight: 500;
    }
  }
  
  mat-divider {
    margin: 16px 0;
  }
  
  mat-card-actions {
    flex-direction: column;
    padding: 16px;
    
    button {
      width: 100%;
      margin-bottom: 10px !important;
      
      &.checkout-button {
        padding: 12px;
        font-size: 1.1em;
      }
    }
  }
}
</file>

<file path="app/features/shopping-cart/shopping-cart.component.ts">
// frontend/src/app/features/shopping-cart/shopping-cart.component.ts
import { Component, OnInit, inject } from '@angular/core';
import { CommonModule, CurrencyPipe } from '@angular/common';
import { RouterModule, Router } from '@angular/router';
import { FormsModule } from '@angular/forms';
import { MatCardModule } from '@angular/material/card';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatDividerModule } from '@angular/material/divider';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar';
import { MatInputModule } from '@angular/material/input';
import { MatFormFieldModule } from '@angular/material/form-field';

import { Cart, CartItem } from '../../shared/models/cart.model';
import { CartService } from './cart.service';
import { AuthService } from '../../auth/auth.service';

@Component({
  selector: 'app-shopping-cart',
  standalone: true,
  imports: [
    CommonModule,
    RouterModule,
    FormsModule,
    CurrencyPipe,
    MatCardModule,
    MatButtonModule,
    MatIconModule,
    MatDividerModule,
    MatProgressSpinnerModule,
    MatSnackBarModule,
    MatInputModule,
    MatFormFieldModule
  ],
  templateUrl: './shopping-cart.component.html',
  styleUrls: ['./shopping-cart.component.scss']
})
export class ShoppingCartComponent implements OnInit {
  cart: Cart | null = null;
  isLoading = true;
  isUpdating = false;
  updatingItemId: number | null = null;

  private cartService = inject(CartService);
  private authService = inject(AuthService);
  private router = inject(Router);
  private snackBar = inject(MatSnackBar);

  ngOnInit(): void {
    if (!this.authService.isLoggedIn) {
      this.router.navigate(['/login'], { queryParams: { returnUrl: '/cart' } });
      return;
    }
    this.loadCart();
  }

  loadCart(): void {
    this.isLoading = true;
    this.cartService.loadCart().subscribe({
      next: (cart) => {
        this.cart = cart;
        this.isLoading = false;
      },
      error: (err) => {
        this.isLoading = false;
        this.snackBar.open('Eroare la încărcarea coșului', 'Închide', { duration: 3000 });
        console.error(err);
      }
    });
  }

  updateQuantity(item: CartItem, newQuantity: number): void {
    if (newQuantity < 1) return;
    if (newQuantity > item.productStock) {
      this.snackBar.open(`Stoc disponibil: ${item.productStock} buc.`, 'OK', { duration: 3000 });
      return;
    }

    this.isUpdating = true;
    this.updatingItemId = item.productId;
    
    this.cartService.updateCartItem(item.productId, { quantity: newQuantity }).subscribe({
      next: (cart) => {
        this.cart = cart;
        this.isUpdating = false;
        this.updatingItemId = null;
      },
      error: (err) => {
        this.isUpdating = false;
        this.updatingItemId = null;
        this.snackBar.open('Eroare la actualizarea cantității', 'Închide', { duration: 3000 });
        console.error(err);
      }
    });
  }

  removeItem(productId: number): void {
    this.isUpdating = true;
    this.cartService.removeFromCart(productId).subscribe({
      next: (cart) => {
        this.cart = cart;
        this.isUpdating = false;
        this.snackBar.open('Produs eliminat din coș', 'OK', { duration: 2000 });
      },
      error: (err) => {
        this.isUpdating = false;
        this.snackBar.open('Eroare la eliminarea produsului', 'Închide', { duration: 3000 });
        console.error(err);
      }
    });
  }

  clearCart(): void {
    if (confirm('Sigur doriți să goliți coșul?')) {
      this.isUpdating = true;
      this.cartService.clearCart().subscribe({
        next: () => {
          this.cart = null;
          this.isUpdating = false;
          this.snackBar.open('Coșul a fost golit', 'OK', { duration: 2000 });
        },
        error: (err) => {
          this.isUpdating = false;
          this.snackBar.open('Eroare la golirea coșului', 'Închide', { duration: 3000 });
          console.error(err);
        }
      });
    }
  }

  proceedToCheckout(): void {
    if (this.cart && this.cart.items.length > 0) {
      this.router.navigate(['/checkout']);
    }
  }

  continueShopping(): void {
    this.router.navigate(['/products-list']);
  }
}
</file>

<file path="app/features/user-dashboard/services/client-order.service.ts">
// src/app/features/user-dashboard/services/client-order.service.ts
import { Injectable, inject } from '@angular/core';
import { HttpClient, HttpErrorResponse } from '@angular/common/http';
import { Observable, throwError } from 'rxjs';
import { catchError } from 'rxjs/operators';
import { Order } from '../../../shared/models/order.model'; // Modelul partajat

/**
 * Serviciu pentru operațiunile clientului legate de comenzi
 * (plasare comandă, vizualizare istoric).
 */
@Injectable({
  providedIn: 'root'
})
export class ClientOrderService {
  // Endpoint-ul pentru comenzile clientului (plasare, istoric propriu)
  private ordersApiUrl = '/api/orders';

  private http = inject(HttpClient);

  /**
   * Plasează o nouă comandă.
   * @param orderData Obiectul Order ce conține detaliile comenzii.
   * @returns Un Observable care emite comanda creată.
   */
  placeOrder(orderData: Order): Observable<Order> {
    // Backend-ul se așteaptă la un OrderDto.
    // Asigură-te că orderData (construit în CheckoutComponent) respectă structura.
    return this.http.post<Order>(this.ordersApiUrl, orderData)
      .pipe(catchError(this.handleError));
  }

  /**
   * Preia istoricul comenzilor pentru utilizatorul autentificat.
   * Backend-ul folosește token-ul JWT pentru a identifica utilizatorul.
   * @returns Un Observable care emite un array cu comenzile utilizatorului.
   */
  getMyOrderHistory(): Observable<Order[]> {
    return this.http.get<Order[]>(`${this.ordersApiUrl}/my-history`)
      .pipe(catchError(this.handleError));
  }

  /**
   * Preia detaliile unei comenzi specifice din istoricul utilizatorului.
   * (Opțional, dacă backend-ul oferă un astfel de endpoint specific pentru 'my-history/:id')
   * Momentan, backend-ul pare să aibă doar GET /api/orders/{id} (admin) și GET /api/orders/my-history (user)
   * @param orderId ID-ul comenzii.
   * @returns Un Observable care emite comanda găsită.
   */
  // getMyOrderById(orderId: number): Observable<Order> {
  //   return this.http.get<Order>(`${this.ordersApiUrl}/my-history/${orderId}`) // Verifică endpoint-ul în backend
  //     .pipe(catchError(this.handleError));
  // }

  private handleError(error: HttpErrorResponse) {
    let errorMessage = 'A apărut o eroare la procesarea comenzii.';
    if (error.error instanceof ErrorEvent) {
      errorMessage = `Eroare client: ${error.error.message}`;
    } else {
      errorMessage = `Cod eroare server: ${error.status}, mesaj: ${error.error?.message || error.message}`;
    }
    console.error(errorMessage, error);
    return throwError(() => new Error(errorMessage));
  }
}
</file>

<file path="app/features/user-dashboard/user-dashboard.component.html">
<mat-sidenav-container class="user-dashboard-container">
  <mat-sidenav #sidenav mode="side" opened class="user-sidenav">
    <div class="sidenav-header">
      <mat-icon>account_circle</mat-icon>
      <h3>Salut, {{ authService.getCurrentUser()?.username || 'Client' }}!</h3>
    </div>
    <mat-nav-list>
      <a mat-list-item routerLink="/user/profile" routerLinkActive="active-link">
        <mat-icon matListItemIcon>person</mat-icon>
        <span matListItemTitle>Profilul Meu</span>
      </a>
      <a mat-list-item routerLink="/user/orders" routerLinkActive="active-link">
        <mat-icon matListItemIcon>history</mat-icon>
        <span matListItemTitle>Comenzile Mele</span>
      </a>
      <a mat-list-item routerLink="/products" routerLinkActive="active-link">
        <mat-icon matListItemIcon>storefront</mat-icon>
        <span matListItemTitle>Vezi Produse</span>
      </a>
      <mat-divider></mat-divider>
      <a mat-list-item (click)="authService.logout()">
        <mat-icon matListItemIcon>logout</mat-icon>
        <span matListItemTitle>Deconectare</span>
      </a>
    </mat-nav-list>
  </mat-sidenav>

  <mat-sidenav-content class="user-content">

    <div *ngIf="router.url === '/user' || router.url === '/user/'">

      <section class="hero-section">
        <div class="hero-overlay"></div>
        <div class="hero-content">
          <div class="text-content">
            <h1>Dive into immersive gaming</h1>
            <p>Feel every explosion, every step, and every sound detail with the new VipeX gaming headsets.</p>
            <button mat-flat-button color="primary">Buy now</button>
          </div>
        </div>
      </section>

      <section class="selection-section">
        <h2 class="section-title">Our selection</h2>

        <div *ngIf="isLoadingRecommendations" class="loading-indicator">
          <mat-spinner diameter="60"></mat-spinner>
        </div>

        <div class="product-grid" *ngIf="!isLoadingRecommendations && recommendedProducts.length > 0">
          <mat-card *ngFor="let product of recommendedProducts" class="product-card" [routerLink]="['/products', product.id]">
            
            <div class="product-image-container">
               <mat-icon>inventory_2</mat-icon>
            </div>
      
            <mat-card-header>
              <mat-card-title>{{ product.name }}</mat-card-title>
            </mat-card-header>
            <mat-card-content>
              <p class="product-price">{{ product.price | currency:'RON':'symbol':'1.2-2' }}</p>
            </mat-card-content>
            <mat-card-actions>
              <button mat-stroked-button color="primary" (click)="$event.stopPropagation()">Add to cart</button>
            </mat-card-actions>
          </mat-card>
        </div>
      </section>

      <section class="social-section">
        <h2 class="section-title">Be connected. Be VipeX.</h2>
        <div class="social-icons">
          <a href="#" class="social-icon-box">X</a>
          <a href="#" class="social-icon-box">O</a>
          <a href="#" class="social-icon-box">f</a>
          <a href="#" class="social-icon-box">B</a>
        </div>
      </section>
    </div>

    <router-outlet></router-outlet>
    
  </mat-sidenav-content>
</mat-sidenav-container>
</file>

<file path="app/features/user-dashboard/user-dashboard.component.scss">
.user-dashboard-container {
  height: calc(100vh - 64px); 
  display: flex;
}

.user-sidenav {
  width: 240px;
  border-right: 1px solid rgba(0,0,0,0.12);

  .sidenav-header {
    padding: 16px;
    border-bottom: 1px solid rgba(0,0,0,0.12);
    display: flex;
    align-items: center;
    gap: 10px;

    mat-icon {
      color: var(--mdc-theme-primary, #673ab7);
    }
    h3 {
      margin: 0;
      font-weight: 500;
    }
  }

  a[mat-list-item] {
    border-left: 4px solid transparent;
    transition: background-color 0.3s, border-left-color 0.3s;
    &:hover { 
      background-color: rgba(0,0,0,0.04); 
    }
    &.active-link {
      background-color: rgba(103, 58, 183, 0.1);
      border-left-color: var(--mdc-theme-primary, #673ab7);
      font-weight: 500;
      mat-icon { 
        color: var(--mdc-theme-primary, #673ab7); 
      }
    }
  }
}

:host ::ng-deep .mat-drawer-content {
  padding: 0;
  overflow: auto;
}

.user-content {
  flex: 1;
  overflow: auto;
}

.section-title {
  font-size: 2rem;
  font-weight: bold;
  margin-bottom: 40px;
  text-align: left;
}

.loading-indicator {
  display: flex;
  justify-content: center;
  padding: 40px;
}

/* Hero Section */
.hero-section {
  min-height: 60vh;
  padding: 40px;
  display: flex;
  align-items: center;
  position: relative;
  background: linear-gradient(135deg, rgba(0,0,0,0.05) 0%, rgba(0,0,0,0.1) 100%);
  
  .hero-overlay {
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    background: linear-gradient(to right, rgba(255,255,255,0.3) 30%, rgba(255,255,255,0.1) 60%, transparent 100%);
  }
  
  .hero-content {
    position: relative;
    z-index: 2;
    max-width: 1200px;
    margin: 0 auto;
    width: 100%;
    
    .text-content {
      max-width: 50%;
      h1 { 
        font-size: 3rem; 
        font-weight: bold; 
      }
      p { 
        font-size: 1.1rem; 
        line-height: 1.6; 
        margin: 20px 0 30px; 
      }
      button {
        padding: 10px 30px;
        font-size: 1rem;
        font-weight: bold;
      }
    }
  }
}

/* Products Section */
.selection-section {
  padding: 60px 40px;
}

.product-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
  gap: 30px;
}

.product-card {
  transition: transform 0.2s ease, box-shadow 0.2s ease;
  cursor: pointer;

  &:hover {
    transform: translateY(-8px);
    box-shadow: 0 8px 20px rgba(0,0,0,0.15);
  }

  .product-image-container {
    height: 200px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(0,0,0,0.05);
    mat-icon { 
      font-size: 60px; 
      width: 60px; 
      height: 60px; 
      opacity: 0.3;
    }
  }

  mat-card-header {
    justify-content: center;
    text-align: center;
  }
  
  mat-card-title {
    font-size: 1.1rem;
  }
  
  mat-card-content {
    text-align: center;
    .product-price { 
      font-size: 1.1rem; 
      font-weight: bold; 
      margin-top: 5px; 
    }
  }

  mat-card-actions {
    justify-content: center;
    padding: 0 16px 16px;
  }
}

/* Social Section */
.social-section {
  padding: 60px 40px;
  background-color: rgba(0,0,0,0.05);
  .social-icons {
    display: flex;
    justify-content: center;
    gap: 20px;
    .social-icon-box {
      width: 120px;
      height: 120px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 4rem;
      font-weight: bold;
      text-decoration: none;
      transition: background-color 0.2s;
      border: 2px solid currentColor;
      border-radius: 8px;
      &:hover { 
        background-color: rgba(0,0,0,0.05); 
      }
    }
  }
}
</file>

<file path="app/features/user-dashboard/user-dashboard.component.ts">
// src/app/features/user-dashboard/user-dashboard.component.ts
import { Component, OnInit, inject } from '@angular/core';
import { CommonModule, CurrencyPipe } from '@angular/common'; // CurrencyPipe pentru preț
import { Router, RouterModule, RouterOutlet } from '@angular/router'; // Router pentru a verifica URL-ul curent
import { MatSidenavModule } from '@angular/material/sidenav';
import { MatListModule } from '@angular/material/list';
import { MatIconModule } from '@angular/material/icon';
import { MatButtonModule } from '@angular/material/button';
import { MatCardModule } from '@angular/material/card'; // Pentru produsele recomandate
import { MatDividerModule } from '@angular/material/divider';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { AuthService } from '../../auth/auth.service';
import { Product } from '../../shared/models/product.model'; // Modelul de produs
import { ProductService } from '../products/product.service'; // Serviciul de produse

@Component({
  selector: 'app-user-dashboard',
  standalone: true,
  imports: [
    CommonModule,
    RouterModule,
    RouterOutlet,
    MatSidenavModule,
    MatListModule,
    MatIconModule,
    MatButtonModule,
    MatCardModule,
    MatDividerModule,
    CurrencyPipe,
    MatProgressSpinnerModule
  ],
  templateUrl: './user-dashboard.component.html',
  styleUrls: ['./user-dashboard.component.scss']
})
export class UserDashboardComponent implements OnInit {
  public authService = inject(AuthService); // Public pentru a fi accesibil în template
  public router = inject(Router); // Public pentru a verifica URL-ul
  private productService = inject(ProductService);

  recommendedProducts: Product[] = [];
  isLoadingRecommendations = false;

  ngOnInit(): void {
    this.loadRecommendedProducts();
  }

  loadRecommendedProducts(): void {
    this.isLoadingRecommendations = true;
    // Exemplu: preia primele câteva produse sau o listă specială de recomandări
    this.productService.getAll().subscribe({ // S-ar putea să vrei un endpoint dedicat pentru recomandări
      next: (products) => {
        this.recommendedProducts = products.slice(0, 4); // Afișează primele 4 ca exemplu
        this.isLoadingRecommendations = false;
      },
      error: (err) => {
        console.error('Eroare la încărcarea produselor recomandate:', err);
        this.isLoadingRecommendations = false;
      }
    });
  }
}
</file>

<file path="app/features/user-dashboard/user-order-history/user-order-history.component.html">
<!-- src/app/features/user-dashboard/user-order-history/user-order-history.component.html -->
<div class="user-order-history-container">
  <div class="header">
    <h2>Comenzile Mele</h2>
  </div>

  <div *ngIf="isLoading" class="loading-indicator">
    <mat-spinner diameter="50"></mat-spinner>
    <p>Se încarcă istoricul comenzilor...</p>
  </div>

  <div *ngIf="error && !isLoading" class="error-message">
    <p>{{ error }}</p>
    <button mat-stroked-button color="warn" (click)="loadOrderHistory()">Reîncearcă</button>
  </div>

  <div *ngIf="!isLoading && !error && orders.length === 0" class="no-data">
    <p>Nu ai plasat nicio comandă încă.</p>
    <button mat-flat-button color="primary" routerLink="/products">Vezi Produse</button>
  </div>

  <mat-accordion multi="true" *ngIf="!isLoading && !error && orders.length > 0" class="order-accordion">
    <mat-expansion-panel *ngFor="let order of orders; let i = index"
                         (opened)="panelOpenState[i] = true"
                         (closed)="panelOpenState[i] = false"
                         class="order-panel">
      <mat-expansion-panel-header>
        <mat-panel-title>
          Comanda #{{ order.id }} - {{ order.orderDate | date:'dd/MM/yyyy' }}
        </mat-panel-title>
        <mat-panel-description fxLayoutAlign="space-between center">
          <span>Total: {{ order.totalAmount | currency:'RON':'symbol':'1.2-2' }}</span>
          <mat-chip-listbox aria-label="Status comandă">
            <mat-chip selected [ngClass]="'status-chip-' + order.status.toLowerCase().replace('_', '-')">
                {{ formatStatus(order.status) }}
            </mat-chip>
          </mat-chip-listbox>
        </mat-panel-description>
      </mat-expansion-panel-header>

      <div class="order-details-content">
        <h4>Detalii Comandă:</h4>
        <p><strong>Data plasării:</strong> {{ order.orderDate | date:'dd/MM/yyyy HH:mm:ss' }}</p>
        <p><strong>Nume client (livrare):</strong> {{ order.customerName }}</p>
        <p><strong>Adresă livrare:</strong> {{ order.shippingAddress }}</p>
        <p><strong>Email contact:</strong> {{ order.customerEmail }}</p>
        <p><strong>Telefon contact:</strong> {{ order.customerPhone }}</p>

        <mat-divider></mat-divider>
        <h4>Articole Comandate:</h4>
        <mat-list role="list" class="order-items-list">
          <mat-list-item *ngFor="let item of order.orderItems" role="listitem" class="order-item-detail">
            <!-- Secțiunea Imagine Articol - COMENTATĂ TEMPORAR -->
            <!--
            <img matListItemAvatar *ngIf="item.productImageBase64Snapshot" [src]="item.productImageBase64Snapshot" [alt]="item.productNameSnapshot" class="item-image-small">
            <mat-icon matListItemAvatar *ngIf="!item.productImageBase64Snapshot">inventory_2</mat-icon>
            -->
            <mat-icon matListItemAvatar>inventory_2</mat-icon> <!-- Placeholder generic -->

            <span matListItemTitle>{{ item.productNameSnapshot }} (ID: {{ item.productId }})</span>
            <span matListItemLine>
              Cantitate: {{ item.quantity }} x {{ item.priceAtPurchase | currency:'RON':'symbol':'1.2-2' }}
            </span>
            <span matListItemMeta class="item-subtotal-small">
              Subtotal: {{ calculateItemSubtotal(item) | currency:'RON':'symbol':'1.2-2' }}
            </span>
          </mat-list-item>
        </mat-list>
      </div>
    </mat-expansion-panel>
  </mat-accordion>
</div>
</file>

<file path="app/features/user-dashboard/user-order-history/user-order-history.component.scss">
.user-order-history-container {
  padding: 20px;
  max-width: 900px;
  margin: auto;
}

.header {
  margin-bottom: 20px;
  h2 {
    margin: 0;
    font-size: 1.8em;
  }
}

.loading-indicator,
.error-message,
.no-data {
  text-align: center;
  padding: 20px;
  margin-top: 20px;
  mat-spinner {
    margin: 0 auto 10px auto;
  }
  button[mat-flat-button] {
    margin-top: 15px;
  }
}

.order-accordion {
  margin-top: 10px;
}

.order-panel {
  margin-bottom: 16px;
  border-radius: 8px !important;
  box-shadow: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24);
  // Remove dark background

  &:first-child {
      border-top-left-radius: 8px;
      border-top-right-radius: 8px;
  }
   &:last-child {
      border-bottom-left-radius: 8px;
      border-bottom-right-radius: 8px;
  }

  mat-expansion-panel-header {
    font-size: 1.05em;
  }

  mat-panel-description {
    justify-content: space-between;
    align-items: center;
    font-size: 0.95em;
    mat-chip-listbox {
        transform: scale(0.9);
    }
  }
}

.status-chip-pending_confirmation { 
  background-color: #FFC107 !important; 
  color: #000 !important; 
}
.status-chip-approved { 
  background-color: #2196F3 !important; 
  color: #fff !important; 
}
.status-chip-processing { 
  background-color: #9C27B0 !important; 
  color: #fff !important; 
}
.status-chip-shipped { 
  background-color: #00BCD4 !important; 
  color: #fff !important; 
}
.status-chip-delivered { 
  background-color: #4CAF50 !important; 
  color: #fff !important; 
}
.status-chip-canceled { 
  background-color: #f44336 !important; 
  color: #fff !important; 
}

.order-details-content {
  padding: 16px 24px 24px 24px;

  h4 {
    margin-top: 16px;
    margin-bottom: 8px;
    font-size: 1.1em;
    font-weight: 500;
  }
  &:first-of-type h4 {
      margin-top: 0;
  }

  p {
    margin-bottom: 6px;
    line-height: 1.5;
    strong {
      font-weight: 500;
      opacity: 0.7;
    }
  }
  mat-divider {
    margin: 16px 0;
  }
}

.order-items-list {
  padding-top: 0;
  .order-item-detail {
    border-bottom: 1px dotted rgba(0,0,0,0.12);
    padding: 8px 0 !important;

    &:last-child {
      border-bottom: none;
    }
  }
  .item-subtotal-small {
    font-weight: 500;
    font-size: 0.9em;
  }
}
</file>

<file path="app/features/user-dashboard/user-order-history/user-order-history.component.ts">
// src/app/features/user-dashboard/user-order-history/user-order-history.component.ts
import { Component, OnInit, inject } from '@angular/core';
import { CommonModule, DatePipe, CurrencyPipe } from '@angular/common';
import { RouterModule } from '@angular/router';
import { MatCardModule } from '@angular/material/card';
import { MatListModule } from '@angular/material/list';
import { MatDividerModule } from '@angular/material/divider';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar';
import { MatExpansionModule } from '@angular/material/expansion';
import { MatIconModule } from '@angular/material/icon';
import { MatChipsModule } from '@angular/material/chips';
import { HttpErrorResponse } from '@angular/common/http';


import { Order } from '../../../shared/models/order.model';
import { OrderItem } from '../../../shared/models/order-item.model'; // <<< CORECTAT
import { ClientOrderService } from '../services/client-order.service';

@Component({
  selector: 'app-user-order-history',
  standalone: true,
  imports: [
    CommonModule,
    RouterModule,
    MatCardModule,
    MatListModule,
    MatDividerModule,
    MatProgressSpinnerModule,
    MatSnackBarModule,
    MatExpansionModule,
    MatIconModule,
    MatChipsModule,
    DatePipe,
    CurrencyPipe
  ],
  templateUrl: './user-order-history.component.html',
  styleUrls: ['./user-order-history.component.scss']
})
export class UserOrderHistoryComponent implements OnInit {
  orders: Order[] = [];
  isLoading = true;
  error: string | null = null;
  panelOpenState: boolean[] = [];

  private clientOrderService = inject(ClientOrderService);
  private snackBar = inject(MatSnackBar);

  ngOnInit(): void {
    this.loadOrderHistory();
  }

  loadOrderHistory(): void {
    this.isLoading = true;
    this.error = null;
    this.clientOrderService.getMyOrderHistory().subscribe({
      next: (data: Order[]) => { // Tipare explicită
        this.orders = data.sort((a, b) => new Date(b.orderDate!).getTime() - new Date(a.orderDate!).getTime());
        this.panelOpenState = new Array(this.orders.length).fill(false);
        this.isLoading = false;
      },
      error: (err: HttpErrorResponse) => { // Tipare explicită
        this.error = 'Nu s-a putut încărca istoricul comenzilor.';
        const errMsg = err.error?.message || err.message || 'Eroare necunoscută.';
        console.error('Eroare la încărcarea istoricului comenzilor:', err);
        this.isLoading = false;
        this.snackBar.open(`${this.error} ${errMsg}`, 'Închide', { duration: 5000 });
      }
    });
  }

  formatStatus(status: string): string {
    if (!status) return '';
    return status.replace(/_/g, ' ').toLowerCase().replace(/\b\w/g, l => l.toUpperCase());
  }

  calculateItemSubtotal(item: OrderItem): number {
    return (item.priceAtPurchase || 0) * item.quantity;
  }

  togglePanel(index: number): void {
    this.panelOpenState[index] = !this.panelOpenState[index];
  }
}
</file>

<file path="app/features/user-profile/user-profile.component.html">
<!-- frontend/src/app/features/user-profile/user-profile.component.html -->
<div class="user-profile-container">
  <div class="profile-header">
    <h1>Profilul Meu</h1>
    <button mat-stroked-button routerLink="/products-list">
      <mat-icon>arrow_back</mat-icon>
      Înapoi la produse
    </button>
  </div>

  <div *ngIf="isLoading" class="loading-container">
    <mat-spinner diameter="50"></mat-spinner>
    <p>Se încarcă profilul...</p>
  </div>

  <mat-tab-group *ngIf="!isLoading" animationDuration="300ms">
    <!-- Profile Information Tab -->
    <mat-tab label="Informații Profil">
      <div class="tab-content">
        <mat-card class="profile-card">
          <mat-card-header>
            <div class="profile-avatar-section">
              <div class="avatar-placeholder">
                <mat-icon>account_circle</mat-icon>
              </div>
              <div class="profile-header-info">
                <mat-card-title>{{ user?.username }}</mat-card-title>
                <mat-card-subtitle>Membru din {{ formatDate('2024-01-01') }}</mat-card-subtitle>
              </div>
            </div>
            <button mat-icon-button (click)="toggleEditMode()" *ngIf="!isEditMode">
              <mat-icon>edit</mat-icon>
            </button>
          </mat-card-header>

          <mat-card-content>
            <form [formGroup]="profileForm">
              <div class="profile-section">
                <h3>Informații de bază</h3>
                <mat-divider></mat-divider>
                
                <div class="form-grid">
                  <mat-form-field appearance="outline">
                    <mat-label>Nume utilizator</mat-label>
                    <input matInput formControlName="username" readonly>
                    <mat-icon matSuffix>person</mat-icon>
                  </mat-form-field>

                  <mat-form-field appearance="outline">
                    <mat-label>Email</mat-label>
                    <input matInput type="email" formControlName="email" [readonly]="!isEditMode">
                    <mat-icon matSuffix>email</mat-icon>
                    <mat-error *ngIf="profileForm.get('email')?.errors?.['email']">
                      Email invalid
                    </mat-error>
                  </mat-form-field>

                  <mat-form-field appearance="outline">
                    <mat-label>Nume complet</mat-label>
                    <input matInput formControlName="fullName" [readonly]="!isEditMode" placeholder="Adaugă numele complet">
                    <mat-icon matSuffix>badge</mat-icon>
                  </mat-form-field>

                  <mat-form-field appearance="outline">
                    <mat-label>Telefon</mat-label>
                    <input matInput formControlName="phone" [readonly]="!isEditMode" placeholder="Adaugă număr de telefon">
                    <mat-icon matSuffix>phone</mat-icon>
                  </mat-form-field>
                </div>

                <mat-form-field appearance="outline" class="full-width">
                  <mat-label>Adresă</mat-label>
                  <textarea matInput formControlName="address" rows="3" [readonly]="!isEditMode" placeholder="Adaugă adresa de livrare"></textarea>
                  <mat-icon matSuffix>location_on</mat-icon>
                </mat-form-field>
              </div>

              <div class="profile-section">
                <h3>Preferințe cont</h3>
                <mat-divider></mat-divider>
                
                <div class="preferences-grid">
                  <div class="preference-item">
                    <mat-icon>security</mat-icon>
                    <div>
                      <h4>Securitate</h4>
                      <p>Autentificare în doi pași: <strong>Dezactivată</strong></p>
                    </div>
                  </div>
                  
                  <div class="preference-item">
                    <mat-icon>notifications</mat-icon>
                    <div>
                      <h4>Notificări</h4>
                      <p>Primește notificări email: <strong>Activat</strong></p>
                    </div>
                  </div>

                  <div class="preference-item">
                    <mat-icon>language</mat-icon>
                    <div>
                      <h4>Limbă</h4>
                      <p>Limba preferată: <strong>Română</strong></p>
                    </div>
                  </div>
                </div>
              </div>
            </form>

            <div class="action-buttons" *ngIf="isEditMode">
              <button mat-stroked-button (click)="toggleEditMode()">
                <mat-icon>cancel</mat-icon>
                Anulează
              </button>
              <button mat-raised-button color="primary" (click)="saveProfile()" [disabled]="profileForm.invalid">
                <mat-icon>save</mat-icon>
                Salvează modificările
              </button>
            </div>
          </mat-card-content>
        </mat-card>
      </div>
    </mat-tab>

    <!-- Reviews Tab -->
    <mat-tab label="Recenziile mele">
      <div class="tab-content">
        <mat-card class="reviews-summary-card">
          <mat-card-content>
            <div class="reviews-stats">
              <div class="stat-item">
                <h3>{{ totalReviews }}</h3>
                <p>Total recenzii</p>
              </div>
              <div class="stat-item">
                <h3>{{ averageRating.toFixed(1) }}</h3>
                <p>Rating mediu acordat</p>
                <app-star-rating [rating]="averageRating" [readonly]="true" [showHalf]="true"></app-star-rating>
              </div>
            </div>
          </mat-card-content>
        </mat-card>

        <div *ngIf="isLoadingReviews" class="loading-container">
          <mat-spinner diameter="40"></mat-spinner>
          <p>Se încarcă recenziile...</p>
        </div>

        <div *ngIf="!isLoadingReviews && userReviews.length === 0" class="no-reviews">
          <mat-icon>rate_review</mat-icon>
          <p>Nu ai scris încă nicio recenzie</p>
          <button mat-raised-button color="primary" routerLink="/products-list">
            Explorează produsele
          </button>
        </div>

        <div class="reviews-list" *ngIf="!isLoadingReviews && userReviews.length > 0">
          <mat-card *ngFor="let review of userReviews" class="review-card">
            <mat-card-header>
              <mat-card-title>{{ review.productName }}</mat-card-title>
              <mat-card-subtitle>
                <app-star-rating [rating]="review.rating" [readonly]="true"></app-star-rating>
                <span class="review-date">{{ formatDate(review.createdAt) }}</span>
              </mat-card-subtitle>
            </mat-card-header>
            <mat-card-content>
              <h4 *ngIf="review.title" class="review-title">{{ review.title }}</h4>
              <p class="review-comment">{{ review.comment || 'Fără comentariu' }}</p>
            </mat-card-content>
            <mat-card-actions>
              <button mat-button [routerLink]="['/products', review.productId]">
                <mat-icon>visibility</mat-icon>
                Vezi produsul
              </button>
              <button mat-button color="primary">
                <mat-icon>edit</mat-icon>
                Editează
              </button>
              <button mat-button color="warn">
                <mat-icon>delete</mat-icon>
                Șterge
              </button>
            </mat-card-actions>
          </mat-card>
        </div>
      </div>
    </mat-tab>

    <!-- Orders Tab (Optional) -->
    <mat-tab label="Comenzile mele">
      <div class="tab-content">
        <div class="orders-placeholder">
          <mat-icon>shopping_bag</mat-icon>
          <p>Pentru a vedea comenzile tale, accesează</p>
          <button mat-raised-button color="primary" routerLink="/my-orders">
            <mat-icon>history</mat-icon>
            Istoric comenzi
          </button>
        </div>
      </div>
    </mat-tab>
  </mat-tab-group>
</div>
</file>

<file path="app/features/user-profile/user-profile.component.scss">
.user-profile-container {
  max-width: 1200px;
  margin: 0 auto;
  padding: 20px;
  min-height: calc(100vh - 64px);
}

.profile-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 30px;

  h1 {
    margin: 0;
    font-size: 2em;
  }

  button {
    mat-icon {
      margin-right: 8px;
    }
  }
}

.loading-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 400px;

  p {
    margin-top: 20px;
  }
}

::ng-deep .mat-mdc-tab-group {
  background-color: transparent;

  .mat-mdc-tab-label {
    font-weight: 500;

    &.mat-mdc-tab-label-active {
      color: var(--mdc-theme-primary, #673ab7);
    }
  }

  .mat-ink-bar {
    background-color: var(--mdc-theme-primary, #673ab7);
  }
}

.tab-content {
  padding: 24px 0;
}

// Profile Card Styles
.profile-card {
  // Remove dark background
  
  mat-card-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 24px;
  }

  .profile-avatar-section {
    display: flex;
    align-items: center;
    gap: 20px;

    .avatar-placeholder {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background-color: rgba(0,0,0,0.1);
      display: flex;
      align-items: center;
      justify-content: center;
      border: 3px solid var(--mdc-theme-primary, #673ab7);

      mat-icon {
        font-size: 48px;
        width: 48px;
        height: 48px;
        color: var(--mdc-theme-primary, #673ab7);
      }
    }

    .profile-header-info {
      mat-card-title {
        font-size: 1.5em;
        margin-bottom: 4px;
      }

      mat-card-subtitle {
        opacity: 0.7;
      }
    }
  }
}

.profile-section {
  margin-bottom: 32px;

  h3 {
    color: var(--mdc-theme-primary, #673ab7);
    margin-bottom: 16px;
    font-size: 1.2em;
  }

  mat-divider {
    margin-bottom: 24px;
  }
}

.form-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: 16px;
  margin-bottom: 16px;
}

.full-width {
  width: 100%;
}

.preferences-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: 20px;
  margin-top: 20px;

  .preference-item {
    display: flex;
    align-items: flex-start;
    gap: 16px;
    padding: 16px;
    background-color: rgba(0,0,0,0.04);
    border-radius: 8px;

    mat-icon {
      color: var(--mdc-theme-primary, #673ab7);
      margin-top: 4px;
    }

    h4 {
      margin: 0 0 4px 0;
      font-size: 1em;
    }

    p {
      margin: 0;
      font-size: 0.9em;
      opacity: 0.7;

      strong {
        color: #4CAF50;
      }
    }
  }
}

.action-buttons {
  display: flex;
  justify-content: flex-end;
  gap: 12px;
  margin-top: 24px;
  padding-top: 24px;
  border-top: 1px solid rgba(0,0,0,0.12);

  button {
    mat-icon {
      margin-right: 8px;
    }
  }
}

// Reviews Section Styles
.reviews-summary-card {
  // Remove dark background
  margin-bottom: 24px;

  .reviews-stats {
    display: flex;
    justify-content: space-around;
    align-items: center;
    padding: 20px 0;

    .stat-item {
      text-align: center;

      h3 {
        margin: 0 0 8px 0;
        font-size: 2.5em;
        color: var(--mdc-theme-primary, #673ab7);
        font-weight: 500;
      }

      p {
        margin: 0 0 8px 0;
        font-size: 1.1em;
        opacity: 0.7;
      }
    }
  }
}

.no-reviews {
  text-align: center;
  padding: 60px 20px;

  mat-icon {
    font-size: 80px;
    width: 80px;
    height: 80px;
    margin: 0 auto 20px;
    opacity: 0.3;
  }

  p {
    font-size: 1.2em;
    margin-bottom: 20px;
    opacity: 0.7;
  }
}

.reviews-list {
  display: grid;
  gap: 16px;
}

.review-card {
  // Remove dark background
  
  mat-card-header {
    mat-card-title {
      color: var(--mdc-theme-primary, #673ab7);
      font-size: 1.1em;
    }

    mat-card-subtitle {
      display: flex;
      align-items: center;
      gap: 16px;
      margin-top: 8px;

      .review-date {
        font-size: 0.9em;
        opacity: 0.7;
      }
    }
  }

  mat-card-content {
    .review-title {
      margin: 16px 0 8px 0;
      font-size: 1.05em;
    }

    .review-comment {
      line-height: 1.6;
      margin: 0;
      opacity: 0.87;
    }
  }

  mat-card-actions {
    button {
      mat-icon {
        margin-right: 4px;
        font-size: 20px;
      }
    }
  }
}

.orders-placeholder {
  text-align: center;
  padding: 80px 20px;

  mat-icon {
    font-size: 80px;
    width: 80px;
    height: 80px;
    margin: 0 auto 20px;
    opacity: 0.3;
  }

  p {
    font-size: 1.1em;
    margin-bottom: 20px;
    opacity: 0.7;
  }

  button {
    mat-icon {
      margin-right: 8px;
    }
  }
}

// Responsive styles
@media (max-width: 768px) {
  .profile-header {
    flex-direction: column;
    align-items: stretch;
    gap: 16px;

    button {
      width: 100%;
    }
  }

  .form-grid {
    grid-template-columns: 1fr;
  }

  .preferences-grid {
    grid-template-columns: 1fr;
  }

  .reviews-stats {
    flex-direction: column;
    gap: 24px;
  }
}
</file>

<file path="app/features/user-profile/user-profile.component.ts">
// frontend/src/app/features/user-profile/user-profile.component.ts
import { Component, OnInit, inject } from '@angular/core';
import { CommonModule } from '@angular/common';
import { Router, RouterModule } from '@angular/router';
import { MatCardModule } from '@angular/material/card';
import { MatTabsModule } from '@angular/material/tabs';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatDividerModule } from '@angular/material/divider';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar';
import { MatChipsModule } from '@angular/material/chips';
import { MatDialogModule } from '@angular/material/dialog';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { ReactiveFormsModule, FormBuilder, FormGroup, Validators } from '@angular/forms';

import { AuthService } from '../../auth/auth.service';
import { ReviewService } from '../reviews/review.service';
import { UserProfileService } from './user-profile.service'; // New service
import { User } from '../../shared/models/user.model';
import { Review } from '../../shared/models/review.model';
import { StarRatingComponent } from '../../shared/components/star-rating/star-rating.component';

@Component({
  selector: 'app-user-profile',
  standalone: true,
  imports: [
    CommonModule,
    RouterModule,
    ReactiveFormsModule,
    MatCardModule,
    MatTabsModule,
    MatButtonModule,
    MatIconModule,
    MatDividerModule,
    MatProgressSpinnerModule,
    MatSnackBarModule,
    MatChipsModule,
    MatDialogModule,
    MatFormFieldModule,
    MatInputModule,
    StarRatingComponent
  ],
  templateUrl: './user-profile.component.html',
  styleUrls: ['./user-profile.component.scss']
})
export class UserProfileComponent implements OnInit {
  user: User | null = null;
  userReviews: Review[] = [];
  isLoading = true;
  isLoadingReviews = true;
  isEditMode = false;
  profileForm!: FormGroup;
  totalReviews = 0;
  averageRating = 0;

  private authService = inject(AuthService);
  private reviewService = inject(ReviewService);
  private userProfileService = inject(UserProfileService); // Use new service
  private snackBar = inject(MatSnackBar);
  private fb = inject(FormBuilder);
  private router = inject(Router);

  ngOnInit(): void {
    if (!this.authService.isLoggedIn()) {
      this.snackBar.open('Sesiunea a expirat. Te rugăm să te autentifici din nou.', 'OK', { duration: 3000 });
      this.router.navigate(['/login'], { queryParams: { returnUrl: '/my-profile' } });
      return;
    }
    
    this.initializeForm();
    this.loadUserProfile();
    this.loadUserReviews();
  }

  initializeForm(): void {
    this.profileForm = this.fb.group({
      username: [{ value: '', disabled: true }],
      email: ['', [Validators.required, Validators.email]],
      fullName: [''],
      phone: [''],
      address: ['']
    });
  }

  loadUserProfile(): void {
    this.isLoading = true;
    
    // Use the new service to get profile data
    this.userProfileService.getMyProfile().subscribe({
      next: (user) => {
        this.user = user;
        this.profileForm.patchValue({
          username: user.username,
          email: user.email
        });
        this.isLoading = false;
      },
      error: (err) => {
        this.isLoading = false;
        
        // Check if it's an authentication error
        if (err.message.includes('Sesiunea a expirat')) {
          this.snackBar.open(err.message, 'Login', { duration: 5000 })
            .onAction().subscribe(() => {
              this.router.navigate(['/login'], { queryParams: { returnUrl: '/my-profile' } });
            });
        } else {
          // For other errors, use cached data if available
          const cachedUser = this.authService.getCurrentUser();
          if (cachedUser) {
            this.user = cachedUser;
            this.profileForm.patchValue({
              username: cachedUser.username,
              email: cachedUser.email
            });
            this.snackBar.open('Folosind datele din cache. Reconectează-te pentru date actualizate.', 'OK', { duration: 3000 });
          } else {
            this.snackBar.open(err.message, 'Închide', { duration: 5000 });
            this.router.navigate(['/']);
          }
        }
      }
    });
  }

  loadUserReviews(): void {
    this.isLoadingReviews = true;
    this.reviewService.getUserReviews().subscribe({
      next: (reviews) => {
        this.userReviews = reviews;
        this.calculateReviewStats();
        this.isLoadingReviews = false;
      },
      error: (err) => {
        this.isLoadingReviews = false;
        console.error('Error loading reviews:', err);
        this.userReviews = [];
        this.calculateReviewStats();
      }
    });
  }

  calculateReviewStats(): void {
    this.totalReviews = this.userReviews.length;
    if (this.totalReviews > 0) {
      const totalRating = this.userReviews.reduce((sum, review) => sum + review.rating, 0);
      this.averageRating = totalRating / this.totalReviews;
    }
  }

  toggleEditMode(): void {
    this.isEditMode = !this.isEditMode;
    if (!this.isEditMode) {
      this.loadUserProfile();
    }
  }

  saveProfile(): void {
    if (this.profileForm.invalid || !this.user) return;

    const updatedData = {
      email: this.profileForm.get('email')?.value,
      roles: undefined // Don't send roles for own profile update
    };

    this.userProfileService.updateMyProfile(updatedData).subscribe({
      next: () => {
        this.snackBar.open('Profil actualizat cu succes!', 'OK', { duration: 3000 });
        this.isEditMode = false;
        this.loadUserProfile();
      },
      error: (err) => {
        this.snackBar.open(err.message || 'Eroare la actualizarea profilului', 'Închide', { duration: 5000 });
      }
    });
  }

  formatDate(dateString: string): string {
    return new Date(dateString).toLocaleDateString('ro-RO', {
      year: 'numeric',
      month: 'long',
      day: 'numeric'
    });
  }
}
</file>

<file path="app/features/user-profile/user-profile.service.ts">
// frontend/src/app/features/user-profile/user-profile.service.ts
import { Injectable, inject } from '@angular/core';
import { HttpClient, HttpErrorResponse } from '@angular/common/http';
import { Observable, throwError } from 'rxjs';
import { catchError } from 'rxjs/operators';
import { User, UserUpdateDto } from '../../shared/models/user.model';

@Injectable({
  providedIn: 'root'
})
export class UserProfileService {
  private apiUrl = '/api/users';
  private http = inject(HttpClient);

  getMyProfile(): Observable<User> {
    return this.http.get<User>(`${this.apiUrl}/me`)
      .pipe(catchError(this.handleError));
  }

  updateMyProfile(userData: UserUpdateDto): Observable<User> {
    return this.http.put<User>(`${this.apiUrl}/me`, userData)
      .pipe(catchError(this.handleError));
  }

  private handleError(error: HttpErrorResponse) {
    let userFriendlyErrorMessage = 'A apărut o problemă. Vă rugăm încercați din nou mai târziu.';
    
    if (error.error && typeof error.error === 'object' && error.error !== null) {
      if (error.error.fieldErrors) {
        const fieldErrors = error.error.fieldErrors;
        const errorMessages = Object.entries(fieldErrors)
          .map(([field, message]) => `${field}: ${message}`)
          .join(', ');
        userFriendlyErrorMessage = `Erori de validare: ${errorMessages}`;
      } else {
        userFriendlyErrorMessage = error.error.message || userFriendlyErrorMessage;
      }
    } else if (typeof error.error === 'string') {
      userFriendlyErrorMessage = error.error;
    } else if (error.message) {
      if (error.status === 0 || error.status === -1) {
        userFriendlyErrorMessage = 'Eroare de conexiune cu serverul.';
      } else if (error.status === 401) {
        userFriendlyErrorMessage = 'Sesiunea a expirat. Te rugăm să te autentifici din nou.';
      } else {
        userFriendlyErrorMessage = `A apărut o eroare (${error.status}): ${error.statusText}`;
      }
    }

    console.error('User Profile Service Error:', error);
    return throwError(() => new Error(userFriendlyErrorMessage));
  }
}
</file>

<file path="app/login/login.component.html">
<!-- src/app/login/login.component.html -->
<div class="login-container">
  <mat-card class="login-card">
    <mat-card-header>
      <mat-card-title>Autentificare</mat-card-title>
      <mat-card-subtitle>Intră în contul tău</mat-card-subtitle>
    </mat-card-header>
    <mat-card-content>
      <form [formGroup]="loginForm" (ngSubmit)="onSubmit()">
        <mat-form-field appearance="outline" class="full-width">
          <mat-label>Nume de Utilizator</mat-label>
          <input matInput formControlName="username" placeholder="Ex: ion.popescu" required>
          <mat-icon matSuffix>person_outline</mat-icon>
          <mat-error *ngIf="f['username'].hasError('required')">
            Numele de utilizator este obligatoriu.
          </mat-error>
          <mat-error *ngIf="f['username'].hasError('minlength')">
            Numele de utilizator trebuie să aibă cel puțin 3 caractere.
          </mat-error>
        </mat-form-field>

        <mat-form-field appearance="outline" class="full-width">
          <mat-label>Parolă</mat-label>
          <input matInput [type]="hidePassword ? 'password' : 'text'" formControlName="password" required>
          <button mat-icon-button matSuffix (click)="togglePasswordVisibility()" type="button" [attr.aria-label]="'Ascunde/Arată parola'" [attr.aria-pressed]="hidePassword">
            <mat-icon>{{hidePassword ? 'visibility_off' : 'visibility'}}</mat-icon>
          </button>
          <mat-error *ngIf="f['password'].hasError('required')">
            Parola este obligatorie.
          </mat-error>
          <mat-error *ngIf="f['password'].hasError('minlength')">
            Parola trebuie să aibă cel puțin 6 caractere.
          </mat-error>
        </mat-form-field>
           <mat-checkbox formControlName="rememberMe" class="remember-me-checkbox">
             Ține-mă minte
           </mat-checkbox>
        <button mat-raised-button color="primary" type="submit" class="full-width login-button" [disabled]="isLoading || loginForm.invalid">
          <mat-spinner *ngIf="isLoading" diameter="20" mode="indeterminate" class="button-spinner"></mat-spinner>
          <span *ngIf="!isLoading">Intră în Cont</span>
        </button>
      </form>
    </mat-card-content>
    <mat-card-actions class="login-card-actions-center"> <!-- Am adăugat o clasă pentru centrare CSS -->
      <p class="signup-link">
        Nu ai cont? <a routerLink="/signup">Înregistrează-te aici!</a>
      </p>
    </mat-card-actions>
  </mat-card>
</div>
</file>

<file path="app/login/login.component.scss">
.login-container {
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: calc(100vh - 128px); 
  padding: 20px;
}

.login-card {
  width: 100%;
  max-width: 400px;
  padding: 20px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  border-radius: 8px;
  // Remove dark background - let Material theme handle it
}

mat-card-header {
  text-align: center;
  padding-bottom: 20px;
  mat-card-title {
    font-size: 1.8em;
  }
  mat-card-subtitle {
    font-size: 1em;
    opacity: 0.7;
  }
}

.full-width {
  width: 100%;
  margin-bottom: 18px;
}

.remember-me-checkbox {
  margin-bottom: 20px;
  display: block;
}

.login-button {
  padding: 10px 0;
  font-size: 1.05em;
  display: flex;
  align-items: center;
  justify-content: center;

  .button-spinner {
    margin-right: 8px;
  }
}

.login-card-actions-center {
  display: flex;
  justify-content: center;
  margin-top: 16px;
  padding-top: 16px;
  border-top: 1px solid rgba(0,0,0,0.12);
}

.signup-link {
  text-align: center;
  font-size: 0.9em;
  opacity: 0.7;
  a {
    color: var(--mdc-theme-primary, #673ab7);
    text-decoration: none;
    font-weight: 500;
    &:hover {
      text-decoration: underline;
    }
  }
}

mat-form-field .mat-icon-button[matSuffix] {
  display: flex;
  align-items: center;
  justify-content: center;
}
</file>

<file path="app/login/login.component.ts">
import { registerables } from 'chart.js';
// src/app/login/login.component.ts
import { Component, OnInit, inject } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ReactiveFormsModule, FormBuilder, FormGroup, Validators } from '@angular/forms';
import { Router, RouterModule, ActivatedRoute } from '@angular/router'; // ActivatedRoute pentru returnUrl
import { MatCardModule } from '@angular/material/card';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { MatCheckboxModule } from '@angular/material/checkbox'; 

import { AuthService } from '../auth/auth.service'; // Serviciul de autentificare

@Component({
  selector: 'app-login',
  standalone: true,
  imports: [
    CommonModule,
    RouterModule, // Pentru link-ul de înregistrare
    ReactiveFormsModule,
    MatCardModule,
    MatFormFieldModule,
    MatInputModule,
    MatButtonModule,
    MatIconModule,
    MatSnackBarModule,
    MatProgressSpinnerModule,
    MatCheckboxModule
  ],
  templateUrl: './login.component.html',
  styleUrls: ['./login.component.scss']
})
export class LoginComponent implements OnInit {
  loginForm!: FormGroup;
  isLoading = false;
  hidePassword = true;
  private returnUrl: string = '/'; // Default redirect URL

  private fb = inject(FormBuilder);
  public authService = inject(AuthService); // Public pentru a fi accesibil în template (ex: pentru link signup)
  private router = inject(Router);
  private route = inject(ActivatedRoute); // Pentru a prelua returnUrl
  private snackBar = inject(MatSnackBar);

  ngOnInit(): void {
    this.loginForm = this.fb.group({
      username: ['', [Validators.required, Validators.minLength(3)]],
      password: ['', [Validators.required, Validators.minLength(6)]],
      rememberMe: [false]
    });

    // Preia URL-ul de redirectare din query params, dacă există
    this.returnUrl = this.route.snapshot.queryParams['returnUrl'] || '/';

    // Dacă utilizatorul este deja logat, redirecționează-l
    if (this.authService.isLoggedIn()) {
        const userRole = this.authService.role;
        if (userRole === 'admin') {
            this.router.navigate(['/admin']);
        } else if (userRole === 'user') {
            this.router.navigate(['/user']);
        } else {
            this.router.navigate([this.returnUrl]); // Sau o pagină default
        }
    }
  }

  onSubmit(): void {
    if (this.loginForm.invalid) {
      this.snackBar.open('Nume de utilizator sau parolă invalidă.', 'OK', { duration: 3000 });
      this.loginForm.markAllAsTouched();
      return;
    }

    this.isLoading = true;
    const { username, password, rememberMe } = this.loginForm.value;

    this.authService.login(username, password, rememberMe).subscribe({
      next: (success) => {
        this.isLoading = false;
        if (success) {
          this.snackBar.open('Autentificare reușită!', 'OK', { duration: 2000 });
          const userRole = this.authService.role; // Preia rolul după login reușit
          
          // Redirecționează în funcție de rol sau la returnUrl
          if (this.returnUrl && this.returnUrl !== '/') {
            this.router.navigateByUrl(this.returnUrl);
          } else if (userRole === 'admin') {
            this.router.navigate(['/admin']);
          } else if (userRole === 'user') {
            this.router.navigate(['/user']);
          } else {
            this.router.navigate(['/']); // Fallback la pagina principală
          }
        } else {
          // AuthService gestionează deja afișarea erorii prin snackbar în cazul în care login-ul eșuează
          // dar putem adăuga un mesaj generic aici dacă metoda login returnează doar boolean
          // this.snackBar.open('Autentificare eșuată. Verificați credențialele.', 'Închide', { duration: 3000 });
        }
      },
      error: (err) => {
        // AuthService ar trebui să gestioneze eroarea și să afișeze un snackbar
        // Dacă nu, o facem aici.
        this.isLoading = false;
        const errorMessage = err.error?.message || err.message || 'Autentificare eșuată. Vă rugăm încercați din nou.';
        this.snackBar.open(errorMessage, 'Închide', { duration: 5000 });
        console.error('Login error:', err);
      }
    });
  }

  togglePasswordVisibility(): void {
    this.hidePassword = !this.hidePassword;
  }

  get f() { return this.loginForm.controls; }
}
</file>

<file path="app/shared/components/star-rating/star-rating.component.ts">
// frontend/src/app/shared/components/star-rating/star-rating.component.ts
import { Component, Input, Output, EventEmitter } from '@angular/core';
import { CommonModule } from '@angular/common';
import { MatIconModule } from '@angular/material/icon';

@Component({
  selector: 'app-star-rating',
  standalone: true,
  imports: [CommonModule, MatIconModule],
  template: `
    <div class="star-rating" [class.readonly]="readonly">
      <mat-icon 
        *ngFor="let star of stars; let i = index"
        [class.filled]="i < displayRating"
        [class.half-filled]="showHalf && i === Math.floor(displayRating) && displayRating % 1 !== 0"
        (click)="!readonly && rate(i + 1)"
        (mouseenter)="!readonly && setHoverRating(i + 1)"
        (mouseleave)="!readonly && clearHoverRating()">
        {{ getStarIcon(i) }}
      </mat-icon>
      <span class="rating-text" *ngIf="showText">
        {{ displayRating.toFixed(1) }} / 5.0
        <span *ngIf="reviewCount !== undefined"> ({{ reviewCount }} {{ reviewCount === 1 ? 'recenzie' : 'recenzii' }})</span>
      </span>
    </div>
  `,
  styles: [`
    .star-rating {
      display: inline-flex;
      align-items: center;
      gap: 2px;
      
      &.readonly {
        pointer-events: none;
      }
      
      mat-icon {
        color: #ddd;
        font-size: 24px;
        width: 24px;
        height: 24px;
        cursor: pointer;
        transition: color 0.2s;
        
        &.filled {
          color: #ffc107;
        }
        
        &.half-filled {
          position: relative;
          
          &::after {
            content: 'star_half';
            position: absolute;
            left: 0;
            color: #ffc107;
          }
        }
        
        &:hover {
          transform: scale(1.1);
        }
      }
      
      .rating-text {
        margin-left: 8px;
        color: #666;
        font-size: 0.9em;
      }
    }
    
    :host-context(.readonly) mat-icon {
      cursor: default;
      
      &:hover {
        transform: none;
      }
    }
  `]
})
export class StarRatingComponent {
  @Input() rating: number = 0;
  @Input() readonly: boolean = false;
  @Input() showText: boolean = false;
  @Input() showHalf: boolean = true;
  @Input() reviewCount?: number;
  @Output() ratingChange = new EventEmitter<number>();

  stars: number[] = [1, 2, 3, 4, 5];
  hoverRating: number = 0;
  Math = Math;

  get displayRating(): number {
    return this.hoverRating || this.rating;
  }

  rate(rating: number): void {
    if (!this.readonly) {
      this.rating = rating;
      this.ratingChange.emit(rating);
    }
  }

  setHoverRating(rating: number): void {
    if (!this.readonly) {
      this.hoverRating = rating;
    }
  }

  clearHoverRating(): void {
    this.hoverRating = 0;
  }

  getStarIcon(index: number): string {
    const rating = this.displayRating;
    if (index < Math.floor(rating)) {
      return 'star';
    } else if (this.showHalf && index === Math.floor(rating) && rating % 1 >= 0.5) {
      return 'star_half';
    } else {
      return 'star_border';
    }
  }
}
</file>

<file path="app/shared/in-memory-data.service.ts">
// src/app/shared/in-memory-data.service.ts
import { Injectable } from '@angular/core';
import { InMemoryDbService, RequestInfo } from 'angular-in-memory-web-api';
import { Observable } from 'rxjs';
import { Product } from './models/product.model'; // Asigură-te că modelul Product e corect
// Importă și alte modele dacă vrei să le mock-uiești (Category, etc.)

@Injectable({
  providedIn: 'root'
})
export class InMemoryDataService implements InMemoryDbService {
  createDb(reqInfo?: RequestInfo): {} | Observable<{}> | Promise<{}> {
    const products: Product[] = [
      // Date mock pentru produse (folosește modelul Product actualizat)
      {
        id: 1,
        name: 'Laptop Gaming X1',
        description: 'Un laptop puternic pentru jocuri și sarcini intensive.',
        price: 5500.99,
        stockQuantity: 15,
        categoryId: 1, // Presupunând că există o categorie cu ID 1
        categoryName: 'Laptopuri',
        imageBase64: null, // Sau un string base64 valid
        specifications: [
          { definitionId: 1, name: 'Procesor', value: 'Intel Core i7-12700H', unit: '' },
          { definitionId: 2, name: 'RAM', value: '16', unit: 'GB' },
          { definitionId: 3, name: 'Stocare SSD', value: '1', unit: 'TB' }
        ]
      },
      {
        id: 2,
        name: 'Monitor LED UltraWide',
        description: 'Monitor curbat pentru o experiență vizuală imersivă.',
        price: 1800.00,
        stockQuantity: 25,
        categoryId: 2, // Presupunând că există o categorie cu ID 2
        categoryName: 'Monitoare',
        imageBase64: null,
        specifications: [
          { definitionId: 4, name: 'Diagonală', value: '34', unit: 'inch' },
          { definitionId: 5, name: 'Rezoluție', value: '3440x1440', unit: 'pixeli' }
        ]
      },
      // Adaugă mai multe produse mock aici
    ];

    const categories = [
        { id: 1, name: 'Laptopuri', description: 'Portabile performante'},
        { id: 2, name: 'Monitoare', description: 'Display-uri pentru PC'},
        { id: 3, name: 'Componente PC', description: 'Piese pentru asamblare PC'}
    ];

    const specificationDefinitions = [
        {id: 1, name: 'Procesor', unit: ''},
        {id: 2, name: 'RAM', unit: 'GB'},
        {id: 3, name: 'Stocare SSD', unit: 'TB'},
        {id: 4, name: 'Diagonală', unit: 'inch'},
        {id: 5, name: 'Rezoluție', unit: 'pixeli'},
        {id: 6, name: 'Tip Placă Video', unit: ''},
    ];


    // Returnează un obiect cu colecțiile tale. Numele proprietăților
    // (ex: 'products') vor fi folosite ca segmente de URL pentru API-ul mock.
    return { products, categories, specificationDefinitions /* , alteColecții */ };
  }

  // Suprascrie genId pentru a te asigura că un produs nou primește un ID.
  // Dacă colecția este goală, această metodă returnează numărul inițial (11).
  // Dacă colecția nu este goală, metoda returnează cel mai mare ID + 1.
  genId<T extends { id?: number }>(collection: T[], collectionName: string): number {
    // Verifică dacă `id` este definit și este un număr pentru fiecare element
    const validIds = collection.map(item => item.id).filter(id => typeof id === 'number') as number[];
    return validIds.length > 0 ? Math.max(...validIds) + 1 : 1;
  }
}
</file>

<file path="app/shared/material.module.ts">
// src/app/shared/material.module.ts
import { NgModule } from '@angular/core';
import { MatButtonModule } from '@angular/material/button';
import { MatCardModule } from '@angular/material/card';
import { MatCheckboxModule } from '@angular/material/checkbox';
import { MatChipsModule } from '@angular/material/chips';
import { MatDialogModule } from '@angular/material/dialog';
import { MatDividerModule } from '@angular/material/divider';
import { MatExpansionModule } from '@angular/material/expansion';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatIconModule } from '@angular/material/icon';
import { MatInputModule } from '@angular/material/input';
import { MatListModule } from '@angular/material/list';
import { MatMenuModule } from '@angular/material/menu';
import { MatPaginatorModule } from '@angular/material/paginator';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { MatSelectModule } from '@angular/material/select';
import { MatSidenavModule } from '@angular/material/sidenav';
import { MatSnackBarModule } from '@angular/material/snack-bar';
import { MatSortModule } from '@angular/material/sort';
import { MatTableModule } from '@angular/material/table';
import { MatToolbarModule } from '@angular/material/toolbar';
import { MatTooltipModule } from '@angular/material/tooltip'; // Util pentru hint-uri

const materialModules = [
  MatButtonModule,
  MatCardModule,
  MatCheckboxModule,
  MatChipsModule,
  MatDialogModule,
  MatDividerModule,
  MatExpansionModule,
  MatFormFieldModule,
  MatIconModule,
  MatInputModule,
  MatListModule,
  MatMenuModule,
  MatPaginatorModule,
  MatProgressSpinnerModule,
  MatSelectModule,
  MatSidenavModule,
  MatSnackBarModule,
  MatSortModule,
  MatTableModule,
  MatToolbarModule,
  MatTooltipModule,
];

@NgModule({
  imports: materialModules,
  exports: materialModules
})
export class MaterialModule { }
</file>

<file path="app/shared/models/cart.model.ts">
// frontend/src/app/shared/models/cart.model.ts
export interface Cart {
  id?: number;
  items: CartItem[];
  totalAmount: number;
  lastUpdated?: string;
  totalItems: number;
}

export interface CartItem {
  id?: number;
  productId: number;
  productName: string;
  productDescription?: string;
  productPrice: number;
  productStock: number;
  productImageBase64?: string;
  quantity: number;
  subtotal: number;
}

export interface AddToCartRequest {
  productId: number;
  quantity: number;
}

export interface UpdateCartItemRequest {
  quantity: number;
}

export interface CheckoutRequest {
  fullName: string;
  email: string;
  phone: string;
  billingAddress: string;
  shippingAddress?: string;
  paymentMethod: 'CARD' | 'CASH_ON_DELIVERY' | 'BANK_TRANSFER';
  orderNotes?: string;
  agreeToTerms: boolean;
}
</file>

<file path="app/shared/models/category.model.ts">
export interface Category {
  id?: number;
  name: string;
  description?: string;
}
</file>

<file path="app/shared/models/order-item.model.ts">
// src/app/shared/models/order-item.model.ts

export interface OrderItem {
  id?: number;
  productId: number;
  productNameSnapshot?: string;         // Corect
  //productImageBase64Snapshot?: string;  // Corect
  quantity: number;
  priceAtPurchase?: number;
  lineTotal?: number;
}
</file>

<file path="app/shared/models/order-status-update.model.ts">
export interface OrderStatusUpdate {
  newStatus: string;
}
</file>

<file path="app/shared/models/order.model.ts">
// src/app/shared/models/order.model.ts
import { OrderItem } from './order-item.model'; // <<< CORECTAT: Importă OrderItem

/**
 * Interfață pentru reprezentarea unei comenzi,
 * aliniată cu OrderDto din backend.
 */
export interface Order {
  id?: number;
  userId?: number;
  username?: string;
  orderDate?: string;
  status: string;
  totalAmount?: number;
  customerName: string;
  shippingAddress: string;
  customerEmail: string;
  customerPhone: string;
  orderItems: OrderItem[]; // Acum OrderItem este cunoscut
}
</file>

<file path="app/shared/models/product.model.ts">
import { SpecificationValue } from "./specification-value.model";

export interface Product {
  id?: number;
  name: string;
  description?: string;
  price: number;
  stockQuantity: number;
 // imageBase64?: string | null;
  categoryId: number;
  categoryName?: string;
  specifications?: SpecificationValue[];
  averageRating?: number;
  reviewCount?: number;
}

export type { SpecificationValue };
</file>

<file path="app/shared/models/report.model.ts">
export interface SalesReport {
  totalSales: number;
  totalRevenue: number;
  periodStart: Date;
  periodEnd: Date;
  dailySales: DailySales[];
  topSellingProducts: ProductSales[];
  categorySales: CategorySales[];
}

export interface DailySales {
  date: string;
  salesCount: number;
  revenue: number;
}

export interface ProductSales {
  productId: number;
  productName: string;
  category: string;
  quantitySold: number;
  revenue: number;
  currentStock: number;
}

export interface CategorySales {
  category: string;
  quantitySold: number;
  revenue: number;
}

export interface StockReport {
  totalProducts: number;
  totalStockValue: number;
  lowStockProducts: StockItem[];
  outOfStockProducts: StockItem[];
  categoryStock: CategoryStock[];
}

export interface StockItem {
  productId: number;
  productName: string;
  category: string;
  currentStock: number;
  price: number;
  stockValue: number;
}

export interface CategoryStock {
  category: string;
  totalProducts: number;
  totalStock: number;
  stockValue: number;
}

export interface UserReport {
  totalUsers: number;
  activeUsers: number;
  newUsersThisMonth: number;
  usersByRole: UserRoleCount[];
  recentRegistrations: UserInfo[];
}

export interface UserRoleCount {
  role: string;
  count: number;
}

export interface UserInfo {
  id: number;
  username: string;
  email: string;
  registrationDate: Date;
  lastLoginDate: Date;
  isActive: boolean;
}

export interface GeneralReport {
  generatedAt: Date;
  reportPeriod: ReportPeriod;
  salesReport: SalesReport;
  stockReport: StockReport;
  userReport: UserReport;
}

export interface ReportPeriod {
  startDate: Date;
  endDate: Date;
  type: 'daily' | 'weekly' | 'monthly' | 'yearly' | 'custom';
}
</file>

<file path="app/shared/models/review.model.ts">
// frontend/src/app/shared/models/review.model.ts
export interface Review {
  id?: number;
  productId: number;
  productName?: string;
  userId: number;
  username: string;
  rating: number;
  title?: string;
  comment?: string;
  createdAt: string;
  updatedAt?: string;
}

export interface CreateReviewRequest {
  productId: number;
  rating: number;
  title?: string;
  comment?: string;
}

export interface ProductReviewSummary {
  averageRating: number;
  totalReviews: number;
  ratingDistribution: { [key: number]: number };
}

export interface ReviewPage {
  content: Review[];
  totalElements: number;
  totalPages: number;
  size: number;
  number: number;
}
</file>

<file path="app/shared/models/specification-definition.model.ts">
export interface SpecificationDefinition {
  id: number;
  name: string;
  unit?: string;
}
</file>

<file path="app/shared/models/specification-value.model.ts">
export interface SpecificationValue {
  definitionId?: number;
  name?: string;
  value: string;
  unit?: string;
}
</file>

<file path="app/shared/models/user.model.ts">
export interface User {
  id: number;
  username: string;
  email: string;
  roles: string[];
}

export interface UserUpdateDto {
  email: string;
  roles?: string[];
}

// Ar putea fi util să ai și un model pentru răspunsul JWT de la login
export interface JwtResponse {
    token: string;
    type?: string; // Usually 'Bearer'
    id: number;
    username: string;
    email: string;
    roles: string[];
}

// Model pentru LoginRequest (dacă vrei să-l typezi explicit în AuthService)
export interface LoginRequest {
    username?: string; // Optional dacă folosești un DTO mai generic
    password?: string;
}

// Model pentru SignupRequest (dacă vrei să-l typezi explicit în AuthService/SignupComponent)
export interface SignupRequest {
    username?: string;
    email?: string;
    password?: string;
    role?: string[]; // Poate fi un set de roluri la înregistrare
}
</file>

<file path="app/shared/pipes/nl2br.pipe.ts">
// src/app/shared/pipes/nl2br.pipe.ts
import { Pipe, PipeTransform } from '@angular/core';
import { DomSanitizer, SafeHtml } from '@angular/platform-browser';

@Pipe({
  name: 'nl2br',
  standalone: true // Fă-l standalone pentru importare ușoară
})
export class Nl2brPipe implements PipeTransform {
  constructor(private sanitizer: DomSanitizer) {}

  transform(value: string | null | undefined): SafeHtml {
    if (value === null || value === undefined) {
      return '';
    }
    // Înlocuiește secvențele de linie nouă (\n, \r\n, \r) cu <br />
    // și sanitizează HTML-ul rezultat pentru securitate.
    return this.sanitizer.bypassSecurityTrustHtml(value.replace(/(\r\n|\n|\r)/gm, '<br />'));
  }
}
</file>

<file path="app/signup/signup.component.html">
<div class="signup-container">
  <mat-card class="signup-card">
    <mat-card-header>
      <mat-card-title>Înregistrare</mat-card-title>
      <mat-card-subtitle>Creează un cont nou</mat-card-subtitle>
    </mat-card-header>
    <mat-card-content>
      <form [formGroup]="signupForm" (ngSubmit)="onSubmit()">
        <mat-form-field appearance="outline" class="full-width">
          <mat-label>Nume de Utilizator</mat-label>
          <input matInput formControlName="username" placeholder="Ex: ion.popescu" required>
          <mat-icon matSuffix>person_outline</mat-icon>
          <mat-error *ngIf="f['username'].hasError('required')">
            Numele de utilizator este obligatoriu.
          </mat-error>
          <mat-error *ngIf="f['username'].hasError('minlength')">
            Minim 3 caractere.
          </mat-error>
          <mat-error *ngIf="f['username'].hasError('maxlength')">
            Maxim 20 de caractere.
          </mat-error>
        </mat-form-field>

        <mat-form-field appearance="outline" class="full-width">
          <mat-label>Adresă Email</mat-label>
          <input matInput type="email" formControlName="email" placeholder="email@example.com" required>
          <mat-icon matSuffix>email</mat-icon>
          <mat-error *ngIf="f['email'].hasError('required')">
            Email-ul este obligatoriu.
          </mat-error>
          <mat-error *ngIf="f['email'].hasError('email')">
            Format email invalid.
          </mat-error>
          <mat-error *ngIf="f['email'].hasError('maxlength')">
            Maxim 50 de caractere.
          </mat-error>
        </mat-form-field>

        <mat-form-field appearance="outline" class="full-width">
          <mat-label>Parolă</mat-label>
          <input matInput [type]="hidePassword ? 'password' : 'text'" formControlName="password" required>
          <button mat-icon-button matSuffix (click)="togglePasswordVisibility()" type="button" 
                  [attr.aria-label]="'Ascunde/Arată parola'" [attr.aria-pressed]="hidePassword">
            <mat-icon>{{hidePassword ? 'visibility_off' : 'visibility'}}</mat-icon>
          </button>
          <mat-error *ngIf="f['password'].hasError('required')">
            Parola este obligatorie.
          </mat-error>
          <mat-error *ngIf="f['password'].hasError('minlength')">
            Minim 6 caractere.
          </mat-error>
          <mat-error *ngIf="f['password'].hasError('maxlength')">
            Maxim 40 de caractere.
          </mat-error>
        </mat-form-field>

        <mat-form-field appearance="outline" class="full-width">
          <mat-label>Confirmă Parola</mat-label>
          <input matInput [type]="hideConfirmPassword ? 'password' : 'text'" formControlName="confirmPassword" required>
          <button mat-icon-button matSuffix (click)="toggleConfirmPasswordVisibility()" type="button"
                  [attr.aria-label]="'Ascunde/Arată parola'" [attr.aria-pressed]="hideConfirmPassword">
            <mat-icon>{{hideConfirmPassword ? 'visibility_off' : 'visibility'}}</mat-icon>
          </button>
          <mat-error *ngIf="f['confirmPassword'].hasError('required')">
            Confirmarea parolei este obligatorie.
          </mat-error>
          <mat-error *ngIf="f['confirmPassword'].hasError('passwordMismatch')">
            Parolele nu se potrivesc.
          </mat-error>
        </mat-form-field>

        <button mat-raised-button color="primary" type="submit" class="full-width signup-button" 
                [disabled]="isLoading || signupForm.invalid">
          <mat-spinner *ngIf="isLoading" diameter="20" mode="indeterminate" class="button-spinner"></mat-spinner>
          <span *ngIf="!isLoading">Creează Cont</span>
        </button>
      </form>
    </mat-card-content>
    <mat-card-actions class="signup-card-actions-center">
      <p class="login-link">
        Ai deja un cont? <a routerLink="/login">Autentifică-te aici!</a>
      </p>
    </mat-card-actions>
  </mat-card>
</div>
</file>

<file path="app/signup/signup.component.scss">
.signup-container {
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: calc(100vh - 128px);
  padding: 20px;
}

.signup-card {
  width: 100%;
  max-width: 450px;
  padding: 20px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  border-radius: 8px;
  // Remove dark background
}

mat-card-header {
  text-align: center;
  padding-bottom: 20px;
  mat-card-title {
    font-size: 1.8em;
  }
  mat-card-subtitle {
    font-size: 1em;
    opacity: 0.7;
  }
}

.full-width {
  width: 100%;
  margin-bottom: 18px;
}

.signup-button {
  padding: 10px 0;
  font-size: 1.05em;
  display: flex;
  align-items: center;
  justify-content: center;
  margin-top: 10px;

  .button-spinner {
    margin-right: 8px;
  }
}

.signup-card-actions-center {
  display: flex;
  justify-content: center;
  margin-top: 16px;
  padding-top: 16px;
  border-top: 1px solid rgba(0,0,0,0.12);
}

.login-link {
  text-align: center;
  font-size: 0.9em;
  opacity: 0.7;
  a {
    color: var(--mdc-theme-primary, #673ab7);
    text-decoration: none;
    font-weight: 500;
    &:hover {
      text-decoration: underline;
    }
  }
}

mat-form-field .mat-icon-button[matSuffix] {
  display: flex;
  align-items: center;
  justify-content: center;
}

::ng-deep .mat-mdc-form-field-error {
  font-size: 0.85em;
}
</file>

<file path="app/signup/signup.component.ts">
import { Component, OnInit, inject } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ReactiveFormsModule, FormBuilder, FormGroup, Validators, AbstractControl } from '@angular/forms';
import { Router, RouterModule } from '@angular/router';
import { MatCardModule } from '@angular/material/card';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';

import { AuthService } from '../auth/auth.service';
import { SignupRequest } from '../shared/models/user.model';

@Component({
  selector: 'app-signup',
  standalone: true,
  imports: [
    CommonModule,
    RouterModule,
    ReactiveFormsModule,
    MatCardModule,
    MatFormFieldModule,
    MatInputModule,
    MatButtonModule,
    MatIconModule,
    MatSnackBarModule,
    MatProgressSpinnerModule
  ],
  templateUrl: './signup.component.html',
  styleUrls: ['./signup.component.scss']
})
export class SignupComponent implements OnInit {
  signupForm!: FormGroup;
  isLoading = false;
  hidePassword = true;
  hideConfirmPassword = true;

  private fb = inject(FormBuilder);
  private authService = inject(AuthService);
  private router = inject(Router);
  private snackBar = inject(MatSnackBar);

  ngOnInit(): void {
    this.signupForm = this.fb.group({
      username: ['', [Validators.required, Validators.minLength(3), Validators.maxLength(20)]],
      email: ['', [Validators.required, Validators.email, Validators.maxLength(50)]],
      password: ['', [Validators.required, Validators.minLength(6), Validators.maxLength(40)]],
      confirmPassword: ['', [Validators.required]]
    }, { validators: this.passwordMatchValidator });

    // Dacă utilizatorul este deja logat, redirecționează
    if (this.authService.isLoggedIn()) {
      const userRole = this.authService.role;
      if (userRole === 'admin') {
        this.router.navigate(['/admin']);
      } else {
        this.router.navigate(['/']);
      }
    }
  }

  // Custom validator pentru verificarea potrivirii parolelor
  passwordMatchValidator(control: AbstractControl): {[key: string]: boolean} | null {
    const password = control.get('password');
    const confirmPassword = control.get('confirmPassword');
    
    if (!password || !confirmPassword) {
      return null;
    }
    
    if (password.value !== confirmPassword.value) {
      confirmPassword.setErrors({ passwordMismatch: true });
      return { passwordMismatch: true };
    } else {
      // Dacă parolele se potrivesc, eliminăm eroarea passwordMismatch
      const errors = confirmPassword.errors;
      if (errors) {
        delete errors['passwordMismatch'];
        // Dacă nu mai sunt alte erori, setăm errors la null
        if (Object.keys(errors).length === 0) {
          confirmPassword.setErrors(null);
        }
      }
      return null;
    }
  }

  onSubmit(): void {
    if (this.signupForm.invalid) {
      this.snackBar.open('Vă rugăm completați corect toate câmpurile.', 'OK', { duration: 3000 });
      this.signupForm.markAllAsTouched();
      return;
    }

    this.isLoading = true;
    const { username, email, password } = this.signupForm.value;
    
    const signupData: SignupRequest = {
      username,
      email,
      password,
      // Nu trimitem roluri - backend-ul va seta automat ROLE_USER
    };

    this.authService.signup(signupData).subscribe({
      next: (response) => {
        this.isLoading = false;
        this.snackBar.open('Cont creat cu succes! Te poți autentifica acum.', 'OK', { duration: 3000 });
        this.router.navigate(['/login']);
      },
      error: (err) => {
        this.isLoading = false;
        let errorMessage = 'Înregistrare eșuată. Vă rugăm încercați din nou.';
        
        if (err.error?.message) {
          errorMessage = err.error.message;
        } else if (err.message) {
          errorMessage = err.message;
        }
        
        this.snackBar.open(errorMessage, 'Închide', { duration: 5000 });
        console.error('Signup error:', err);
      }
    });
  }

  togglePasswordVisibility(): void {
    this.hidePassword = !this.hidePassword;
  }

  toggleConfirmPasswordVisibility(): void {
    this.hideConfirmPassword = !this.hideConfirmPassword;
  }

  get f() { return this.signupForm.controls; }
}
</file>

<file path="index.html">
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>MagazinCalculatoare</title>
  <base href="/">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" type="image/x-icon" href="favicon.ico">
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
</head>
<body class="mat-typography">
  <app-root></app-root>
</body>
</html>
</file>

<file path="main.server.ts">
import { bootstrapApplication } from '@angular/platform-browser';
import { AppComponent } from './app/app.component';
import { config } from './app/app.config.server';

const bootstrap = () => bootstrapApplication(AppComponent, config);

export default bootstrap;
</file>

<file path="main.ts">
import { bootstrapApplication } from '@angular/platform-browser';
import { AppComponent }         from './app/app.component';
import { appConfig }            from './app/app.config';

bootstrapApplication(AppComponent, appConfig)
  .catch(err => console.error('Bootstrap error:', err));
</file>

<file path="server.ts">
import {
  AngularNodeAppEngine,
  createNodeRequestHandler,
  isMainModule,
  writeResponseToNodeResponse,
} from '@angular/ssr/node';
import express from 'express';
import { dirname, resolve } from 'node:path';
import { fileURLToPath } from 'node:url';

const serverDistFolder = dirname(fileURLToPath(import.meta.url));
const browserDistFolder = resolve(serverDistFolder, '../browser');

const app = express();
const angularApp = new AngularNodeAppEngine();

/**
 * Example Express Rest API endpoints can be defined here.
 * Uncomment and define endpoints as necessary.
 *
 * Example:
 * ```ts
 * app.get('/api/**', (req, res) => {
 *   // Handle API request
 * });
 * ```
 */

/**
 * Serve static files from /browser
 */
app.use(
  express.static(browserDistFolder, {
    maxAge: '1y',
    index: false,
    redirect: false,
  }),
);

/**
 * Handle all other requests by rendering the Angular application.
 */
app.use('/**', (req, res, next) => {
  angularApp
    .handle(req)
    .then((response) =>
      response ? writeResponseToNodeResponse(response, res) : next(),
    )
    .catch(next);
});

/**
 * Start the server if this module is the main entry point.
 * The server listens on the port defined by the `PORT` environment variable, or defaults to 4000.
 */
if (isMainModule(import.meta.url)) {
  const port = process.env['PORT'] || 4000;
  app.listen(port, () => {
    console.log(`Node Express server listening on http://localhost:${port}`);
  });
}

/**
 * Request handler used by the Angular CLI (for dev-server and during build) or Firebase Cloud Functions.
 */
export const reqHandler = createNodeRequestHandler(app);
</file>

<file path="styles.scss">
/* Global Styles */
html, body { 
  height: 100%; 
  margin: 0;
}

body { 
  font-family: Roboto, "Helvetica Neue", sans-serif; 
}

/* Utility classes */
.full-width {
  width: 100%;
}

.text-center {
  text-align: center;
}

/* Remove all dark theme overrides */
</file>

</files>
