This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitattributes
.gitignore
.mvn/wrapper/maven-wrapper.properties
mvnw
mvnw.cmd
pom.xml
src/main/java/com/magazincomputere/magazin_api/config/SecurityConfig.java
src/main/java/com/magazincomputere/magazin_api/config/WebConfig.java
src/main/java/com/magazincomputere/magazin_api/controller/AngularForwardController.java
src/main/java/com/magazincomputere/magazin_api/controller/AuthController.java
src/main/java/com/magazincomputere/magazin_api/controller/CartController.java
src/main/java/com/magazincomputere/magazin_api/controller/CategoryController.java
src/main/java/com/magazincomputere/magazin_api/controller/CustomerController.java
src/main/java/com/magazincomputere/magazin_api/controller/OrderController.java
src/main/java/com/magazincomputere/magazin_api/controller/ProductController.java
src/main/java/com/magazincomputere/magazin_api/controller/ReportController.java
src/main/java/com/magazincomputere/magazin_api/controller/ReviewController.java
src/main/java/com/magazincomputere/magazin_api/controller/SpecificationController.java
src/main/java/com/magazincomputere/magazin_api/controller/UserController.java
src/main/java/com/magazincomputere/magazin_api/dto/AddToCartRequest.java
src/main/java/com/magazincomputere/magazin_api/dto/CartDto.java
src/main/java/com/magazincomputere/magazin_api/dto/CartItemDto.java
src/main/java/com/magazincomputere/magazin_api/dto/CategoryDto.java
src/main/java/com/magazincomputere/magazin_api/dto/CheckoutRequest.java
src/main/java/com/magazincomputere/magazin_api/dto/CreateReviewRequest.java
src/main/java/com/magazincomputere/magazin_api/dto/CustomerDto.java
src/main/java/com/magazincomputere/magazin_api/dto/JwtResponse.java
src/main/java/com/magazincomputere/magazin_api/dto/LoginRequest.java
src/main/java/com/magazincomputere/magazin_api/dto/MessageResponse.java
src/main/java/com/magazincomputere/magazin_api/dto/OrderDto.java
src/main/java/com/magazincomputere/magazin_api/dto/OrderItemDto.java
src/main/java/com/magazincomputere/magazin_api/dto/OrderStatusUpdateDto.java
src/main/java/com/magazincomputere/magazin_api/dto/ProductDto.java
src/main/java/com/magazincomputere/magazin_api/dto/ProductReviewSummary.java
src/main/java/com/magazincomputere/magazin_api/dto/report/CategorySalesDto.java
src/main/java/com/magazincomputere/magazin_api/dto/report/CategoryStockDto.java
src/main/java/com/magazincomputere/magazin_api/dto/report/DailySalesDto.java
src/main/java/com/magazincomputere/magazin_api/dto/report/GeneralReportDto.java
src/main/java/com/magazincomputere/magazin_api/dto/report/ProductSalesDto.java
src/main/java/com/magazincomputere/magazin_api/dto/report/ReportPeriodDto.java
src/main/java/com/magazincomputere/magazin_api/dto/report/SalesReportDto.java
src/main/java/com/magazincomputere/magazin_api/dto/report/StockItemDto.java
src/main/java/com/magazincomputere/magazin_api/dto/report/StockReportDto.java
src/main/java/com/magazincomputere/magazin_api/dto/report/UserInfoDto.java
src/main/java/com/magazincomputere/magazin_api/dto/report/UserReportDto.java
src/main/java/com/magazincomputere/magazin_api/dto/report/UserRoleCountDto.java
src/main/java/com/magazincomputere/magazin_api/dto/ReviewDto.java
src/main/java/com/magazincomputere/magazin_api/dto/SignupRequest.java
src/main/java/com/magazincomputere/magazin_api/dto/SpecificationDefinitionDto.java
src/main/java/com/magazincomputere/magazin_api/dto/SpecificationDto.java
src/main/java/com/magazincomputere/magazin_api/dto/UpdateCartItemRequest.java
src/main/java/com/magazincomputere/magazin_api/dto/UserDto.java
src/main/java/com/magazincomputere/magazin_api/dto/UserUpdateDto.java
src/main/java/com/magazincomputere/magazin_api/exception/BadRequestException.java
src/main/java/com/magazincomputere/magazin_api/exception/GlobalExceptionHandler.java
src/main/java/com/magazincomputere/magazin_api/exception/ResourceNotFoundException.java
src/main/java/com/magazincomputere/magazin_api/MagazinApiApplication.java
src/main/java/com/magazincomputere/magazin_api/model/Cart.java
src/main/java/com/magazincomputere/magazin_api/model/CartItem.java
src/main/java/com/magazincomputere/magazin_api/model/Category.java
src/main/java/com/magazincomputere/magazin_api/model/Customer.java
src/main/java/com/magazincomputere/magazin_api/model/ERole.java
src/main/java/com/magazincomputere/magazin_api/model/Order.java
src/main/java/com/magazincomputere/magazin_api/model/OrderItem.java
src/main/java/com/magazincomputere/magazin_api/model/Product.java
src/main/java/com/magazincomputere/magazin_api/model/ProductSpecificationValue.java
src/main/java/com/magazincomputere/magazin_api/model/Review.java
src/main/java/com/magazincomputere/magazin_api/model/Role.java
src/main/java/com/magazincomputere/magazin_api/model/SpecificationDefinition.java
src/main/java/com/magazincomputere/magazin_api/model/User.java
src/main/java/com/magazincomputere/magazin_api/repository/CartItemRepository.java
src/main/java/com/magazincomputere/magazin_api/repository/CartRepository.java
src/main/java/com/magazincomputere/magazin_api/repository/CategoryRepository.java
src/main/java/com/magazincomputere/magazin_api/repository/CustomerRepository.java
src/main/java/com/magazincomputere/magazin_api/repository/OrderItemRepository.java
src/main/java/com/magazincomputere/magazin_api/repository/OrderRepository.java
src/main/java/com/magazincomputere/magazin_api/repository/ProductRepository.java
src/main/java/com/magazincomputere/magazin_api/repository/ProductSpecificationValueRepository.java
src/main/java/com/magazincomputere/magazin_api/repository/ReviewRepository.java
src/main/java/com/magazincomputere/magazin_api/repository/RoleRepository.java
src/main/java/com/magazincomputere/magazin_api/repository/SpecificationDefinitionRepository.java
src/main/java/com/magazincomputere/magazin_api/repository/UserRepository.java
src/main/java/com/magazincomputere/magazin_api/security/jwt/AuthEntryPointJwt.java
src/main/java/com/magazincomputere/magazin_api/security/jwt/JwtAuthTokenFilter.java
src/main/java/com/magazincomputere/magazin_api/security/jwt/JwtUtils.java
src/main/java/com/magazincomputere/magazin_api/security/services/UserDetailsImpl.java
src/main/java/com/magazincomputere/magazin_api/security/services/UserDetailsServiceImpl.java
src/main/java/com/magazincomputere/magazin_api/service/CartService.java
src/main/java/com/magazincomputere/magazin_api/service/CategoryService.java
src/main/java/com/magazincomputere/magazin_api/service/CustomerService.java
src/main/java/com/magazincomputere/magazin_api/service/OrderService.java
src/main/java/com/magazincomputere/magazin_api/service/ProductService.java
src/main/java/com/magazincomputere/magazin_api/service/ReportService.java
src/main/java/com/magazincomputere/magazin_api/service/ReviewService.java
src/main/java/com/magazincomputere/magazin_api/service/SpecificationService.java
src/main/java/com/magazincomputere/magazin_api/service/UserService.java
src/main/resources/application.properties
src/test/java/com/magazincomputere/magazin_api/MagazinApiApplicationTests.java
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitattributes">
/mvnw text eol=lf
*.cmd text eol=crlf
</file>

<file path=".gitignore">
HELP.md
target/
.mvn/wrapper/maven-wrapper.jar
!**/src/main/**/target/
!**/src/test/**/target/

### STS ###
.apt_generated
.classpath
.factorypath
.project
.settings
.springBeans
.sts4-cache

### IntelliJ IDEA ###
.idea
*.iws
*.iml
*.ipr

### NetBeans ###
/nbproject/private/
/nbbuild/
/dist/
/nbdist/
/.nb-gradle/
build/
!**/src/main/**/build/
!**/src/test/**/build/

### VS Code ###
.vscode/
</file>

<file path=".mvn/wrapper/maven-wrapper.properties">
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
wrapperVersion=3.3.2
distributionType=only-script
distributionUrl=https://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.9.9/apache-maven-3.9.9-bin.zip
</file>

<file path="mvnw">
#!/bin/sh
# ----------------------------------------------------------------------------
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
# ----------------------------------------------------------------------------

# ----------------------------------------------------------------------------
# Apache Maven Wrapper startup batch script, version 3.3.2
#
# Optional ENV vars
# -----------------
#   JAVA_HOME - location of a JDK home dir, required when download maven via java source
#   MVNW_REPOURL - repo url base for downloading maven distribution
#   MVNW_USERNAME/MVNW_PASSWORD - user and password for downloading maven
#   MVNW_VERBOSE - true: enable verbose log; debug: trace the mvnw script; others: silence the output
# ----------------------------------------------------------------------------

set -euf
[ "${MVNW_VERBOSE-}" != debug ] || set -x

# OS specific support.
native_path() { printf %s\\n "$1"; }
case "$(uname)" in
CYGWIN* | MINGW*)
  [ -z "${JAVA_HOME-}" ] || JAVA_HOME="$(cygpath --unix "$JAVA_HOME")"
  native_path() { cygpath --path --windows "$1"; }
  ;;
esac

# set JAVACMD and JAVACCMD
set_java_home() {
  # For Cygwin and MinGW, ensure paths are in Unix format before anything is touched
  if [ -n "${JAVA_HOME-}" ]; then
    if [ -x "$JAVA_HOME/jre/sh/java" ]; then
      # IBM's JDK on AIX uses strange locations for the executables
      JAVACMD="$JAVA_HOME/jre/sh/java"
      JAVACCMD="$JAVA_HOME/jre/sh/javac"
    else
      JAVACMD="$JAVA_HOME/bin/java"
      JAVACCMD="$JAVA_HOME/bin/javac"

      if [ ! -x "$JAVACMD" ] || [ ! -x "$JAVACCMD" ]; then
        echo "The JAVA_HOME environment variable is not defined correctly, so mvnw cannot run." >&2
        echo "JAVA_HOME is set to \"$JAVA_HOME\", but \"\$JAVA_HOME/bin/java\" or \"\$JAVA_HOME/bin/javac\" does not exist." >&2
        return 1
      fi
    fi
  else
    JAVACMD="$(
      'set' +e
      'unset' -f command 2>/dev/null
      'command' -v java
    )" || :
    JAVACCMD="$(
      'set' +e
      'unset' -f command 2>/dev/null
      'command' -v javac
    )" || :

    if [ ! -x "${JAVACMD-}" ] || [ ! -x "${JAVACCMD-}" ]; then
      echo "The java/javac command does not exist in PATH nor is JAVA_HOME set, so mvnw cannot run." >&2
      return 1
    fi
  fi
}

# hash string like Java String::hashCode
hash_string() {
  str="${1:-}" h=0
  while [ -n "$str" ]; do
    char="${str%"${str#?}"}"
    h=$(((h * 31 + $(LC_CTYPE=C printf %d "'$char")) % 4294967296))
    str="${str#?}"
  done
  printf %x\\n $h
}

verbose() { :; }
[ "${MVNW_VERBOSE-}" != true ] || verbose() { printf %s\\n "${1-}"; }

die() {
  printf %s\\n "$1" >&2
  exit 1
}

trim() {
  # MWRAPPER-139:
  #   Trims trailing and leading whitespace, carriage returns, tabs, and linefeeds.
  #   Needed for removing poorly interpreted newline sequences when running in more
  #   exotic environments such as mingw bash on Windows.
  printf "%s" "${1}" | tr -d '[:space:]'
}

# parse distributionUrl and optional distributionSha256Sum, requires .mvn/wrapper/maven-wrapper.properties
while IFS="=" read -r key value; do
  case "${key-}" in
  distributionUrl) distributionUrl=$(trim "${value-}") ;;
  distributionSha256Sum) distributionSha256Sum=$(trim "${value-}") ;;
  esac
done <"${0%/*}/.mvn/wrapper/maven-wrapper.properties"
[ -n "${distributionUrl-}" ] || die "cannot read distributionUrl property in ${0%/*}/.mvn/wrapper/maven-wrapper.properties"

case "${distributionUrl##*/}" in
maven-mvnd-*bin.*)
  MVN_CMD=mvnd.sh _MVNW_REPO_PATTERN=/maven/mvnd/
  case "${PROCESSOR_ARCHITECTURE-}${PROCESSOR_ARCHITEW6432-}:$(uname -a)" in
  *AMD64:CYGWIN* | *AMD64:MINGW*) distributionPlatform=windows-amd64 ;;
  :Darwin*x86_64) distributionPlatform=darwin-amd64 ;;
  :Darwin*arm64) distributionPlatform=darwin-aarch64 ;;
  :Linux*x86_64*) distributionPlatform=linux-amd64 ;;
  *)
    echo "Cannot detect native platform for mvnd on $(uname)-$(uname -m), use pure java version" >&2
    distributionPlatform=linux-amd64
    ;;
  esac
  distributionUrl="${distributionUrl%-bin.*}-$distributionPlatform.zip"
  ;;
maven-mvnd-*) MVN_CMD=mvnd.sh _MVNW_REPO_PATTERN=/maven/mvnd/ ;;
*) MVN_CMD="mvn${0##*/mvnw}" _MVNW_REPO_PATTERN=/org/apache/maven/ ;;
esac

# apply MVNW_REPOURL and calculate MAVEN_HOME
# maven home pattern: ~/.m2/wrapper/dists/{apache-maven-<version>,maven-mvnd-<version>-<platform>}/<hash>
[ -z "${MVNW_REPOURL-}" ] || distributionUrl="$MVNW_REPOURL$_MVNW_REPO_PATTERN${distributionUrl#*"$_MVNW_REPO_PATTERN"}"
distributionUrlName="${distributionUrl##*/}"
distributionUrlNameMain="${distributionUrlName%.*}"
distributionUrlNameMain="${distributionUrlNameMain%-bin}"
MAVEN_USER_HOME="${MAVEN_USER_HOME:-${HOME}/.m2}"
MAVEN_HOME="${MAVEN_USER_HOME}/wrapper/dists/${distributionUrlNameMain-}/$(hash_string "$distributionUrl")"

exec_maven() {
  unset MVNW_VERBOSE MVNW_USERNAME MVNW_PASSWORD MVNW_REPOURL || :
  exec "$MAVEN_HOME/bin/$MVN_CMD" "$@" || die "cannot exec $MAVEN_HOME/bin/$MVN_CMD"
}

if [ -d "$MAVEN_HOME" ]; then
  verbose "found existing MAVEN_HOME at $MAVEN_HOME"
  exec_maven "$@"
fi

case "${distributionUrl-}" in
*?-bin.zip | *?maven-mvnd-?*-?*.zip) ;;
*) die "distributionUrl is not valid, must match *-bin.zip or maven-mvnd-*.zip, but found '${distributionUrl-}'" ;;
esac

# prepare tmp dir
if TMP_DOWNLOAD_DIR="$(mktemp -d)" && [ -d "$TMP_DOWNLOAD_DIR" ]; then
  clean() { rm -rf -- "$TMP_DOWNLOAD_DIR"; }
  trap clean HUP INT TERM EXIT
else
  die "cannot create temp dir"
fi

mkdir -p -- "${MAVEN_HOME%/*}"

# Download and Install Apache Maven
verbose "Couldn't find MAVEN_HOME, downloading and installing it ..."
verbose "Downloading from: $distributionUrl"
verbose "Downloading to: $TMP_DOWNLOAD_DIR/$distributionUrlName"

# select .zip or .tar.gz
if ! command -v unzip >/dev/null; then
  distributionUrl="${distributionUrl%.zip}.tar.gz"
  distributionUrlName="${distributionUrl##*/}"
fi

# verbose opt
__MVNW_QUIET_WGET=--quiet __MVNW_QUIET_CURL=--silent __MVNW_QUIET_UNZIP=-q __MVNW_QUIET_TAR=''
[ "${MVNW_VERBOSE-}" != true ] || __MVNW_QUIET_WGET='' __MVNW_QUIET_CURL='' __MVNW_QUIET_UNZIP='' __MVNW_QUIET_TAR=v

# normalize http auth
case "${MVNW_PASSWORD:+has-password}" in
'') MVNW_USERNAME='' MVNW_PASSWORD='' ;;
has-password) [ -n "${MVNW_USERNAME-}" ] || MVNW_USERNAME='' MVNW_PASSWORD='' ;;
esac

if [ -z "${MVNW_USERNAME-}" ] && command -v wget >/dev/null; then
  verbose "Found wget ... using wget"
  wget ${__MVNW_QUIET_WGET:+"$__MVNW_QUIET_WGET"} "$distributionUrl" -O "$TMP_DOWNLOAD_DIR/$distributionUrlName" || die "wget: Failed to fetch $distributionUrl"
elif [ -z "${MVNW_USERNAME-}" ] && command -v curl >/dev/null; then
  verbose "Found curl ... using curl"
  curl ${__MVNW_QUIET_CURL:+"$__MVNW_QUIET_CURL"} -f -L -o "$TMP_DOWNLOAD_DIR/$distributionUrlName" "$distributionUrl" || die "curl: Failed to fetch $distributionUrl"
elif set_java_home; then
  verbose "Falling back to use Java to download"
  javaSource="$TMP_DOWNLOAD_DIR/Downloader.java"
  targetZip="$TMP_DOWNLOAD_DIR/$distributionUrlName"
  cat >"$javaSource" <<-END
	public class Downloader extends java.net.Authenticator
	{
	  protected java.net.PasswordAuthentication getPasswordAuthentication()
	  {
	    return new java.net.PasswordAuthentication( System.getenv( "MVNW_USERNAME" ), System.getenv( "MVNW_PASSWORD" ).toCharArray() );
	  }
	  public static void main( String[] args ) throws Exception
	  {
	    setDefault( new Downloader() );
	    java.nio.file.Files.copy( java.net.URI.create( args[0] ).toURL().openStream(), java.nio.file.Paths.get( args[1] ).toAbsolutePath().normalize() );
	  }
	}
	END
  # For Cygwin/MinGW, switch paths to Windows format before running javac and java
  verbose " - Compiling Downloader.java ..."
  "$(native_path "$JAVACCMD")" "$(native_path "$javaSource")" || die "Failed to compile Downloader.java"
  verbose " - Running Downloader.java ..."
  "$(native_path "$JAVACMD")" -cp "$(native_path "$TMP_DOWNLOAD_DIR")" Downloader "$distributionUrl" "$(native_path "$targetZip")"
fi

# If specified, validate the SHA-256 sum of the Maven distribution zip file
if [ -n "${distributionSha256Sum-}" ]; then
  distributionSha256Result=false
  if [ "$MVN_CMD" = mvnd.sh ]; then
    echo "Checksum validation is not supported for maven-mvnd." >&2
    echo "Please disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties." >&2
    exit 1
  elif command -v sha256sum >/dev/null; then
    if echo "$distributionSha256Sum  $TMP_DOWNLOAD_DIR/$distributionUrlName" | sha256sum -c >/dev/null 2>&1; then
      distributionSha256Result=true
    fi
  elif command -v shasum >/dev/null; then
    if echo "$distributionSha256Sum  $TMP_DOWNLOAD_DIR/$distributionUrlName" | shasum -a 256 -c >/dev/null 2>&1; then
      distributionSha256Result=true
    fi
  else
    echo "Checksum validation was requested but neither 'sha256sum' or 'shasum' are available." >&2
    echo "Please install either command, or disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties." >&2
    exit 1
  fi
  if [ $distributionSha256Result = false ]; then
    echo "Error: Failed to validate Maven distribution SHA-256, your Maven distribution might be compromised." >&2
    echo "If you updated your Maven version, you need to update the specified distributionSha256Sum property." >&2
    exit 1
  fi
fi

# unzip and move
if command -v unzip >/dev/null; then
  unzip ${__MVNW_QUIET_UNZIP:+"$__MVNW_QUIET_UNZIP"} "$TMP_DOWNLOAD_DIR/$distributionUrlName" -d "$TMP_DOWNLOAD_DIR" || die "failed to unzip"
else
  tar xzf${__MVNW_QUIET_TAR:+"$__MVNW_QUIET_TAR"} "$TMP_DOWNLOAD_DIR/$distributionUrlName" -C "$TMP_DOWNLOAD_DIR" || die "failed to untar"
fi
printf %s\\n "$distributionUrl" >"$TMP_DOWNLOAD_DIR/$distributionUrlNameMain/mvnw.url"
mv -- "$TMP_DOWNLOAD_DIR/$distributionUrlNameMain" "$MAVEN_HOME" || [ -d "$MAVEN_HOME" ] || die "fail to move MAVEN_HOME"

clean || :
exec_maven "$@"
</file>

<file path="mvnw.cmd">
<# : batch portion
@REM ----------------------------------------------------------------------------
@REM Licensed to the Apache Software Foundation (ASF) under one
@REM or more contributor license agreements.  See the NOTICE file
@REM distributed with this work for additional information
@REM regarding copyright ownership.  The ASF licenses this file
@REM to you under the Apache License, Version 2.0 (the
@REM "License"); you may not use this file except in compliance
@REM with the License.  You may obtain a copy of the License at
@REM
@REM    http://www.apache.org/licenses/LICENSE-2.0
@REM
@REM Unless required by applicable law or agreed to in writing,
@REM software distributed under the License is distributed on an
@REM "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
@REM KIND, either express or implied.  See the License for the
@REM specific language governing permissions and limitations
@REM under the License.
@REM ----------------------------------------------------------------------------

@REM ----------------------------------------------------------------------------
@REM Apache Maven Wrapper startup batch script, version 3.3.2
@REM
@REM Optional ENV vars
@REM   MVNW_REPOURL - repo url base for downloading maven distribution
@REM   MVNW_USERNAME/MVNW_PASSWORD - user and password for downloading maven
@REM   MVNW_VERBOSE - true: enable verbose log; others: silence the output
@REM ----------------------------------------------------------------------------

@IF "%__MVNW_ARG0_NAME__%"=="" (SET __MVNW_ARG0_NAME__=%~nx0)
@SET __MVNW_CMD__=
@SET __MVNW_ERROR__=
@SET __MVNW_PSMODULEP_SAVE=%PSModulePath%
@SET PSModulePath=
@FOR /F "usebackq tokens=1* delims==" %%A IN (`powershell -noprofile "& {$scriptDir='%~dp0'; $script='%__MVNW_ARG0_NAME__%'; icm -ScriptBlock ([Scriptblock]::Create((Get-Content -Raw '%~f0'))) -NoNewScope}"`) DO @(
  IF "%%A"=="MVN_CMD" (set __MVNW_CMD__=%%B) ELSE IF "%%B"=="" (echo %%A) ELSE (echo %%A=%%B)
)
@SET PSModulePath=%__MVNW_PSMODULEP_SAVE%
@SET __MVNW_PSMODULEP_SAVE=
@SET __MVNW_ARG0_NAME__=
@SET MVNW_USERNAME=
@SET MVNW_PASSWORD=
@IF NOT "%__MVNW_CMD__%"=="" (%__MVNW_CMD__% %*)
@echo Cannot start maven from wrapper >&2 && exit /b 1
@GOTO :EOF
: end batch / begin powershell #>

$ErrorActionPreference = "Stop"
if ($env:MVNW_VERBOSE -eq "true") {
  $VerbosePreference = "Continue"
}

# calculate distributionUrl, requires .mvn/wrapper/maven-wrapper.properties
$distributionUrl = (Get-Content -Raw "$scriptDir/.mvn/wrapper/maven-wrapper.properties" | ConvertFrom-StringData).distributionUrl
if (!$distributionUrl) {
  Write-Error "cannot read distributionUrl property in $scriptDir/.mvn/wrapper/maven-wrapper.properties"
}

switch -wildcard -casesensitive ( $($distributionUrl -replace '^.*/','') ) {
  "maven-mvnd-*" {
    $USE_MVND = $true
    $distributionUrl = $distributionUrl -replace '-bin\.[^.]*$',"-windows-amd64.zip"
    $MVN_CMD = "mvnd.cmd"
    break
  }
  default {
    $USE_MVND = $false
    $MVN_CMD = $script -replace '^mvnw','mvn'
    break
  }
}

# apply MVNW_REPOURL and calculate MAVEN_HOME
# maven home pattern: ~/.m2/wrapper/dists/{apache-maven-<version>,maven-mvnd-<version>-<platform>}/<hash>
if ($env:MVNW_REPOURL) {
  $MVNW_REPO_PATTERN = if ($USE_MVND) { "/org/apache/maven/" } else { "/maven/mvnd/" }
  $distributionUrl = "$env:MVNW_REPOURL$MVNW_REPO_PATTERN$($distributionUrl -replace '^.*'+$MVNW_REPO_PATTERN,'')"
}
$distributionUrlName = $distributionUrl -replace '^.*/',''
$distributionUrlNameMain = $distributionUrlName -replace '\.[^.]*$','' -replace '-bin$',''
$MAVEN_HOME_PARENT = "$HOME/.m2/wrapper/dists/$distributionUrlNameMain"
if ($env:MAVEN_USER_HOME) {
  $MAVEN_HOME_PARENT = "$env:MAVEN_USER_HOME/wrapper/dists/$distributionUrlNameMain"
}
$MAVEN_HOME_NAME = ([System.Security.Cryptography.MD5]::Create().ComputeHash([byte[]][char[]]$distributionUrl) | ForEach-Object {$_.ToString("x2")}) -join ''
$MAVEN_HOME = "$MAVEN_HOME_PARENT/$MAVEN_HOME_NAME"

if (Test-Path -Path "$MAVEN_HOME" -PathType Container) {
  Write-Verbose "found existing MAVEN_HOME at $MAVEN_HOME"
  Write-Output "MVN_CMD=$MAVEN_HOME/bin/$MVN_CMD"
  exit $?
}

if (! $distributionUrlNameMain -or ($distributionUrlName -eq $distributionUrlNameMain)) {
  Write-Error "distributionUrl is not valid, must end with *-bin.zip, but found $distributionUrl"
}

# prepare tmp dir
$TMP_DOWNLOAD_DIR_HOLDER = New-TemporaryFile
$TMP_DOWNLOAD_DIR = New-Item -Itemtype Directory -Path "$TMP_DOWNLOAD_DIR_HOLDER.dir"
$TMP_DOWNLOAD_DIR_HOLDER.Delete() | Out-Null
trap {
  if ($TMP_DOWNLOAD_DIR.Exists) {
    try { Remove-Item $TMP_DOWNLOAD_DIR -Recurse -Force | Out-Null }
    catch { Write-Warning "Cannot remove $TMP_DOWNLOAD_DIR" }
  }
}

New-Item -Itemtype Directory -Path "$MAVEN_HOME_PARENT" -Force | Out-Null

# Download and Install Apache Maven
Write-Verbose "Couldn't find MAVEN_HOME, downloading and installing it ..."
Write-Verbose "Downloading from: $distributionUrl"
Write-Verbose "Downloading to: $TMP_DOWNLOAD_DIR/$distributionUrlName"

$webclient = New-Object System.Net.WebClient
if ($env:MVNW_USERNAME -and $env:MVNW_PASSWORD) {
  $webclient.Credentials = New-Object System.Net.NetworkCredential($env:MVNW_USERNAME, $env:MVNW_PASSWORD)
}
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
$webclient.DownloadFile($distributionUrl, "$TMP_DOWNLOAD_DIR/$distributionUrlName") | Out-Null

# If specified, validate the SHA-256 sum of the Maven distribution zip file
$distributionSha256Sum = (Get-Content -Raw "$scriptDir/.mvn/wrapper/maven-wrapper.properties" | ConvertFrom-StringData).distributionSha256Sum
if ($distributionSha256Sum) {
  if ($USE_MVND) {
    Write-Error "Checksum validation is not supported for maven-mvnd. `nPlease disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties."
  }
  Import-Module $PSHOME\Modules\Microsoft.PowerShell.Utility -Function Get-FileHash
  if ((Get-FileHash "$TMP_DOWNLOAD_DIR/$distributionUrlName" -Algorithm SHA256).Hash.ToLower() -ne $distributionSha256Sum) {
    Write-Error "Error: Failed to validate Maven distribution SHA-256, your Maven distribution might be compromised. If you updated your Maven version, you need to update the specified distributionSha256Sum property."
  }
}

# unzip and move
Expand-Archive "$TMP_DOWNLOAD_DIR/$distributionUrlName" -DestinationPath "$TMP_DOWNLOAD_DIR" | Out-Null
Rename-Item -Path "$TMP_DOWNLOAD_DIR/$distributionUrlNameMain" -NewName $MAVEN_HOME_NAME | Out-Null
try {
  Move-Item -Path "$TMP_DOWNLOAD_DIR/$MAVEN_HOME_NAME" -Destination $MAVEN_HOME_PARENT | Out-Null
} catch {
  if (! (Test-Path -Path "$MAVEN_HOME" -PathType Container)) {
    Write-Error "fail to move MAVEN_HOME"
  }
} finally {
  try { Remove-Item $TMP_DOWNLOAD_DIR -Recurse -Force | Out-Null }
  catch { Write-Warning "Cannot remove $TMP_DOWNLOAD_DIR" }
}

Write-Output "MVN_CMD=$MAVEN_HOME/bin/$MVN_CMD"
</file>

<file path="pom.xml">
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
                             https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.2.5</version>
        <relativePath/>
    </parent>

    <groupId>com.magazincomputere</groupId>
    <artifactId>magazin-api</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>magazin-api</name>
    <description>API pentru Magazin Computere</description>

    <properties>
        <java.version>17</java.version>
        <!-- păstrăm doar springdoc aici; jjwt îl setăm direct în dependențe -->
        <springdoc.version>2.3.0</springdoc.version>
    </properties>

    <dependencies>
        <!-- Spring Boot starters – toate pe 3.2.5 -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
            <version>3.2.5</version>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
            <version>3.2.5</version>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
            <version>3.2.5</version>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
            <version>3.2.5</version>
        </dependency>

        <!-- Baze de date -->
        <dependency>
            <groupId>com.h2database</groupId>
            <artifactId>h2</artifactId>
            <version>2.2.224</version>
            <scope>runtime</scope>
        </dependency>

        <dependency>
            <groupId>com.mysql</groupId>
            <artifactId>mysql-connector-j</artifactId>
            <version>8.3.0</version>
            <scope>runtime</scope>
        </dependency>

        <!-- Utility -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>1.18.32</version>
            <optional>true</optional>
        </dependency>

        <!-- JJWT 0.12.6 -->
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-api</artifactId>
            <version>0.11.5</version>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-impl</artifactId>
            <version>0.11.5</version>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-jackson</artifactId>
            <version>0.11.5</version>
            <scope>runtime</scope>
        </dependency>

        <!-- SpringDoc OpenAPI (lasă proprietatea) -->
        <dependency>
            <groupId>org.springdoc</groupId>
            <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
            <version>${springdoc.version}</version>
        </dependency>
        <!-- Apache POI for Excel generation -->
        <dependency>
             <groupId>org.apache.poi</groupId>
             <artifactId>poi</artifactId>
             <version>5.2.5</version>
        </dependency>
        <dependency>
             <groupId>org.apache.poi</groupId>
             <artifactId>poi-ooxml</artifactId>
             <version>5.2.5</version>
        </dependency>

        <!-- iText for PDF generation -->
        <dependency>
             <groupId>com.itextpdf</groupId>
             <artifactId>itext7-core</artifactId>
             <version>8.0.2</version>
             <type>pom</type>
        </dependency>

        <!-- Teste -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <version>3.2.5</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-test</artifactId>
            <version>6.2.4</version>
            <scope>test</scope>
        </dependency>
        <dependency>
    <groupId>org.postgresql</groupId>
    <artifactId>postgresql</artifactId>
    <scope>runtime</scope>
</dependency>
<dependency>
    <groupId>com.mysql</groupId>
    <artifactId>mysql-connector-j</artifactId>
    <scope>runtime</scope>
</dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <excludes>
                        <exclude>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                        </exclude>
                    </excludes>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/config/SecurityConfig.java">
package com.magazincomputere.magazin_api.config;

import com.magazincomputere.magazin_api.security.jwt.AuthEntryPointJwt;
import com.magazincomputere.magazin_api.security.jwt.JwtAuthTokenFilter;
import com.magazincomputere.magazin_api.security.services.UserDetailsServiceImpl;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.security.web.util.matcher.AntPathRequestMatcher;


@Configuration
@EnableWebSecurity
@EnableMethodSecurity(prePostEnabled = true)
public class SecurityConfig {

    @Autowired
    private UserDetailsServiceImpl userDetailsService;

    @Autowired
    private AuthEntryPointJwt unauthorizedHandler;

    @Bean
    public JwtAuthTokenFilter authenticationJwtTokenFilter() {
        return new JwtAuthTokenFilter();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authenticationConfiguration) throws Exception {
        return authenticationConfiguration.getAuthenticationManager();
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .cors(cors -> {})
            .csrf(csrf -> csrf.disable())
            .exceptionHandling(exception -> exception.authenticationEntryPoint(unauthorizedHandler))
            .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            .authorizeHttpRequests(auth -> auth
                // -- ÎNCEPUT: REGULI SPECIFICE (TREBUIE SĂ FIE PRIMELE) --

                // Permite acces liber la autentificare, produse, categorii etc.
                .requestMatchers("/swagger-ui.html", "/swagger-ui/**", "/api-docs/**", "/h2-console/**").permitAll()
                .requestMatchers("/api/auth/**").permitAll()
                .requestMatchers(AntPathRequestMatcher.antMatcher(HttpMethod.GET, "/api/products/**")).permitAll()
                .requestMatchers(AntPathRequestMatcher.antMatcher(HttpMethod.GET, "/api/categories/**")).permitAll()
                .requestMatchers(AntPathRequestMatcher.antMatcher(HttpMethod.GET, "/api/specifications/**")).permitAll()

                // Reguli pentru Coș (Cart)
                .requestMatchers(AntPathRequestMatcher.antMatcher("/api/cart/**")).hasAnyRole("USER", "ADMIN")
                
                // Reguli pentru Produse, Categorii, Specificații (doar Admin poate modifica)
                .requestMatchers(AntPathRequestMatcher.antMatcher(HttpMethod.POST, "/api/products")).hasRole("ADMIN")
                .requestMatchers(AntPathRequestMatcher.antMatcher(HttpMethod.PUT, "/api/products/**")).hasRole("ADMIN")
                .requestMatchers(AntPathRequestMatcher.antMatcher(HttpMethod.DELETE, "/api/products/**")).hasRole("ADMIN")
                .requestMatchers(AntPathRequestMatcher.antMatcher(HttpMethod.POST, "/api/categories")).hasRole("ADMIN")
                .requestMatchers(AntPathRequestMatcher.antMatcher(HttpMethod.PUT, "/api/categories/**")).hasRole("ADMIN")
                .requestMatchers(AntPathRequestMatcher.antMatcher(HttpMethod.DELETE, "/api/categories/**")).hasRole("ADMIN")
                .requestMatchers(AntPathRequestMatcher.antMatcher(HttpMethod.POST, "/api/specifications")).hasRole("ADMIN")
                .requestMatchers(AntPathRequestMatcher.antMatcher(HttpMethod.PUT, "/api/specifications/**")).hasRole("ADMIN")
                .requestMatchers(AntPathRequestMatcher.antMatcher(HttpMethod.DELETE, "/api/specifications/**")).hasRole("ADMIN")

                // Reguli pentru Comenzi (Orders)
                .requestMatchers(AntPathRequestMatcher.antMatcher(HttpMethod.POST, "/api/orders")).hasAnyRole("USER", "ADMIN")
                .requestMatchers(AntPathRequestMatcher.antMatcher(HttpMethod.GET, "/api/orders/my-history")).hasAnyRole("USER", "ADMIN")
                .requestMatchers(AntPathRequestMatcher.antMatcher(HttpMethod.GET, "/api/orders/**")).hasRole("ADMIN")
                .requestMatchers(AntPathRequestMatcher.antMatcher(HttpMethod.PUT, "/api/orders/**/status")).hasRole("ADMIN")

                // Reguli pentru Utilizatori, Clienți și Rapoarte (doar Admin)
                .requestMatchers(AntPathRequestMatcher.antMatcher("/api/users/**")).hasRole("ADMIN")
                .requestMatchers(AntPathRequestMatcher.antMatcher("/api/customers/**")).hasRole("ADMIN")
                .requestMatchers(AntPathRequestMatcher.antMatcher("/api/reports/**")).hasRole("ADMIN")
                
                // Permite fișierele statice pentru frontend
                .requestMatchers("/", "/*.html", "/*.js", "/*.css", "/*.ico", "/*.png", "/*.jpg", "/*.webmanifest", "/assets/**").permitAll()

                // Public access to view reviews
                .requestMatchers(AntPathRequestMatcher.antMatcher(HttpMethod.GET, "/api/reviews/product/**")).permitAll()
                // Authenticated users can create/update/delete reviews
                .requestMatchers(AntPathRequestMatcher.antMatcher(HttpMethod.POST, "/api/reviews")).authenticated()
                .requestMatchers(AntPathRequestMatcher.antMatcher(HttpMethod.PUT, "/api/reviews/**")).authenticated()
                .requestMatchers(AntPathRequestMatcher.antMatcher(HttpMethod.DELETE, "/api/reviews/**")).authenticated()

                // -- FINAL: REGULA GENERALĂ (TREBUIE SĂ FIE ULTIMA) --
                .anyRequest().authenticated()
            );

        // Necesar pentru H2 console
        http.headers(headers -> headers.frameOptions(frameOptions -> frameOptions.sameOrigin()));
        http.addFilterBefore(authenticationJwtTokenFilter(), UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/config/WebConfig.java">
package com.magazincomputere.magazin_api.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class WebConfig implements WebMvcConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**") // Se aplică tuturor endpoint-urilor
                // MODIFICARE: Specificăm explicit originea permisă în loc de "*"
                .allowedOrigins("http://localhost:4200", "http://localhost:8080") 
                .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS") // Metodele HTTP permise
                .allowedHeaders("*") // Permite toate headerele
                .allowCredentials(true); // Permite trimiterea de credentials (cookies, token-uri etc.)
    }
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/controller/AngularForwardController.java">
package com.magazincomputere.magazin_api.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
public class AngularForwardController {
    // Această expresie regulată este un exemplu și s-ar putea să necesite ajustări fine.
    // Scopul este să redirecționeze către index.html pentru rutele Angular,
    // cu excepția celor care încep cu /api, /swagger-ui, /api-docs, /h2-console
    // și a celor care par a fi pentru fișiere statice (conțin un punct).
    @RequestMapping(value = {"/", "/{path:^(?!api|swagger-ui|api-docs|h2-console|.*\\.).*$}/**", "/{path:^(?!api|swagger-ui|api-docs|h2-console|.*\\.).*$}"})
    public String forward() {
        return "forward:/index.html";
    }
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/controller/AuthController.java">
package com.magazincomputere.magazin_api.controller;

import com.magazincomputere.magazin_api.dto.LoginRequest;
import com.magazincomputere.magazin_api.dto.SignupRequest; // Va trebui să creezi acest DTO
import com.magazincomputere.magazin_api.dto.JwtResponse;
import com.magazincomputere.magazin_api.dto.MessageResponse;
import com.magazincomputere.magazin_api.model.ERole;
import com.magazincomputere.magazin_api.model.Role;
import com.magazincomputere.magazin_api.model.User;
import com.magazincomputere.magazin_api.repository.RoleRepository;
import com.magazincomputere.magazin_api.repository.UserRepository;
import com.magazincomputere.magazin_api.security.jwt.JwtUtils;
import com.magazincomputere.magazin_api.security.services.UserDetailsImpl;

import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.web.bind.annotation.*;

import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/auth")
public class AuthController {

    @Autowired
    AuthenticationManager authenticationManager;

    @Autowired
    UserRepository userRepository;

    @Autowired
    RoleRepository roleRepository;

    @Autowired
    PasswordEncoder encoder;

    @Autowired
    JwtUtils jwtUtils;

    @PostMapping("/login")
    public ResponseEntity<?> authenticateUser(@Valid @RequestBody LoginRequest loginRequest) {
        Authentication authentication = authenticationManager.authenticate(
                new UsernamePasswordAuthenticationToken(loginRequest.getUsername(), loginRequest.getPassword()));

        SecurityContextHolder.getContext().setAuthentication(authentication);
        String jwt = jwtUtils.generateJwtToken(authentication);

        UserDetailsImpl userDetails = (UserDetailsImpl) authentication.getPrincipal();
        List<String> roles = userDetails.getAuthorities().stream()
                .map(item -> item.getAuthority())
                .collect(Collectors.toList());

        return ResponseEntity.ok(new JwtResponse(jwt,
                                                 userDetails.getId(),
                                                 userDetails.getUsername(),
                                                 userDetails.getEmail(),
                                                 roles));
    }

    @PostMapping("/signup")
    public ResponseEntity<?> registerUser(@Valid @RequestBody SignupRequest signUpRequest) { // Creează DTO-ul SignupRequest
        if (userRepository.existsByUsername(signUpRequest.getUsername())) {
            return ResponseEntity
                    .badRequest()
                    .body(new MessageResponse("Error: Username is already taken!"));
        }

        if (userRepository.existsByEmail(signUpRequest.getEmail())) {
            return ResponseEntity
                    .badRequest()
                    .body(new MessageResponse("Error: Email is already in use!"));
        }

        // Create new user's account
        User user = new User(signUpRequest.getUsername(),
                             signUpRequest.getEmail(),
                             encoder.encode(signUpRequest.getPassword()));

        Set<String> strRoles = signUpRequest.getRoles(); // SignupRequest ar trebui să permită specificarea rolurilor
        Set<Role> roles = new HashSet<>();

        if (strRoles == null || strRoles.isEmpty()) {
            Role userRole = roleRepository.findByName(ERole.ROLE_USER)
                    .orElseThrow(() -> new RuntimeException("Error: Role USER is not found."));
            roles.add(userRole);
        } else {
            strRoles.forEach(role -> {
                switch (role.toLowerCase()) {
                    case "admin":
                        Role adminRole = roleRepository.findByName(ERole.ROLE_ADMIN)
                                .orElseThrow(() -> new RuntimeException("Error: Role ADMIN is not found."));
                        roles.add(adminRole);
                        break;
                    default:
                        Role userRole = roleRepository.findByName(ERole.ROLE_USER)
                                .orElseThrow(() -> new RuntimeException("Error: Role USER is not found."));
                        roles.add(userRole);
                }
            });
        }

        user.setRoles(roles);
        userRepository.save(user);

        return ResponseEntity.ok(new MessageResponse("User registered successfully!"));
    }
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/controller/CartController.java">
// backend/src/main/java/com/magazincomputere/magazin_api/controller/CartController.java
package com.magazincomputere.magazin_api.controller;

import com.magazincomputere.magazin_api.dto.*;
import com.magazincomputere.magazin_api.security.services.UserDetailsImpl;
import com.magazincomputere.magazin_api.service.CartService;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/cart")
public class CartController {

    @Autowired
    private CartService cartService;

    @GetMapping
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<CartDto> getCart() {
        Long userId = getCurrentUserId();
        CartDto cart = cartService.getCartByUserId(userId);
        return ResponseEntity.ok(cart);
    }

    @PostMapping("/items")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<CartDto> addToCart(@Valid @RequestBody AddToCartRequest request) {
        Long userId = getCurrentUserId();
        CartDto cart = cartService.addToCart(userId, request);
        return new ResponseEntity<>(cart, HttpStatus.CREATED);
    }

    @PutMapping("/items/{productId}")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<CartDto> updateCartItem(
            @PathVariable Long productId,
            @Valid @RequestBody UpdateCartItemRequest request) {
        Long userId = getCurrentUserId();
        CartDto cart = cartService.updateCartItem(userId, productId, request);
        return ResponseEntity.ok(cart);
    }

    @DeleteMapping("/items/{productId}")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<CartDto> removeFromCart(@PathVariable Long productId) {
        Long userId = getCurrentUserId();
        CartDto cart = cartService.removeFromCart(userId, productId);
        return ResponseEntity.ok(cart);
    }

    @DeleteMapping("/clear")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<Void> clearCart() {
        Long userId = getCurrentUserId();
        cartService.clearCart(userId);
        return ResponseEntity.noContent().build();
    }

    @PostMapping("/checkout")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<OrderDto> checkout(@Valid @RequestBody CheckoutRequest request) {
        Long userId = getCurrentUserId();
        OrderDto order = cartService.checkout(userId, request);
        return new ResponseEntity<>(order, HttpStatus.CREATED);
    }

    private Long getCurrentUserId() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        UserDetailsImpl userDetails = (UserDetailsImpl) authentication.getPrincipal();
        return userDetails.getId();
    }
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/controller/CategoryController.java">
package com.magazincomputere.magazin_api.controller;

import com.magazincomputere.magazin_api.dto.CategoryDto;
import com.magazincomputere.magazin_api.service.CategoryService; // Va trebui să creezi CategoryService
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/categories")
public class CategoryController {

    @Autowired
    private CategoryService categoryService; // Asigură-te că ai creat CategoryService

    @GetMapping
    public List<CategoryDto> getAllCategories() { // Acces public
        return categoryService.getAllCategories();
    }

    @GetMapping("/{id}")
    public ResponseEntity<CategoryDto> getCategoryById(@PathVariable Long id) { // Acces public
        CategoryDto categoryDto = categoryService.getCategoryById(id);
        return ResponseEntity.ok(categoryDto);
    }

    @PostMapping
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<CategoryDto> createCategory(@Valid @RequestBody CategoryDto categoryDto) {
        CategoryDto createdCategory = categoryService.createCategory(categoryDto);
        return new ResponseEntity<>(createdCategory, HttpStatus.CREATED);
    }

    @PutMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<CategoryDto> updateCategory(@PathVariable Long id, @Valid @RequestBody CategoryDto categoryDto) {
        CategoryDto updatedCategory = categoryService.updateCategory(id, categoryDto);
        return ResponseEntity.ok(updatedCategory);
    }

    @DeleteMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<Void> deleteCategory(@PathVariable Long id) {
        categoryService.deleteCategory(id);
        return ResponseEntity.noContent().build();
    }
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/controller/CustomerController.java">
package com.magazincomputere.magazin_api.controller;

// import com.magazincomputere.magazin_api.dto.CustomerDto;
// import com.magazincomputere.magazin_api.service.CustomerService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/customers")
@PreAuthorize("hasRole('ADMIN')")
public class CustomerController {

    // @Autowired
    // private CustomerService customerService;

    // @GetMapping
    // public List<CustomerDto> getAllCustomers() {
    //     return customerService.findAllCustomers();
    // }

    // @GetMapping("/{id}")
    // public ResponseEntity<CustomerDto> getCustomerById(@PathVariable Long id) {
    //     return ResponseEntity.ok(customerService.findCustomerById(id));
    // }
    // TODO: Adaugă endpoint-uri pentru UPDATE, DELETE dacă este necesar
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/controller/OrderController.java">
// src/main/java/com/magazincomputere/magazin_api/controller/OrderController.java
package com.magazincomputere.magazin_api.controller;

import com.magazincomputere.magazin_api.dto.OrderDto;
import com.magazincomputere.magazin_api.dto.OrderStatusUpdateDto; // Asigură-te că acest DTO este importat
import com.magazincomputere.magazin_api.model.User; // Nu este folosit direct, dar poate rămâne
import com.magazincomputere.magazin_api.repository.UserRepository; // Nu este folosit direct, dar poate rămâne
import com.magazincomputere.magazin_api.security.services.UserDetailsImpl;
import com.magazincomputere.magazin_api.service.OrderService;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/orders")
public class OrderController {

    @Autowired
    private OrderService orderService;

    // @Autowired // Nu este folosit direct aici, poate fi eliminat dacă nu e necesar pentru altceva
    // private UserRepository userRepository;

    @PostMapping
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<OrderDto> createOrder(@Valid @RequestBody OrderDto orderDto) {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        UserDetailsImpl userDetails = (UserDetailsImpl) authentication.getPrincipal();
        Long userId = userDetails.getId();

        OrderDto createdOrder = orderService.createOrder(orderDto, userId);
        return new ResponseEntity<>(createdOrder, HttpStatus.CREATED);
    }

    @GetMapping("/my-history")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<List<OrderDto>> getMyOrderHistory() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        UserDetailsImpl userDetails = (UserDetailsImpl) authentication.getPrincipal();
        Long userId = userDetails.getId();
        // Folosește numele corect al metodei din OrderService
        List<OrderDto> orders = orderService.getOrdersByUser(userId); // <<< CORECTAT AICI
        return ResponseEntity.ok(orders);
    }

    @GetMapping
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<List<OrderDto>> getAllOrders(@RequestParam(required = false) String status) {
        List<OrderDto> orders = orderService.getAllOrders(status);
        return ResponseEntity.ok(orders);
    }

    @GetMapping("/{orderId}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<OrderDto> getOrderById(@PathVariable Long orderId) {
        OrderDto orderDto = orderService.getOrderById(orderId);
        return ResponseEntity.ok(orderDto);
    }

    @PutMapping("/{orderId}/status")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<OrderDto> updateOrderStatus(
            @PathVariable Long orderId,
            @Valid @RequestBody OrderStatusUpdateDto statusUpdateDto) { // <<< CORECTAT AICI: Primește DTO-ul
        // Transmite DTO-ul la serviciu
        OrderDto updatedOrder = orderService.updateOrderStatus(orderId, statusUpdateDto); // <<< CORECTAT AICI
        return ResponseEntity.ok(updatedOrder);
    }
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/controller/ProductController.java">
package com.magazincomputere.magazin_api.controller;

import com.magazincomputere.magazin_api.dto.ProductDto;
import com.magazincomputere.magazin_api.service.ProductService;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize; // IMPORTĂ
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/products")
public class ProductController {

    @Autowired
    private ProductService productService;

    @GetMapping
    public List<ProductDto> getAllProducts() { // Acces public
        return productService.getAllProducts();
    }

    @GetMapping("/{id}")
    public ResponseEntity<ProductDto> getProductById(@PathVariable Long id) { // Acces public
        return ResponseEntity.ok(productService.getProductById(id));
    }

    @PostMapping
    @PreAuthorize("hasRole('ADMIN')") // Doar ADMIN poate crea produse
    public ResponseEntity<ProductDto> createProduct(@Valid @RequestBody ProductDto productDto) {
        ProductDto createdProduct = productService.createProduct(productDto);
        return new ResponseEntity<>(createdProduct, HttpStatus.CREATED);
    }

    @PutMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')") // Doar ADMIN poate actualiza produse
    public ResponseEntity<ProductDto> updateProduct(@PathVariable Long id, @Valid @RequestBody ProductDto productDto) {
        ProductDto updatedProduct = productService.updateProduct(id, productDto);
        return ResponseEntity.ok(updatedProduct);
    }

    @DeleteMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')") // Doar ADMIN poate șterge produse
    public ResponseEntity<Void> deleteProduct(@PathVariable Long id) {
        productService.deleteProduct(id);
        return ResponseEntity.noContent().build();
    }
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/controller/ReportController.java">
package com.magazincomputere.magazin_api.controller;

import com.magazincomputere.magazin_api.dto.report.*;
import com.magazincomputere.magazin_api.service.ReportService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDate;
import java.time.format.DateTimeFormatter;

@RestController
// Am actualizat ruta de bază pentru a se potrivi cu celelalte controllere de admin
@RequestMapping("/api/admin/reports") 
@PreAuthorize("hasRole('ADMIN')")
public class ReportController {

    @Autowired
    private ReportService reportService;

    // Endpoint pentru a vedea datele raportului în format JSON (util pentru debugging)
    @GetMapping("/general")
    public ResponseEntity<GeneralReportDto> generateGeneralReport(
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate startDate,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate endDate) {
        
        GeneralReportDto report = reportService.generateGeneralReport(startDate, endDate);
        return ResponseEntity.ok(report);
    }
    
    // Endpoint unic și robust pentru descărcarea rapoartelor
    @GetMapping("/download")
    public ResponseEntity<byte[]> downloadReport(
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate startDate,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate endDate,
            @RequestParam String format) {
        
        byte[] reportData;
        String contentType;
        String fileName;

        // Construim un nume de fișier dinamic, care include perioada
        String dateSuffix = startDate.toString() + "_to_" + endDate.toString();

        if ("pdf".equalsIgnoreCase(format)) {
            reportData = reportService.generatePdfReport(startDate, endDate);
            contentType = MediaType.APPLICATION_PDF_VALUE;
            fileName = "Raport_" + dateSuffix + ".pdf";
        } else if ("excel".equalsIgnoreCase(format)) {
            reportData = reportService.generateExcelReport(startDate, endDate);
            contentType = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
            fileName = "Raport_" + dateSuffix + ".xlsx";
        } else {
            // Dacă formatul nu este nici pdf, nici excel, returnăm o eroare
            return ResponseEntity.badRequest().body("Format invalid. Folosiți 'pdf' sau 'excel'.".getBytes());
        }

        // Setăm antetele HTTP corecte pentru a forța descărcarea
        return ResponseEntity.ok()
                .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\"" + fileName + "\"")
                .contentType(MediaType.parseMediaType(contentType))
                .body(reportData);
    }
    
    // Am eliminat celelalte endpoint-uri individuale (/sales, /stock, /users) pentru a simplifica.
    // Acum totul se gestionează prin /general (pentru vizualizare JSON) și /download (pentru descărcare).
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/controller/ReviewController.java">
// backend/src/main/java/com/magazincomputere/magazin_api/controller/ReviewController.java
package com.magazincomputere.magazin_api.controller;

import com.magazincomputere.magazin_api.dto.*;
import com.magazincomputere.magazin_api.security.services.UserDetailsImpl;
import com.magazincomputere.magazin_api.service.ReviewService;
import jakarta.validation.Valid;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/reviews")
public class ReviewController {

    @Autowired
    private ReviewService reviewService;

    @PostMapping
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<ReviewDto> createReview(@Valid @RequestBody CreateReviewRequest request) {
        Long userId = getCurrentUserId();
        ReviewDto review = reviewService.createReview(request, userId);
        return new ResponseEntity<>(review, HttpStatus.CREATED);
    }

    @PutMapping("/{reviewId}")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<ReviewDto> updateReview(
            @PathVariable Long reviewId,
            @Valid @RequestBody CreateReviewRequest request) {
        Long userId = getCurrentUserId();
        ReviewDto review = reviewService.updateReview(reviewId, request, userId);
        return ResponseEntity.ok(review);
    }

    @DeleteMapping("/{reviewId}")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<Void> deleteReview(@PathVariable Long reviewId) {
        Long userId = getCurrentUserId();
        boolean isAdmin = isCurrentUserAdmin();
        reviewService.deleteReview(reviewId, userId, isAdmin);
        return ResponseEntity.noContent().build();
    }

    @GetMapping("/product/{productId}")
    public ResponseEntity<Page<ReviewDto>> getProductReviews(
            @PathVariable Long productId,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size) {
        Page<ReviewDto> reviews = reviewService.getProductReviews(productId, page, size);
        return ResponseEntity.ok(reviews);
    }

    @GetMapping("/product/{productId}/summary")
    public ResponseEntity<ProductReviewSummary> getProductReviewSummary(@PathVariable Long productId) {
        ProductReviewSummary summary = reviewService.getProductReviewSummary(productId);
        return ResponseEntity.ok(summary);
    }

    @GetMapping("/product/{productId}/my-review")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<ReviewDto> getMyReviewForProduct(@PathVariable Long productId) {
        Long userId = getCurrentUserId();
        ReviewDto review = reviewService.getUserReviewForProduct(productId, userId);
        return ResponseEntity.ok(review);
    }

    private Long getCurrentUserId() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        UserDetailsImpl userDetails = (UserDetailsImpl) authentication.getPrincipal();
        return userDetails.getId();
    }

    private boolean isCurrentUserAdmin() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        return authentication.getAuthorities().contains(new SimpleGrantedAuthority("ROLE_ADMIN"));
    }
    @GetMapping("/user/my-reviews")
@PreAuthorize("isAuthenticated()")
public ResponseEntity<List<ReviewDto>> getMyReviews() {
    Long userId = getCurrentUserId();
    List<ReviewDto> reviews = reviewService.getUserReviews(userId);
    return ResponseEntity.ok(reviews);
}
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/controller/SpecificationController.java">
package com.magazincomputere.magazin_api.controller;

import com.magazincomputere.magazin_api.dto.SpecificationDefinitionDto; // Va trebui să creezi acest DTO
import com.magazincomputere.magazin_api.service.SpecificationService; // Va trebui să creezi acest serviciu
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/specifications/definitions") // Am specificat 'definitions' pentru claritate
public class SpecificationController {

    @Autowired
    private SpecificationService specificationService;

    @GetMapping
    public List<SpecificationDefinitionDto> getAllSpecificationDefinitions() { // Acces public
        return specificationService.getAllDefinitions();
    }

    @GetMapping("/{id}")
    public ResponseEntity<SpecificationDefinitionDto> getSpecificationDefinitionById(@PathVariable Long id) { // Acces public
        SpecificationDefinitionDto dto = specificationService.getDefinitionById(id);
        return ResponseEntity.ok(dto);
    }

    @PostMapping
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<SpecificationDefinitionDto> createSpecificationDefinition(@Valid @RequestBody SpecificationDefinitionDto definitionDto) {
        SpecificationDefinitionDto savedDto = specificationService.createDefinition(definitionDto);
        return ResponseEntity.status(HttpStatus.CREATED).body(savedDto);
    }

    @PutMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<SpecificationDefinitionDto> updateSpecificationDefinition(@PathVariable Long id, @Valid @RequestBody SpecificationDefinitionDto definitionDto) {
        SpecificationDefinitionDto updatedDto = specificationService.updateDefinition(id, definitionDto);
        return ResponseEntity.ok(updatedDto);
    }

    @DeleteMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<Void> deleteSpecificationDefinition(@PathVariable Long id) {
        specificationService.deleteDefinition(id);
        return ResponseEntity.noContent().build();
    }
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/controller/UserController.java">
// backend/src/main/java/com/magazincomputere/magazin_api/controller/UserController.java
package com.magazincomputere.magazin_api.controller;

import com.magazincomputere.magazin_api.dto.UserDto;
import com.magazincomputere.magazin_api.dto.UserUpdateDto;
import com.magazincomputere.magazin_api.service.UserService;
import com.magazincomputere.magazin_api.security.services.UserDetailsImpl;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.*;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/users")
public class UserController {

    @Autowired
    private UserService userService;

    // New endpoint for users to get their own profile
    @GetMapping("/me")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<UserDto> getMyProfile() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        UserDetailsImpl userDetails = (UserDetailsImpl) authentication.getPrincipal();
        UserDto userDto = userService.findUserById(userDetails.getId());
        return ResponseEntity.ok(userDto);
    }

    // New endpoint for users to update their own profile
    @PutMapping("/me")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<?> updateMyProfile(
            @Valid @RequestBody UserUpdateDto userUpdateDto,
            BindingResult bindingResult) {
        
        if (bindingResult.hasErrors()) {
            Map<String, String> fieldErrors = new HashMap<>();
            bindingResult.getFieldErrors().forEach(error -> 
                fieldErrors.put(error.getField(), error.getDefaultMessage())
            );
            
            Map<String, Object> errorResponse = new HashMap<>();
            errorResponse.put("message", "Input data validation failed");
            errorResponse.put("fieldErrors", fieldErrors);
            
            return ResponseEntity.badRequest().body(errorResponse);
        }
        
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        UserDetailsImpl userDetails = (UserDetailsImpl) authentication.getPrincipal();
        
        try {
            // For user's own profile update, don't allow role changes
            userUpdateDto.setRoles(null); // Clear any role changes
            UserDto updatedUser = userService.updateUser(userDetails.getId(), userUpdateDto);
            return ResponseEntity.ok(updatedUser);
        } catch (Exception e) {
            Map<String, String> errorResponse = new HashMap<>();
            errorResponse.put("message", e.getMessage());
            return ResponseEntity.badRequest().body(errorResponse);
        }
    }

    // Existing admin endpoints remain unchanged
    @GetMapping
    @PreAuthorize("hasRole('ADMIN')")
    public List<UserDto> getAllUsers() {
        return userService.findAllUsers();
    }

    @GetMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<UserDto> getUserById(@PathVariable Long id) {
        UserDto userDto = userService.findUserById(id);
        return ResponseEntity.ok(userDto);
    }

    @PutMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<?> updateUser(
            @PathVariable Long id, 
            @Valid @RequestBody UserUpdateDto userUpdateDto,
            BindingResult bindingResult) {
        
        if (bindingResult.hasErrors()) {
            Map<String, String> fieldErrors = new HashMap<>();
            bindingResult.getFieldErrors().forEach(error -> 
                fieldErrors.put(error.getField(), error.getDefaultMessage())
            );
            
            Map<String, Object> errorResponse = new HashMap<>();
            errorResponse.put("message", "Input data validation failed");
            errorResponse.put("fieldErrors", fieldErrors);
            
            return ResponseEntity.badRequest().body(errorResponse);
        }
        
        try {
            System.out.println("Updating user " + id + " with data: " + userUpdateDto);
            UserDto updatedUser = userService.updateUser(id, userUpdateDto);
            return ResponseEntity.ok(updatedUser);
        } catch (Exception e) {
            Map<String, String> errorResponse = new HashMap<>();
            errorResponse.put("message", e.getMessage());
            return ResponseEntity.badRequest().body(errorResponse);
        }
    }

    @DeleteMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<Void> deleteUser(@PathVariable Long id) {
        userService.deleteUser(id);
        return ResponseEntity.noContent().build();
    }
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/dto/AddToCartRequest.java">
package com.magazincomputere.magazin_api.dto;

import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotNull;
import lombok.Data;

@Data
public class AddToCartRequest {
    @NotNull(message = "ID-ul produsului este obligatoriu")
    private Long productId;
    
    @NotNull(message = "Cantitatea este obligatorie")
    @Min(value = 1, message = "Cantitatea trebuie să fie cel puțin 1")
    private Integer quantity;
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/dto/CartDto.java">
package com.magazincomputere.magazin_api.dto;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class CartDto {
    private Long id;
    private List<CartItemDto> items;
    private BigDecimal totalAmount;
    private LocalDateTime lastUpdated;
    private Integer totalItems;
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/dto/CartItemDto.java">
package com.magazincomputere.magazin_api.dto;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

import java.math.BigDecimal;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class CartItemDto {
    private Long id;
    private Long productId;
    private String productName;
    private String productDescription;
    private BigDecimal productPrice;
    private Integer productStock;
    private String productImageBase64;
    private Integer quantity;
    private BigDecimal subtotal;
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/dto/CategoryDto.java">
package com.magazincomputere.magazin_api.dto;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class CategoryDto {
    private Long id;

    @NotBlank(message = "Numele categoriei este obligatoriu.")
    @Size(min = 2, max = 100, message = "Numele categoriei trebuie să aibă între 2 și 100 de caractere.")
    private String name;

    @Size(max = 1000, message = "Descrierea categoriei nu poate depăși 1000 de caractere.")
    private String description;
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/dto/CheckoutRequest.java">
package com.magazincomputere.magazin_api.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import lombok.Data;

@Data
public class CheckoutRequest {
    @NotBlank(message = "Numele complet este obligatoriu")
    @Size(max = 100)
    private String fullName;
    
    @NotBlank(message = "Email-ul este obligatoriu")
    @Email(message = "Format email invalid")
    private String email;
    
    @NotBlank(message = "Numărul de telefon este obligatoriu")
    @Pattern(regexp = "^[0-9]{10,15}$", message = "Număr de telefon invalid")
    private String phone;
    
    @NotBlank(message = "Adresa este obligatorie")
    @Size(max = 500)
    private String billingAddress;
    
    private String shippingAddress; // Poate fi diferită de billing address
    
    @NotBlank(message = "Metoda de plată este obligatorie")
    @Pattern(regexp = "^(CARD|CASH_ON_DELIVERY|BANK_TRANSFER)$", message = "Metodă de plată invalidă")
    private String paymentMethod;
    
    private String orderNotes;
    
    private boolean agreeToTerms;
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/dto/CreateReviewRequest.java">
// backend/src/main/java/com/magazincomputere/magazin_api/dto/CreateReviewRequest.java
package com.magazincomputere.magazin_api.dto;

import jakarta.validation.constraints.*;
import lombok.Data;

@Data
public class CreateReviewRequest {
    @NotNull(message = "ID-ul produsului este obligatoriu")
    private Long productId;
    
    @NotNull(message = "Rating-ul este obligatoriu")
    @Min(value = 1, message = "Rating-ul minim este 1")
    @Max(value = 5, message = "Rating-ul maxim este 5")
    private Integer rating;
    
    @Size(max = 100, message = "Titlul nu poate depăși 100 de caractere")
    private String title;
    
    @Size(max = 1000, message = "Comentariul nu poate depăși 1000 de caractere")
    private String comment;
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/dto/CustomerDto.java">
package com.magazincomputere.magazin_api.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.Size;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class CustomerDto { // Acest DTO reflectă mai mult entitatea Customer
    private Long id;
    private Long userId; // Poate fi null dacă un client nu are cont de utilizator

    @Size(max = 100, message = "Prenumele nu poate depăși 100 de caractere.")
    private String firstName;

    @Size(max = 100, message = "Numele de familie nu poate depăși 100 de caractere.")
    private String lastName;

    @Email(message = "Formatul emailului este invalid.")
    @Size(max = 100, message = "Emailul nu poate depăși 100 de caractere.")
    private String email; // Poate fi diferit de emailul User-ului dacă e cazul

    @Size(max = 20, message = "Numărul de telefon nu poate depăși 20 de caractere.")
    private String phone;

    @Size(max = 500, message = "Adresa nu poate depăși 500 de caractere.")
    private String address;
    // Alte câmpuri relevante pentru admin
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/dto/JwtResponse.java">
package com.magazincomputere.magazin_api.dto;

import lombok.Getter;
import lombok.Setter;

import java.util.List;

@Getter
@Setter
public class JwtResponse {
    private String token;
    private String type = "Bearer";
    private Long id;
    private String username;
    private String email;
    private List<String> roles; // Lista de roluri (ex: ["ROLE_USER", "ROLE_ADMIN"])

    public JwtResponse(String accessToken, Long id, String username, String email, List<String> roles) {
        this.token = accessToken;
        this.id = id;
        this.username = username;
        this.email = email;
        this.roles = roles;
    }
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/dto/LoginRequest.java">
package com.magazincomputere.magazin_api.dto;

import jakarta.validation.constraints.NotBlank;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class LoginRequest {
    @NotBlank(message = "Numele de utilizator este obligatoriu.")
    private String username;

    @NotBlank(message = "Parola este obligatorie.")
    private String password;
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/dto/MessageResponse.java">
package com.magazincomputere.magazin_api.dto;

import lombok.Data;
import lombok.AllArgsConstructor;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class MessageResponse {
    private String message;
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/dto/OrderDto.java">
package com.magazincomputere.magazin_api.dto;

import jakarta.validation.Valid;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotEmpty;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class OrderDto {
    // Câmpuri pentru răspuns
    private Long id;
    private Long userId;
    private String username; // Numele utilizatorului care a plasat comanda
    private LocalDateTime orderDate;
    private String status;
    private BigDecimal totalAmount;

    // Câmpuri pentru request și răspuns
    @NotEmpty(message = "Comanda trebuie să conțină cel puțin un produs.")
    @Valid // Asigură validarea fiecărui OrderItemDto din listă
    private List<OrderItemDto> orderItems;

    // Informații de livrare/client (pot fi preluate parțial din profilul utilizatorului)
    @NotBlank(message = "Numele clientului este obligatoriu pentru livrare.")
    @Size(max = 100, message = "Numele clientului este prea lung.")
    private String customerName;

    @NotBlank(message = "Adresa de livrare este obligatorie.")
    @Size(max = 255, message = "Adresa de livrare este prea lungă.")
    private String shippingAddress;

    @NotBlank(message = "Emailul clientului este obligatoriu.")
    @Email(message = "Formatul emailului este invalid.")
    @Size(max = 100)
    private String customerEmail;

    @NotBlank(message = "Numărul de telefon este obligatoriu.")
    @Size(min=10, max = 20, message = "Numărul de telefon are format invalid.")
    private String customerPhone;
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/dto/OrderItemDto.java">
// src/main/java/com/magazincomputere/magazin_api/dto/OrderItemDto.java
package com.magazincomputere.magazin_api.dto;

import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotNull;
import lombok.Data;
import java.math.BigDecimal;

@Data
public class OrderItemDto {
    private Long id;

    @NotNull(message = "ID-ul produsului este obligatoriu")
    private Long productId; // ID-ul produsului original

    private String productNameSnapshot;
    // private String productImageBase64Snapshot; // COMENTAT TEMPORAR

    @NotNull(message = "Cantitatea este obligatorie")
    @Min(value = 1, message = "Cantitatea trebuie să fie cel puțin 1")
    private Integer quantity;

    private BigDecimal priceAtPurchase;
    private BigDecimal lineTotal;
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/dto/OrderStatusUpdateDto.java">
package com.magazincomputere.magazin_api.dto;

import jakarta.validation.constraints.NotBlank;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class OrderStatusUpdateDto {
    @NotBlank(message = "Noua stare a comenzii este obligatorie.")
    private String newStatus;
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/dto/ProductDto.java">
// src/main/java/com/magazincomputere/magazin_api/dto/ProductDto.java
package com.magazincomputere.magazin_api.dto;

import jakarta.validation.constraints.*;
import lombok.Data;
import java.util.List;
import java.math.BigDecimal;


@Data
public class ProductDto {
    private Long id;

    @NotBlank(message = "Numele produsului este obligatoriu")
    @Size(min = 3, max = 255, message = "Numele produsului trebuie să aibă între 3 și 255 de caractere")
    private String name;

    private String description;

    @NotNull(message = "Prețul este obligatoriu")
    @DecimalMin(value = "0.01", message = "Prețul trebuie să fie pozitiv")
    private BigDecimal price;

    @NotNull(message = "Cantitatea în stoc este obligatorie")
    @Min(value = 0, message = "Stocul nu poate fi negativ")
    private Integer stockQuantity;

    // private String imageBase64; // COMENTAT TEMPORAR

    @NotNull(message = "ID-ul categoriei este obligatoriu")
    private Long categoryId;
    private String categoryName;

    private List<SpecificationDto> specifications;
    private Double averageRating;
    private Integer reviewCount;
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/dto/ProductReviewSummary.java">
// backend/src/main/java/com/magazincomputere/magazin_api/dto/ProductReviewSummary.java
package com.magazincomputere.magazin_api.dto;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

import java.util.Map;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ProductReviewSummary {
    private Double averageRating;
    private Integer totalReviews;
    private Map<Integer, Integer> ratingDistribution; // Key: rating (1-5), Value: count
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/dto/report/CategorySalesDto.java">
package com.magazincomputere.magazin_api.dto.report;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import java.math.BigDecimal;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class CategorySalesDto {
    private String category;
    private Integer quantitySold;
    private BigDecimal revenue;
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/dto/report/CategoryStockDto.java">
package com.magazincomputere.magazin_api.dto.report;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import java.math.BigDecimal;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class CategoryStockDto {
    private String category;
    private Integer totalProducts;
    private Integer totalStock;
    private BigDecimal stockValue;
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/dto/report/DailySalesDto.java">
package com.magazincomputere.magazin_api.dto.report;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import java.math.BigDecimal;
import java.time.LocalDate;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class DailySalesDto {
    private LocalDate date;
    private Integer salesCount;
    private BigDecimal revenue;
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/dto/report/GeneralReportDto.java">
package com.magazincomputere.magazin_api.dto.report;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import java.time.LocalDateTime;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class GeneralReportDto {
    private LocalDateTime generatedAt;
    private ReportPeriodDto reportPeriod;
    private SalesReportDto salesReport;
    private StockReportDto stockReport;
    private UserReportDto userReport;
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/dto/report/ProductSalesDto.java">
package com.magazincomputere.magazin_api.dto.report;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import java.math.BigDecimal;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ProductSalesDto {
    private Long productId;
    private String productName;
    private String category;
    private Integer quantitySold;
    private BigDecimal revenue;
    private Integer currentStock;
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/dto/report/ReportPeriodDto.java">
package com.magazincomputere.magazin_api.dto.report;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import java.time.LocalDate;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ReportPeriodDto {
    private LocalDate startDate;
    private LocalDate endDate;
    private String type; // daily, weekly, monthly, yearly, custom
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/dto/report/SalesReportDto.java">
package com.magazincomputere.magazin_api.dto.report;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class SalesReportDto {
    private Integer totalSales;
    private BigDecimal totalRevenue;
    private LocalDate periodStart;
    private LocalDate periodEnd;
    private List<DailySalesDto> dailySales;
    private List<ProductSalesDto> topSellingProducts;
    private List<CategorySalesDto> categorySales;
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/dto/report/StockItemDto.java">
package com.magazincomputere.magazin_api.dto.report;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import java.math.BigDecimal;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class StockItemDto {
    private Long productId;
    private String productName;
    private String category;
    private Integer currentStock;
    private BigDecimal price;
    private BigDecimal stockValue;
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/dto/report/StockReportDto.java">
package com.magazincomputere.magazin_api.dto.report;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import java.math.BigDecimal;
import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class StockReportDto {
    private Integer totalProducts;
    private BigDecimal totalStockValue;
    private List<StockItemDto> lowStockProducts;
    private List<StockItemDto> outOfStockProducts;
    private List<CategoryStockDto> categoryStock;
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/dto/report/UserInfoDto.java">
package com.magazincomputere.magazin_api.dto.report;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import java.time.LocalDateTime;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class UserInfoDto {
    private Long id;
    private String username;
    private String email;
    private LocalDateTime registrationDate;
    private LocalDateTime lastLoginDate;
    private Boolean isActive;
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/dto/report/UserReportDto.java">
package com.magazincomputere.magazin_api.dto.report;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class UserReportDto {
    private Integer totalUsers;
    private Integer activeUsers;
    private Integer newUsersThisMonth;
    private List<UserRoleCountDto> usersByRole;
    private List<UserInfoDto> recentRegistrations;
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/dto/report/UserRoleCountDto.java">
package com.magazincomputere.magazin_api.dto.report;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class UserRoleCountDto {
    private String role;
    private Integer count;
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/dto/ReviewDto.java">
// backend/src/main/java/com/magazincomputere/magazin_api/dto/ReviewDto.java
package com.magazincomputere.magazin_api.dto;

import jakarta.validation.constraints.*;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

import java.time.LocalDateTime;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ReviewDto {
    private Long id;
    private Long productId;
    private String productName;
    private Long userId;
    private String username;
    
    @NotNull(message = "Rating-ul este obligatoriu")
    @Min(value = 1, message = "Rating-ul minim este 1")
    @Max(value = 5, message = "Rating-ul maxim este 5")
    private Integer rating;
    
    @Size(max = 100, message = "Titlul nu poate depăși 100 de caractere")
    private String title;
    
    @Size(max = 1000, message = "Comentariul nu poate depăși 1000 de caractere")
    private String comment;
    
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/dto/SignupRequest.java">
package com.magazincomputere.magazin_api.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

import java.util.Set;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class SignupRequest {
    @NotBlank(message = "Numele de utilizator este obligatoriu.")
    @Size(min = 3, max = 20, message = "Numele de utilizator trebuie să aibă între 3 și 20 de caractere.")
    private String username;

    @NotBlank(message = "Emailul este obligatoriu.")
    @Size(max = 50, message = "Emailul nu poate depăși 50 de caractere.")
    @Email(message = "Formatul emailului este invalid.")
    private String email;

    @NotBlank(message = "Parola este obligatorie.")
    @Size(min = 6, max = 40, message = "Parola trebuie să aibă între 6 și 40 de caractere.")
    private String password;

    // Frontend-ul poate trimite rolurile dorite (ex: la crearea unui admin de către alt admin)
    // Sau acest câmp poate fi ignorat la signup-ul standard al unui client, backend-ul setând rolul USER.
    private Set<String> roles;
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/dto/SpecificationDefinitionDto.java">
package com.magazincomputere.magazin_api.dto;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class SpecificationDefinitionDto {
    private Long id;

    @NotBlank(message = "Numele definiției specificației este obligatoriu.")
    @Size(max = 100)
    private String name;

    @Size(max = 50)
    private String unit; // opțional
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/dto/SpecificationDto.java">
package com.magazincomputere.magazin_api.dto;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class SpecificationDto {
    // Când se trimit datele pentru un produs, definitionId sau name+unit ar trebui să fie prezente.
    // La citire, toate ar putea fi populate.
    private Long definitionId; // ID-ul din SpecificationDefinition (pentru a lega de o definiție existentă)

    @Size(max = 100, message = "Numele specificației nu poate depăși 100 de caractere.")
    // Numele este necesar dacă definitionId nu este furnizat la creare/update specificație pentru produs
    private String name;       // Numele specificației (ex: "RAM")

    @NotBlank(message = "Valoarea specificației este obligatorie.")
    @Size(max = 255, message = "Valoarea specificației nu poate depăși 255 de caractere.")
    private String value;      // Valoarea (ex: "16GB")

    @Size(max = 50, message = "Unitatea de măsură nu poate depăși 50 de caractere.")
    private String unit;       // Opțional (ex: "GB", "MHz")
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/dto/UpdateCartItemRequest.java">
package com.magazincomputere.magazin_api.dto;

import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotNull;
import lombok.Data;

@Data
public class UpdateCartItemRequest {
    @NotNull(message = "Cantitatea este obligatorie")
    @Min(value = 1, message = "Cantitatea trebuie să fie cel puțin 1")
    private Integer quantity;
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/dto/UserDto.java">
package com.magazincomputere.magazin_api.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

import java.util.Set;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class UserDto {
    private Long id;

    // La creare/update, username-ul nu ar trebui să se schimbe ușor după creare.
    // Validările sunt mai importante pentru SignupRequestDto.
    @NotBlank(message = "Numele de utilizator este obligatoriu.")
    @Size(min = 3, max = 20)
    private String username;

    @NotBlank(message = "Emailul este obligatoriu.")
    @Size(max = 50)
    @Email(message = "Formatul emailului este invalid.")
    private String email;

    // Parola nu este expusă în DTO-urile de răspuns.
    // Pentru schimbarea parolei, se va folosi un DTO dedicat.

    private Set<String> roles; // Numele rolurilor, ex: "ROLE_ADMIN", "ROLE_USER"
                               // La update de către admin, acest câmp poate fi modificat.
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/dto/UserUpdateDto.java">
package com.magazincomputere.magazin_api.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

import java.util.Set;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class UserUpdateDto {
    @NotBlank(message = "Emailul este obligatoriu.")
    @Size(max = 50)
    @Email(message = "Formatul emailului este invalid.")
    private String email;

    private Set<String> roles; // Rolurile pot fi opționale la update
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/exception/BadRequestException.java">
package com.magazincomputere.magazin_api.exception;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

@ResponseStatus(HttpStatus.BAD_REQUEST) // Returnează automat 400 Bad Request
public class BadRequestException extends RuntimeException {

    public BadRequestException(String message) {
        super(message);
    }

    public BadRequestException(String message, Throwable cause) {
        super(message, cause);
    }
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/exception/GlobalExceptionHandler.java">
package com.magazincomputere.magazin_api.exception;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.AccessDeniedException; // Pentru erori de autorizare
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.context.request.WebRequest;

import java.time.LocalDateTime; // Folosim LocalDateTime
import java.util.HashMap;
import java.util.Map;
import java.util.stream.Collectors;

@ControllerAdvice // Permite gestionarea centralizată a excepțiilor pentru toate controllerele
public class GlobalExceptionHandler {

    private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class);

    // Handler pentru excepția noastră custom ResourceNotFoundException
    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<ErrorDetails> handleResourceNotFoundException(ResourceNotFoundException ex, WebRequest request) {
        logger.warn("Resource not found: {}", ex.getMessage());
        ErrorDetails errorDetails = new ErrorDetails(
                LocalDateTime.now(),
                HttpStatus.NOT_FOUND.value(),
                "Not Found",
                ex.getMessage(),
                request.getDescription(false) // Calea cererii
        );
        return new ResponseEntity<>(errorDetails, HttpStatus.NOT_FOUND);
    }

    // Handler pentru excepția noastră custom BadRequestException
    @ExceptionHandler(BadRequestException.class)
    public ResponseEntity<ErrorDetails> handleBadRequestException(BadRequestException ex, WebRequest request) {
        logger.warn("Bad request: {}", ex.getMessage());
        ErrorDetails errorDetails = new ErrorDetails(
                LocalDateTime.now(),
                HttpStatus.BAD_REQUEST.value(),
                "Bad Request",
                ex.getMessage(),
                request.getDescription(false)
        );
        return new ResponseEntity<>(errorDetails, HttpStatus.BAD_REQUEST);
    }

    // Handler pentru excepțiile de validare (când @Valid pe un @RequestBody eșuează)
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorDetailsWithFields> handleValidationExceptions(MethodArgumentNotValidException ex, WebRequest request) {
        logger.warn("Validation error: {}", ex.getMessage());
        Map<String, String> fieldErrors = ex.getBindingResult().getFieldErrors().stream()
                .collect(Collectors.toMap(FieldError::getField,
                                          FieldError::getDefaultMessage,
                                          (existingValue, newValue) -> existingValue + "; " + newValue)); // În caz de mai multe erori pe același câmp

        ErrorDetailsWithFields errorDetails = new ErrorDetailsWithFields(
                LocalDateTime.now(),
                HttpStatus.BAD_REQUEST.value(),
                "Validation Failed",
                "Input data validation failed",
                request.getDescription(false),
                fieldErrors
        );
        return new ResponseEntity<>(errorDetails, HttpStatus.BAD_REQUEST);
    }

    // Handler pentru AccessDeniedException (când @PreAuthorize eșuează)
    @ExceptionHandler(AccessDeniedException.class)
    public ResponseEntity<ErrorDetails> handleAccessDeniedException(AccessDeniedException ex, WebRequest request) {
        logger.warn("Access denied: {}", ex.getMessage());
        ErrorDetails errorDetails = new ErrorDetails(
                LocalDateTime.now(),
                HttpStatus.FORBIDDEN.value(),
                "Forbidden",
                "Nu aveți permisiunea de a accesa această resursă.", // Mesaj mai prietenos
                request.getDescription(false)
        );
        return new ResponseEntity<>(errorDetails, HttpStatus.FORBIDDEN);
    }

    // Handler pentru IllegalArgumentException (poate fi util pentru validări de business în servicii)
    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<ErrorDetails> handleIllegalArgumentException(IllegalArgumentException ex, WebRequest request) {
        logger.warn("Illegal argument: {}", ex.getMessage());
        ErrorDetails errorDetails = new ErrorDetails(
                LocalDateTime.now(),
                HttpStatus.BAD_REQUEST.value(),
                "Bad Request",
                ex.getMessage(),
                request.getDescription(false)
        );
        return new ResponseEntity<>(errorDetails, HttpStatus.BAD_REQUEST);
    }


    // Handler generic pentru orice altă excepție neprinsă specific
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorDetails> handleGlobalException(Exception ex, WebRequest request) {
        logger.error("An unexpected error occurred: ", ex); // Loghează stack trace-ul complet pentru erori neașteptate
        ErrorDetails errorDetails = new ErrorDetails(
                LocalDateTime.now(),
                HttpStatus.INTERNAL_SERVER_ERROR.value(),
                "Internal Server Error",
                "A apărut o eroare neașteptată pe server.", // Mesaj generic pentru client
                request.getDescription(false)
        );
        return new ResponseEntity<>(errorDetails, HttpStatus.INTERNAL_SERVER_ERROR);
    }


    // Clasa internă pentru detalii eroare standard
    public static class ErrorDetails {
        private LocalDateTime timestamp;
        private int status;
        private String error;
        private String message;
        private String path;

        public ErrorDetails(LocalDateTime timestamp, int status, String error, String message, String path) {
            this.timestamp = timestamp;
            this.status = status;
            this.error = error;
            this.message = message;
            this.path = path;
        }

        // Getteri
        public LocalDateTime getTimestamp() { return timestamp; }
        public int getStatus() { return status; }
        public String getError() { return error; }
        public String getMessage() { return message; }
        public String getPath() { return path; }
    }

    // Clasa internă pentru detalii eroare cu câmpuri specifice (pentru validare)
    public static class ErrorDetailsWithFields extends ErrorDetails {
        private Map<String, String> fieldErrors;

        public ErrorDetailsWithFields(LocalDateTime timestamp, int status, String error, String message, String path, Map<String, String> fieldErrors) {
            super(timestamp, status, error, message, path);
            this.fieldErrors = fieldErrors;
        }

        // Getter
        public Map<String, String> getFieldErrors() { return fieldErrors; }
    }
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/exception/ResourceNotFoundException.java">
package com.magazincomputere.magazin_api.exception;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

@ResponseStatus(HttpStatus.NOT_FOUND) // Returnează automat 404 Not Found
public class ResourceNotFoundException extends RuntimeException {

    public ResourceNotFoundException(String message) {
        super(message);
    }

    public ResourceNotFoundException(String resourceName, String fieldName, Object fieldValue) {
        super(String.format("%s not found with %s : '%s'", resourceName, fieldName, fieldValue));
    }
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/MagazinApiApplication.java">
package com.magazincomputere.magazin_api;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class MagazinApiApplication {

	public static void main(String[] args) {
		SpringApplication.run(MagazinApiApplication.class, args);
	}

}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/model/Cart.java">
// backend/src/main/java/com/magazincomputere/magazin_api/model/Cart.java
package com.magazincomputere.magazin_api.model;

import jakarta.persistence.*;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.ToString;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "carts")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Cart {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @OneToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", unique = true)
    @ToString.Exclude
    @EqualsAndHashCode.Exclude
    private User user;

    @OneToMany(mappedBy = "cart", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    @ToString.Exclude
    @EqualsAndHashCode.Exclude
    private List<CartItem> items = new ArrayList<>();

    @Column(name = "last_updated")
    private LocalDateTime lastUpdated;

    @Column(name = "session_id")
    private String sessionId; // Pentru coșuri guest

    @PrePersist
    @PreUpdate
    protected void onUpdate() {
        lastUpdated = LocalDateTime.now();
    }

    public BigDecimal getTotalAmount() {
        return items.stream()
            .map(item -> item.getProduct().getPrice().multiply(new BigDecimal(item.getQuantity())))
            .reduce(BigDecimal.ZERO, BigDecimal::add);
    }

    public void clearCart() {
        items.clear();
    }
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/model/CartItem.java">
// backend/src/main/java/com/magazincomputere/magazin_api/model/CartItem.java
package com.magazincomputere.magazin_api.model;

import jakarta.persistence.*;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.ToString;

import java.time.LocalDateTime;

@Entity
@Table(name = "cart_items")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class CartItem {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "cart_id", nullable = false)
    @ToString.Exclude
    @EqualsAndHashCode.Exclude
    private Cart cart;

    @ManyToOne(fetch = FetchType.EAGER)
    @JoinColumn(name = "product_id", nullable = false)
    private Product product;

    @Column(nullable = false)
    private Integer quantity;

    @Column(name = "added_at")
    private LocalDateTime addedAt;

    @PrePersist
    protected void onCreate() {
        addedAt = LocalDateTime.now();
    }
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/model/Category.java">
package com.magazincomputere.magazin_api.model;

import jakarta.persistence.*;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode; // Pentru a gestiona corect relațiile bidirecționale
import lombok.ToString; // Pentru a gestiona corect relațiile bidirecționale

import java.util.List;

@Entity
@Table(name = "categories")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Category {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true, length = 100)
    private String name;

    @Column(length = 1000)
    private String description;

    // Relația One-to-Many cu Product (o categorie poate avea mai multe produse)
    // Comentat pentru a evita problemele de serializare ciclică dacă nu este gestionat atent în DTO-uri
    // Poți decomenta dacă ai nevoie să navighezi de la Category la Products și gestionezi DTO-urile corespunzător.
    // @OneToMany(mappedBy = "category", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    // @ToString.Exclude // Pentru a evita bucle infinite la toString
    // @EqualsAndHashCode.Exclude // Pentru a evita bucle infinite la equals/hashCode
    // private List<Product> products;
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/model/Customer.java">
package com.magazincomputere.magazin_api.model;

import jakarta.persistence.*;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.ToString;

import java.util.List;

@Entity
@Table(name = "customers")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Customer {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(length = 100)
    private String firstName;

    @Column(length = 100)
    private String lastName;

    // Emailul clientului poate fi diferit de cel al contului de utilizator,
    // sau poate fi același. Depinde de logica de business.
    @Column(unique = true, length = 100) // Poate fi null dacă un client nu are cont și face comandă ca guest
    private String email;

    @Column(length = 20)
    private String phone;

    @Lob // Pentru adrese multiple sau mai lungi
    @Column(columnDefinition = "TEXT")
    private String addressDetails; // Poate stoca adresa principală sau un JSON cu mai multe adrese

    // Relație opțională OneToOne cu User (un client poate avea un cont de utilizator)
    @OneToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", referencedColumnName = "id", unique = true) // Poate fi null
    @ToString.Exclude
    @EqualsAndHashCode.Exclude
    private User user;

    // Un client poate avea mai multe comenzi
    @OneToMany(mappedBy = "customer", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    @ToString.Exclude
    @EqualsAndHashCode.Exclude
    private List<Order> orders;
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/model/ERole.java">
package com.magazincomputere.magazin_api.model;

public enum ERole {
    ROLE_USER,  // Pentru clienți standard
    ROLE_ADMIN  // Pentru administratori
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/model/Order.java">
package com.magazincomputere.magazin_api.model;

import jakarta.persistence.*;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.ToString;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "orders") // "order" este adesea un cuvânt cheie SQL, deci "orders" e mai sigur
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Order {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    // Referință către User (dacă utilizatorul este logat) sau Customer (dacă informațiile sunt separate)
    // Alege una dintre următoarele două sau gestionează ambele dacă permiți comenzi guest
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id") // Poate fi null dacă se permite comandă fără cont și se folosește Customer
    @ToString.Exclude
    @EqualsAndHashCode.Exclude
    private User user;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "customer_id", nullable = false) // O comandă trebuie să aibă un client asociat
    @ToString.Exclude
    @EqualsAndHashCode.Exclude
    private Customer customer;

    @Column(nullable = false)
    private LocalDateTime orderDate;

    @Column(nullable = false, length = 50)
    private String status; // Ex: PENDING_PAYMENT, PROCESSING, SHIPPED, DELIVERED, CANCELED, APPROVED

    @Column(nullable = false, precision = 12, scale = 2)
    private BigDecimal totalAmount;

    // Informații denormalizate pentru livrare, chiar dacă există în Customer/User,
    // pentru a păstra adresa exactă la momentul comenzii.
    @Column(nullable = false, length = 255)
    private String shippingAddress;

    @Column(nullable = false, length = 100)
    private String shippingCustomerName;

    @Column(nullable = false, length = 100)
    private String shippingCustomerEmail;

    @Column(nullable = false, length = 20)
    private String shippingCustomerPhone;

    @OneToMany(mappedBy = "order", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    @ToString.Exclude
    @EqualsAndHashCode.Exclude
    private List<OrderItem> orderItems = new ArrayList<>();

    @PrePersist
    protected void onCreate() {
        orderDate = LocalDateTime.now();
        // Poți seta un status inițial aici, de ex. "PENDING_PAYMENT"
        if (status == null) {
            status = "PENDING_CONFIRMATION";
        }
    }
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/model/OrderItem.java">
// src/main/java/com/magazincomputere/magazin_api/model/OrderItem.java
package com.magazincomputere.magazin_api.model;

import java.math.BigDecimal;

import jakarta.persistence.*;
import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Entity
@Table(name = "order_items")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class OrderItem {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "order_id", nullable = false)
    private Order order;

    @NotNull(message = "ID-ul produsului este obligatoriu pentru un articol de comandă")
    @Column(nullable = false)
    private Long productIdSnapshot;

    @NotNull(message = "Numele produsului este obligatoriu")
    @Column(nullable = false)
    private String productNameSnapshot;

    // @Lob
    // @Column(columnDefinition = "TEXT")
    // private String productImageBase64Snapshot; // COMENTAT TEMPORAR

    @NotNull(message = "Cantitatea este obligatorie")
    @Min(value = 1, message = "Cantitatea trebuie să fie cel puțin 1")
    @Column(nullable = false)
    private Integer quantity;

    @NotNull(message = "Prețul la achiziție este obligatoriu")
    @Column(nullable = false)
    private BigDecimal priceAtPurchase;

    @NotNull(message = "Totalul liniei este obligatoriu")
    @Column(nullable = false)
    private BigDecimal lineTotal;
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/model/Product.java">
// src/main/java/com/magazincomputere/magazin_api/model/Product.java
package com.magazincomputere.magazin_api.model;

import jakarta.persistence.*;
import jakarta.validation.constraints.DecimalMin;
import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.ToString;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "products")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class Product {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @NotBlank(message = "Numele produsului este obligatoriu")
    @Size(min = 3, max = 255, message = "Numele produsului trebuie să aibă între 3 și 255 de caractere")
    @Column(nullable = false)
    private String name;

    @Column(columnDefinition = "TEXT")
    private String description;

    @NotNull(message = "Prețul este obligatoriu")
    @DecimalMin(value = "0.01", message = "Prețul trebuie să fie pozitiv")
    @Column(nullable = false)
   private BigDecimal price;

    @NotNull(message = "Cantitatea în stoc este obligatorie")
    @Min(value = 0, message = "Stocul nu poate fi negativ")
    @Column(nullable = false)
    private Integer stockQuantity;

    // @Lob // Adnotarea @Lob este importantă pentru câmpuri mari de tip TEXT în unele baze de date
    // @Column(columnDefinition = "TEXT") // Asigură-te că tipul de coloană este adecvat pentru base64
    // private String imageBase64; // COMENTAT TEMPORAR

    @ManyToOne(fetch = FetchType.EAGER)
    @JoinColumn(name = "category_id", nullable = false)
    @NotNull(message = "Categoria este obligatorie")
    private Category category;

    @OneToMany(mappedBy = "product", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private List<ProductSpecificationValue> specifications;

    public Product(Long id) {
        this.id = id;
    }
    @OneToMany(mappedBy = "product", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
@ToString.Exclude
@EqualsAndHashCode.Exclude
private List<Review> reviews = new ArrayList<>();

@Transient
private Double averageRating;

@Transient
private Integer reviewCount;

// Add a method to calculate average rating
public Double calculateAverageRating() {
    if (reviews == null || reviews.isEmpty()) {
        return 0.0;
    }
    return reviews.stream()
        .mapToInt(Review::getRating)
        .average()
        .orElse(0.0);
}

public Integer getReviewCount() {
    return reviews != null ? reviews.size() : 0;
}
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/model/ProductSpecificationValue.java">
package com.magazincomputere.magazin_api.model;

import jakarta.persistence.*;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.ToString;

@Entity
@Table(name = "product_specification_values", uniqueConstraints = {
    @UniqueConstraint(columnNames = {"product_id", "specification_definition_id"})
})
@Data
@NoArgsConstructor
@AllArgsConstructor
public class ProductSpecificationValue {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "product_id", nullable = false)
    @ToString.Exclude
    @EqualsAndHashCode.Exclude
    private Product product;

    @ManyToOne(fetch = FetchType.EAGER)
    @JoinColumn(name = "specification_definition_id", nullable = false)
    private SpecificationDefinition specificationDefinition;

    @Column(name = "specification_value", nullable = false, length = 255) // AM SCHIMBAT NUMELE COLOANEI AICI
    private String value;
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/model/Review.java">
// backend/src/main/java/com/magazincomputere/magazin_api/model/Review.java
package com.magazincomputere.magazin_api.model;

import jakarta.persistence.*;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.ToString;

import java.time.LocalDateTime;

@Entity
@Table(name = "reviews", uniqueConstraints = {
    @UniqueConstraint(columnNames = {"product_id", "user_id"})
})
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Review {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "product_id", nullable = false)
    @ToString.Exclude
    @EqualsAndHashCode.Exclude
    private Product product;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    @ToString.Exclude
    @EqualsAndHashCode.Exclude
    private User user;

    @Column(nullable = false)
    private Integer rating; // 1-5 stars

    @Column(length = 100)
    private String title;

    @Column(columnDefinition = "TEXT")
    private String comment;

    @Column(name = "created_at", nullable = false)
    private LocalDateTime createdAt;

    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/model/Role.java">
// src/main/java/com/magazincomputere/magazin_api/model/Role.java
package com.magazincomputere.magazin_api.model;

import jakarta.persistence.*;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import org.hibernate.annotations.JdbcTypeCode; // << IMPORTĂ ACEASTA
import org.hibernate.type.SqlTypes;           // << IMPORTĂ ACEASTA

@Entity
@Table(name = "roles")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Role {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;

    @Enumerated(EnumType.STRING)
    @JdbcTypeCode(SqlTypes.VARCHAR) // << ADAUGĂ ACEASTĂ ADNOTARE
    @Column(length = 20, unique = true, nullable = false)
    private ERole name;
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/model/SpecificationDefinition.java">
package com.magazincomputere.magazin_api.model;

import jakarta.persistence.*;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

@Entity
@Table(name = "specification_definitions")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class SpecificationDefinition {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true, length = 100)
    private String name; // Ex: "Procesor", "RAM", "Culoare"

    @Column(length = 50)
    private String unit; // Ex: "GB", "MHz", "inch" (opțional)
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/model/User.java">
package com.magazincomputere.magazin_api.model;

import jakarta.persistence.*;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.ToString;

import java.util.HashSet;
import java.util.Set;
import java.util.List; // Pentru comenzi

@Entity
@Table(name = "users", uniqueConstraints = {
        @UniqueConstraint(columnNames = "username"),
        @UniqueConstraint(columnNames = "email")
})
@Data
@NoArgsConstructor
@AllArgsConstructor
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true, length = 50)
    private String username;

    @Column(nullable = false, unique = true, length = 100)
    private String email;

    @Column(nullable = false, length = 100) // Lungime pentru parola encodată
    private String password;

    @ManyToMany(fetch = FetchType.EAGER) // EAGER pentru a încărca rolurile odată cu utilizatorul
    @JoinTable(name = "user_roles",
            joinColumns = @JoinColumn(name = "user_id"),
            inverseJoinColumns = @JoinColumn(name = "role_id"))
    private Set<Role> roles = new HashSet<>();

    // Relația cu comenzile (un utilizator poate avea mai multe comenzi)
    // @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    // @ToString.Exclude
    // @EqualsAndHashCode.Exclude
    // private List<Order> orders;

    // Relația cu Customer (dacă un User este și Customer)
    // @OneToOne(mappedBy = "user", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    // @ToString.Exclude
    // @EqualsAndHashCode.Exclude
    // private Customer customer;

    public User(String username, String email, String password) {
        this.username = username;
        this.email = email;
        this.password = password;
    }
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/repository/CartItemRepository.java">
package com.magazincomputere.magazin_api.repository;

import com.magazincomputere.magazin_api.model.CartItem;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface CartItemRepository extends JpaRepository<CartItem, Long> {
    Optional<CartItem> findByCartIdAndProductId(Long cartId, Long productId);
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/repository/CartRepository.java">
package com.magazincomputere.magazin_api.repository;

import com.magazincomputere.magazin_api.model.Cart;
import com.magazincomputere.magazin_api.model.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

@Repository
public interface CartRepository extends JpaRepository<Cart, Long> {
    Optional<Cart> findByUser(User user);
    
    Optional<Cart> findByUserId(Long userId);
    
    Optional<Cart> findBySessionId(String sessionId);
    
    
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/repository/CategoryRepository.java">
package com.magazincomputere.magazin_api.repository;

import com.magazincomputere.magazin_api.model.Category;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface CategoryRepository extends JpaRepository<Category, Long> {
    // Găsește o categorie după nume (util pentru a evita duplicate)
    Optional<Category> findByNameIgnoreCase(String name);
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/repository/CustomerRepository.java">
package com.magazincomputere.magazin_api.repository;

import com.magazincomputere.magazin_api.model.Customer;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface CustomerRepository extends JpaRepository<Customer, Long> {
    // Găsește un client după email (dacă emailul este unic și folosit pentru identificare)
    Optional<Customer> findByEmail(String email);

    // Găsește un client după ID-ul utilizatorului asociat
    Optional<Customer> findByUserId(Long userId);
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/repository/OrderItemRepository.java">
// src/main/java/com/magazincomputere/magazin_api/repository/OrderItemRepository.java
package com.magazincomputere.magazin_api.repository;

import com.magazincomputere.magazin_api.model.OrderItem;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

// import java.util.List; // Decomentează dacă adaugi metode custom

@Repository
public interface OrderItemRepository extends JpaRepository<OrderItem, Long> {

    // Spring Data JPA va furniza automat implementările pentru metodele CRUD de bază
    // (save, findById, findAll, delete, etc.) pentru entitatea OrderItem.

    // Poți adăuga metode custom de interogare aici dacă este necesar în viitor.
    // De exemplu, dacă ai vrea să găsești toate articolele unei anumite comenzi
    // direct prin acest repository (deși acest lucru este de obicei gestionat
    // prin colecția `orderItems` din entitatea `Order`):
    // List<OrderItem> findByOrderId(Long orderId);

    // Sau pentru a găsi articolele care conțin un anumit produs (snapshot ID):
    // List<OrderItem> findByProductIdSnapshot(Long productIdSnapshot);
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/repository/OrderRepository.java">
// src/main/java/com/magazincomputere/magazin_api/repository/OrderRepository.java
package com.magazincomputere.magazin_api.repository;

import com.magazincomputere.magazin_api.model.Order;
import com.magazincomputere.magazin_api.model.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface OrderRepository extends JpaRepository<Order, Long> {

    /**
     * Găsește toate comenzile pentru un utilizator specific, ordonate descrescător după data comenzii.
     * @param user Utilizatorul pentru care se caută comenzile.
     * @return O listă de comenzi.
     */
    List<Order> findByUserOrderByOrderDateDesc(User user);

    /**
     * Găsește toate comenzile cu un anumit status, ordonate descrescător după data comenzii.
     * @param status Statusul comenzii.
     * @return O listă de comenzi.
     */
    List<Order> findByStatusOrderByOrderDateDesc(String status);

    /**
     * Găsește toate comenzile, ordonate descrescător după data comenzii.
     * @return O listă cu toate comenzile ordonate.
     */
    List<Order> findAllByOrderByOrderDateDesc();

    // Poți adăuga și alte metode custom de interogare aici dacă este necesar.
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/repository/ProductRepository.java">
package com.magazincomputere.magazin_api.repository;

import com.magazincomputere.magazin_api.model.Product;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor; // Pentru căutare/filtrare complexă
import org.springframework.stereotype.Repository;

import java.math.BigDecimal;
import java.util.List;

@Repository
public interface ProductRepository extends JpaRepository<Product, Long>, JpaSpecificationExecutor<Product> {

    // Găsește produse după ID-ul categoriei
    List<Product> findByCategoryId(Long categoryId);

    // Găsește produse al căror nume conține un anumit string (case-insensitive)
    List<Product> findByNameContainingIgnoreCase(String name);

    // Găsește produse într-un interval de preț
    List<Product> findByPriceBetween(BigDecimal minPrice, BigDecimal maxPrice);

    // Găsește produse după ID categorie și într-un interval de preț
    List<Product> findByCategoryIdAndPriceBetween(Long categoryId, BigDecimal minPrice, BigDecimal maxPrice);

    // Poți adăuga aici și alte metode de interogare bazate pe convențiile de numire Spring Data JPA
    // sau folosind @Query pentru interogări JPQL sau SQL native mai complexe.
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/repository/ProductSpecificationValueRepository.java">
package com.magazincomputere.magazin_api.repository;

import com.magazincomputere.magazin_api.model.ProductSpecificationValue;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface ProductSpecificationValueRepository extends JpaRepository<ProductSpecificationValue, Long> {
    // Găsește toate valorile specificațiilor pentru un anumit produs
    List<ProductSpecificationValue> findByProductId(Long productId);

    // Găsește toate valorile pentru o anumită definiție de specificație
    List<ProductSpecificationValue> findBySpecificationDefinitionId(Long definitionId);

    // Șterge toate valorile specificațiilor pentru un produs (util la actualizarea produsului)
    void deleteByProductId(Long productId);
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/repository/ReviewRepository.java">
// backend/src/main/java/com/magazincomputere/magazin_api/repository/ReviewRepository.java
package com.magazincomputere.magazin_api.repository;

import com.magazincomputere.magazin_api.model.Review;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface ReviewRepository extends JpaRepository<Review, Long> {
    Page<Review> findByProductIdOrderByCreatedAtDesc(Long productId, Pageable pageable);
    
    Optional<Review> findByProductIdAndUserId(Long productId, Long userId);
    
    boolean existsByProductIdAndUserId(Long productId, Long userId);
    
    @Query("SELECT AVG(r.rating) FROM Review r WHERE r.product.id = :productId")
    Double calculateAverageRatingByProductId(@Param("productId") Long productId);
    
    @Query("SELECT COUNT(r) FROM Review r WHERE r.product.id = :productId")
    Integer countByProductId(@Param("productId") Long productId);
    
    @Query("SELECT r.rating, COUNT(r) FROM Review r WHERE r.product.id = :productId GROUP BY r.rating")
    List<Object[]> getRatingDistributionByProductId(@Param("productId") Long productId);

    List<Review> findByUserId(Long userId);
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/repository/RoleRepository.java">
package com.magazincomputere.magazin_api.repository;

import com.magazincomputere.magazin_api.model.ERole;
import com.magazincomputere.magazin_api.model.Role;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface RoleRepository extends JpaRepository<Role, Integer> {
    // Găsește un rol după numele său (enum)
    Optional<Role> findByName(ERole name);
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/repository/SpecificationDefinitionRepository.java">
package com.magazincomputere.magazin_api.repository;

import com.magazincomputere.magazin_api.model.SpecificationDefinition;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface SpecificationDefinitionRepository extends JpaRepository<SpecificationDefinition, Long> {
    // Găsește o definiție de specificație după nume (util pentru a evita duplicate)
    Optional<SpecificationDefinition> findByNameIgnoreCase(String name);
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/repository/UserRepository.java">
package com.magazincomputere.magazin_api.repository;

import com.magazincomputere.magazin_api.model.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    // Găsește un utilizator după username (pentru login și verificare existență)
    Optional<User> findByUsername(String username);

    // Verifică dacă un utilizator există după username
    Boolean existsByUsername(String username);

    // Verifică dacă un utilizator există după email
    Boolean existsByEmail(String email);
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/security/jwt/AuthEntryPointJwt.java">
package com.magazincomputere.magazin_api.security.jwt;

import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.stereotype.Component;

import java.io.IOException;
import com.fasterxml.jackson.databind.ObjectMapper; // Pentru a scrie un răspuns JSON
import java.util.HashMap; // Pentru a crea un corp de răspuns JSON
import java.util.Map; // Pentru a crea un corp de răspuns JSON


@Component
public class AuthEntryPointJwt implements AuthenticationEntryPoint {
    private static final Logger logger = LoggerFactory.getLogger(AuthEntryPointJwt.class);

    @Override
    public void commence(HttpServletRequest request, HttpServletResponse response,
                         AuthenticationException authException) throws IOException, ServletException {
        logger.error("Unauthorized error: {}", authException.getMessage());
        // Trimite un răspuns JSON mai prietenos în loc de eroarea default
        response.setContentType("application/json");
        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);

        final Map<String, Object> body = new HashMap<>();
        body.put("status", HttpServletResponse.SC_UNAUTHORIZED);
        body.put("error", "Unauthorized");
        body.put("message", authException.getMessage());
        body.put("path", request.getServletPath());

        final ObjectMapper mapper = new ObjectMapper();
        mapper.writeValue(response.getOutputStream(), body);
    }
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/security/jwt/JwtAuthTokenFilter.java">
package com.magazincomputere.magazin_api.security.jwt;

import com.magazincomputere.magazin_api.security.services.UserDetailsServiceImpl;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component; // Adaugă @Component pentru a fi un bean gestionat de Spring
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;

@Component // Important pentru ca Spring să poată injecta această clasă în SecurityConfig
public class JwtAuthTokenFilter extends OncePerRequestFilter {
    @Autowired
    private JwtUtils jwtUtils;

    @Autowired
    private UserDetailsServiceImpl userDetailsService;

    private static final Logger logger = LoggerFactory.getLogger(JwtAuthTokenFilter.class);

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException {
        try {
            String jwt = jwtUtils.parseJwt(request);
            if (jwt != null && jwtUtils.validateJwtToken(jwt)) {
                String username = jwtUtils.getUserNameFromJwtToken(jwt);

                UserDetails userDetails = userDetailsService.loadUserByUsername(username);
                UsernamePasswordAuthenticationToken authentication =
                        new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());
                authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));

                SecurityContextHolder.getContext().setAuthentication(authentication);
            }
        } catch (Exception e) {
            logger.error("Cannot set user authentication: {}", e.getMessage());
        }

        filterChain.doFilter(request, response);
    }
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/security/jwt/JwtUtils.java">
package com.magazincomputere.magazin_api.security.jwt; // Asigură-te că pachetul e corect

import com.magazincomputere.magazin_api.security.services.UserDetailsImpl;
import io.jsonwebtoken.*; // Importurile principale JJWT
// Nu mai importăm io.jsonwebtoken.security.Keys pentru această versiune veche
import jakarta.servlet.http.HttpServletRequest;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.Authentication;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;

import javax.crypto.spec.SecretKeySpec; // Necesar pentru crearea cheii în versiuni mai vechi
import java.security.Key; // Interfața Key
import java.util.Base64; // Pentru decodarea cheii dacă e stocată ca Base64
import java.util.Date;

@Component
public class JwtUtils {
    private static final Logger logger = LoggerFactory.getLogger(JwtUtils.class);

    @Value("${app.jwtSecret}")
    private String jwtSecretString; // Asigură-te că e un string simplu sau gestionează decodarea Base64 aici

    @Value("${app.jwtExpirationMs}")
    private int jwtExpirationMs;

    // Metodă adaptată pentru crearea cheii cu JJWT 0.11.x
    private Key getSigningKey() {
        // Dacă jwtSecretString este encodat Base64, va trebui să-l decodezi:
        // byte[] keyBytes = Base64.getDecoder().decode(this.jwtSecretString);
        // Altfel, dacă e un string simplu:
        byte[] keyBytes = jwtSecretString.getBytes();
        // Folosește SignatureAlgorithm.HS512.getJcaName() pentru a obține numele algoritmului
        return new SecretKeySpec(keyBytes, SignatureAlgorithm.HS512.getJcaName());
    }

    public String generateJwtToken(Authentication authentication) {
        UserDetailsImpl userPrincipal = (UserDetailsImpl) authentication.getPrincipal();
        return buildToken(userPrincipal.getUsername());
    }

    public String generateTokenFromUsername(String username) {
        return buildToken(username);
    }

    private String buildToken(String subject) {
         return Jwts.builder()
                 .setSubject(subject)
                 .setIssuedAt(new Date())
                 .setExpiration(new Date((new Date()).getTime() + jwtExpirationMs))
                 .signWith(SignatureAlgorithm.HS512, getSigningKey()) // Sintaxa pentru 0.11.x
                 .compact();
    }

    public String getUserNameFromJwtToken(String token) {
        // Sintaxa pentru 0.11.x - FĂRĂ parserBuilder()
        return Jwts.parser()
                   .setSigningKey(getSigningKey())
                   .parseClaimsJws(token)
                   .getBody()
                   .getSubject();
    }

    public boolean validateJwtToken(String authToken) {
        try {
            // Sintaxa pentru 0.11.x - FĂRĂ parserBuilder()
            Jwts.parser().setSigningKey(getSigningKey()).parseClaimsJws(authToken);
            return true;
        } catch (io.jsonwebtoken.SignatureException e) { // Folosește io.jsonwebtoken.SignatureException
            logger.error("Invalid JWT signature: {}", e.getMessage());
        } catch (MalformedJwtException e) {
            logger.error("Invalid JWT token: {}", e.getMessage());
        } catch (ExpiredJwtException e) {
            logger.error("JWT token is expired: {}", e.getMessage());
        } catch (UnsupportedJwtException e) {
            logger.error("JWT token is unsupported: {}", e.getMessage());
        } catch (IllegalArgumentException e) {
            logger.error("JWT claims string is empty: {}", e.getMessage());
        }
        return false;
    }

    public String parseJwt(HttpServletRequest request) {
        String headerAuth = request.getHeader("Authorization");
        if (StringUtils.hasText(headerAuth) && headerAuth.startsWith("Bearer ")) {
            return headerAuth.substring(7);
        }
        return null;
    }
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/security/services/UserDetailsImpl.java">
package com.magazincomputere.magazin_api.security.services;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.magazincomputere.magazin_api.model.User;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import java.util.Collection;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

public class UserDetailsImpl implements UserDetails {
    private static final long serialVersionUID = 1L;

    private Long id;
    private String username;
    private String email;
    @JsonIgnore
    private String password;

    private Collection<? extends GrantedAuthority> authorities;

    public UserDetailsImpl(Long id, String username, String email, String password,
                           Collection<? extends GrantedAuthority> authorities) {
        this.id = id;
        this.username = username;
        this.email = email;
        this.password = password;
        this.authorities = authorities;
    }

    public static UserDetailsImpl build(User user) {
        List<GrantedAuthority> authorities = user.getRoles().stream()
                .map(role -> new SimpleGrantedAuthority(role.getName().name()))
                .collect(Collectors.toList());

        return new UserDetailsImpl(
                user.getId(),
                user.getUsername(),
                user.getEmail(),
                user.getPassword(),
                authorities);
    }

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return authorities;
    }

    public Long getId() {
        return id;
    }

    public String getEmail() {
        return email;
    }

    @Override
    public String getPassword() {
        return password;
    }

    @Override
    public String getUsername() {
        return username;
    }

    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

    @Override
    public boolean isAccountNonLocked() {
        return true;
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

    @Override
    public boolean isEnabled() {
        return true;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        UserDetailsImpl user = (UserDetailsImpl) o;
        return Objects.equals(id, user.id);
    }
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/security/services/UserDetailsServiceImpl.java">
package com.magazincomputere.magazin_api.security.services;

import com.magazincomputere.magazin_api.model.User;
import com.magazincomputere.magazin_api.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class UserDetailsServiceImpl implements UserDetailsService {
    @Autowired
    UserRepository userRepository;

    @Override
    @Transactional
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        User user = userRepository.findByUsername(username)
                .orElseThrow(() -> new UsernameNotFoundException("User Not Found with username: " + username));

        return UserDetailsImpl.build(user);
    }
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/service/CartService.java">
// backend/src/main/java/com/magazincomputere/magazin_api/service/CartService.java
package com.magazincomputere.magazin_api.service;

import com.magazincomputere.magazin_api.dto.*;
import com.magazincomputere.magazin_api.exception.BadRequestException;
import com.magazincomputere.magazin_api.exception.ResourceNotFoundException;
import com.magazincomputere.magazin_api.model.*;
import com.magazincomputere.magazin_api.repository.*;
import jakarta.transaction.Transactional;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.math.BigDecimal;
import java.util.stream.Collectors;

@Service
public class CartService {

    @Autowired
    private CartRepository cartRepository;
    
    @Autowired
    private CartItemRepository cartItemRepository;
    
    @Autowired
    private ProductRepository productRepository;
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private OrderService orderService;

    @Transactional
    public CartDto getCartByUserId(Long userId) {
        Cart cart = cartRepository.findByUserId(userId)
            .orElseGet(() -> createNewCart(userId));
        return convertToDto(cart);
    }

    @Transactional
    public CartDto addToCart(Long userId, AddToCartRequest request) {
        Cart cart = cartRepository.findByUserId(userId)
            .orElseGet(() -> createNewCart(userId));
            
        Product product = productRepository.findById(request.getProductId())
            .orElseThrow(() -> new ResourceNotFoundException("Product not found with id: " + request.getProductId()));
            
        if (product.getStockQuantity() < request.getQuantity()) {
            throw new BadRequestException("Insufficient stock. Available: " + product.getStockQuantity());
        }
        
        CartItem existingItem = cart.getItems().stream()
            .filter(item -> item.getProduct().getId().equals(request.getProductId()))
            .findFirst()
            .orElse(null);
            
        if (existingItem != null) {
            int newQuantity = existingItem.getQuantity() + request.getQuantity();
            if (product.getStockQuantity() < newQuantity) {
                throw new BadRequestException("Insufficient stock. Available: " + product.getStockQuantity());
            }
            existingItem.setQuantity(newQuantity);
        } else {
            CartItem newItem = new CartItem();
            newItem.setCart(cart);
            newItem.setProduct(product);
            newItem.setQuantity(request.getQuantity());
            cart.getItems().add(newItem);
        }
        
        cart = cartRepository.save(cart);
        return convertToDto(cart);
    }

    @Transactional
    public CartDto updateCartItem(Long userId, Long productId, UpdateCartItemRequest request) {
        Cart cart = cartRepository.findByUserId(userId)
            .orElseThrow(() -> new ResourceNotFoundException("Cart not found for user"));
            
        CartItem item = cart.getItems().stream()
            .filter(cartItem -> cartItem.getProduct().getId().equals(productId))
            .findFirst()
            .orElseThrow(() -> new ResourceNotFoundException("Product not found in cart"));
            
        if (item.getProduct().getStockQuantity() < request.getQuantity()) {
            throw new BadRequestException("Insufficient stock. Available: " + item.getProduct().getStockQuantity());
        }
        
        item.setQuantity(request.getQuantity());
        cart = cartRepository.save(cart);
        return convertToDto(cart);
    }

    @Transactional
    public CartDto removeFromCart(Long userId, Long productId) {
        Cart cart = cartRepository.findByUserId(userId)
            .orElseThrow(() -> new ResourceNotFoundException("Cart not found for user"));
            
        cart.getItems().removeIf(item -> item.getProduct().getId().equals(productId));
        cart = cartRepository.save(cart);
        return convertToDto(cart);
    }

    @Transactional
    public void clearCart(Long userId) {
        Cart cart = cartRepository.findByUserId(userId)
            .orElseThrow(() -> new ResourceNotFoundException("Cart not found for user"));
        cart.clearCart();
        cartRepository.save(cart);
    }

    @Transactional
    public OrderDto checkout(Long userId, CheckoutRequest request) {
        Cart cart = cartRepository.findByUserId(userId)
            .orElseThrow(() -> new ResourceNotFoundException("Cart not found for user"));
            
        if (cart.getItems().isEmpty()) {
            throw new BadRequestException("Cart is empty");
        }
        
        if (!request.isAgreeToTerms()) {
            throw new BadRequestException("You must agree to terms and conditions");
        }
        
        // Validare stoc pentru toate produsele
        for (CartItem item : cart.getItems()) {
            if (item.getProduct().getStockQuantity() < item.getQuantity()) {
                throw new BadRequestException("Insufficient stock for product: " + item.getProduct().getName());
            }
        }
        
        // Creare comandă
        OrderDto orderDto = new OrderDto();
        orderDto.setCustomerName(request.getFullName());
        orderDto.setCustomerEmail(request.getEmail());
        orderDto.setCustomerPhone(request.getPhone());
        orderDto.setShippingAddress(request.getShippingAddress() != null ? 
            request.getShippingAddress() : request.getBillingAddress());
        
        // Convertire cart items la order items
        orderDto.setOrderItems(cart.getItems().stream().map(cartItem -> {
            OrderItemDto orderItem = new OrderItemDto();
            orderItem.setProductId(cartItem.getProduct().getId());
            orderItem.setQuantity(cartItem.getQuantity());
            return orderItem;
        }).collect(Collectors.toList()));
        
        // Plasare comandă
        OrderDto createdOrder = orderService.createOrder(orderDto, userId);
        
        // Golire coș după comandă reușită
        clearCart(userId);
        
        return createdOrder;
    }

    private Cart createNewCart(Long userId) {
        User user = userRepository.findById(userId)
            .orElseThrow(() -> new ResourceNotFoundException("User not found with id: " + userId));
            
        Cart cart = new Cart();
        cart.setUser(user);
        return cartRepository.save(cart);
    }

    private CartDto convertToDto(Cart cart) {
        CartDto dto = new CartDto();
        dto.setId(cart.getId());
        dto.setLastUpdated(cart.getLastUpdated());
        dto.setTotalAmount(cart.getTotalAmount());
        dto.setTotalItems(cart.getItems().stream()
            .mapToInt(CartItem::getQuantity)
            .sum());
        
        dto.setItems(cart.getItems().stream().map(item -> {
            CartItemDto itemDto = new CartItemDto();
            itemDto.setId(item.getId());
            itemDto.setProductId(item.getProduct().getId());
            itemDto.setProductName(item.getProduct().getName());
            itemDto.setProductDescription(item.getProduct().getDescription());
            itemDto.setProductPrice(item.getProduct().getPrice());
            itemDto.setProductStock(item.getProduct().getStockQuantity());
            // itemDto.setProductImageBase64(item.getProduct().getImageBase64());
            itemDto.setQuantity(item.getQuantity());
            itemDto.setSubtotal(item.getProduct().getPrice().multiply(new BigDecimal(item.getQuantity())));
            return itemDto;
        }).collect(Collectors.toList()));
        
        return dto;
    }
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/service/CategoryService.java">
package com.magazincomputere.magazin_api.service;

import com.magazincomputere.magazin_api.dto.CategoryDto;
import com.magazincomputere.magazin_api.exception.ResourceNotFoundException;
import com.magazincomputere.magazin_api.model.Category;
import com.magazincomputere.magazin_api.repository.CategoryRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.stream.Collectors;

@Service
public class CategoryService {

    @Autowired
    private CategoryRepository categoryRepository;

    // --- Metode de conversie DTO <-> Entity ---
    private CategoryDto convertToDto(Category category) {
        CategoryDto dto = new CategoryDto();
        dto.setId(category.getId());
        dto.setName(category.getName());
        dto.setDescription(category.getDescription());
        return dto;
    }

    // Această metodă modifică direct obiectul 'category' pasat
    private void updateEntityFromDto(CategoryDto categoryDto, Category category) {
        category.setName(categoryDto.getName());
        category.setDescription(categoryDto.getDescription());
    }
    // --- Sfârșit metode de conversie ---

    @Transactional(readOnly = true)
    public List<CategoryDto> getAllCategories() {
        return categoryRepository.findAll().stream()
                .map(this::convertToDto)
                .collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public CategoryDto getCategoryById(Long id) {
        Category category = categoryRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Category", "id", id));
        return convertToDto(category);
    }

    @Transactional
    public CategoryDto createCategory(CategoryDto categoryDto) {
        categoryRepository.findByNameIgnoreCase(categoryDto.getName()).ifPresent(existingCategory -> {
            throw new IllegalArgumentException("Category with name '" + existingCategory.getName() + "' already exists.");
        });
        Category category = new Category();
        updateEntityFromDto(categoryDto, category); // Folosim metoda care nu returnează pentru claritate
        Category savedCategory = categoryRepository.save(category);
        return convertToDto(savedCategory);
    }

    @Transactional
    public CategoryDto updateCategory(Long id, CategoryDto categoryDto) {
        // Pasul 1: Găsește entitatea existentă
        Category existingCategory = categoryRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Category", "id", id));

        // Pasul 2: Verifică dacă noul nume este deja folosit de altă categorie
        // Folosim o variabilă finală sau effectively final pentru ID-ul categoriei existente în lambda
        final Long existingCategoryId = existingCategory.getId();
        categoryRepository.findByNameIgnoreCase(categoryDto.getName()).ifPresent(catWithSameName -> {
            if (!catWithSameName.getId().equals(existingCategoryId)) {
                throw new IllegalArgumentException("Another category with name '" + catWithSameName.getName() + "' already exists.");
            }
        });

        // Pasul 3: Actualizează câmpurile entității existente cu datele din DTO
        // Nu re-atribuim existingCategory, ci îi modificăm starea.
        updateEntityFromDto(categoryDto, existingCategory);

        // Pasul 4: Salvează entitatea actualizată
        Category updatedCategory = categoryRepository.save(existingCategory);

        // Pasul 5: Converteste entitatea actualizată în DTO și returneaz-o
        return convertToDto(updatedCategory);
    }

    @Transactional
    public void deleteCategory(Long id) {
        Category category = categoryRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Category", "id", id));
        
        // TODO: Adaugă logica de verificare dacă există produse în această categorie înainte de ștergere
        // De exemplu: if (!productRepository.findByCategoryId(id).isEmpty()) { throw new BadRequestException("Cannot delete category with products."); }
        categoryRepository.delete(category);
    }
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/service/CustomerService.java">
package com.magazincomputere.magazin_api.service;

import com.magazincomputere.magazin_api.dto.CustomerDto;
import com.magazincomputere.magazin_api.exception.ResourceNotFoundException;
import com.magazincomputere.magazin_api.model.Customer;
import com.magazincomputere.magazin_api.repository.CustomerRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.stream.Collectors;

@Service
public class CustomerService {

    @Autowired
    private CustomerRepository customerRepository;
    // @Autowired private UserRepository userRepository; // Dacă e nevoie să legi de User

    private CustomerDto convertToDto(Customer customer) {
        CustomerDto dto = new CustomerDto();
        dto.setId(customer.getId());
        if (customer.getUser() != null) {
            dto.setUserId(customer.getUser().getId());
        }
        dto.setFirstName(customer.getFirstName());
        dto.setLastName(customer.getLastName());
        dto.setEmail(customer.getEmail());
        dto.setPhone(customer.getPhone());
        dto.setAddress(customer.getAddressDetails());
        return dto;
    }

    private Customer convertToEntity(CustomerDto dto, Customer customer) {
        // Nu setăm User aici, se face la creare/asociere
        customer.setFirstName(dto.getFirstName());
        customer.setLastName(dto.getLastName());
        customer.setEmail(dto.getEmail());
        customer.setPhone(dto.getPhone());
        customer.setAddressDetails(dto.getAddress());
        return customer;
    }

    @Transactional(readOnly = true)
    public List<CustomerDto> findAllCustomers() {
        return customerRepository.findAll().stream().map(this::convertToDto).collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public CustomerDto findCustomerById(Long id) {
        Customer customer = customerRepository.findById(id)
            .orElseThrow(() -> new ResourceNotFoundException("Customer not found with id: " + id));
        return convertToDto(customer);
    }

    // Crearea de Customer se poate face și implicit la prima comandă a unui User,
    // sau explicit de către un admin.
    // @Transactional
    // public CustomerDto createCustomer(CustomerDto customerDto) {
    //     Customer customer = new Customer();
    //     // Dacă se trimite userId, asociază-l
    //     if (customerDto.getUserId() != null) {
    //         User user = userRepository.findById(customerDto.getUserId()).orElse(null);
    //         customer.setUser(user);
    //     }
    //     customer = convertToEntity(customerDto, customer);
    //     return convertToDto(customerRepository.save(customer));
    // }

    // @Transactional
    // public CustomerDto updateCustomer(Long id, CustomerDto customerDto) {
    //     Customer existingCustomer = customerRepository.findById(id)
    //         .orElseThrow(() -> new ResourceNotFoundException("Customer not found with id: " + id));
    //     existingCustomer = convertToEntity(customerDto, existingCustomer);
    //     return convertToDto(customerRepository.save(existingCustomer));
    // }

    // @Transactional
    // public void deleteCustomer(Long id){
    //      if(!customerRepository.existsById(id)){
    //          throw new ResourceNotFoundException("Customer not found with id: " + id);
    //      }
    //      // Verifică dacă clientul are comenzi înainte de ștergere
    //      customerRepository.deleteById(id);
    // }

}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/service/OrderService.java">
// src/main/java/com/magazincomputere/magazin_api/service/OrderService.java
package com.magazincomputere.magazin_api.service;

import com.magazincomputere.magazin_api.dto.OrderDto;
import com.magazincomputere.magazin_api.dto.OrderItemDto;
import com.magazincomputere.magazin_api.dto.OrderStatusUpdateDto;
import com.magazincomputere.magazin_api.exception.BadRequestException;
import com.magazincomputere.magazin_api.exception.ResourceNotFoundException;
import com.magazincomputere.magazin_api.model.*;
import com.magazincomputere.magazin_api.repository.*;
import jakarta.transaction.Transactional;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

@Service
public class OrderService {

    @Autowired
    private OrderRepository orderRepository;

    // @Autowired // Comentat - presupunem salvare prin cascadă din Order
    // private OrderItemRepository orderItemRepository; 

    @Autowired
    private ProductRepository productRepository;

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private CustomerRepository customerRepository;

    private OrderDto convertToDto(Order order) {
        OrderDto orderDto = new OrderDto();
        orderDto.setId(order.getId());
        if (order.getUser() != null) {
            orderDto.setUserId(order.getUser().getId());
            orderDto.setUsername(order.getUser().getUsername());
        } else if (order.getCustomer() != null) {
             orderDto.setUsername(order.getCustomer().getFirstName() + " " + order.getCustomer().getLastName());
        }
        orderDto.setOrderDate(order.getOrderDate());
        orderDto.setStatus(order.getStatus());
        orderDto.setTotalAmount(order.getTotalAmount()); // Direct BigDecimal to BigDecimal


        orderDto.setCustomerName(order.getShippingCustomerName());
        orderDto.setShippingAddress(order.getShippingAddress());
        orderDto.setCustomerEmail(order.getShippingCustomerEmail());
        orderDto.setCustomerPhone(order.getShippingCustomerPhone());

        if (order.getOrderItems() != null) {
            orderDto.setOrderItems(order.getOrderItems().stream()
                    .map(this::convertOrderItemToDto)
                    .collect(Collectors.toList()));
        }
        return orderDto;
    }

    private OrderItemDto convertOrderItemToDto(OrderItem orderItem) {
        OrderItemDto dto = new OrderItemDto();
        dto.setId(orderItem.getId());
        dto.setProductId(orderItem.getProductIdSnapshot());
        dto.setProductNameSnapshot(orderItem.getProductNameSnapshot());
        dto.setQuantity(orderItem.getQuantity());
        dto.setPriceAtPurchase(orderItem.getPriceAtPurchase()); // Direct BigDecimal to BigDecimal
        dto.setLineTotal(orderItem.getLineTotal()); // Direct BigDecimal to BigDecimal
        return dto;
    }


    @Transactional
    public OrderDto createOrder(OrderDto orderDto, Long userId) {
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new ResourceNotFoundException("User not found with id: " + userId));

        Customer customer = customerRepository.findByUserId(userId).orElseGet(() -> {
            Customer newCustomer = new Customer();
            newCustomer.setUser(user);
            newCustomer.setEmail(orderDto.getCustomerEmail());
            String[] nameParts = orderDto.getCustomerName().split(" ", 2);
            newCustomer.setFirstName(nameParts.length > 0 ? nameParts[0] : orderDto.getCustomerName());
            if (nameParts.length > 1) newCustomer.setLastName(nameParts[1]); else newCustomer.setLastName("");
            newCustomer.setPhone(orderDto.getCustomerPhone());
            newCustomer.setAddressDetails(orderDto.getShippingAddress());
            return customerRepository.save(newCustomer);
        });

        Order order = new Order();
        order.setUser(user);
        order.setCustomer(customer);
        order.setShippingCustomerName(orderDto.getCustomerName());
        order.setShippingAddress(orderDto.getShippingAddress());
        order.setShippingCustomerEmail(orderDto.getCustomerEmail());
        order.setShippingCustomerPhone(orderDto.getCustomerPhone());

        List<OrderItem> orderItemsList = new ArrayList<>();
        BigDecimal totalOrderAmount = BigDecimal.ZERO;

        if (orderDto.getOrderItems() == null || orderDto.getOrderItems().isEmpty()) {
            throw new BadRequestException("Order must contain at least one item.");
        }

        for (OrderItemDto itemDto : orderDto.getOrderItems()) {
            Product product = productRepository.findById(itemDto.getProductId())
                    .orElseThrow(() -> new ResourceNotFoundException("Product not found with id: " + itemDto.getProductId()));

            if (product.getStockQuantity() < itemDto.getQuantity()) {
                throw new BadRequestException("Insufficient stock for product: " + product.getName());
            }

            OrderItem orderItem = new OrderItem();
            orderItem.setOrder(order);
            orderItem.setProductIdSnapshot(product.getId());
            orderItem.setProductNameSnapshot(product.getName());
            orderItem.setQuantity(itemDto.getQuantity());
            
            // Acum `product.getPrice()` este deja BigDecimal
            BigDecimal itemPrice = product.getPrice(); 
            orderItem.setPriceAtPurchase(itemPrice); // Setează direct BigDecimal

            BigDecimal quantity = new BigDecimal(itemDto.getQuantity());
            BigDecimal lineTotal = itemPrice.multiply(quantity); 
            
            orderItem.setLineTotal(lineTotal); // Setează direct BigDecimal

            orderItemsList.add(orderItem);
            totalOrderAmount = totalOrderAmount.add(lineTotal);

            product.setStockQuantity(product.getStockQuantity() - itemDto.getQuantity());
            productRepository.save(product);
        }

        order.setOrderItems(orderItemsList);
        order.setTotalAmount(totalOrderAmount); // Setează direct BigDecimal

        Order savedOrder = orderRepository.save(order);
        return convertToDto(savedOrder);
    }

    public List<OrderDto> getOrdersByUser(Long userId) {
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new ResourceNotFoundException("User not found with id: " + userId));
        return orderRepository.findByUserOrderByOrderDateDesc(user)
                .stream()
                .map(this::convertToDto)
                .collect(Collectors.toList());
    }

    public List<OrderDto> getAllOrders(String status) {
        List<Order> orders;
        if (status != null && !status.trim().isEmpty()) {
            orders = orderRepository.findByStatusOrderByOrderDateDesc(status);
        } else {
            orders = orderRepository.findAllByOrderByOrderDateDesc();
        }
        return orders.stream().map(this::convertToDto).collect(Collectors.toList());
    }
     public OrderDto getOrderById(Long orderId) {
        Order order = orderRepository.findById(orderId)
                .orElseThrow(() -> new ResourceNotFoundException("Order not found with id: " + orderId));
        return convertToDto(order);
    }

    @Transactional
    public OrderDto updateOrderStatus(Long orderId, OrderStatusUpdateDto statusUpdateDto) {
        Order order = orderRepository.findById(orderId)
                .orElseThrow(() -> new ResourceNotFoundException("Order not found with id: " + orderId));

        // TODO: Adaugă validare pentru tranzițiile de status permise, dacă e necesar
        order.setStatus(statusUpdateDto.getNewStatus().toUpperCase());
        Order updatedOrder = orderRepository.save(order);
        return convertToDto(updatedOrder);
    }
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/service/ProductService.java">
package com.magazincomputere.magazin_api.service;

import com.magazincomputere.magazin_api.dto.ProductDto;
import com.magazincomputere.magazin_api.dto.SpecificationDto;
import com.magazincomputere.magazin_api.exception.ResourceNotFoundException;
import com.magazincomputere.magazin_api.model.Category;
import com.magazincomputere.magazin_api.model.Product;
import com.magazincomputere.magazin_api.model.ProductSpecificationValue;
import com.magazincomputere.magazin_api.model.SpecificationDefinition;
import com.magazincomputere.magazin_api.repository.CategoryRepository;
import com.magazincomputere.magazin_api.repository.ProductRepository;
import com.magazincomputere.magazin_api.repository.ProductSpecificationValueRepository;
import com.magazincomputere.magazin_api.repository.SpecificationDefinitionRepository;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

@Service
public class ProductService {

    private final ProductRepository productRepository;
    private final CategoryRepository categoryRepository;
    private final SpecificationDefinitionRepository specDefRepository;
    private final ProductSpecificationValueRepository specValueRepository;

    public ProductService(ProductRepository productRepository, CategoryRepository categoryRepository, SpecificationDefinitionRepository specDefRepository, ProductSpecificationValueRepository specValueRepository) {
        this.productRepository = productRepository;
        this.categoryRepository = categoryRepository;
        this.specDefRepository = specDefRepository;
        this.specValueRepository = specValueRepository;
    }

    public List<ProductDto> getAllProducts() {
        return productRepository.findAll().stream()
                .map(this::mapToDto)
                .collect(Collectors.toList());
    }

    public ProductDto getProductById(Long id) {
        Product product = productRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Product not found with id: " + id));
        return mapToDto(product);
    }

    @Transactional
    public ProductDto createProduct(ProductDto productDto) {
        Product product = new Product();
        product.setName(productDto.getName());
        product.setDescription(productDto.getDescription());
        product.setPrice(productDto.getPrice());
        // MODIFICARE: Adăugăm stockQuantity la creare
        product.setStockQuantity(productDto.getStockQuantity());
        
        Category category = categoryRepository.findById(productDto.getCategoryId())
                .orElseThrow(() -> new ResourceNotFoundException("Category not found"));
        product.setCategory(category);
        
        Product savedProduct = productRepository.save(product);

        if (productDto.getSpecifications() != null) {
            for (SpecificationDto specDto : productDto.getSpecifications()) {
                SpecificationDefinition specDef = specDefRepository.findById(specDto.getDefinitionId())
                        .orElseThrow(() -> new ResourceNotFoundException("Specification Definition not found"));

                ProductSpecificationValue specValue = new ProductSpecificationValue();
                specValue.setProduct(savedProduct);
                specValue.setSpecificationDefinition(specDef);
                specValue.setValue(specDto.getValue());
                
                specValueRepository.save(specValue);
            }
        }
        return mapToDto(productRepository.findById(savedProduct.getId()).get());
    }

    @Transactional
    public ProductDto updateProduct(Long id, ProductDto productDto) {
        Product existingProduct = productRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Product not found with id: " + id));

        existingProduct.setName(productDto.getName());
        existingProduct.setDescription(productDto.getDescription());
        existingProduct.setPrice(productDto.getPrice());
        // MODIFICARE: Adăugăm stockQuantity la actualizare
        existingProduct.setStockQuantity(productDto.getStockQuantity());

        if (!existingProduct.getCategory().getId().equals(productDto.getCategoryId())) {
            Category newCategory = categoryRepository.findById(productDto.getCategoryId())
                    .orElseThrow(() -> new ResourceNotFoundException("Category not found"));
            existingProduct.setCategory(newCategory);
        }
        
        specValueRepository.deleteAll(existingProduct.getSpecifications());
        existingProduct.getSpecifications().clear();
        productRepository.saveAndFlush(existingProduct);

        if (productDto.getSpecifications() != null) {
            for (SpecificationDto specDto : productDto.getSpecifications()) {
                SpecificationDefinition specDef = specDefRepository.findById(specDto.getDefinitionId())
                        .orElseThrow(() -> new ResourceNotFoundException("Specification Definition not found"));
                
                ProductSpecificationValue specValue = new ProductSpecificationValue();
                specValue.setProduct(existingProduct);
                specValue.setSpecificationDefinition(specDef);
                specValue.setValue(specDto.getValue());
                
                existingProduct.getSpecifications().add(specValue);
            }
        }
        
        Product updatedProduct = productRepository.save(existingProduct);
        return mapToDto(updatedProduct);
    }

    public void deleteProduct(Long id) {
        if (!productRepository.existsById(id)) {
            throw new ResourceNotFoundException("Product not found with id: " + id);
        }
        productRepository.deleteById(id);
    }
    
    // Update the mapToDto method in ProductService to include review data:

private ProductDto mapToDto(Product product) {
    ProductDto dto = new ProductDto();
    dto.setId(product.getId());
    dto.setName(product.getName());
    dto.setDescription(product.getDescription());
    dto.setPrice(product.getPrice());
    dto.setStockQuantity(product.getStockQuantity());
    dto.setCategoryId(product.getCategory().getId());
    dto.setCategoryName(product.getCategory().getName());
    
    // Add review data
    dto.setAverageRating(product.calculateAverageRating());
    dto.setReviewCount(product.getReviewCount());

    if (product.getSpecifications() != null) {
        dto.setSpecifications(product.getSpecifications().stream().map(specValue -> {
            SpecificationDto specDto = new SpecificationDto();
            specDto.setDefinitionId(specValue.getSpecificationDefinition().getId());
            specDto.setName(specValue.getSpecificationDefinition().getName());
            specDto.setValue(specValue.getValue());
            return specDto;
        }).collect(Collectors.toList()));
    } else {
        dto.setSpecifications(new ArrayList<>());
    }
    return dto;
}
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/service/ReportService.java">
package com.magazincomputere.magazin_api.service;

import com.magazincomputere.magazin_api.dto.report.*;
import com.magazincomputere.magazin_api.model.*;
import com.magazincomputere.magazin_api.repository.*;

// Excel imports
import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.apache.poi.ss.util.CellRangeAddress;

// PDF imports
import com.itextpdf.kernel.pdf.PdfDocument;
import com.itextpdf.kernel.pdf.PdfWriter;
import com.itextpdf.layout.Document;
import com.itextpdf.layout.element.Paragraph;
import com.itextpdf.layout.element.Table;
// Not importing com.itextpdf.layout.element.Cell to avoid conflicts
import com.itextpdf.layout.properties.TextAlignment;
import com.itextpdf.layout.properties.UnitValue;
import com.itextpdf.kernel.colors.ColorConstants;
import com.itextpdf.kernel.font.PdfFont;
import com.itextpdf.kernel.font.PdfFontFactory;
import com.itextpdf.io.font.constants.StandardFonts;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.YearMonth;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.stream.Collectors;
@Service
@Transactional(readOnly = true)
public class ReportService {

    @Autowired
    private OrderRepository orderRepository;
    
    @Autowired
    private ProductRepository productRepository;
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private CategoryRepository categoryRepository;

    public GeneralReportDto generateGeneralReport(LocalDate startDate, LocalDate endDate) {
        GeneralReportDto report = new GeneralReportDto();
        report.setGeneratedAt(LocalDateTime.now());
        
        ReportPeriodDto period = new ReportPeriodDto();
        period.setStartDate(startDate);
        period.setEndDate(endDate);
        period.setType("custom");
        report.setReportPeriod(period);
        
        report.setSalesReport(generateSalesReport(startDate, endDate));
        report.setStockReport(generateStockReport());
        report.setUserReport(generateUserReport());
        
        return report;
    }

    public SalesReportDto generateSalesReport(LocalDate startDate, LocalDate endDate) {
        SalesReportDto salesReport = new SalesReportDto();
        salesReport.setPeriodStart(startDate);
        salesReport.setPeriodEnd(endDate);
        
        // Obține toate comenzile din perioada specificată
        List<Order> orders = orderRepository.findAll().stream()
            .filter(order -> {
                LocalDate orderDate = order.getOrderDate().toLocalDate();
                return !orderDate.isBefore(startDate) && !orderDate.isAfter(endDate);
            })
            .filter(order -> !"CANCELED".equals(order.getStatus()))
            .collect(Collectors.toList());
        
        // Calculează totaluri
        salesReport.setTotalSales(orders.size());
        BigDecimal totalRevenue = orders.stream()
            .map(Order::getTotalAmount)
            .reduce(BigDecimal.ZERO, BigDecimal::add);
        salesReport.setTotalRevenue(totalRevenue);
        
        // Vânzări zilnice
        Map<LocalDate, List<Order>> ordersByDate = orders.stream()
            .collect(Collectors.groupingBy(order -> order.getOrderDate().toLocalDate()));
        
        List<DailySalesDto> dailySales = new ArrayList<>();
        LocalDate currentDate = startDate;
        while (!currentDate.isAfter(endDate)) {
            List<Order> dayOrders = ordersByDate.getOrDefault(currentDate, new ArrayList<>());
            DailySalesDto dailySale = new DailySalesDto();
            dailySale.setDate(currentDate);
            dailySale.setSalesCount(dayOrders.size());
            dailySale.setRevenue(dayOrders.stream()
                .map(Order::getTotalAmount)
                .reduce(BigDecimal.ZERO, BigDecimal::add));
            dailySales.add(dailySale);
            currentDate = currentDate.plusDays(1);
        }
        salesReport.setDailySales(dailySales);
        
        // Top produse vândute
        Map<Product, Integer> productSales = new HashMap<>();
        Map<Product, BigDecimal> productRevenue = new HashMap<>();
        
        for (Order order : orders) {
            for (OrderItem item : order.getOrderItems()) {
                Product product = productRepository.findById(item.getProductIdSnapshot()).orElse(null);
                if (product != null) {
                    productSales.merge(product, item.getQuantity(), Integer::sum);
                    productRevenue.merge(product, item.getLineTotal(), BigDecimal::add);
                }
            }
        }
        
        List<ProductSalesDto> topProducts = productSales.entrySet().stream()
            .sorted(Map.Entry.<Product, Integer>comparingByValue().reversed())
            .limit(10)
            .map(entry -> {
                Product product = entry.getKey();
                ProductSalesDto dto = new ProductSalesDto();
                dto.setProductId(product.getId());
                dto.setProductName(product.getName());
                dto.setCategory(product.getCategory().getName());
                dto.setQuantitySold(entry.getValue());
                dto.setRevenue(productRevenue.get(product));
                dto.setCurrentStock(product.getStockQuantity());
                return dto;
            })
            .collect(Collectors.toList());
        salesReport.setTopSellingProducts(topProducts);
        
        // Vânzări pe categorii
        Map<String, Integer> categorySales = new HashMap<>();
        Map<String, BigDecimal> categoryRevenue = new HashMap<>();
        
        for (Map.Entry<Product, Integer> entry : productSales.entrySet()) {
            String categoryName = entry.getKey().getCategory().getName();
            categorySales.merge(categoryName, entry.getValue(), Integer::sum);
            categoryRevenue.merge(categoryName, productRevenue.get(entry.getKey()), BigDecimal::add);
        }
        
        List<CategorySalesDto> categorySalesList = categorySales.entrySet().stream()
            .map(entry -> {
                CategorySalesDto dto = new CategorySalesDto();
                dto.setCategory(entry.getKey());
                dto.setQuantitySold(entry.getValue());
                dto.setRevenue(categoryRevenue.get(entry.getKey()));
                return dto;
            })
            .collect(Collectors.toList());
        salesReport.setCategorySales(categorySalesList);
        
        return salesReport;
    }

    public StockReportDto generateStockReport() {
        StockReportDto stockReport = new StockReportDto();
        
        List<Product> allProducts = productRepository.findAll();
        
        // Total produse și valoare stoc
        stockReport.setTotalProducts(allProducts.size());
        BigDecimal totalStockValue = allProducts.stream()
            .map(p -> p.getPrice().multiply(new BigDecimal(p.getStockQuantity())))
            .reduce(BigDecimal.ZERO, BigDecimal::add);
        stockReport.setTotalStockValue(totalStockValue);
        
        // Produse cu stoc redus (< 10)
        List<StockItemDto> lowStock = allProducts.stream()
            .filter(p -> p.getStockQuantity() > 0 && p.getStockQuantity() < 10)
            .map(this::productToStockItem)
            .collect(Collectors.toList());
        stockReport.setLowStockProducts(lowStock);
        
        // Produse fără stoc
        List<StockItemDto> outOfStock = allProducts.stream()
            .filter(p -> p.getStockQuantity() == 0)
            .map(this::productToStockItem)
            .collect(Collectors.toList());
        stockReport.setOutOfStockProducts(outOfStock);
        
        // Stoc pe categorii
        Map<Category, List<Product>> productsByCategory = allProducts.stream()
            .collect(Collectors.groupingBy(Product::getCategory));
        
        List<CategoryStockDto> categoryStocks = productsByCategory.entrySet().stream()
            .map(entry -> {
                CategoryStockDto dto = new CategoryStockDto();
                dto.setCategory(entry.getKey().getName());
                dto.setTotalProducts(entry.getValue().size());
                dto.setTotalStock(entry.getValue().stream()
                    .mapToInt(Product::getStockQuantity)
                    .sum());
                dto.setStockValue(entry.getValue().stream()
                    .map(p -> p.getPrice().multiply(new BigDecimal(p.getStockQuantity())))
                    .reduce(BigDecimal.ZERO, BigDecimal::add));
                return dto;
            })
            .collect(Collectors.toList());
        stockReport.setCategoryStock(categoryStocks);
        
        return stockReport;
    }

    public UserReportDto generateUserReport() {
        UserReportDto userReport = new UserReportDto();
        
        List<User> allUsers = userRepository.findAll();
        userReport.setTotalUsers(allUsers.size());
        
        // Pentru active users - considerăm toți utilizatorii ca activi momentan
        // În producție, ai putea avea un câmp lastLoginDate în User
        userReport.setActiveUsers(allUsers.size());
        
        // Utilizatori noi luna aceasta
        YearMonth currentMonth = YearMonth.now();
        LocalDateTime startOfMonth = currentMonth.atDay(1).atStartOfDay();
        long newUsersCount = allUsers.stream()
            .filter(user -> {
                // Presupunem că avem un câmp createdDate în User
                // Pentru moment, returnăm un număr estimativ
                return true; // Înlocuiește cu logica reală
            })
            .count();
        userReport.setNewUsersThisMonth((int) newUsersCount);
        
        // Utilizatori pe roluri
        Map<String, Long> usersByRole = allUsers.stream()
            .flatMap(user -> user.getRoles().stream())
            .collect(Collectors.groupingBy(role -> role.getName().name(), Collectors.counting()));
        
        List<UserRoleCountDto> roleCountList = usersByRole.entrySet().stream()
            .map(entry -> {
                UserRoleCountDto dto = new UserRoleCountDto();
                dto.setRole(entry.getKey());
                dto.setCount(entry.getValue().intValue());
                return dto;
            })
            .collect(Collectors.toList());
        userReport.setUsersByRole(roleCountList);
        
        // Înregistrări recente (ultimii 10 utilizatori)
        List<UserInfoDto> recentUsers = allUsers.stream()
            .sorted((u1, u2) -> Long.compare(u2.getId(), u1.getId())) // Sortare inversă după ID
            .limit(10)
            .map(user -> {
                UserInfoDto dto = new UserInfoDto();
                dto.setId(user.getId());
                dto.setUsername(user.getUsername());
                dto.setEmail(user.getEmail());
                dto.setRegistrationDate(LocalDateTime.now()); // Placeholder
                dto.setLastLoginDate(LocalDateTime.now()); // Placeholder
                dto.setIsActive(true);
                return dto;
            })
            .collect(Collectors.toList());
        userReport.setRecentRegistrations(recentUsers);
        
        return userReport;
    }

    private StockItemDto productToStockItem(Product product) {
        StockItemDto dto = new StockItemDto();
        dto.setProductId(product.getId());
        dto.setProductName(product.getName());
        dto.setCategory(product.getCategory().getName());
        dto.setCurrentStock(product.getStockQuantity());
        dto.setPrice(product.getPrice());
        dto.setStockValue(product.getPrice().multiply(new BigDecimal(product.getStockQuantity())));
        return dto;
    }

    public byte[] generatePdfReport(LocalDate startDate, LocalDate endDate) {
        try (ByteArrayOutputStream baos = new ByteArrayOutputStream()) {
            PdfWriter writer = new PdfWriter(baos);
            PdfDocument pdf = new PdfDocument(writer);
            Document document = new Document(pdf);
            
            PdfFont titleFont = PdfFontFactory.createFont(StandardFonts.HELVETICA_BOLD);
            PdfFont normalFont = PdfFontFactory.createFont(StandardFonts.HELVETICA);
            PdfFont headerFont = PdfFontFactory.createFont(StandardFonts.HELVETICA_BOLD);
            
            document.add(new Paragraph("RAPORT GENERAL - MAGAZIN CALCULATOARE")
                .setFont(titleFont).setFontSize(18).setTextAlignment(TextAlignment.CENTER).setMarginBottom(20));
            
            document.add(new Paragraph(String.format("Perioada: %s - %s", 
                startDate.format(DateTimeFormatter.ofPattern("dd/MM/yyyy")),
                endDate.format(DateTimeFormatter.ofPattern("dd/MM/yyyy"))))
                .setFont(normalFont).setTextAlignment(TextAlignment.CENTER).setMarginBottom(20));
            
            GeneralReportDto report = generateGeneralReport(startDate, endDate);
            
            // SALES SUMMARY
            document.add(new Paragraph("1. REZUMAT VÂNZĂRI").setFont(titleFont).setFontSize(14).setMarginTop(20).setMarginBottom(10));
            Table salesSummaryTable = new Table(2).setWidth(UnitValue.createPercentValue(100));
            salesSummaryTable.addCell(createHeaderCell("Total Vânzări:", headerFont));
            salesSummaryTable.addCell(createCell(report.getSalesReport().getTotalSales().toString() + " comenzi", normalFont));
            salesSummaryTable.addCell(createHeaderCell("Venituri Totale:", headerFont));
            salesSummaryTable.addCell(createCell(formatCurrency(report.getSalesReport().getTotalRevenue()), normalFont));
            document.add(salesSummaryTable);
            
            // TOP SELLING PRODUCTS
            document.add(new Paragraph("2. TOP PRODUSE VÂNDUTE").setFont(titleFont).setFontSize(14).setMarginTop(20).setMarginBottom(10));
            Table topProductsTable = new Table(new float[]{3, 2, 1, 2, 1}).setWidth(UnitValue.createPercentValue(100));
            topProductsTable.addHeaderCell(createHeaderCell("Produs", headerFont));
            topProductsTable.addHeaderCell(createHeaderCell("Categorie", headerFont));
            topProductsTable.addHeaderCell(createHeaderCell("Cantitate", headerFont));
            topProductsTable.addHeaderCell(createHeaderCell("Venituri", headerFont));
            topProductsTable.addHeaderCell(createHeaderCell("Stoc", headerFont));
            for (ProductSalesDto product : report.getSalesReport().getTopSellingProducts()) {
                topProductsTable.addCell(createCell(product.getProductName(), normalFont));
                topProductsTable.addCell(createCell(product.getCategory(), normalFont));
                topProductsTable.addCell(createCell(product.getQuantitySold().toString(), normalFont));
                topProductsTable.addCell(createCell(formatCurrency(product.getRevenue()), normalFont));
                topProductsTable.addCell(createCell(product.getCurrentStock().toString(), normalFont));
            }
            document.add(topProductsTable);
            
            // STOCK SUMMARY
            document.add(new Paragraph("3. REZUMAT STOC").setFont(titleFont).setFontSize(14).setMarginTop(20).setMarginBottom(10));
            Table stockSummaryTable = new Table(2).setWidth(UnitValue.createPercentValue(100));
            stockSummaryTable.addCell(createHeaderCell("Total Produse:", headerFont));
            stockSummaryTable.addCell(createCell(report.getStockReport().getTotalProducts().toString(), normalFont));
            stockSummaryTable.addCell(createHeaderCell("Valoare Totală Stoc:", headerFont));
            stockSummaryTable.addCell(createCell(formatCurrency(report.getStockReport().getTotalStockValue()), normalFont));
            stockSummaryTable.addCell(createHeaderCell("Produse Fără Stoc:", headerFont));
            stockSummaryTable.addCell(createCell(String.valueOf(report.getStockReport().getOutOfStockProducts().size()), normalFont));
            stockSummaryTable.addCell(createHeaderCell("Produse Stoc Redus:", headerFont));
            stockSummaryTable.addCell(createCell(String.valueOf(report.getStockReport().getLowStockProducts().size()), normalFont));
            document.add(stockSummaryTable);

            document.close();
            return baos.toByteArray();
        } catch (IOException e) {
            throw new RuntimeException("Eroare la generarea PDF", e);
        }
    }

     public byte[] generateExcelReport(LocalDate startDate, LocalDate endDate) {
        try (XSSFWorkbook workbook = new XSSFWorkbook();
             ByteArrayOutputStream baos = new ByteArrayOutputStream()) {
            
            GeneralReportDto report = generateGeneralReport(startDate, endDate);
            
            CellStyle headerStyle = createHeaderStyle(workbook);
            CellStyle titleStyle = createTitleStyle(workbook);
            CellStyle currencyStyle = createCurrencyStyle(workbook);
            CellStyle dateStyle = createDateStyle(workbook);
            
            // SUMMARY SHEET
            Sheet summarySheet = workbook.createSheet("Rezumat");
            int rowNum = 0;
            
            // Title
            Row titleRow = summarySheet.createRow(rowNum++);
            Cell titleCell = titleRow.createCell(0);
            titleCell.setCellValue("RAPORT GENERAL - MAGAZIN CALCULATOARE");
            titleCell.setCellStyle(titleStyle);
            summarySheet.addMergedRegion(new CellRangeAddress(0, 0, 0, 3));
            
            // Period
            Row periodRow = summarySheet.createRow(rowNum++);
            periodRow.createCell(0).setCellValue("Perioada: " + startDate + " - " + endDate);
            rowNum++; // Empty row
            
            // Sales Summary
            Row salesHeaderRow = summarySheet.createRow(rowNum++);
            salesHeaderRow.createCell(0).setCellValue("REZUMAT VÂNZĂRI");
            salesHeaderRow.getCell(0).setCellStyle(headerStyle);
            
            Row totalSalesRow = summarySheet.createRow(rowNum++);
            totalSalesRow.createCell(0).setCellValue("Total Vânzări:");
            totalSalesRow.createCell(1).setCellValue(report.getSalesReport().getTotalSales());
            
            Row totalRevenueRow = summarySheet.createRow(rowNum++);
            totalRevenueRow.createCell(0).setCellValue("Venituri Totale:");
            Cell revenueCell = totalRevenueRow.createCell(1);
            revenueCell.setCellValue(report.getSalesReport().getTotalRevenue().doubleValue());
            revenueCell.setCellStyle(currencyStyle);
            
            rowNum++; // Empty row
            
            // Stock Summary
            Row stockHeaderRow = summarySheet.createRow(rowNum++);
            stockHeaderRow.createCell(0).setCellValue("REZUMAT STOC");
            stockHeaderRow.getCell(0).setCellStyle(headerStyle);
            
            Row totalProductsRow = summarySheet.createRow(rowNum++);
            totalProductsRow.createCell(0).setCellValue("Total Produse:");
            totalProductsRow.createCell(1).setCellValue(report.getStockReport().getTotalProducts());
            
            Row stockValueRow = summarySheet.createRow(rowNum++);
            stockValueRow.createCell(0).setCellValue("Valoare Stoc:");
            Cell stockValueCell = stockValueRow.createCell(1);
            stockValueCell.setCellValue(report.getStockReport().getTotalStockValue().doubleValue());
            stockValueCell.setCellStyle(currencyStyle);
            
            // Auto-size columns
            for (int i = 0; i < 4; i++) {
                summarySheet.autoSizeColumn(i);
            }
            
            // 2. SALES DETAILS SHEET
            Sheet salesSheet = workbook.createSheet("Vânzări Detaliate");
            createSalesDetailsSheet(salesSheet, report.getSalesReport(), headerStyle, currencyStyle);
            
            // 3. TOP PRODUCTS SHEET
            Sheet topProductsSheet = workbook.createSheet("Top Produse");
            createTopProductsSheet(topProductsSheet, report.getSalesReport().getTopSellingProducts(), headerStyle, currencyStyle);
            
            // 4. STOCK DETAILS SHEET
            Sheet stockSheet = workbook.createSheet("Detalii Stoc");
            createStockDetailsSheet(stockSheet, report.getStockReport(), headerStyle, currencyStyle);
            
            // 5. USER DETAILS SHEET
            Sheet userSheet = workbook.createSheet("Utilizatori");
            createUserDetailsSheet(userSheet, report.getUserReport(), headerStyle, dateStyle);
            
            workbook.write(baos);
            return baos.toByteArray();
            
        } catch (IOException e) {
            throw new RuntimeException("Eroare la generarea Excel", e);
        }
    }
    
    private void createSalesDetailsSheet(Sheet sheet, SalesReportDto salesReport, CellStyle headerStyle, CellStyle currencyStyle) {
        int rowNum = 0;
        
        // Headers
        Row headerRow = sheet.createRow(rowNum++);
        String[] headers = {"Data", "Nr. Vânzări", "Venituri"};
        for (int i = 0; i < headers.length; i++) {
            Cell cell = headerRow.createCell(i);
            cell.setCellValue(headers[i]);
            cell.setCellStyle(headerStyle);
        }
        
        // Data
        for (DailySalesDto dailySale : salesReport.getDailySales()) {
            Row row = sheet.createRow(rowNum++);
            row.createCell(0).setCellValue(dailySale.getDate().toString());
            row.createCell(1).setCellValue(dailySale.getSalesCount());
            Cell revenueCell = row.createCell(2);
            revenueCell.setCellValue(dailySale.getRevenue().doubleValue());
            revenueCell.setCellStyle(currencyStyle);
        }
        
        // Auto-size columns
        for (int i = 0; i < headers.length; i++) {
            sheet.autoSizeColumn(i);
        }
    }
    
    private void createTopProductsSheet(Sheet sheet, List<ProductSalesDto> products, CellStyle headerStyle, CellStyle currencyStyle) {
        int rowNum = 0;
        
        // Headers
        Row headerRow = sheet.createRow(rowNum++);
        String[] headers = {"Produs", "Categorie", "Cantitate Vândută", "Venituri", "Stoc Curent"};
        for (int i = 0; i < headers.length; i++) {
            Cell cell = headerRow.createCell(i);
            cell.setCellValue(headers[i]);
            cell.setCellStyle(headerStyle);
        }
        
        // Data
        for (ProductSalesDto product : products) {
            Row row = sheet.createRow(rowNum++);
            row.createCell(0).setCellValue(product.getProductName());
            row.createCell(1).setCellValue(product.getCategory());
            row.createCell(2).setCellValue(product.getQuantitySold());
            Cell revenueCell = row.createCell(3);
            revenueCell.setCellValue(product.getRevenue().doubleValue());
            revenueCell.setCellStyle(currencyStyle);
            row.createCell(4).setCellValue(product.getCurrentStock());
        }
        
        // Auto-size columns
        for (int i = 0; i < headers.length; i++) {
            sheet.autoSizeColumn(i);
        }
    }
    
    private void createStockDetailsSheet(Sheet sheet, StockReportDto stockReport, CellStyle headerStyle, CellStyle currencyStyle) {
        int rowNum = 0;
        
        // Low Stock Products Section
        Row lowStockHeader = sheet.createRow(rowNum++);
        lowStockHeader.createCell(0).setCellValue("PRODUSE CU STOC REDUS");
        lowStockHeader.getCell(0).setCellStyle(headerStyle);
        rowNum++;
        
        if (!stockReport.getLowStockProducts().isEmpty()) {
            // Headers
            Row headerRow = sheet.createRow(rowNum++);
            String[] headers = {"Produs", "Categorie", "Stoc", "Preț", "Valoare Stoc"};
            for (int i = 0; i < headers.length; i++) {
                Cell cell = headerRow.createCell(i);
                cell.setCellValue(headers[i]);
                cell.setCellStyle(headerStyle);
            }
            
            // Data
            for (StockItemDto item : stockReport.getLowStockProducts()) {
                Row row = sheet.createRow(rowNum++);
                row.createCell(0).setCellValue(item.getProductName());
                row.createCell(1).setCellValue(item.getCategory());
                row.createCell(2).setCellValue(item.getCurrentStock());
                Cell priceCell = row.createCell(3);
                priceCell.setCellValue(item.getPrice().doubleValue());
                priceCell.setCellStyle(currencyStyle);
                Cell valueCell = row.createCell(4);
                valueCell.setCellValue(item.getStockValue().doubleValue());
                valueCell.setCellStyle(currencyStyle);
            }
        }
        
        rowNum += 2; // Empty rows
        
        // Out of Stock Products Section
        Row outOfStockHeader = sheet.createRow(rowNum++);
        outOfStockHeader.createCell(0).setCellValue("PRODUSE FĂRĂ STOC");
        outOfStockHeader.getCell(0).setCellStyle(headerStyle);
        rowNum++;
        
        if (!stockReport.getOutOfStockProducts().isEmpty()) {
            // Headers
            Row headerRow = sheet.createRow(rowNum++);
            String[] headers = {"Produs", "Categorie", "Preț"};
            for (int i = 0; i < headers.length; i++) {
                Cell cell = headerRow.createCell(i);
                cell.setCellValue(headers[i]);
                cell.setCellStyle(headerStyle);
            }
            
            // Data
            for (StockItemDto item : stockReport.getOutOfStockProducts()) {
                Row row = sheet.createRow(rowNum++);
                row.createCell(0).setCellValue(item.getProductName());
                row.createCell(1).setCellValue(item.getCategory());
                Cell priceCell = row.createCell(2);
                priceCell.setCellValue(item.getPrice().doubleValue());
                priceCell.setCellStyle(currencyStyle);
            }
        }
        
        // Auto-size columns
        for (int i = 0; i < 5; i++) {
            sheet.autoSizeColumn(i);
        }
    }
    
    private void createUserDetailsSheet(Sheet sheet, UserReportDto userReport, CellStyle headerStyle, CellStyle dateStyle) {
        int rowNum = 0;
        
        // Summary
        Row summaryHeader = sheet.createRow(rowNum++);
        summaryHeader.createCell(0).setCellValue("REZUMAT UTILIZATORI");
        summaryHeader.getCell(0).setCellStyle(headerStyle);
        rowNum++;
        
        Row totalUsersRow = sheet.createRow(rowNum++);
        totalUsersRow.createCell(0).setCellValue("Total Utilizatori:");
        totalUsersRow.createCell(1).setCellValue(userReport.getTotalUsers());
        
        Row activeUsersRow = sheet.createRow(rowNum++);
        activeUsersRow.createCell(0).setCellValue("Utilizatori Activi:");
        activeUsersRow.createCell(1).setCellValue(userReport.getActiveUsers());
        
        Row newUsersRow = sheet.createRow(rowNum++);
        newUsersRow.createCell(0).setCellValue("Utilizatori Noi (luna aceasta):");
        newUsersRow.createCell(1).setCellValue(userReport.getNewUsersThisMonth());
        
        rowNum += 2; // Empty rows
        
        // Users by Role
        Row rolesHeader = sheet.createRow(rowNum++);
        rolesHeader.createCell(0).setCellValue("UTILIZATORI PE ROLURI");
        rolesHeader.getCell(0).setCellStyle(headerStyle);
        rowNum++;
        
        for (UserRoleCountDto roleCount : userReport.getUsersByRole()) {
            Row row = sheet.createRow(rowNum++);
            row.createCell(0).setCellValue(roleCount.getRole());
            row.createCell(1).setCellValue(roleCount.getCount());
        }
        
        // Auto-size columns
        for (int i = 0; i < 4; i++) {
            sheet.autoSizeColumn(i);
        }
    }
    
    // --- PDF HELPER METHODS ---
    private com.itextpdf.layout.element.Cell createCell(String content, PdfFont font) {
        return new com.itextpdf.layout.element.Cell().add(new Paragraph(content).setFont(font));
    }
    
    private com.itextpdf.layout.element.Cell createHeaderCell(String content, PdfFont font) {
        return new com.itextpdf.layout.element.Cell()
            .add(new Paragraph(content).setFont(font))
            .setBackgroundColor(ColorConstants.LIGHT_GRAY);
    }
    
    private String formatCurrency(BigDecimal amount) {
        return String.format("RON %.2f", amount);
    }
    
    // Helper methods for Excel styles
    private CellStyle createHeaderStyle(Workbook workbook) {
        CellStyle style = workbook.createCellStyle();
        Font font = workbook.createFont();
        font.setBold(true);
        style.setFont(font);
        style.setFillForegroundColor(IndexedColors.GREY_25_PERCENT.getIndex());
        style.setFillPattern(FillPatternType.SOLID_FOREGROUND);
        style.setBorderBottom(BorderStyle.THIN);
        style.setBorderTop(BorderStyle.THIN);
        style.setBorderLeft(BorderStyle.THIN);
        style.setBorderRight(BorderStyle.THIN);
        return style;
    }
    
    private CellStyle createTitleStyle(Workbook workbook) {
        CellStyle style = workbook.createCellStyle();
        Font font = workbook.createFont();
        font.setBold(true);
        font.setFontHeightInPoints((short) 16);
        style.setFont(font);
        style.setAlignment(HorizontalAlignment.CENTER);
        return style;
    }
    
    private CellStyle createCurrencyStyle(Workbook workbook) {
        CellStyle style = workbook.createCellStyle();
        DataFormat format = workbook.createDataFormat();
        style.setDataFormat(format.getFormat("RON #,##0.00"));
        return style;
    }
    
    private CellStyle createDateStyle(Workbook workbook) {
        CellStyle style = workbook.createCellStyle();
        DataFormat format = workbook.createDataFormat();
        style.setDataFormat(format.getFormat("dd/mm/yyyy"));
        return style;
    }
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/service/ReviewService.java">
// backend/src/main/java/com/magazincomputere/magazin_api/service/ReviewService.java
package com.magazincomputere.magazin_api.service;

import com.magazincomputere.magazin_api.dto.*;
import com.magazincomputere.magazin_api.exception.BadRequestException;
import com.magazincomputere.magazin_api.exception.ResourceNotFoundException;
import com.magazincomputere.magazin_api.model.*;
import com.magazincomputere.magazin_api.repository.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;


import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@Service
public class ReviewService {

    @Autowired
    private ReviewRepository reviewRepository;
    
    @Autowired
    private ProductRepository productRepository;
    
    @Autowired
    private UserRepository userRepository;

    @Transactional
    public ReviewDto createReview(CreateReviewRequest request, Long userId) {
        // Check if user already reviewed this product
        if (reviewRepository.existsByProductIdAndUserId(request.getProductId(), userId)) {
            throw new BadRequestException("Ai deja o recenzie pentru acest produs");
        }
        
        Product product = productRepository.findById(request.getProductId())
            .orElseThrow(() -> new ResourceNotFoundException("Produsul nu a fost găsit"));
            
        User user = userRepository.findById(userId)
            .orElseThrow(() -> new ResourceNotFoundException("Utilizatorul nu a fost găsit"));
        
        Review review = new Review();
        review.setProduct(product);
        review.setUser(user);
        review.setRating(request.getRating());
        review.setTitle(request.getTitle());
        review.setComment(request.getComment());
        
        Review savedReview = reviewRepository.save(review);
        return convertToDto(savedReview);
    }
    
    @Transactional
    public ReviewDto updateReview(Long reviewId, CreateReviewRequest request, Long userId) {
        Review review = reviewRepository.findById(reviewId)
            .orElseThrow(() -> new ResourceNotFoundException("Recenzia nu a fost găsită"));
            
        if (!review.getUser().getId().equals(userId)) {
            throw new BadRequestException("Nu poți modifica recenzia altui utilizator");
        }
        
        review.setRating(request.getRating());
        review.setTitle(request.getTitle());
        review.setComment(request.getComment());
        
        Review updatedReview = reviewRepository.save(review);
        return convertToDto(updatedReview);
    }
    
    @Transactional
    public void deleteReview(Long reviewId, Long userId, boolean isAdmin) {
        Review review = reviewRepository.findById(reviewId)
            .orElseThrow(() -> new ResourceNotFoundException("Recenzia nu a fost găsită"));
            
        if (!isAdmin && !review.getUser().getId().equals(userId)) {
            throw new BadRequestException("Nu poți șterge recenzia altui utilizator");
        }
        
        reviewRepository.delete(review);
    }
    
    public Page<ReviewDto> getProductReviews(Long productId, int page, int size) {
        Pageable pageable = PageRequest.of(page, size);
        Page<Review> reviews = reviewRepository.findByProductIdOrderByCreatedAtDesc(productId, pageable);
        return reviews.map(this::convertToDto);
    }
    
    public ReviewDto getUserReviewForProduct(Long productId, Long userId) {
        Review review = reviewRepository.findByProductIdAndUserId(productId, userId)
            .orElse(null);
        return review != null ? convertToDto(review) : null;
    }
    
    public ProductReviewSummary getProductReviewSummary(Long productId) {
        ProductReviewSummary summary = new ProductReviewSummary();
        
        Double avgRating = reviewRepository.calculateAverageRatingByProductId(productId);
        summary.setAverageRating(avgRating != null ? avgRating : 0.0);
        
        Integer totalReviews = reviewRepository.countByProductId(productId);
        summary.setTotalReviews(totalReviews != null ? totalReviews : 0);
        
        Map<Integer, Integer> distribution = new HashMap<>();
        for (int i = 1; i <= 5; i++) {
            distribution.put(i, 0);
        }
        
        List<Object[]> ratingCounts = reviewRepository.getRatingDistributionByProductId(productId);
        for (Object[] row : ratingCounts) {
            Integer rating = (Integer) row[0];
            Long count = (Long) row[1];
            distribution.put(rating, count.intValue());
        }
        
        summary.setRatingDistribution(distribution);
        return summary;
    }
    public List<ReviewDto> getUserReviews(Long userId) {
    List<Review> reviews = reviewRepository.findByUserId(userId);
    return reviews.stream()
            .map(this::convertToDto)
            .collect(Collectors.toList());
}
    
    private ReviewDto convertToDto(Review review) {
        ReviewDto dto = new ReviewDto();
        dto.setId(review.getId());
        dto.setProductId(review.getProduct().getId());
        dto.setProductName(review.getProduct().getName());
        dto.setUserId(review.getUser().getId());
        dto.setUsername(review.getUser().getUsername());
        dto.setRating(review.getRating());
        dto.setTitle(review.getTitle());
        dto.setComment(review.getComment());
        dto.setCreatedAt(review.getCreatedAt());
        dto.setUpdatedAt(review.getUpdatedAt());
        return dto;
    }
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/service/SpecificationService.java">
package com.magazincomputere.magazin_api.service;

import com.magazincomputere.magazin_api.dto.SpecificationDefinitionDto;
import com.magazincomputere.magazin_api.exception.ResourceNotFoundException;
import com.magazincomputere.magazin_api.model.SpecificationDefinition;
import com.magazincomputere.magazin_api.repository.SpecificationDefinitionRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.stream.Collectors;

@Service
public class SpecificationService {

    @Autowired
    private SpecificationDefinitionRepository definitionRepository;

    private SpecificationDefinitionDto convertToDto(SpecificationDefinition definition) {
        return new SpecificationDefinitionDto(definition.getId(), definition.getName(), definition.getUnit());
    }

    // Metodă pentru a actualiza câmpurile unei entități existente dintr-un DTO
    private void updateEntityFromDto(SpecificationDefinitionDto dto, SpecificationDefinition definition) {
        definition.setName(dto.getName());
        definition.setUnit(dto.getUnit());
    }

    @Transactional(readOnly = true)
    public List<SpecificationDefinitionDto> getAllDefinitions() {
        return definitionRepository.findAll().stream().map(this::convertToDto).collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public SpecificationDefinitionDto getDefinitionById(Long id) {
        SpecificationDefinition def = definitionRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("SpecificationDefinition", "id", id));
        return convertToDto(def);
    }

    @Transactional
    public SpecificationDefinitionDto createDefinition(SpecificationDefinitionDto definitionDto) {
         definitionRepository.findByNameIgnoreCase(definitionDto.getName()).ifPresent(existingDef -> {
            throw new IllegalArgumentException("Specification definition with name '" + existingDef.getName() + "' already exists.");
        });
        SpecificationDefinition definition = new SpecificationDefinition();
        updateEntityFromDto(definitionDto, definition); // Folosim metoda care nu returnează pentru claritate
        SpecificationDefinition saved = definitionRepository.save(definition);
        return convertToDto(saved);
    }

    @Transactional
    public SpecificationDefinitionDto updateDefinition(Long id, SpecificationDefinitionDto definitionDto) {
        // Pasul 1: Găsește entitatea existentă
        SpecificationDefinition existingDef = definitionRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("SpecificationDefinition", "id", id));
        
        // Pasul 2: Verifică dacă noul nume este deja folosit de altă definiție
        // Folosim o variabilă finală sau effectively final pentru ID-ul definiției existente în lambda
        final Long existingDefId = existingDef.getId();
        definitionRepository.findByNameIgnoreCase(definitionDto.getName()).ifPresent(defWithSameName -> {
            if(!defWithSameName.getId().equals(existingDefId)){
                 throw new IllegalArgumentException("Another specification definition with name '" + defWithSameName.getName() + "' already exists.");
            }
        });

        // Pasul 3: Actualizează câmpurile entității existente cu datele din DTO
        // Nu re-atribuim existingDef, ci îi modificăm starea.
        updateEntityFromDto(definitionDto, existingDef);

        // Pasul 4: Salvează entitatea actualizată
        SpecificationDefinition updated = definitionRepository.save(existingDef);

        // Pasul 5: Converteste entitatea actualizată în DTO și returneaz-o
        return convertToDto(updated);
    }

    @Transactional
    public void deleteDefinition(Long id) {
        SpecificationDefinition definition = definitionRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("SpecificationDefinition", "id", id));
        
        // TODO: Verifică dacă această definiție este folosită în ProductSpecificationValue înainte de ștergere.
        // De exemplu: if (!productSpecificationValueRepository.findBySpecificationDefinitionId(id).isEmpty()) {
        // throw new BadRequestException("Cannot delete specification definition that is in use by products.");
        // }
        definitionRepository.delete(definition);
    }
}
</file>

<file path="src/main/java/com/magazincomputere/magazin_api/service/UserService.java">
package com.magazincomputere.magazin_api.service;

import com.magazincomputere.magazin_api.dto.UserDto;
import com.magazincomputere.magazin_api.dto.UserUpdateDto; // Import the new DTO
import com.magazincomputere.magazin_api.exception.ResourceNotFoundException;
import com.magazincomputere.magazin_api.model.User;
import com.magazincomputere.magazin_api.model.Role;
import com.magazincomputere.magazin_api.model.ERole;
import com.magazincomputere.magazin_api.repository.UserRepository;
import com.magazincomputere.magazin_api.repository.RoleRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

@Service
public class UserService {

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private RoleRepository roleRepository;

    @Autowired
    private PasswordEncoder passwordEncoder;

    private UserDto convertToDto(User user) {
        UserDto dto = new UserDto();
        dto.setId(user.getId());
        dto.setUsername(user.getUsername());
        dto.setEmail(user.getEmail());
        if (user.getRoles() != null) {
            dto.setRoles(user.getRoles().stream()
                .map(role -> role.getName().name())
                .collect(Collectors.toSet()));
        }
        return dto;
    }

    @Transactional(readOnly = true)
    public List<UserDto> findAllUsers() {
        return userRepository.findAll().stream()
            .map(this::convertToDto)
            .collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public UserDto findUserById(Long id) {
        User user = userRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("User not found with id: " + id));
        return convertToDto(user);
    }

    @Transactional
    public UserDto updateUser(Long id, UserUpdateDto userUpdateDto) { // Accept UserUpdateDto
        User existingUser = userRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("User not found with id: " + id));

        // Log for debugging
        System.out.println("Existing user: " + existingUser.getUsername());
        System.out.println("Update data - email: " + userUpdateDto.getEmail());
        System.out.println("Update data - roles: " + userUpdateDto.getRoles());

        // Update email
        existingUser.setEmail(userUpdateDto.getEmail());

        // Update roles if provided
        if (userUpdateDto.getRoles() != null && !userUpdateDto.getRoles().isEmpty()) {
            Set<Role> newRoles = new HashSet<>();
            for (String roleName : userUpdateDto.getRoles()) {
                // Handle both with and without ROLE_ prefix
                String normalizedRoleName = roleName.startsWith("ROLE_") ? roleName : "ROLE_" + roleName;
                
                try {
                    ERole eRole = ERole.valueOf(normalizedRoleName);
                    Role role = roleRepository.findByName(eRole)
                            .orElseThrow(() -> new RuntimeException("Error: Role " + normalizedRoleName + " is not found."));
                    newRoles.add(role);
                } catch (IllegalArgumentException e) {
                    throw new RuntimeException("Error: Invalid role name " + roleName);
                }
            }
            existingUser.setRoles(newRoles);
        }

        User updatedUser = userRepository.save(existingUser);
        return convertToDto(updatedUser);
    }

    @Transactional
    public void deleteUser(Long id) {
        if (!userRepository.existsById(id)) {
            throw new ResourceNotFoundException("User not found with id: " + id);
        }
        userRepository.deleteById(id);
    }
}
</file>

<file path="src/main/resources/application.properties">
# Server Port
server.port=8080

# MySQL Datasource Configuration
# Înlocuiește 'magazin_computere_db' cu numele bazei tale de date create în MySQL Workbench.
# Înlocuiește 'root' și 'parola_ta_mysql' cu userul și parola ta MySQL.
spring.datasource.url=jdbc:mysql://localhost:3306/licenta?useSSL=false&serverTimezone=UTC&allowPublicKeyRetrieval=true
spring.datasource.username=root
spring.datasource.password=wx9ec8rv7
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

# JPA and Hibernate Configuration for MySQL
# Pentru MySQL 8+, dialectul este org.hibernate.dialect.MySQLDialect sau org.hibernate.dialect.MySQL8Dialect (mai nou)
# Pentru versiuni mai vechi de MySQL (ex: 5.7), poți folosi org.hibernate.dialect.MySQL57Dialect
spring.jpa.database-platform=org.hibernate.dialect.MySQLDialect

# Strategia DDL (Data Definition Language)
# RECOMANDAT: 'validate' - Hibernate verifică dacă schema din DB corespunde cu entitățile. Eșuează la pornire dacă sunt nepotriviri.
# SAU: 'none' - Hibernate nu face nimic cu schema. Tu ești responsabil pentru crearea și actualizarea ei manuală.
# EVITĂ: 'update' pe termen lung sau în producție cu MySQL, deoarece poate fi imprevizibil.
# NICIODATĂ: 'create' sau 'create-drop' dacă vrei să păstrezi datele între reporniri.
spring.jpa.hibernate.ddl-auto=validate

# Afișare SQL generat de Hibernate (util pentru debugging)
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true
# spring.jpa.properties.hibernate.use_sql_comments=true # Opțional, adaugă comentarii în SQL-ul logat

# JWT Properties (rămân la fel)
app.jwtSecret=ThisIsMySuperLongAndVerySecureSecretKeyForMagazinComputereLicentaProject2025
app.jwtExpirationMs=86400000

# SpringDoc OpenAPI (Swagger UI) (rămân la fel)
springdoc.api-docs.path=/api-docs
springdoc.swagger-ui.path=/swagger-ui.html
springdoc.swagger-ui.operationsSorter=method
springdoc.swagger-ui.tagsSorter=alpha
# springdoc.swagger-ui.doc-expansion=none # Opțional, controlează cum se expandează documentația

# H2 Console (dezactivează-l când folosești MySQL sau PostgreSQL)
spring.h2.console.enabled=false
# spring.h2.console.path=/h2-console
# spring.h2.console.settings.trace=false
# spring.h2.console.settings.web-allow-others=false
</file>

<file path="src/test/java/com/magazincomputere/magazin_api/MagazinApiApplicationTests.java">
package com.magazincomputere.magazin_api;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class MagazinApiApplicationTests {

	@Test
	void contextLoads() {
	}

}
</file>

</files>
