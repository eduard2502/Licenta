This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
backend/.gitattributes
backend/.gitignore
backend/.mvn/wrapper/maven-wrapper.properties
backend/mvnw
backend/mvnw.cmd
backend/pom.xml
backend/src/main/java/com/magazincomputere/magazin_api/config/SecurityConfig.java
backend/src/main/java/com/magazincomputere/magazin_api/config/WebConfig.java
backend/src/main/java/com/magazincomputere/magazin_api/controller/AngularForwardController.java
backend/src/main/java/com/magazincomputere/magazin_api/controller/AuthController.java
backend/src/main/java/com/magazincomputere/magazin_api/controller/CartController.java
backend/src/main/java/com/magazincomputere/magazin_api/controller/CategoryController.java
backend/src/main/java/com/magazincomputere/magazin_api/controller/CustomerController.java
backend/src/main/java/com/magazincomputere/magazin_api/controller/OrderController.java
backend/src/main/java/com/magazincomputere/magazin_api/controller/ProductController.java
backend/src/main/java/com/magazincomputere/magazin_api/controller/ReportController.java
backend/src/main/java/com/magazincomputere/magazin_api/controller/ReviewController.java
backend/src/main/java/com/magazincomputere/magazin_api/controller/SpecificationController.java
backend/src/main/java/com/magazincomputere/magazin_api/controller/UserController.java
backend/src/main/java/com/magazincomputere/magazin_api/dto/AddToCartRequest.java
backend/src/main/java/com/magazincomputere/magazin_api/dto/CartDto.java
backend/src/main/java/com/magazincomputere/magazin_api/dto/CartItemDto.java
backend/src/main/java/com/magazincomputere/magazin_api/dto/CategoryDto.java
backend/src/main/java/com/magazincomputere/magazin_api/dto/CheckoutRequest.java
backend/src/main/java/com/magazincomputere/magazin_api/dto/CreateReviewRequest.java
backend/src/main/java/com/magazincomputere/magazin_api/dto/CustomerDto.java
backend/src/main/java/com/magazincomputere/magazin_api/dto/JwtResponse.java
backend/src/main/java/com/magazincomputere/magazin_api/dto/LoginRequest.java
backend/src/main/java/com/magazincomputere/magazin_api/dto/MessageResponse.java
backend/src/main/java/com/magazincomputere/magazin_api/dto/OrderDto.java
backend/src/main/java/com/magazincomputere/magazin_api/dto/OrderItemDto.java
backend/src/main/java/com/magazincomputere/magazin_api/dto/OrderStatusUpdateDto.java
backend/src/main/java/com/magazincomputere/magazin_api/dto/ProductDto.java
backend/src/main/java/com/magazincomputere/magazin_api/dto/ProductReviewSummary.java
backend/src/main/java/com/magazincomputere/magazin_api/dto/report/CategorySalesDto.java
backend/src/main/java/com/magazincomputere/magazin_api/dto/report/CategoryStockDto.java
backend/src/main/java/com/magazincomputere/magazin_api/dto/report/DailySalesDto.java
backend/src/main/java/com/magazincomputere/magazin_api/dto/report/GeneralReportDto.java
backend/src/main/java/com/magazincomputere/magazin_api/dto/report/ProductSalesDto.java
backend/src/main/java/com/magazincomputere/magazin_api/dto/report/ReportPeriodDto.java
backend/src/main/java/com/magazincomputere/magazin_api/dto/report/SalesReportDto.java
backend/src/main/java/com/magazincomputere/magazin_api/dto/report/StockItemDto.java
backend/src/main/java/com/magazincomputere/magazin_api/dto/report/StockReportDto.java
backend/src/main/java/com/magazincomputere/magazin_api/dto/report/UserInfoDto.java
backend/src/main/java/com/magazincomputere/magazin_api/dto/report/UserReportDto.java
backend/src/main/java/com/magazincomputere/magazin_api/dto/report/UserRoleCountDto.java
backend/src/main/java/com/magazincomputere/magazin_api/dto/ReviewDto.java
backend/src/main/java/com/magazincomputere/magazin_api/dto/SignupRequest.java
backend/src/main/java/com/magazincomputere/magazin_api/dto/SpecificationDefinitionDto.java
backend/src/main/java/com/magazincomputere/magazin_api/dto/SpecificationDto.java
backend/src/main/java/com/magazincomputere/magazin_api/dto/UpdateCartItemRequest.java
backend/src/main/java/com/magazincomputere/magazin_api/dto/UserDto.java
backend/src/main/java/com/magazincomputere/magazin_api/dto/UserUpdateDto.java
backend/src/main/java/com/magazincomputere/magazin_api/exception/BadRequestException.java
backend/src/main/java/com/magazincomputere/magazin_api/exception/GlobalExceptionHandler.java
backend/src/main/java/com/magazincomputere/magazin_api/exception/ResourceNotFoundException.java
backend/src/main/java/com/magazincomputere/magazin_api/MagazinApiApplication.java
backend/src/main/java/com/magazincomputere/magazin_api/model/Cart.java
backend/src/main/java/com/magazincomputere/magazin_api/model/CartItem.java
backend/src/main/java/com/magazincomputere/magazin_api/model/Category.java
backend/src/main/java/com/magazincomputere/magazin_api/model/Customer.java
backend/src/main/java/com/magazincomputere/magazin_api/model/ERole.java
backend/src/main/java/com/magazincomputere/magazin_api/model/Order.java
backend/src/main/java/com/magazincomputere/magazin_api/model/OrderItem.java
backend/src/main/java/com/magazincomputere/magazin_api/model/Product.java
backend/src/main/java/com/magazincomputere/magazin_api/model/ProductSpecificationValue.java
backend/src/main/java/com/magazincomputere/magazin_api/model/Review.java
backend/src/main/java/com/magazincomputere/magazin_api/model/Role.java
backend/src/main/java/com/magazincomputere/magazin_api/model/SpecificationDefinition.java
backend/src/main/java/com/magazincomputere/magazin_api/model/User.java
backend/src/main/java/com/magazincomputere/magazin_api/repository/CartItemRepository.java
backend/src/main/java/com/magazincomputere/magazin_api/repository/CartRepository.java
backend/src/main/java/com/magazincomputere/magazin_api/repository/CategoryRepository.java
backend/src/main/java/com/magazincomputere/magazin_api/repository/CustomerRepository.java
backend/src/main/java/com/magazincomputere/magazin_api/repository/OrderItemRepository.java
backend/src/main/java/com/magazincomputere/magazin_api/repository/OrderRepository.java
backend/src/main/java/com/magazincomputere/magazin_api/repository/ProductRepository.java
backend/src/main/java/com/magazincomputere/magazin_api/repository/ProductSpecificationValueRepository.java
backend/src/main/java/com/magazincomputere/magazin_api/repository/ReviewRepository.java
backend/src/main/java/com/magazincomputere/magazin_api/repository/RoleRepository.java
backend/src/main/java/com/magazincomputere/magazin_api/repository/SpecificationDefinitionRepository.java
backend/src/main/java/com/magazincomputere/magazin_api/repository/UserRepository.java
backend/src/main/java/com/magazincomputere/magazin_api/security/jwt/AuthEntryPointJwt.java
backend/src/main/java/com/magazincomputere/magazin_api/security/jwt/JwtAuthTokenFilter.java
backend/src/main/java/com/magazincomputere/magazin_api/security/jwt/JwtUtils.java
backend/src/main/java/com/magazincomputere/magazin_api/security/services/UserDetailsImpl.java
backend/src/main/java/com/magazincomputere/magazin_api/security/services/UserDetailsServiceImpl.java
backend/src/main/java/com/magazincomputere/magazin_api/service/CartService.java
backend/src/main/java/com/magazincomputere/magazin_api/service/CategoryService.java
backend/src/main/java/com/magazincomputere/magazin_api/service/CustomerService.java
backend/src/main/java/com/magazincomputere/magazin_api/service/OrderService.java
backend/src/main/java/com/magazincomputere/magazin_api/service/ProductService.java
backend/src/main/java/com/magazincomputere/magazin_api/service/ReportService.java
backend/src/main/java/com/magazincomputere/magazin_api/service/ReviewService.java
backend/src/main/java/com/magazincomputere/magazin_api/service/SpecificationService.java
backend/src/main/java/com/magazincomputere/magazin_api/service/UserService.java
backend/src/main/resources/application.properties
backend/src/test/java/com/magazincomputere/magazin_api/MagazinApiApplicationTests.java
frontend/.editorconfig
frontend/.gitignore
frontend/.vscode/extensions.json
frontend/.vscode/launch.json
frontend/.vscode/tasks.json
frontend/angular.json
frontend/package.json
frontend/proxy.conf.json
frontend/README.md
frontend/src/app/app.component.html
frontend/src/app/app.component.scss
frontend/src/app/app.component.spec.ts
frontend/src/app/app.component.ts
frontend/src/app/app.config.server.ts
frontend/src/app/app.config.ts
frontend/src/app/app.routes.server.ts
frontend/src/app/app.routes.ts
frontend/src/app/auth/admin.guard.ts
frontend/src/app/auth/auth.guard.ts
frontend/src/app/auth/auth.interceptor.ts
frontend/src/app/auth/auth.service.ts
frontend/src/app/auth/inactivity.service.ts
frontend/src/app/auth/token-storage.service.ts
frontend/src/app/auth/user.guard.ts
frontend/src/app/enviornments/environment.prod.ts
frontend/src/app/enviornments/environment.ts
frontend/src/app/features/admin-dashboard/admin-dashboard.component.html
frontend/src/app/features/admin-dashboard/admin-dashboard.component.scss
frontend/src/app/features/admin-dashboard/admin-dashboard.component.ts
frontend/src/app/features/admin/admin-categories/admin-category-form/admin-category-form.component.html
frontend/src/app/features/admin/admin-categories/admin-category-form/admin-category-form.component.scss
frontend/src/app/features/admin/admin-categories/admin-category-form/admin-category-form.component.ts
frontend/src/app/features/admin/admin-categories/admin-category-list/admin-category-list.component.html
frontend/src/app/features/admin/admin-categories/admin-category-list/admin-category-list.component.scss
frontend/src/app/features/admin/admin-categories/admin-category-list/admin-category-list.component.ts
frontend/src/app/features/admin/admin-orders/admin-order-detail/admin-order-detail.component.html
frontend/src/app/features/admin/admin-orders/admin-order-detail/admin-order-detail.component.scss
frontend/src/app/features/admin/admin-orders/admin-order-detail/admin-order-detail.component.ts
frontend/src/app/features/admin/admin-orders/admin-order-list/admin-order-list.component.html
frontend/src/app/features/admin/admin-orders/admin-order-list/admin-order-list.component.scss
frontend/src/app/features/admin/admin-orders/admin-order-list/admin-order-list.component.ts
frontend/src/app/features/admin/admin-specifications/admin-spec-def-form/admin-spec-def-form.component.html
frontend/src/app/features/admin/admin-specifications/admin-spec-def-form/admin-spec-def-form.component.scss
frontend/src/app/features/admin/admin-specifications/admin-spec-def-form/admin-spec-def-form.component.ts
frontend/src/app/features/admin/admin-specifications/admin-spec-def-list/admin-spec-def-list.component.html
frontend/src/app/features/admin/admin-specifications/admin-spec-def-list/admin-spec-def-list.component.scss
frontend/src/app/features/admin/admin-specifications/admin-spec-def-list/admin-spec-def-list.component.ts
frontend/src/app/features/admin/admin-users/admin-user-form/admin-user-form.component.html
frontend/src/app/features/admin/admin-users/admin-user-form/admin-user-form.component.scss
frontend/src/app/features/admin/admin-users/admin-user-form/admin-user-form.component.ts
frontend/src/app/features/admin/admin-users/admin-user-list/admin-user-list.component.html
frontend/src/app/features/admin/admin-users/admin-user-list/admin-user-list.component.scss
frontend/src/app/features/admin/admin-users/admin-user-list/admin-user-list.component.ts
frontend/src/app/features/admin/reports/reports.component.html
frontend/src/app/features/admin/reports/reports.component.scss
frontend/src/app/features/admin/reports/reports.component.ts
frontend/src/app/features/admin/services/category.admin.service.ts
frontend/src/app/features/admin/services/order.admin.service.ts
frontend/src/app/features/admin/services/report.service.ts
frontend/src/app/features/admin/services/specification-admin.service.ts
frontend/src/app/features/admin/services/user-admin.service.ts
frontend/src/app/features/checkout/checkout.component.html
frontend/src/app/features/checkout/checkout.component.scss
frontend/src/app/features/checkout/checkout.component.ts
frontend/src/app/features/home/home-page/home-page.component.html
frontend/src/app/features/home/home-page/home-page.component.scss
frontend/src/app/features/home/home-page/home-page.component.spec.ts
frontend/src/app/features/home/home-page/home-page.component.ts
frontend/src/app/features/products/product-detail/product-detail.component.html
frontend/src/app/features/products/product-detail/product-detail.component.scss
frontend/src/app/features/products/product-detail/product-detail.component.ts
frontend/src/app/features/products/product-form/product-form.component.html
frontend/src/app/features/products/product-form/product-form.component.scss
frontend/src/app/features/products/product-form/product-form.component.ts
frontend/src/app/features/products/product-list/product-list.component.html
frontend/src/app/features/products/product-list/product-list.component.scss
frontend/src/app/features/products/product-list/product-list.component.ts
frontend/src/app/features/products/product.service.ts
frontend/src/app/features/products/products.module.ts
frontend/src/app/features/products/user-product-list/user-product-list.component.html
frontend/src/app/features/products/user-product-list/user-product-list.component.scss
frontend/src/app/features/products/user-product-list/user-product-list.component.spec.ts
frontend/src/app/features/products/user-product-list/user-product-list.component.ts
frontend/src/app/features/reviews/review-form-dialog/review-form-dialog.component.ts
frontend/src/app/features/reviews/review-list/review-list.component.html
frontend/src/app/features/reviews/review-list/review-list.component.scss
frontend/src/app/features/reviews/review-list/review-list.component.ts
frontend/src/app/features/reviews/review.service.ts
frontend/src/app/features/shopping-cart/cart.service.ts
frontend/src/app/features/shopping-cart/shopping-cart.component.html
frontend/src/app/features/shopping-cart/shopping-cart.component.scss
frontend/src/app/features/shopping-cart/shopping-cart.component.ts
frontend/src/app/features/user-dashboard/services/client-order.service.ts
frontend/src/app/features/user-dashboard/user-dashboard.component.html
frontend/src/app/features/user-dashboard/user-dashboard.component.scss
frontend/src/app/features/user-dashboard/user-dashboard.component.ts
frontend/src/app/features/user-dashboard/user-order-history/user-order-history.component.html
frontend/src/app/features/user-dashboard/user-order-history/user-order-history.component.scss
frontend/src/app/features/user-dashboard/user-order-history/user-order-history.component.ts
frontend/src/app/features/user-profile/user-profile.component.html
frontend/src/app/features/user-profile/user-profile.component.scss
frontend/src/app/features/user-profile/user-profile.component.ts
frontend/src/app/features/user-profile/user-profile.service.ts
frontend/src/app/login/login.component.html
frontend/src/app/login/login.component.scss
frontend/src/app/login/login.component.ts
frontend/src/app/shared/components/star-rating/star-rating.component.ts
frontend/src/app/shared/in-memory-data.service.ts
frontend/src/app/shared/material.module.ts
frontend/src/app/shared/models/cart.model.ts
frontend/src/app/shared/models/category.model.ts
frontend/src/app/shared/models/order-item.model.ts
frontend/src/app/shared/models/order-status-update.model.ts
frontend/src/app/shared/models/order.model.ts
frontend/src/app/shared/models/product.model.ts
frontend/src/app/shared/models/report.model.ts
frontend/src/app/shared/models/review.model.ts
frontend/src/app/shared/models/specification-definition.model.ts
frontend/src/app/shared/models/specification-value.model.ts
frontend/src/app/shared/models/user.model.ts
frontend/src/app/shared/pipes/nl2br.pipe.ts
frontend/src/app/signup/signup.component.html
frontend/src/app/signup/signup.component.scss
frontend/src/app/signup/signup.component.ts
frontend/src/index.html
frontend/src/main.server.ts
frontend/src/main.ts
frontend/src/server.ts
frontend/src/styles.scss
frontend/tsconfig.app.json
frontend/tsconfig.json
frontend/tsconfig.spec.json
package.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="frontend/src/app/features/user-profile/user-profile.service.ts">
// frontend/src/app/features/user-profile/user-profile.service.ts
import { Injectable, inject } from '@angular/core';
import { HttpClient, HttpErrorResponse } from '@angular/common/http';
import { Observable, throwError } from 'rxjs';
import { catchError } from 'rxjs/operators';
import { User, UserUpdateDto } from '../../shared/models/user.model';

@Injectable({
  providedIn: 'root'
})
export class UserProfileService {
  private apiUrl = '/api/users';
  private http = inject(HttpClient);

  getMyProfile(): Observable<User> {
    return this.http.get<User>(`${this.apiUrl}/me`)
      .pipe(catchError(this.handleError));
  }

  updateMyProfile(userData: UserUpdateDto): Observable<User> {
    return this.http.put<User>(`${this.apiUrl}/me`, userData)
      .pipe(catchError(this.handleError));
  }

  private handleError(error: HttpErrorResponse) {
    let userFriendlyErrorMessage = 'A apărut o problemă. Vă rugăm încercați din nou mai târziu.';
    
    if (error.error && typeof error.error === 'object' && error.error !== null) {
      if (error.error.fieldErrors) {
        const fieldErrors = error.error.fieldErrors;
        const errorMessages = Object.entries(fieldErrors)
          .map(([field, message]) => `${field}: ${message}`)
          .join(', ');
        userFriendlyErrorMessage = `Erori de validare: ${errorMessages}`;
      } else {
        userFriendlyErrorMessage = error.error.message || userFriendlyErrorMessage;
      }
    } else if (typeof error.error === 'string') {
      userFriendlyErrorMessage = error.error;
    } else if (error.message) {
      if (error.status === 0 || error.status === -1) {
        userFriendlyErrorMessage = 'Eroare de conexiune cu serverul.';
      } else if (error.status === 401) {
        userFriendlyErrorMessage = 'Sesiunea a expirat. Te rugăm să te autentifici din nou.';
      } else {
        userFriendlyErrorMessage = `A apărut o eroare (${error.status}): ${error.statusText}`;
      }
    }

    console.error('User Profile Service Error:', error);
    return throwError(() => new Error(userFriendlyErrorMessage));
  }
}
</file>

<file path="backend/.gitattributes">
/mvnw text eol=lf
*.cmd text eol=crlf
</file>

<file path="backend/.gitignore">
HELP.md
target/
.mvn/wrapper/maven-wrapper.jar
!**/src/main/**/target/
!**/src/test/**/target/

### STS ###
.apt_generated
.classpath
.factorypath
.project
.settings
.springBeans
.sts4-cache

### IntelliJ IDEA ###
.idea
*.iws
*.iml
*.ipr

### NetBeans ###
/nbproject/private/
/nbbuild/
/dist/
/nbdist/
/.nb-gradle/
build/
!**/src/main/**/build/
!**/src/test/**/build/

### VS Code ###
.vscode/
</file>

<file path="backend/.mvn/wrapper/maven-wrapper.properties">
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
wrapperVersion=3.3.2
distributionType=only-script
distributionUrl=https://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.9.9/apache-maven-3.9.9-bin.zip
</file>

<file path="backend/mvnw">
#!/bin/sh
# ----------------------------------------------------------------------------
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
# ----------------------------------------------------------------------------

# ----------------------------------------------------------------------------
# Apache Maven Wrapper startup batch script, version 3.3.2
#
# Optional ENV vars
# -----------------
#   JAVA_HOME - location of a JDK home dir, required when download maven via java source
#   MVNW_REPOURL - repo url base for downloading maven distribution
#   MVNW_USERNAME/MVNW_PASSWORD - user and password for downloading maven
#   MVNW_VERBOSE - true: enable verbose log; debug: trace the mvnw script; others: silence the output
# ----------------------------------------------------------------------------

set -euf
[ "${MVNW_VERBOSE-}" != debug ] || set -x

# OS specific support.
native_path() { printf %s\\n "$1"; }
case "$(uname)" in
CYGWIN* | MINGW*)
  [ -z "${JAVA_HOME-}" ] || JAVA_HOME="$(cygpath --unix "$JAVA_HOME")"
  native_path() { cygpath --path --windows "$1"; }
  ;;
esac

# set JAVACMD and JAVACCMD
set_java_home() {
  # For Cygwin and MinGW, ensure paths are in Unix format before anything is touched
  if [ -n "${JAVA_HOME-}" ]; then
    if [ -x "$JAVA_HOME/jre/sh/java" ]; then
      # IBM's JDK on AIX uses strange locations for the executables
      JAVACMD="$JAVA_HOME/jre/sh/java"
      JAVACCMD="$JAVA_HOME/jre/sh/javac"
    else
      JAVACMD="$JAVA_HOME/bin/java"
      JAVACCMD="$JAVA_HOME/bin/javac"

      if [ ! -x "$JAVACMD" ] || [ ! -x "$JAVACCMD" ]; then
        echo "The JAVA_HOME environment variable is not defined correctly, so mvnw cannot run." >&2
        echo "JAVA_HOME is set to \"$JAVA_HOME\", but \"\$JAVA_HOME/bin/java\" or \"\$JAVA_HOME/bin/javac\" does not exist." >&2
        return 1
      fi
    fi
  else
    JAVACMD="$(
      'set' +e
      'unset' -f command 2>/dev/null
      'command' -v java
    )" || :
    JAVACCMD="$(
      'set' +e
      'unset' -f command 2>/dev/null
      'command' -v javac
    )" || :

    if [ ! -x "${JAVACMD-}" ] || [ ! -x "${JAVACCMD-}" ]; then
      echo "The java/javac command does not exist in PATH nor is JAVA_HOME set, so mvnw cannot run." >&2
      return 1
    fi
  fi
}

# hash string like Java String::hashCode
hash_string() {
  str="${1:-}" h=0
  while [ -n "$str" ]; do
    char="${str%"${str#?}"}"
    h=$(((h * 31 + $(LC_CTYPE=C printf %d "'$char")) % 4294967296))
    str="${str#?}"
  done
  printf %x\\n $h
}

verbose() { :; }
[ "${MVNW_VERBOSE-}" != true ] || verbose() { printf %s\\n "${1-}"; }

die() {
  printf %s\\n "$1" >&2
  exit 1
}

trim() {
  # MWRAPPER-139:
  #   Trims trailing and leading whitespace, carriage returns, tabs, and linefeeds.
  #   Needed for removing poorly interpreted newline sequences when running in more
  #   exotic environments such as mingw bash on Windows.
  printf "%s" "${1}" | tr -d '[:space:]'
}

# parse distributionUrl and optional distributionSha256Sum, requires .mvn/wrapper/maven-wrapper.properties
while IFS="=" read -r key value; do
  case "${key-}" in
  distributionUrl) distributionUrl=$(trim "${value-}") ;;
  distributionSha256Sum) distributionSha256Sum=$(trim "${value-}") ;;
  esac
done <"${0%/*}/.mvn/wrapper/maven-wrapper.properties"
[ -n "${distributionUrl-}" ] || die "cannot read distributionUrl property in ${0%/*}/.mvn/wrapper/maven-wrapper.properties"

case "${distributionUrl##*/}" in
maven-mvnd-*bin.*)
  MVN_CMD=mvnd.sh _MVNW_REPO_PATTERN=/maven/mvnd/
  case "${PROCESSOR_ARCHITECTURE-}${PROCESSOR_ARCHITEW6432-}:$(uname -a)" in
  *AMD64:CYGWIN* | *AMD64:MINGW*) distributionPlatform=windows-amd64 ;;
  :Darwin*x86_64) distributionPlatform=darwin-amd64 ;;
  :Darwin*arm64) distributionPlatform=darwin-aarch64 ;;
  :Linux*x86_64*) distributionPlatform=linux-amd64 ;;
  *)
    echo "Cannot detect native platform for mvnd on $(uname)-$(uname -m), use pure java version" >&2
    distributionPlatform=linux-amd64
    ;;
  esac
  distributionUrl="${distributionUrl%-bin.*}-$distributionPlatform.zip"
  ;;
maven-mvnd-*) MVN_CMD=mvnd.sh _MVNW_REPO_PATTERN=/maven/mvnd/ ;;
*) MVN_CMD="mvn${0##*/mvnw}" _MVNW_REPO_PATTERN=/org/apache/maven/ ;;
esac

# apply MVNW_REPOURL and calculate MAVEN_HOME
# maven home pattern: ~/.m2/wrapper/dists/{apache-maven-<version>,maven-mvnd-<version>-<platform>}/<hash>
[ -z "${MVNW_REPOURL-}" ] || distributionUrl="$MVNW_REPOURL$_MVNW_REPO_PATTERN${distributionUrl#*"$_MVNW_REPO_PATTERN"}"
distributionUrlName="${distributionUrl##*/}"
distributionUrlNameMain="${distributionUrlName%.*}"
distributionUrlNameMain="${distributionUrlNameMain%-bin}"
MAVEN_USER_HOME="${MAVEN_USER_HOME:-${HOME}/.m2}"
MAVEN_HOME="${MAVEN_USER_HOME}/wrapper/dists/${distributionUrlNameMain-}/$(hash_string "$distributionUrl")"

exec_maven() {
  unset MVNW_VERBOSE MVNW_USERNAME MVNW_PASSWORD MVNW_REPOURL || :
  exec "$MAVEN_HOME/bin/$MVN_CMD" "$@" || die "cannot exec $MAVEN_HOME/bin/$MVN_CMD"
}

if [ -d "$MAVEN_HOME" ]; then
  verbose "found existing MAVEN_HOME at $MAVEN_HOME"
  exec_maven "$@"
fi

case "${distributionUrl-}" in
*?-bin.zip | *?maven-mvnd-?*-?*.zip) ;;
*) die "distributionUrl is not valid, must match *-bin.zip or maven-mvnd-*.zip, but found '${distributionUrl-}'" ;;
esac

# prepare tmp dir
if TMP_DOWNLOAD_DIR="$(mktemp -d)" && [ -d "$TMP_DOWNLOAD_DIR" ]; then
  clean() { rm -rf -- "$TMP_DOWNLOAD_DIR"; }
  trap clean HUP INT TERM EXIT
else
  die "cannot create temp dir"
fi

mkdir -p -- "${MAVEN_HOME%/*}"

# Download and Install Apache Maven
verbose "Couldn't find MAVEN_HOME, downloading and installing it ..."
verbose "Downloading from: $distributionUrl"
verbose "Downloading to: $TMP_DOWNLOAD_DIR/$distributionUrlName"

# select .zip or .tar.gz
if ! command -v unzip >/dev/null; then
  distributionUrl="${distributionUrl%.zip}.tar.gz"
  distributionUrlName="${distributionUrl##*/}"
fi

# verbose opt
__MVNW_QUIET_WGET=--quiet __MVNW_QUIET_CURL=--silent __MVNW_QUIET_UNZIP=-q __MVNW_QUIET_TAR=''
[ "${MVNW_VERBOSE-}" != true ] || __MVNW_QUIET_WGET='' __MVNW_QUIET_CURL='' __MVNW_QUIET_UNZIP='' __MVNW_QUIET_TAR=v

# normalize http auth
case "${MVNW_PASSWORD:+has-password}" in
'') MVNW_USERNAME='' MVNW_PASSWORD='' ;;
has-password) [ -n "${MVNW_USERNAME-}" ] || MVNW_USERNAME='' MVNW_PASSWORD='' ;;
esac

if [ -z "${MVNW_USERNAME-}" ] && command -v wget >/dev/null; then
  verbose "Found wget ... using wget"
  wget ${__MVNW_QUIET_WGET:+"$__MVNW_QUIET_WGET"} "$distributionUrl" -O "$TMP_DOWNLOAD_DIR/$distributionUrlName" || die "wget: Failed to fetch $distributionUrl"
elif [ -z "${MVNW_USERNAME-}" ] && command -v curl >/dev/null; then
  verbose "Found curl ... using curl"
  curl ${__MVNW_QUIET_CURL:+"$__MVNW_QUIET_CURL"} -f -L -o "$TMP_DOWNLOAD_DIR/$distributionUrlName" "$distributionUrl" || die "curl: Failed to fetch $distributionUrl"
elif set_java_home; then
  verbose "Falling back to use Java to download"
  javaSource="$TMP_DOWNLOAD_DIR/Downloader.java"
  targetZip="$TMP_DOWNLOAD_DIR/$distributionUrlName"
  cat >"$javaSource" <<-END
	public class Downloader extends java.net.Authenticator
	{
	  protected java.net.PasswordAuthentication getPasswordAuthentication()
	  {
	    return new java.net.PasswordAuthentication( System.getenv( "MVNW_USERNAME" ), System.getenv( "MVNW_PASSWORD" ).toCharArray() );
	  }
	  public static void main( String[] args ) throws Exception
	  {
	    setDefault( new Downloader() );
	    java.nio.file.Files.copy( java.net.URI.create( args[0] ).toURL().openStream(), java.nio.file.Paths.get( args[1] ).toAbsolutePath().normalize() );
	  }
	}
	END
  # For Cygwin/MinGW, switch paths to Windows format before running javac and java
  verbose " - Compiling Downloader.java ..."
  "$(native_path "$JAVACCMD")" "$(native_path "$javaSource")" || die "Failed to compile Downloader.java"
  verbose " - Running Downloader.java ..."
  "$(native_path "$JAVACMD")" -cp "$(native_path "$TMP_DOWNLOAD_DIR")" Downloader "$distributionUrl" "$(native_path "$targetZip")"
fi

# If specified, validate the SHA-256 sum of the Maven distribution zip file
if [ -n "${distributionSha256Sum-}" ]; then
  distributionSha256Result=false
  if [ "$MVN_CMD" = mvnd.sh ]; then
    echo "Checksum validation is not supported for maven-mvnd." >&2
    echo "Please disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties." >&2
    exit 1
  elif command -v sha256sum >/dev/null; then
    if echo "$distributionSha256Sum  $TMP_DOWNLOAD_DIR/$distributionUrlName" | sha256sum -c >/dev/null 2>&1; then
      distributionSha256Result=true
    fi
  elif command -v shasum >/dev/null; then
    if echo "$distributionSha256Sum  $TMP_DOWNLOAD_DIR/$distributionUrlName" | shasum -a 256 -c >/dev/null 2>&1; then
      distributionSha256Result=true
    fi
  else
    echo "Checksum validation was requested but neither 'sha256sum' or 'shasum' are available." >&2
    echo "Please install either command, or disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties." >&2
    exit 1
  fi
  if [ $distributionSha256Result = false ]; then
    echo "Error: Failed to validate Maven distribution SHA-256, your Maven distribution might be compromised." >&2
    echo "If you updated your Maven version, you need to update the specified distributionSha256Sum property." >&2
    exit 1
  fi
fi

# unzip and move
if command -v unzip >/dev/null; then
  unzip ${__MVNW_QUIET_UNZIP:+"$__MVNW_QUIET_UNZIP"} "$TMP_DOWNLOAD_DIR/$distributionUrlName" -d "$TMP_DOWNLOAD_DIR" || die "failed to unzip"
else
  tar xzf${__MVNW_QUIET_TAR:+"$__MVNW_QUIET_TAR"} "$TMP_DOWNLOAD_DIR/$distributionUrlName" -C "$TMP_DOWNLOAD_DIR" || die "failed to untar"
fi
printf %s\\n "$distributionUrl" >"$TMP_DOWNLOAD_DIR/$distributionUrlNameMain/mvnw.url"
mv -- "$TMP_DOWNLOAD_DIR/$distributionUrlNameMain" "$MAVEN_HOME" || [ -d "$MAVEN_HOME" ] || die "fail to move MAVEN_HOME"

clean || :
exec_maven "$@"
</file>

<file path="backend/mvnw.cmd">
<# : batch portion
@REM ----------------------------------------------------------------------------
@REM Licensed to the Apache Software Foundation (ASF) under one
@REM or more contributor license agreements.  See the NOTICE file
@REM distributed with this work for additional information
@REM regarding copyright ownership.  The ASF licenses this file
@REM to you under the Apache License, Version 2.0 (the
@REM "License"); you may not use this file except in compliance
@REM with the License.  You may obtain a copy of the License at
@REM
@REM    http://www.apache.org/licenses/LICENSE-2.0
@REM
@REM Unless required by applicable law or agreed to in writing,
@REM software distributed under the License is distributed on an
@REM "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
@REM KIND, either express or implied.  See the License for the
@REM specific language governing permissions and limitations
@REM under the License.
@REM ----------------------------------------------------------------------------

@REM ----------------------------------------------------------------------------
@REM Apache Maven Wrapper startup batch script, version 3.3.2
@REM
@REM Optional ENV vars
@REM   MVNW_REPOURL - repo url base for downloading maven distribution
@REM   MVNW_USERNAME/MVNW_PASSWORD - user and password for downloading maven
@REM   MVNW_VERBOSE - true: enable verbose log; others: silence the output
@REM ----------------------------------------------------------------------------

@IF "%__MVNW_ARG0_NAME__%"=="" (SET __MVNW_ARG0_NAME__=%~nx0)
@SET __MVNW_CMD__=
@SET __MVNW_ERROR__=
@SET __MVNW_PSMODULEP_SAVE=%PSModulePath%
@SET PSModulePath=
@FOR /F "usebackq tokens=1* delims==" %%A IN (`powershell -noprofile "& {$scriptDir='%~dp0'; $script='%__MVNW_ARG0_NAME__%'; icm -ScriptBlock ([Scriptblock]::Create((Get-Content -Raw '%~f0'))) -NoNewScope}"`) DO @(
  IF "%%A"=="MVN_CMD" (set __MVNW_CMD__=%%B) ELSE IF "%%B"=="" (echo %%A) ELSE (echo %%A=%%B)
)
@SET PSModulePath=%__MVNW_PSMODULEP_SAVE%
@SET __MVNW_PSMODULEP_SAVE=
@SET __MVNW_ARG0_NAME__=
@SET MVNW_USERNAME=
@SET MVNW_PASSWORD=
@IF NOT "%__MVNW_CMD__%"=="" (%__MVNW_CMD__% %*)
@echo Cannot start maven from wrapper >&2 && exit /b 1
@GOTO :EOF
: end batch / begin powershell #>

$ErrorActionPreference = "Stop"
if ($env:MVNW_VERBOSE -eq "true") {
  $VerbosePreference = "Continue"
}

# calculate distributionUrl, requires .mvn/wrapper/maven-wrapper.properties
$distributionUrl = (Get-Content -Raw "$scriptDir/.mvn/wrapper/maven-wrapper.properties" | ConvertFrom-StringData).distributionUrl
if (!$distributionUrl) {
  Write-Error "cannot read distributionUrl property in $scriptDir/.mvn/wrapper/maven-wrapper.properties"
}

switch -wildcard -casesensitive ( $($distributionUrl -replace '^.*/','') ) {
  "maven-mvnd-*" {
    $USE_MVND = $true
    $distributionUrl = $distributionUrl -replace '-bin\.[^.]*$',"-windows-amd64.zip"
    $MVN_CMD = "mvnd.cmd"
    break
  }
  default {
    $USE_MVND = $false
    $MVN_CMD = $script -replace '^mvnw','mvn'
    break
  }
}

# apply MVNW_REPOURL and calculate MAVEN_HOME
# maven home pattern: ~/.m2/wrapper/dists/{apache-maven-<version>,maven-mvnd-<version>-<platform>}/<hash>
if ($env:MVNW_REPOURL) {
  $MVNW_REPO_PATTERN = if ($USE_MVND) { "/org/apache/maven/" } else { "/maven/mvnd/" }
  $distributionUrl = "$env:MVNW_REPOURL$MVNW_REPO_PATTERN$($distributionUrl -replace '^.*'+$MVNW_REPO_PATTERN,'')"
}
$distributionUrlName = $distributionUrl -replace '^.*/',''
$distributionUrlNameMain = $distributionUrlName -replace '\.[^.]*$','' -replace '-bin$',''
$MAVEN_HOME_PARENT = "$HOME/.m2/wrapper/dists/$distributionUrlNameMain"
if ($env:MAVEN_USER_HOME) {
  $MAVEN_HOME_PARENT = "$env:MAVEN_USER_HOME/wrapper/dists/$distributionUrlNameMain"
}
$MAVEN_HOME_NAME = ([System.Security.Cryptography.MD5]::Create().ComputeHash([byte[]][char[]]$distributionUrl) | ForEach-Object {$_.ToString("x2")}) -join ''
$MAVEN_HOME = "$MAVEN_HOME_PARENT/$MAVEN_HOME_NAME"

if (Test-Path -Path "$MAVEN_HOME" -PathType Container) {
  Write-Verbose "found existing MAVEN_HOME at $MAVEN_HOME"
  Write-Output "MVN_CMD=$MAVEN_HOME/bin/$MVN_CMD"
  exit $?
}

if (! $distributionUrlNameMain -or ($distributionUrlName -eq $distributionUrlNameMain)) {
  Write-Error "distributionUrl is not valid, must end with *-bin.zip, but found $distributionUrl"
}

# prepare tmp dir
$TMP_DOWNLOAD_DIR_HOLDER = New-TemporaryFile
$TMP_DOWNLOAD_DIR = New-Item -Itemtype Directory -Path "$TMP_DOWNLOAD_DIR_HOLDER.dir"
$TMP_DOWNLOAD_DIR_HOLDER.Delete() | Out-Null
trap {
  if ($TMP_DOWNLOAD_DIR.Exists) {
    try { Remove-Item $TMP_DOWNLOAD_DIR -Recurse -Force | Out-Null }
    catch { Write-Warning "Cannot remove $TMP_DOWNLOAD_DIR" }
  }
}

New-Item -Itemtype Directory -Path "$MAVEN_HOME_PARENT" -Force | Out-Null

# Download and Install Apache Maven
Write-Verbose "Couldn't find MAVEN_HOME, downloading and installing it ..."
Write-Verbose "Downloading from: $distributionUrl"
Write-Verbose "Downloading to: $TMP_DOWNLOAD_DIR/$distributionUrlName"

$webclient = New-Object System.Net.WebClient
if ($env:MVNW_USERNAME -and $env:MVNW_PASSWORD) {
  $webclient.Credentials = New-Object System.Net.NetworkCredential($env:MVNW_USERNAME, $env:MVNW_PASSWORD)
}
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
$webclient.DownloadFile($distributionUrl, "$TMP_DOWNLOAD_DIR/$distributionUrlName") | Out-Null

# If specified, validate the SHA-256 sum of the Maven distribution zip file
$distributionSha256Sum = (Get-Content -Raw "$scriptDir/.mvn/wrapper/maven-wrapper.properties" | ConvertFrom-StringData).distributionSha256Sum
if ($distributionSha256Sum) {
  if ($USE_MVND) {
    Write-Error "Checksum validation is not supported for maven-mvnd. `nPlease disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties."
  }
  Import-Module $PSHOME\Modules\Microsoft.PowerShell.Utility -Function Get-FileHash
  if ((Get-FileHash "$TMP_DOWNLOAD_DIR/$distributionUrlName" -Algorithm SHA256).Hash.ToLower() -ne $distributionSha256Sum) {
    Write-Error "Error: Failed to validate Maven distribution SHA-256, your Maven distribution might be compromised. If you updated your Maven version, you need to update the specified distributionSha256Sum property."
  }
}

# unzip and move
Expand-Archive "$TMP_DOWNLOAD_DIR/$distributionUrlName" -DestinationPath "$TMP_DOWNLOAD_DIR" | Out-Null
Rename-Item -Path "$TMP_DOWNLOAD_DIR/$distributionUrlNameMain" -NewName $MAVEN_HOME_NAME | Out-Null
try {
  Move-Item -Path "$TMP_DOWNLOAD_DIR/$MAVEN_HOME_NAME" -Destination $MAVEN_HOME_PARENT | Out-Null
} catch {
  if (! (Test-Path -Path "$MAVEN_HOME" -PathType Container)) {
    Write-Error "fail to move MAVEN_HOME"
  }
} finally {
  try { Remove-Item $TMP_DOWNLOAD_DIR -Recurse -Force | Out-Null }
  catch { Write-Warning "Cannot remove $TMP_DOWNLOAD_DIR" }
}

Write-Output "MVN_CMD=$MAVEN_HOME/bin/$MVN_CMD"
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/controller/AngularForwardController.java">
package com.magazincomputere.magazin_api.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
public class AngularForwardController {
    // Această expresie regulată este un exemplu și s-ar putea să necesite ajustări fine.
    // Scopul este să redirecționeze către index.html pentru rutele Angular,
    // cu excepția celor care încep cu /api, /swagger-ui, /api-docs, /h2-console
    // și a celor care par a fi pentru fișiere statice (conțin un punct).
    @RequestMapping(value = {"/", "/{path:^(?!api|swagger-ui|api-docs|h2-console|.*\\.).*$}/**", "/{path:^(?!api|swagger-ui|api-docs|h2-console|.*\\.).*$}"})
    public String forward() {
        return "forward:/index.html";
    }
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/controller/AuthController.java">
package com.magazincomputere.magazin_api.controller;

import com.magazincomputere.magazin_api.dto.LoginRequest;
import com.magazincomputere.magazin_api.dto.SignupRequest; // Va trebui să creezi acest DTO
import com.magazincomputere.magazin_api.dto.JwtResponse;
import com.magazincomputere.magazin_api.dto.MessageResponse;
import com.magazincomputere.magazin_api.model.ERole;
import com.magazincomputere.magazin_api.model.Role;
import com.magazincomputere.magazin_api.model.User;
import com.magazincomputere.magazin_api.repository.RoleRepository;
import com.magazincomputere.magazin_api.repository.UserRepository;
import com.magazincomputere.magazin_api.security.jwt.JwtUtils;
import com.magazincomputere.magazin_api.security.services.UserDetailsImpl;

import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.web.bind.annotation.*;

import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/auth")
public class AuthController {

    @Autowired
    AuthenticationManager authenticationManager;

    @Autowired
    UserRepository userRepository;

    @Autowired
    RoleRepository roleRepository;

    @Autowired
    PasswordEncoder encoder;

    @Autowired
    JwtUtils jwtUtils;

    @PostMapping("/login")
    public ResponseEntity<?> authenticateUser(@Valid @RequestBody LoginRequest loginRequest) {
        Authentication authentication = authenticationManager.authenticate(
                new UsernamePasswordAuthenticationToken(loginRequest.getUsername(), loginRequest.getPassword()));

        SecurityContextHolder.getContext().setAuthentication(authentication);
        String jwt = jwtUtils.generateJwtToken(authentication);

        UserDetailsImpl userDetails = (UserDetailsImpl) authentication.getPrincipal();
        List<String> roles = userDetails.getAuthorities().stream()
                .map(item -> item.getAuthority())
                .collect(Collectors.toList());

        return ResponseEntity.ok(new JwtResponse(jwt,
                                                 userDetails.getId(),
                                                 userDetails.getUsername(),
                                                 userDetails.getEmail(),
                                                 roles));
    }

    @PostMapping("/signup")
    public ResponseEntity<?> registerUser(@Valid @RequestBody SignupRequest signUpRequest) { // Creează DTO-ul SignupRequest
        if (userRepository.existsByUsername(signUpRequest.getUsername())) {
            return ResponseEntity
                    .badRequest()
                    .body(new MessageResponse("Error: Username is already taken!"));
        }

        if (userRepository.existsByEmail(signUpRequest.getEmail())) {
            return ResponseEntity
                    .badRequest()
                    .body(new MessageResponse("Error: Email is already in use!"));
        }

        // Create new user's account
        User user = new User(signUpRequest.getUsername(),
                             signUpRequest.getEmail(),
                             encoder.encode(signUpRequest.getPassword()));

        Set<String> strRoles = signUpRequest.getRoles(); // SignupRequest ar trebui să permită specificarea rolurilor
        Set<Role> roles = new HashSet<>();

        if (strRoles == null || strRoles.isEmpty()) {
            Role userRole = roleRepository.findByName(ERole.ROLE_USER)
                    .orElseThrow(() -> new RuntimeException("Error: Role USER is not found."));
            roles.add(userRole);
        } else {
            strRoles.forEach(role -> {
                switch (role.toLowerCase()) {
                    case "admin":
                        Role adminRole = roleRepository.findByName(ERole.ROLE_ADMIN)
                                .orElseThrow(() -> new RuntimeException("Error: Role ADMIN is not found."));
                        roles.add(adminRole);
                        break;
                    default:
                        Role userRole = roleRepository.findByName(ERole.ROLE_USER)
                                .orElseThrow(() -> new RuntimeException("Error: Role USER is not found."));
                        roles.add(userRole);
                }
            });
        }

        user.setRoles(roles);
        userRepository.save(user);

        return ResponseEntity.ok(new MessageResponse("User registered successfully!"));
    }
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/controller/CategoryController.java">
package com.magazincomputere.magazin_api.controller;

import com.magazincomputere.magazin_api.dto.CategoryDto;
import com.magazincomputere.magazin_api.service.CategoryService; // Va trebui să creezi CategoryService
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/categories")
public class CategoryController {

    @Autowired
    private CategoryService categoryService; // Asigură-te că ai creat CategoryService

    @GetMapping
    public List<CategoryDto> getAllCategories() { // Acces public
        return categoryService.getAllCategories();
    }

    @GetMapping("/{id}")
    public ResponseEntity<CategoryDto> getCategoryById(@PathVariable Long id) { // Acces public
        CategoryDto categoryDto = categoryService.getCategoryById(id);
        return ResponseEntity.ok(categoryDto);
    }

    @PostMapping
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<CategoryDto> createCategory(@Valid @RequestBody CategoryDto categoryDto) {
        CategoryDto createdCategory = categoryService.createCategory(categoryDto);
        return new ResponseEntity<>(createdCategory, HttpStatus.CREATED);
    }

    @PutMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<CategoryDto> updateCategory(@PathVariable Long id, @Valid @RequestBody CategoryDto categoryDto) {
        CategoryDto updatedCategory = categoryService.updateCategory(id, categoryDto);
        return ResponseEntity.ok(updatedCategory);
    }

    @DeleteMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<Void> deleteCategory(@PathVariable Long id) {
        categoryService.deleteCategory(id);
        return ResponseEntity.noContent().build();
    }
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/controller/CustomerController.java">
package com.magazincomputere.magazin_api.controller;

// import com.magazincomputere.magazin_api.dto.CustomerDto;
// import com.magazincomputere.magazin_api.service.CustomerService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/customers")
@PreAuthorize("hasRole('ADMIN')")
public class CustomerController {

    // @Autowired
    // private CustomerService customerService;

    // @GetMapping
    // public List<CustomerDto> getAllCustomers() {
    //     return customerService.findAllCustomers();
    // }

    // @GetMapping("/{id}")
    // public ResponseEntity<CustomerDto> getCustomerById(@PathVariable Long id) {
    //     return ResponseEntity.ok(customerService.findCustomerById(id));
    // }
    // TODO: Adaugă endpoint-uri pentru UPDATE, DELETE dacă este necesar
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/controller/ProductController.java">
package com.magazincomputere.magazin_api.controller;

import com.magazincomputere.magazin_api.dto.ProductDto;
import com.magazincomputere.magazin_api.service.ProductService;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize; // IMPORTĂ
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/products")
public class ProductController {

    @Autowired
    private ProductService productService;

    @GetMapping
    public List<ProductDto> getAllProducts() { // Acces public
        return productService.getAllProducts();
    }

    @GetMapping("/{id}")
    public ResponseEntity<ProductDto> getProductById(@PathVariable Long id) { // Acces public
        return ResponseEntity.ok(productService.getProductById(id));
    }

    @PostMapping
    @PreAuthorize("hasRole('ADMIN')") // Doar ADMIN poate crea produse
    public ResponseEntity<ProductDto> createProduct(@Valid @RequestBody ProductDto productDto) {
        ProductDto createdProduct = productService.createProduct(productDto);
        return new ResponseEntity<>(createdProduct, HttpStatus.CREATED);
    }

    @PutMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')") // Doar ADMIN poate actualiza produse
    public ResponseEntity<ProductDto> updateProduct(@PathVariable Long id, @Valid @RequestBody ProductDto productDto) {
        ProductDto updatedProduct = productService.updateProduct(id, productDto);
        return ResponseEntity.ok(updatedProduct);
    }

    @DeleteMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')") // Doar ADMIN poate șterge produse
    public ResponseEntity<Void> deleteProduct(@PathVariable Long id) {
        productService.deleteProduct(id);
        return ResponseEntity.noContent().build();
    }
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/controller/ReviewController.java">
// backend/src/main/java/com/magazincomputere/magazin_api/controller/ReviewController.java
package com.magazincomputere.magazin_api.controller;

import com.magazincomputere.magazin_api.dto.*;
import com.magazincomputere.magazin_api.security.services.UserDetailsImpl;
import com.magazincomputere.magazin_api.service.ReviewService;
import jakarta.validation.Valid;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/reviews")
public class ReviewController {

    @Autowired
    private ReviewService reviewService;

    @PostMapping
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<ReviewDto> createReview(@Valid @RequestBody CreateReviewRequest request) {
        Long userId = getCurrentUserId();
        ReviewDto review = reviewService.createReview(request, userId);
        return new ResponseEntity<>(review, HttpStatus.CREATED);
    }

    @PutMapping("/{reviewId}")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<ReviewDto> updateReview(
            @PathVariable Long reviewId,
            @Valid @RequestBody CreateReviewRequest request) {
        Long userId = getCurrentUserId();
        ReviewDto review = reviewService.updateReview(reviewId, request, userId);
        return ResponseEntity.ok(review);
    }

    @DeleteMapping("/{reviewId}")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<Void> deleteReview(@PathVariable Long reviewId) {
        Long userId = getCurrentUserId();
        boolean isAdmin = isCurrentUserAdmin();
        reviewService.deleteReview(reviewId, userId, isAdmin);
        return ResponseEntity.noContent().build();
    }

    @GetMapping("/product/{productId}")
    public ResponseEntity<Page<ReviewDto>> getProductReviews(
            @PathVariable Long productId,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size) {
        Page<ReviewDto> reviews = reviewService.getProductReviews(productId, page, size);
        return ResponseEntity.ok(reviews);
    }

    @GetMapping("/product/{productId}/summary")
    public ResponseEntity<ProductReviewSummary> getProductReviewSummary(@PathVariable Long productId) {
        ProductReviewSummary summary = reviewService.getProductReviewSummary(productId);
        return ResponseEntity.ok(summary);
    }

    @GetMapping("/product/{productId}/my-review")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<ReviewDto> getMyReviewForProduct(@PathVariable Long productId) {
        Long userId = getCurrentUserId();
        ReviewDto review = reviewService.getUserReviewForProduct(productId, userId);
        return ResponseEntity.ok(review);
    }

    private Long getCurrentUserId() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        UserDetailsImpl userDetails = (UserDetailsImpl) authentication.getPrincipal();
        return userDetails.getId();
    }

    private boolean isCurrentUserAdmin() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        return authentication.getAuthorities().contains(new SimpleGrantedAuthority("ROLE_ADMIN"));
    }
    @GetMapping("/user/my-reviews")
@PreAuthorize("isAuthenticated()")
public ResponseEntity<List<ReviewDto>> getMyReviews() {
    Long userId = getCurrentUserId();
    List<ReviewDto> reviews = reviewService.getUserReviews(userId);
    return ResponseEntity.ok(reviews);
}
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/controller/SpecificationController.java">
package com.magazincomputere.magazin_api.controller;

import com.magazincomputere.magazin_api.dto.SpecificationDefinitionDto; // Va trebui să creezi acest DTO
import com.magazincomputere.magazin_api.service.SpecificationService; // Va trebui să creezi acest serviciu
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/specifications/definitions") // Am specificat 'definitions' pentru claritate
public class SpecificationController {

    @Autowired
    private SpecificationService specificationService;

    @GetMapping
    public List<SpecificationDefinitionDto> getAllSpecificationDefinitions() { // Acces public
        return specificationService.getAllDefinitions();
    }

    @GetMapping("/{id}")
    public ResponseEntity<SpecificationDefinitionDto> getSpecificationDefinitionById(@PathVariable Long id) { // Acces public
        SpecificationDefinitionDto dto = specificationService.getDefinitionById(id);
        return ResponseEntity.ok(dto);
    }

    @PostMapping
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<SpecificationDefinitionDto> createSpecificationDefinition(@Valid @RequestBody SpecificationDefinitionDto definitionDto) {
        SpecificationDefinitionDto savedDto = specificationService.createDefinition(definitionDto);
        return ResponseEntity.status(HttpStatus.CREATED).body(savedDto);
    }

    @PutMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<SpecificationDefinitionDto> updateSpecificationDefinition(@PathVariable Long id, @Valid @RequestBody SpecificationDefinitionDto definitionDto) {
        SpecificationDefinitionDto updatedDto = specificationService.updateDefinition(id, definitionDto);
        return ResponseEntity.ok(updatedDto);
    }

    @DeleteMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<Void> deleteSpecificationDefinition(@PathVariable Long id) {
        specificationService.deleteDefinition(id);
        return ResponseEntity.noContent().build();
    }
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/dto/AddToCartRequest.java">
package com.magazincomputere.magazin_api.dto;

import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotNull;
import lombok.Data;

@Data
public class AddToCartRequest {
    @NotNull(message = "ID-ul produsului este obligatoriu")
    private Long productId;
    
    @NotNull(message = "Cantitatea este obligatorie")
    @Min(value = 1, message = "Cantitatea trebuie să fie cel puțin 1")
    private Integer quantity;
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/dto/CartDto.java">
package com.magazincomputere.magazin_api.dto;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class CartDto {
    private Long id;
    private List<CartItemDto> items;
    private BigDecimal totalAmount;
    private LocalDateTime lastUpdated;
    private Integer totalItems;
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/dto/CartItemDto.java">
package com.magazincomputere.magazin_api.dto;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

import java.math.BigDecimal;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class CartItemDto {
    private Long id;
    private Long productId;
    private String productName;
    private String productDescription;
    private BigDecimal productPrice;
    private Integer productStock;
    private String productImageBase64;
    private Integer quantity;
    private BigDecimal subtotal;
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/dto/CategoryDto.java">
package com.magazincomputere.magazin_api.dto;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class CategoryDto {
    private Long id;

    @NotBlank(message = "Numele categoriei este obligatoriu.")
    @Size(min = 2, max = 100, message = "Numele categoriei trebuie să aibă între 2 și 100 de caractere.")
    private String name;

    @Size(max = 1000, message = "Descrierea categoriei nu poate depăși 1000 de caractere.")
    private String description;
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/dto/CheckoutRequest.java">
package com.magazincomputere.magazin_api.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import lombok.Data;

@Data
public class CheckoutRequest {
    @NotBlank(message = "Numele complet este obligatoriu")
    @Size(max = 100)
    private String fullName;
    
    @NotBlank(message = "Email-ul este obligatoriu")
    @Email(message = "Format email invalid")
    private String email;
    
    @NotBlank(message = "Numărul de telefon este obligatoriu")
    @Pattern(regexp = "^[0-9]{10,15}$", message = "Număr de telefon invalid")
    private String phone;
    
    @NotBlank(message = "Adresa este obligatorie")
    @Size(max = 500)
    private String billingAddress;
    
    private String shippingAddress; // Poate fi diferită de billing address
    
    @NotBlank(message = "Metoda de plată este obligatorie")
    @Pattern(regexp = "^(CARD|CASH_ON_DELIVERY|BANK_TRANSFER)$", message = "Metodă de plată invalidă")
    private String paymentMethod;
    
    private String orderNotes;
    
    private boolean agreeToTerms;
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/dto/CreateReviewRequest.java">
// backend/src/main/java/com/magazincomputere/magazin_api/dto/CreateReviewRequest.java
package com.magazincomputere.magazin_api.dto;

import jakarta.validation.constraints.*;
import lombok.Data;

@Data
public class CreateReviewRequest {
    @NotNull(message = "ID-ul produsului este obligatoriu")
    private Long productId;
    
    @NotNull(message = "Rating-ul este obligatoriu")
    @Min(value = 1, message = "Rating-ul minim este 1")
    @Max(value = 5, message = "Rating-ul maxim este 5")
    private Integer rating;
    
    @Size(max = 100, message = "Titlul nu poate depăși 100 de caractere")
    private String title;
    
    @Size(max = 1000, message = "Comentariul nu poate depăși 1000 de caractere")
    private String comment;
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/dto/CustomerDto.java">
package com.magazincomputere.magazin_api.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.Size;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class CustomerDto { // Acest DTO reflectă mai mult entitatea Customer
    private Long id;
    private Long userId; // Poate fi null dacă un client nu are cont de utilizator

    @Size(max = 100, message = "Prenumele nu poate depăși 100 de caractere.")
    private String firstName;

    @Size(max = 100, message = "Numele de familie nu poate depăși 100 de caractere.")
    private String lastName;

    @Email(message = "Formatul emailului este invalid.")
    @Size(max = 100, message = "Emailul nu poate depăși 100 de caractere.")
    private String email; // Poate fi diferit de emailul User-ului dacă e cazul

    @Size(max = 20, message = "Numărul de telefon nu poate depăși 20 de caractere.")
    private String phone;

    @Size(max = 500, message = "Adresa nu poate depăși 500 de caractere.")
    private String address;
    // Alte câmpuri relevante pentru admin
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/dto/JwtResponse.java">
package com.magazincomputere.magazin_api.dto;

import lombok.Getter;
import lombok.Setter;

import java.util.List;

@Getter
@Setter
public class JwtResponse {
    private String token;
    private String type = "Bearer";
    private Long id;
    private String username;
    private String email;
    private List<String> roles; // Lista de roluri (ex: ["ROLE_USER", "ROLE_ADMIN"])

    public JwtResponse(String accessToken, Long id, String username, String email, List<String> roles) {
        this.token = accessToken;
        this.id = id;
        this.username = username;
        this.email = email;
        this.roles = roles;
    }
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/dto/LoginRequest.java">
package com.magazincomputere.magazin_api.dto;

import jakarta.validation.constraints.NotBlank;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class LoginRequest {
    @NotBlank(message = "Numele de utilizator este obligatoriu.")
    private String username;

    @NotBlank(message = "Parola este obligatorie.")
    private String password;
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/dto/MessageResponse.java">
package com.magazincomputere.magazin_api.dto;

import lombok.Data;
import lombok.AllArgsConstructor;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class MessageResponse {
    private String message;
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/dto/OrderDto.java">
package com.magazincomputere.magazin_api.dto;

import jakarta.validation.Valid;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotEmpty;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class OrderDto {
    // Câmpuri pentru răspuns
    private Long id;
    private Long userId;
    private String username; // Numele utilizatorului care a plasat comanda
    private LocalDateTime orderDate;
    private String status;
    private BigDecimal totalAmount;

    // Câmpuri pentru request și răspuns
    @NotEmpty(message = "Comanda trebuie să conțină cel puțin un produs.")
    @Valid // Asigură validarea fiecărui OrderItemDto din listă
    private List<OrderItemDto> orderItems;

    // Informații de livrare/client (pot fi preluate parțial din profilul utilizatorului)
    @NotBlank(message = "Numele clientului este obligatoriu pentru livrare.")
    @Size(max = 100, message = "Numele clientului este prea lung.")
    private String customerName;

    @NotBlank(message = "Adresa de livrare este obligatorie.")
    @Size(max = 255, message = "Adresa de livrare este prea lungă.")
    private String shippingAddress;

    @NotBlank(message = "Emailul clientului este obligatoriu.")
    @Email(message = "Formatul emailului este invalid.")
    @Size(max = 100)
    private String customerEmail;

    @NotBlank(message = "Numărul de telefon este obligatoriu.")
    @Size(min=10, max = 20, message = "Numărul de telefon are format invalid.")
    private String customerPhone;
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/dto/OrderStatusUpdateDto.java">
package com.magazincomputere.magazin_api.dto;

import jakarta.validation.constraints.NotBlank;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class OrderStatusUpdateDto {
    @NotBlank(message = "Noua stare a comenzii este obligatorie.")
    private String newStatus;
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/dto/ProductReviewSummary.java">
// backend/src/main/java/com/magazincomputere/magazin_api/dto/ProductReviewSummary.java
package com.magazincomputere.magazin_api.dto;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

import java.util.Map;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ProductReviewSummary {
    private Double averageRating;
    private Integer totalReviews;
    private Map<Integer, Integer> ratingDistribution; // Key: rating (1-5), Value: count
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/dto/report/CategorySalesDto.java">
package com.magazincomputere.magazin_api.dto.report;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import java.math.BigDecimal;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class CategorySalesDto {
    private String category;
    private Integer quantitySold;
    private BigDecimal revenue;
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/dto/report/CategoryStockDto.java">
package com.magazincomputere.magazin_api.dto.report;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import java.math.BigDecimal;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class CategoryStockDto {
    private String category;
    private Integer totalProducts;
    private Integer totalStock;
    private BigDecimal stockValue;
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/dto/report/DailySalesDto.java">
package com.magazincomputere.magazin_api.dto.report;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import java.math.BigDecimal;
import java.time.LocalDate;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class DailySalesDto {
    private LocalDate date;
    private Integer salesCount;
    private BigDecimal revenue;
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/dto/report/GeneralReportDto.java">
package com.magazincomputere.magazin_api.dto.report;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import java.time.LocalDateTime;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class GeneralReportDto {
    private LocalDateTime generatedAt;
    private ReportPeriodDto reportPeriod;
    private SalesReportDto salesReport;
    private StockReportDto stockReport;
    private UserReportDto userReport;
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/dto/report/ProductSalesDto.java">
package com.magazincomputere.magazin_api.dto.report;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import java.math.BigDecimal;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ProductSalesDto {
    private Long productId;
    private String productName;
    private String category;
    private Integer quantitySold;
    private BigDecimal revenue;
    private Integer currentStock;
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/dto/report/ReportPeriodDto.java">
package com.magazincomputere.magazin_api.dto.report;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import java.time.LocalDate;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ReportPeriodDto {
    private LocalDate startDate;
    private LocalDate endDate;
    private String type; // daily, weekly, monthly, yearly, custom
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/dto/report/SalesReportDto.java">
package com.magazincomputere.magazin_api.dto.report;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class SalesReportDto {
    private Integer totalSales;
    private BigDecimal totalRevenue;
    private LocalDate periodStart;
    private LocalDate periodEnd;
    private List<DailySalesDto> dailySales;
    private List<ProductSalesDto> topSellingProducts;
    private List<CategorySalesDto> categorySales;
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/dto/report/StockItemDto.java">
package com.magazincomputere.magazin_api.dto.report;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import java.math.BigDecimal;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class StockItemDto {
    private Long productId;
    private String productName;
    private String category;
    private Integer currentStock;
    private BigDecimal price;
    private BigDecimal stockValue;
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/dto/report/StockReportDto.java">
package com.magazincomputere.magazin_api.dto.report;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import java.math.BigDecimal;
import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class StockReportDto {
    private Integer totalProducts;
    private BigDecimal totalStockValue;
    private List<StockItemDto> lowStockProducts;
    private List<StockItemDto> outOfStockProducts;
    private List<CategoryStockDto> categoryStock;
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/dto/report/UserInfoDto.java">
package com.magazincomputere.magazin_api.dto.report;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import java.time.LocalDateTime;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class UserInfoDto {
    private Long id;
    private String username;
    private String email;
    private LocalDateTime registrationDate;
    private LocalDateTime lastLoginDate;
    private Boolean isActive;
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/dto/report/UserReportDto.java">
package com.magazincomputere.magazin_api.dto.report;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class UserReportDto {
    private Integer totalUsers;
    private Integer activeUsers;
    private Integer newUsersThisMonth;
    private List<UserRoleCountDto> usersByRole;
    private List<UserInfoDto> recentRegistrations;
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/dto/report/UserRoleCountDto.java">
package com.magazincomputere.magazin_api.dto.report;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class UserRoleCountDto {
    private String role;
    private Integer count;
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/dto/ReviewDto.java">
// backend/src/main/java/com/magazincomputere/magazin_api/dto/ReviewDto.java
package com.magazincomputere.magazin_api.dto;

import jakarta.validation.constraints.*;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

import java.time.LocalDateTime;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ReviewDto {
    private Long id;
    private Long productId;
    private String productName;
    private Long userId;
    private String username;
    
    @NotNull(message = "Rating-ul este obligatoriu")
    @Min(value = 1, message = "Rating-ul minim este 1")
    @Max(value = 5, message = "Rating-ul maxim este 5")
    private Integer rating;
    
    @Size(max = 100, message = "Titlul nu poate depăși 100 de caractere")
    private String title;
    
    @Size(max = 1000, message = "Comentariul nu poate depăși 1000 de caractere")
    private String comment;
    
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/dto/SignupRequest.java">
package com.magazincomputere.magazin_api.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

import java.util.Set;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class SignupRequest {
    @NotBlank(message = "Numele de utilizator este obligatoriu.")
    @Size(min = 3, max = 20, message = "Numele de utilizator trebuie să aibă între 3 și 20 de caractere.")
    private String username;

    @NotBlank(message = "Emailul este obligatoriu.")
    @Size(max = 50, message = "Emailul nu poate depăși 50 de caractere.")
    @Email(message = "Formatul emailului este invalid.")
    private String email;

    @NotBlank(message = "Parola este obligatorie.")
    @Size(min = 6, max = 40, message = "Parola trebuie să aibă între 6 și 40 de caractere.")
    private String password;

    // Frontend-ul poate trimite rolurile dorite (ex: la crearea unui admin de către alt admin)
    // Sau acest câmp poate fi ignorat la signup-ul standard al unui client, backend-ul setând rolul USER.
    private Set<String> roles;
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/dto/SpecificationDefinitionDto.java">
package com.magazincomputere.magazin_api.dto;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class SpecificationDefinitionDto {
    private Long id;

    @NotBlank(message = "Numele definiției specificației este obligatoriu.")
    @Size(max = 100)
    private String name;

    @Size(max = 50)
    private String unit; // opțional
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/dto/SpecificationDto.java">
package com.magazincomputere.magazin_api.dto;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class SpecificationDto {
    // Când se trimit datele pentru un produs, definitionId sau name+unit ar trebui să fie prezente.
    // La citire, toate ar putea fi populate.
    private Long definitionId; // ID-ul din SpecificationDefinition (pentru a lega de o definiție existentă)

    @Size(max = 100, message = "Numele specificației nu poate depăși 100 de caractere.")
    // Numele este necesar dacă definitionId nu este furnizat la creare/update specificație pentru produs
    private String name;       // Numele specificației (ex: "RAM")

    @NotBlank(message = "Valoarea specificației este obligatorie.")
    @Size(max = 255, message = "Valoarea specificației nu poate depăși 255 de caractere.")
    private String value;      // Valoarea (ex: "16GB")

    @Size(max = 50, message = "Unitatea de măsură nu poate depăși 50 de caractere.")
    private String unit;       // Opțional (ex: "GB", "MHz")
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/dto/UpdateCartItemRequest.java">
package com.magazincomputere.magazin_api.dto;

import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotNull;
import lombok.Data;

@Data
public class UpdateCartItemRequest {
    @NotNull(message = "Cantitatea este obligatorie")
    @Min(value = 1, message = "Cantitatea trebuie să fie cel puțin 1")
    private Integer quantity;
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/dto/UserDto.java">
package com.magazincomputere.magazin_api.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

import java.util.Set;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class UserDto {
    private Long id;

    // La creare/update, username-ul nu ar trebui să se schimbe ușor după creare.
    // Validările sunt mai importante pentru SignupRequestDto.
    @NotBlank(message = "Numele de utilizator este obligatoriu.")
    @Size(min = 3, max = 20)
    private String username;

    @NotBlank(message = "Emailul este obligatoriu.")
    @Size(max = 50)
    @Email(message = "Formatul emailului este invalid.")
    private String email;

    // Parola nu este expusă în DTO-urile de răspuns.
    // Pentru schimbarea parolei, se va folosi un DTO dedicat.

    private Set<String> roles; // Numele rolurilor, ex: "ROLE_ADMIN", "ROLE_USER"
                               // La update de către admin, acest câmp poate fi modificat.
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/dto/UserUpdateDto.java">
package com.magazincomputere.magazin_api.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

import java.util.Set;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class UserUpdateDto {
    @NotBlank(message = "Emailul este obligatoriu.")
    @Size(max = 50)
    @Email(message = "Formatul emailului este invalid.")
    private String email;

    private Set<String> roles; // Rolurile pot fi opționale la update
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/exception/BadRequestException.java">
package com.magazincomputere.magazin_api.exception;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

@ResponseStatus(HttpStatus.BAD_REQUEST) // Returnează automat 400 Bad Request
public class BadRequestException extends RuntimeException {

    public BadRequestException(String message) {
        super(message);
    }

    public BadRequestException(String message, Throwable cause) {
        super(message, cause);
    }
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/exception/GlobalExceptionHandler.java">
package com.magazincomputere.magazin_api.exception;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.AccessDeniedException; // Pentru erori de autorizare
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.context.request.WebRequest;

import java.time.LocalDateTime; // Folosim LocalDateTime
import java.util.HashMap;
import java.util.Map;
import java.util.stream.Collectors;

@ControllerAdvice // Permite gestionarea centralizată a excepțiilor pentru toate controllerele
public class GlobalExceptionHandler {

    private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class);

    // Handler pentru excepția noastră custom ResourceNotFoundException
    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<ErrorDetails> handleResourceNotFoundException(ResourceNotFoundException ex, WebRequest request) {
        logger.warn("Resource not found: {}", ex.getMessage());
        ErrorDetails errorDetails = new ErrorDetails(
                LocalDateTime.now(),
                HttpStatus.NOT_FOUND.value(),
                "Not Found",
                ex.getMessage(),
                request.getDescription(false) // Calea cererii
        );
        return new ResponseEntity<>(errorDetails, HttpStatus.NOT_FOUND);
    }

    // Handler pentru excepția noastră custom BadRequestException
    @ExceptionHandler(BadRequestException.class)
    public ResponseEntity<ErrorDetails> handleBadRequestException(BadRequestException ex, WebRequest request) {
        logger.warn("Bad request: {}", ex.getMessage());
        ErrorDetails errorDetails = new ErrorDetails(
                LocalDateTime.now(),
                HttpStatus.BAD_REQUEST.value(),
                "Bad Request",
                ex.getMessage(),
                request.getDescription(false)
        );
        return new ResponseEntity<>(errorDetails, HttpStatus.BAD_REQUEST);
    }

    // Handler pentru excepțiile de validare (când @Valid pe un @RequestBody eșuează)
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorDetailsWithFields> handleValidationExceptions(MethodArgumentNotValidException ex, WebRequest request) {
        logger.warn("Validation error: {}", ex.getMessage());
        Map<String, String> fieldErrors = ex.getBindingResult().getFieldErrors().stream()
                .collect(Collectors.toMap(FieldError::getField,
                                          FieldError::getDefaultMessage,
                                          (existingValue, newValue) -> existingValue + "; " + newValue)); // În caz de mai multe erori pe același câmp

        ErrorDetailsWithFields errorDetails = new ErrorDetailsWithFields(
                LocalDateTime.now(),
                HttpStatus.BAD_REQUEST.value(),
                "Validation Failed",
                "Input data validation failed",
                request.getDescription(false),
                fieldErrors
        );
        return new ResponseEntity<>(errorDetails, HttpStatus.BAD_REQUEST);
    }

    // Handler pentru AccessDeniedException (când @PreAuthorize eșuează)
    @ExceptionHandler(AccessDeniedException.class)
    public ResponseEntity<ErrorDetails> handleAccessDeniedException(AccessDeniedException ex, WebRequest request) {
        logger.warn("Access denied: {}", ex.getMessage());
        ErrorDetails errorDetails = new ErrorDetails(
                LocalDateTime.now(),
                HttpStatus.FORBIDDEN.value(),
                "Forbidden",
                "Nu aveți permisiunea de a accesa această resursă.", // Mesaj mai prietenos
                request.getDescription(false)
        );
        return new ResponseEntity<>(errorDetails, HttpStatus.FORBIDDEN);
    }

    // Handler pentru IllegalArgumentException (poate fi util pentru validări de business în servicii)
    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<ErrorDetails> handleIllegalArgumentException(IllegalArgumentException ex, WebRequest request) {
        logger.warn("Illegal argument: {}", ex.getMessage());
        ErrorDetails errorDetails = new ErrorDetails(
                LocalDateTime.now(),
                HttpStatus.BAD_REQUEST.value(),
                "Bad Request",
                ex.getMessage(),
                request.getDescription(false)
        );
        return new ResponseEntity<>(errorDetails, HttpStatus.BAD_REQUEST);
    }


    // Handler generic pentru orice altă excepție neprinsă specific
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorDetails> handleGlobalException(Exception ex, WebRequest request) {
        logger.error("An unexpected error occurred: ", ex); // Loghează stack trace-ul complet pentru erori neașteptate
        ErrorDetails errorDetails = new ErrorDetails(
                LocalDateTime.now(),
                HttpStatus.INTERNAL_SERVER_ERROR.value(),
                "Internal Server Error",
                "A apărut o eroare neașteptată pe server.", // Mesaj generic pentru client
                request.getDescription(false)
        );
        return new ResponseEntity<>(errorDetails, HttpStatus.INTERNAL_SERVER_ERROR);
    }


    // Clasa internă pentru detalii eroare standard
    public static class ErrorDetails {
        private LocalDateTime timestamp;
        private int status;
        private String error;
        private String message;
        private String path;

        public ErrorDetails(LocalDateTime timestamp, int status, String error, String message, String path) {
            this.timestamp = timestamp;
            this.status = status;
            this.error = error;
            this.message = message;
            this.path = path;
        }

        // Getteri
        public LocalDateTime getTimestamp() { return timestamp; }
        public int getStatus() { return status; }
        public String getError() { return error; }
        public String getMessage() { return message; }
        public String getPath() { return path; }
    }

    // Clasa internă pentru detalii eroare cu câmpuri specifice (pentru validare)
    public static class ErrorDetailsWithFields extends ErrorDetails {
        private Map<String, String> fieldErrors;

        public ErrorDetailsWithFields(LocalDateTime timestamp, int status, String error, String message, String path, Map<String, String> fieldErrors) {
            super(timestamp, status, error, message, path);
            this.fieldErrors = fieldErrors;
        }

        // Getter
        public Map<String, String> getFieldErrors() { return fieldErrors; }
    }
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/exception/ResourceNotFoundException.java">
package com.magazincomputere.magazin_api.exception;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

@ResponseStatus(HttpStatus.NOT_FOUND) // Returnează automat 404 Not Found
public class ResourceNotFoundException extends RuntimeException {

    public ResourceNotFoundException(String message) {
        super(message);
    }

    public ResourceNotFoundException(String resourceName, String fieldName, Object fieldValue) {
        super(String.format("%s not found with %s : '%s'", resourceName, fieldName, fieldValue));
    }
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/MagazinApiApplication.java">
package com.magazincomputere.magazin_api;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class MagazinApiApplication {

	public static void main(String[] args) {
		SpringApplication.run(MagazinApiApplication.class, args);
	}

}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/model/Cart.java">
// backend/src/main/java/com/magazincomputere/magazin_api/model/Cart.java
package com.magazincomputere.magazin_api.model;

import jakarta.persistence.*;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.ToString;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "carts")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Cart {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @OneToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", unique = true)
    @ToString.Exclude
    @EqualsAndHashCode.Exclude
    private User user;

    @OneToMany(mappedBy = "cart", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    @ToString.Exclude
    @EqualsAndHashCode.Exclude
    private List<CartItem> items = new ArrayList<>();

    @Column(name = "last_updated")
    private LocalDateTime lastUpdated;

    @Column(name = "session_id")
    private String sessionId; // Pentru coșuri guest

    @PrePersist
    @PreUpdate
    protected void onUpdate() {
        lastUpdated = LocalDateTime.now();
    }

    public BigDecimal getTotalAmount() {
        return items.stream()
            .map(item -> item.getProduct().getPrice().multiply(new BigDecimal(item.getQuantity())))
            .reduce(BigDecimal.ZERO, BigDecimal::add);
    }

    public void clearCart() {
        items.clear();
    }
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/model/CartItem.java">
// backend/src/main/java/com/magazincomputere/magazin_api/model/CartItem.java
package com.magazincomputere.magazin_api.model;

import jakarta.persistence.*;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.ToString;

import java.time.LocalDateTime;

@Entity
@Table(name = "cart_items")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class CartItem {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "cart_id", nullable = false)
    @ToString.Exclude
    @EqualsAndHashCode.Exclude
    private Cart cart;

    @ManyToOne(fetch = FetchType.EAGER)
    @JoinColumn(name = "product_id", nullable = false)
    private Product product;

    @Column(nullable = false)
    private Integer quantity;

    @Column(name = "added_at")
    private LocalDateTime addedAt;

    @PrePersist
    protected void onCreate() {
        addedAt = LocalDateTime.now();
    }
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/model/Category.java">
package com.magazincomputere.magazin_api.model;

import jakarta.persistence.*;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode; // Pentru a gestiona corect relațiile bidirecționale
import lombok.ToString; // Pentru a gestiona corect relațiile bidirecționale

import java.util.List;

@Entity
@Table(name = "categories")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Category {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true, length = 100)
    private String name;

    @Column(length = 1000)
    private String description;

    // Relația One-to-Many cu Product (o categorie poate avea mai multe produse)
    // Comentat pentru a evita problemele de serializare ciclică dacă nu este gestionat atent în DTO-uri
    // Poți decomenta dacă ai nevoie să navighezi de la Category la Products și gestionezi DTO-urile corespunzător.
    // @OneToMany(mappedBy = "category", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    // @ToString.Exclude // Pentru a evita bucle infinite la toString
    // @EqualsAndHashCode.Exclude // Pentru a evita bucle infinite la equals/hashCode
    // private List<Product> products;
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/model/Customer.java">
package com.magazincomputere.magazin_api.model;

import jakarta.persistence.*;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.ToString;

import java.util.List;

@Entity
@Table(name = "customers")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Customer {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(length = 100)
    private String firstName;

    @Column(length = 100)
    private String lastName;

    // Emailul clientului poate fi diferit de cel al contului de utilizator,
    // sau poate fi același. Depinde de logica de business.
    @Column(unique = true, length = 100) // Poate fi null dacă un client nu are cont și face comandă ca guest
    private String email;

    @Column(length = 20)
    private String phone;

    @Lob // Pentru adrese multiple sau mai lungi
    @Column(columnDefinition = "TEXT")
    private String addressDetails; // Poate stoca adresa principală sau un JSON cu mai multe adrese

    // Relație opțională OneToOne cu User (un client poate avea un cont de utilizator)
    @OneToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", referencedColumnName = "id", unique = true) // Poate fi null
    @ToString.Exclude
    @EqualsAndHashCode.Exclude
    private User user;

    // Un client poate avea mai multe comenzi
    @OneToMany(mappedBy = "customer", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    @ToString.Exclude
    @EqualsAndHashCode.Exclude
    private List<Order> orders;
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/model/ERole.java">
package com.magazincomputere.magazin_api.model;

public enum ERole {
    ROLE_USER,  // Pentru clienți standard
    ROLE_ADMIN  // Pentru administratori
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/model/Order.java">
package com.magazincomputere.magazin_api.model;

import jakarta.persistence.*;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.ToString;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "orders") // "order" este adesea un cuvânt cheie SQL, deci "orders" e mai sigur
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Order {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    // Referință către User (dacă utilizatorul este logat) sau Customer (dacă informațiile sunt separate)
    // Alege una dintre următoarele două sau gestionează ambele dacă permiți comenzi guest
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id") // Poate fi null dacă se permite comandă fără cont și se folosește Customer
    @ToString.Exclude
    @EqualsAndHashCode.Exclude
    private User user;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "customer_id", nullable = false) // O comandă trebuie să aibă un client asociat
    @ToString.Exclude
    @EqualsAndHashCode.Exclude
    private Customer customer;

    @Column(nullable = false)
    private LocalDateTime orderDate;

    @Column(nullable = false, length = 50)
    private String status; // Ex: PENDING_PAYMENT, PROCESSING, SHIPPED, DELIVERED, CANCELED, APPROVED

    @Column(nullable = false, precision = 12, scale = 2)
    private BigDecimal totalAmount;

    // Informații denormalizate pentru livrare, chiar dacă există în Customer/User,
    // pentru a păstra adresa exactă la momentul comenzii.
    @Column(nullable = false, length = 255)
    private String shippingAddress;

    @Column(nullable = false, length = 100)
    private String shippingCustomerName;

    @Column(nullable = false, length = 100)
    private String shippingCustomerEmail;

    @Column(nullable = false, length = 20)
    private String shippingCustomerPhone;

    @OneToMany(mappedBy = "order", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    @ToString.Exclude
    @EqualsAndHashCode.Exclude
    private List<OrderItem> orderItems = new ArrayList<>();

    @PrePersist
    protected void onCreate() {
        orderDate = LocalDateTime.now();
        // Poți seta un status inițial aici, de ex. "PENDING_PAYMENT"
        if (status == null) {
            status = "PENDING_CONFIRMATION";
        }
    }
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/model/ProductSpecificationValue.java">
package com.magazincomputere.magazin_api.model;

import jakarta.persistence.*;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.ToString;

@Entity
@Table(name = "product_specification_values", uniqueConstraints = {
    @UniqueConstraint(columnNames = {"product_id", "specification_definition_id"})
})
@Data
@NoArgsConstructor
@AllArgsConstructor
public class ProductSpecificationValue {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "product_id", nullable = false)
    @ToString.Exclude
    @EqualsAndHashCode.Exclude
    private Product product;

    @ManyToOne(fetch = FetchType.EAGER)
    @JoinColumn(name = "specification_definition_id", nullable = false)
    private SpecificationDefinition specificationDefinition;

    @Column(name = "specification_value", nullable = false, length = 255) // AM SCHIMBAT NUMELE COLOANEI AICI
    private String value;
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/model/Review.java">
// backend/src/main/java/com/magazincomputere/magazin_api/model/Review.java
package com.magazincomputere.magazin_api.model;

import jakarta.persistence.*;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.ToString;

import java.time.LocalDateTime;

@Entity
@Table(name = "reviews", uniqueConstraints = {
    @UniqueConstraint(columnNames = {"product_id", "user_id"})
})
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Review {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "product_id", nullable = false)
    @ToString.Exclude
    @EqualsAndHashCode.Exclude
    private Product product;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    @ToString.Exclude
    @EqualsAndHashCode.Exclude
    private User user;

    @Column(nullable = false)
    private Integer rating; // 1-5 stars

    @Column(length = 100)
    private String title;

    @Column(columnDefinition = "TEXT")
    private String comment;

    @Column(name = "created_at", nullable = false)
    private LocalDateTime createdAt;

    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/model/SpecificationDefinition.java">
package com.magazincomputere.magazin_api.model;

import jakarta.persistence.*;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

@Entity
@Table(name = "specification_definitions")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class SpecificationDefinition {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true, length = 100)
    private String name; // Ex: "Procesor", "RAM", "Culoare"

    @Column(length = 50)
    private String unit; // Ex: "GB", "MHz", "inch" (opțional)
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/model/User.java">
package com.magazincomputere.magazin_api.model;

import jakarta.persistence.*;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.ToString;

import java.util.HashSet;
import java.util.Set;
import java.util.List; // Pentru comenzi

@Entity
@Table(name = "users", uniqueConstraints = {
        @UniqueConstraint(columnNames = "username"),
        @UniqueConstraint(columnNames = "email")
})
@Data
@NoArgsConstructor
@AllArgsConstructor
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true, length = 50)
    private String username;

    @Column(nullable = false, unique = true, length = 100)
    private String email;

    @Column(nullable = false, length = 100) // Lungime pentru parola encodată
    private String password;

    @ManyToMany(fetch = FetchType.EAGER) // EAGER pentru a încărca rolurile odată cu utilizatorul
    @JoinTable(name = "user_roles",
            joinColumns = @JoinColumn(name = "user_id"),
            inverseJoinColumns = @JoinColumn(name = "role_id"))
    private Set<Role> roles = new HashSet<>();

    // Relația cu comenzile (un utilizator poate avea mai multe comenzi)
    // @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    // @ToString.Exclude
    // @EqualsAndHashCode.Exclude
    // private List<Order> orders;

    // Relația cu Customer (dacă un User este și Customer)
    // @OneToOne(mappedBy = "user", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    // @ToString.Exclude
    // @EqualsAndHashCode.Exclude
    // private Customer customer;

    public User(String username, String email, String password) {
        this.username = username;
        this.email = email;
        this.password = password;
    }
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/repository/CartItemRepository.java">
package com.magazincomputere.magazin_api.repository;

import com.magazincomputere.magazin_api.model.CartItem;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface CartItemRepository extends JpaRepository<CartItem, Long> {
    Optional<CartItem> findByCartIdAndProductId(Long cartId, Long productId);
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/repository/CategoryRepository.java">
package com.magazincomputere.magazin_api.repository;

import com.magazincomputere.magazin_api.model.Category;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface CategoryRepository extends JpaRepository<Category, Long> {
    // Găsește o categorie după nume (util pentru a evita duplicate)
    Optional<Category> findByNameIgnoreCase(String name);
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/repository/CustomerRepository.java">
package com.magazincomputere.magazin_api.repository;

import com.magazincomputere.magazin_api.model.Customer;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface CustomerRepository extends JpaRepository<Customer, Long> {
    // Găsește un client după email (dacă emailul este unic și folosit pentru identificare)
    Optional<Customer> findByEmail(String email);

    // Găsește un client după ID-ul utilizatorului asociat
    Optional<Customer> findByUserId(Long userId);
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/repository/OrderItemRepository.java">
// src/main/java/com/magazincomputere/magazin_api/repository/OrderItemRepository.java
package com.magazincomputere.magazin_api.repository;

import com.magazincomputere.magazin_api.model.OrderItem;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

// import java.util.List; // Decomentează dacă adaugi metode custom

@Repository
public interface OrderItemRepository extends JpaRepository<OrderItem, Long> {

    // Spring Data JPA va furniza automat implementările pentru metodele CRUD de bază
    // (save, findById, findAll, delete, etc.) pentru entitatea OrderItem.

    // Poți adăuga metode custom de interogare aici dacă este necesar în viitor.
    // De exemplu, dacă ai vrea să găsești toate articolele unei anumite comenzi
    // direct prin acest repository (deși acest lucru este de obicei gestionat
    // prin colecția `orderItems` din entitatea `Order`):
    // List<OrderItem> findByOrderId(Long orderId);

    // Sau pentru a găsi articolele care conțin un anumit produs (snapshot ID):
    // List<OrderItem> findByProductIdSnapshot(Long productIdSnapshot);
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/repository/ProductRepository.java">
package com.magazincomputere.magazin_api.repository;

import com.magazincomputere.magazin_api.model.Product;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor; // Pentru căutare/filtrare complexă
import org.springframework.stereotype.Repository;

import java.math.BigDecimal;
import java.util.List;

@Repository
public interface ProductRepository extends JpaRepository<Product, Long>, JpaSpecificationExecutor<Product> {

    // Găsește produse după ID-ul categoriei
    List<Product> findByCategoryId(Long categoryId);

    // Găsește produse al căror nume conține un anumit string (case-insensitive)
    List<Product> findByNameContainingIgnoreCase(String name);

    // Găsește produse într-un interval de preț
    List<Product> findByPriceBetween(BigDecimal minPrice, BigDecimal maxPrice);

    // Găsește produse după ID categorie și într-un interval de preț
    List<Product> findByCategoryIdAndPriceBetween(Long categoryId, BigDecimal minPrice, BigDecimal maxPrice);

    // Poți adăuga aici și alte metode de interogare bazate pe convențiile de numire Spring Data JPA
    // sau folosind @Query pentru interogări JPQL sau SQL native mai complexe.
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/repository/ProductSpecificationValueRepository.java">
package com.magazincomputere.magazin_api.repository;

import com.magazincomputere.magazin_api.model.ProductSpecificationValue;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface ProductSpecificationValueRepository extends JpaRepository<ProductSpecificationValue, Long> {
    // Găsește toate valorile specificațiilor pentru un anumit produs
    List<ProductSpecificationValue> findByProductId(Long productId);

    // Găsește toate valorile pentru o anumită definiție de specificație
    List<ProductSpecificationValue> findBySpecificationDefinitionId(Long definitionId);

    // Șterge toate valorile specificațiilor pentru un produs (util la actualizarea produsului)
    void deleteByProductId(Long productId);
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/repository/ReviewRepository.java">
// backend/src/main/java/com/magazincomputere/magazin_api/repository/ReviewRepository.java
package com.magazincomputere.magazin_api.repository;

import com.magazincomputere.magazin_api.model.Review;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface ReviewRepository extends JpaRepository<Review, Long> {
    Page<Review> findByProductIdOrderByCreatedAtDesc(Long productId, Pageable pageable);
    
    Optional<Review> findByProductIdAndUserId(Long productId, Long userId);
    
    boolean existsByProductIdAndUserId(Long productId, Long userId);
    
    @Query("SELECT AVG(r.rating) FROM Review r WHERE r.product.id = :productId")
    Double calculateAverageRatingByProductId(@Param("productId") Long productId);
    
    @Query("SELECT COUNT(r) FROM Review r WHERE r.product.id = :productId")
    Integer countByProductId(@Param("productId") Long productId);
    
    @Query("SELECT r.rating, COUNT(r) FROM Review r WHERE r.product.id = :productId GROUP BY r.rating")
    List<Object[]> getRatingDistributionByProductId(@Param("productId") Long productId);

    List<Review> findByUserId(Long userId);
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/repository/RoleRepository.java">
package com.magazincomputere.magazin_api.repository;

import com.magazincomputere.magazin_api.model.ERole;
import com.magazincomputere.magazin_api.model.Role;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface RoleRepository extends JpaRepository<Role, Integer> {
    // Găsește un rol după numele său (enum)
    Optional<Role> findByName(ERole name);
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/repository/SpecificationDefinitionRepository.java">
package com.magazincomputere.magazin_api.repository;

import com.magazincomputere.magazin_api.model.SpecificationDefinition;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface SpecificationDefinitionRepository extends JpaRepository<SpecificationDefinition, Long> {
    // Găsește o definiție de specificație după nume (util pentru a evita duplicate)
    Optional<SpecificationDefinition> findByNameIgnoreCase(String name);
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/repository/UserRepository.java">
package com.magazincomputere.magazin_api.repository;

import com.magazincomputere.magazin_api.model.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    // Găsește un utilizator după username (pentru login și verificare existență)
    Optional<User> findByUsername(String username);

    // Verifică dacă un utilizator există după username
    Boolean existsByUsername(String username);

    // Verifică dacă un utilizator există după email
    Boolean existsByEmail(String email);
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/security/jwt/AuthEntryPointJwt.java">
package com.magazincomputere.magazin_api.security.jwt;

import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.stereotype.Component;

import java.io.IOException;
import com.fasterxml.jackson.databind.ObjectMapper; // Pentru a scrie un răspuns JSON
import java.util.HashMap; // Pentru a crea un corp de răspuns JSON
import java.util.Map; // Pentru a crea un corp de răspuns JSON


@Component
public class AuthEntryPointJwt implements AuthenticationEntryPoint {
    private static final Logger logger = LoggerFactory.getLogger(AuthEntryPointJwt.class);

    @Override
    public void commence(HttpServletRequest request, HttpServletResponse response,
                         AuthenticationException authException) throws IOException, ServletException {
        logger.error("Unauthorized error: {}", authException.getMessage());
        // Trimite un răspuns JSON mai prietenos în loc de eroarea default
        response.setContentType("application/json");
        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);

        final Map<String, Object> body = new HashMap<>();
        body.put("status", HttpServletResponse.SC_UNAUTHORIZED);
        body.put("error", "Unauthorized");
        body.put("message", authException.getMessage());
        body.put("path", request.getServletPath());

        final ObjectMapper mapper = new ObjectMapper();
        mapper.writeValue(response.getOutputStream(), body);
    }
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/security/jwt/JwtAuthTokenFilter.java">
package com.magazincomputere.magazin_api.security.jwt;

import com.magazincomputere.magazin_api.security.services.UserDetailsServiceImpl;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component; // Adaugă @Component pentru a fi un bean gestionat de Spring
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;

@Component // Important pentru ca Spring să poată injecta această clasă în SecurityConfig
public class JwtAuthTokenFilter extends OncePerRequestFilter {
    @Autowired
    private JwtUtils jwtUtils;

    @Autowired
    private UserDetailsServiceImpl userDetailsService;

    private static final Logger logger = LoggerFactory.getLogger(JwtAuthTokenFilter.class);

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException {
        try {
            String jwt = jwtUtils.parseJwt(request);
            if (jwt != null && jwtUtils.validateJwtToken(jwt)) {
                String username = jwtUtils.getUserNameFromJwtToken(jwt);

                UserDetails userDetails = userDetailsService.loadUserByUsername(username);
                UsernamePasswordAuthenticationToken authentication =
                        new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());
                authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));

                SecurityContextHolder.getContext().setAuthentication(authentication);
            }
        } catch (Exception e) {
            logger.error("Cannot set user authentication: {}", e.getMessage());
        }

        filterChain.doFilter(request, response);
    }
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/security/jwt/JwtUtils.java">
package com.magazincomputere.magazin_api.security.jwt; // Asigură-te că pachetul e corect

import com.magazincomputere.magazin_api.security.services.UserDetailsImpl;
import io.jsonwebtoken.*; // Importurile principale JJWT
// Nu mai importăm io.jsonwebtoken.security.Keys pentru această versiune veche
import jakarta.servlet.http.HttpServletRequest;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.Authentication;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;

import javax.crypto.spec.SecretKeySpec; // Necesar pentru crearea cheii în versiuni mai vechi
import java.security.Key; // Interfața Key
import java.util.Base64; // Pentru decodarea cheii dacă e stocată ca Base64
import java.util.Date;

@Component
public class JwtUtils {
    private static final Logger logger = LoggerFactory.getLogger(JwtUtils.class);

    @Value("${app.jwtSecret}")
    private String jwtSecretString; // Asigură-te că e un string simplu sau gestionează decodarea Base64 aici

    @Value("${app.jwtExpirationMs}")
    private int jwtExpirationMs;

    // Metodă adaptată pentru crearea cheii cu JJWT 0.11.x
    private Key getSigningKey() {
        // Dacă jwtSecretString este encodat Base64, va trebui să-l decodezi:
        // byte[] keyBytes = Base64.getDecoder().decode(this.jwtSecretString);
        // Altfel, dacă e un string simplu:
        byte[] keyBytes = jwtSecretString.getBytes();
        // Folosește SignatureAlgorithm.HS512.getJcaName() pentru a obține numele algoritmului
        return new SecretKeySpec(keyBytes, SignatureAlgorithm.HS512.getJcaName());
    }

    public String generateJwtToken(Authentication authentication) {
        UserDetailsImpl userPrincipal = (UserDetailsImpl) authentication.getPrincipal();
        return buildToken(userPrincipal.getUsername());
    }

    public String generateTokenFromUsername(String username) {
        return buildToken(username);
    }

    private String buildToken(String subject) {
         return Jwts.builder()
                 .setSubject(subject)
                 .setIssuedAt(new Date())
                 .setExpiration(new Date((new Date()).getTime() + jwtExpirationMs))
                 .signWith(SignatureAlgorithm.HS512, getSigningKey()) // Sintaxa pentru 0.11.x
                 .compact();
    }

    public String getUserNameFromJwtToken(String token) {
        // Sintaxa pentru 0.11.x - FĂRĂ parserBuilder()
        return Jwts.parser()
                   .setSigningKey(getSigningKey())
                   .parseClaimsJws(token)
                   .getBody()
                   .getSubject();
    }

    public boolean validateJwtToken(String authToken) {
        try {
            // Sintaxa pentru 0.11.x - FĂRĂ parserBuilder()
            Jwts.parser().setSigningKey(getSigningKey()).parseClaimsJws(authToken);
            return true;
        } catch (io.jsonwebtoken.SignatureException e) { // Folosește io.jsonwebtoken.SignatureException
            logger.error("Invalid JWT signature: {}", e.getMessage());
        } catch (MalformedJwtException e) {
            logger.error("Invalid JWT token: {}", e.getMessage());
        } catch (ExpiredJwtException e) {
            logger.error("JWT token is expired: {}", e.getMessage());
        } catch (UnsupportedJwtException e) {
            logger.error("JWT token is unsupported: {}", e.getMessage());
        } catch (IllegalArgumentException e) {
            logger.error("JWT claims string is empty: {}", e.getMessage());
        }
        return false;
    }

    public String parseJwt(HttpServletRequest request) {
        String headerAuth = request.getHeader("Authorization");
        if (StringUtils.hasText(headerAuth) && headerAuth.startsWith("Bearer ")) {
            return headerAuth.substring(7);
        }
        return null;
    }
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/security/services/UserDetailsImpl.java">
package com.magazincomputere.magazin_api.security.services;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.magazincomputere.magazin_api.model.User;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import java.util.Collection;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

public class UserDetailsImpl implements UserDetails {
    private static final long serialVersionUID = 1L;

    private Long id;
    private String username;
    private String email;
    @JsonIgnore
    private String password;

    private Collection<? extends GrantedAuthority> authorities;

    public UserDetailsImpl(Long id, String username, String email, String password,
                           Collection<? extends GrantedAuthority> authorities) {
        this.id = id;
        this.username = username;
        this.email = email;
        this.password = password;
        this.authorities = authorities;
    }

    public static UserDetailsImpl build(User user) {
        List<GrantedAuthority> authorities = user.getRoles().stream()
                .map(role -> new SimpleGrantedAuthority(role.getName().name()))
                .collect(Collectors.toList());

        return new UserDetailsImpl(
                user.getId(),
                user.getUsername(),
                user.getEmail(),
                user.getPassword(),
                authorities);
    }

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return authorities;
    }

    public Long getId() {
        return id;
    }

    public String getEmail() {
        return email;
    }

    @Override
    public String getPassword() {
        return password;
    }

    @Override
    public String getUsername() {
        return username;
    }

    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

    @Override
    public boolean isAccountNonLocked() {
        return true;
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

    @Override
    public boolean isEnabled() {
        return true;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        UserDetailsImpl user = (UserDetailsImpl) o;
        return Objects.equals(id, user.id);
    }
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/security/services/UserDetailsServiceImpl.java">
package com.magazincomputere.magazin_api.security.services;

import com.magazincomputere.magazin_api.model.User;
import com.magazincomputere.magazin_api.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class UserDetailsServiceImpl implements UserDetailsService {
    @Autowired
    UserRepository userRepository;

    @Override
    @Transactional
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        User user = userRepository.findByUsername(username)
                .orElseThrow(() -> new UsernameNotFoundException("User Not Found with username: " + username));

        return UserDetailsImpl.build(user);
    }
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/service/CartService.java">
// backend/src/main/java/com/magazincomputere/magazin_api/service/CartService.java
package com.magazincomputere.magazin_api.service;

import com.magazincomputere.magazin_api.dto.*;
import com.magazincomputere.magazin_api.exception.BadRequestException;
import com.magazincomputere.magazin_api.exception.ResourceNotFoundException;
import com.magazincomputere.magazin_api.model.*;
import com.magazincomputere.magazin_api.repository.*;
import jakarta.transaction.Transactional;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.math.BigDecimal;
import java.util.stream.Collectors;

@Service
public class CartService {

    @Autowired
    private CartRepository cartRepository;
    
    @Autowired
    private CartItemRepository cartItemRepository;
    
    @Autowired
    private ProductRepository productRepository;
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private OrderService orderService;

    @Transactional
    public CartDto getCartByUserId(Long userId) {
        Cart cart = cartRepository.findByUserId(userId)
            .orElseGet(() -> createNewCart(userId));
        return convertToDto(cart);
    }

    @Transactional
    public CartDto addToCart(Long userId, AddToCartRequest request) {
        Cart cart = cartRepository.findByUserId(userId)
            .orElseGet(() -> createNewCart(userId));
            
        Product product = productRepository.findById(request.getProductId())
            .orElseThrow(() -> new ResourceNotFoundException("Product not found with id: " + request.getProductId()));
            
        if (product.getStockQuantity() < request.getQuantity()) {
            throw new BadRequestException("Insufficient stock. Available: " + product.getStockQuantity());
        }
        
        CartItem existingItem = cart.getItems().stream()
            .filter(item -> item.getProduct().getId().equals(request.getProductId()))
            .findFirst()
            .orElse(null);
            
        if (existingItem != null) {
            int newQuantity = existingItem.getQuantity() + request.getQuantity();
            if (product.getStockQuantity() < newQuantity) {
                throw new BadRequestException("Insufficient stock. Available: " + product.getStockQuantity());
            }
            existingItem.setQuantity(newQuantity);
        } else {
            CartItem newItem = new CartItem();
            newItem.setCart(cart);
            newItem.setProduct(product);
            newItem.setQuantity(request.getQuantity());
            cart.getItems().add(newItem);
        }
        
        cart = cartRepository.save(cart);
        return convertToDto(cart);
    }

    @Transactional
    public CartDto updateCartItem(Long userId, Long productId, UpdateCartItemRequest request) {
        Cart cart = cartRepository.findByUserId(userId)
            .orElseThrow(() -> new ResourceNotFoundException("Cart not found for user"));
            
        CartItem item = cart.getItems().stream()
            .filter(cartItem -> cartItem.getProduct().getId().equals(productId))
            .findFirst()
            .orElseThrow(() -> new ResourceNotFoundException("Product not found in cart"));
            
        if (item.getProduct().getStockQuantity() < request.getQuantity()) {
            throw new BadRequestException("Insufficient stock. Available: " + item.getProduct().getStockQuantity());
        }
        
        item.setQuantity(request.getQuantity());
        cart = cartRepository.save(cart);
        return convertToDto(cart);
    }

    @Transactional
    public CartDto removeFromCart(Long userId, Long productId) {
        Cart cart = cartRepository.findByUserId(userId)
            .orElseThrow(() -> new ResourceNotFoundException("Cart not found for user"));
            
        cart.getItems().removeIf(item -> item.getProduct().getId().equals(productId));
        cart = cartRepository.save(cart);
        return convertToDto(cart);
    }

    @Transactional
    public void clearCart(Long userId) {
        Cart cart = cartRepository.findByUserId(userId)
            .orElseThrow(() -> new ResourceNotFoundException("Cart not found for user"));
        cart.clearCart();
        cartRepository.save(cart);
    }

    @Transactional
    public OrderDto checkout(Long userId, CheckoutRequest request) {
        Cart cart = cartRepository.findByUserId(userId)
            .orElseThrow(() -> new ResourceNotFoundException("Cart not found for user"));
            
        if (cart.getItems().isEmpty()) {
            throw new BadRequestException("Cart is empty");
        }
        
        if (!request.isAgreeToTerms()) {
            throw new BadRequestException("You must agree to terms and conditions");
        }
        
        // Validare stoc pentru toate produsele
        for (CartItem item : cart.getItems()) {
            if (item.getProduct().getStockQuantity() < item.getQuantity()) {
                throw new BadRequestException("Insufficient stock for product: " + item.getProduct().getName());
            }
        }
        
        // Creare comandă
        OrderDto orderDto = new OrderDto();
        orderDto.setCustomerName(request.getFullName());
        orderDto.setCustomerEmail(request.getEmail());
        orderDto.setCustomerPhone(request.getPhone());
        orderDto.setShippingAddress(request.getShippingAddress() != null ? 
            request.getShippingAddress() : request.getBillingAddress());
        
        // Convertire cart items la order items
        orderDto.setOrderItems(cart.getItems().stream().map(cartItem -> {
            OrderItemDto orderItem = new OrderItemDto();
            orderItem.setProductId(cartItem.getProduct().getId());
            orderItem.setQuantity(cartItem.getQuantity());
            return orderItem;
        }).collect(Collectors.toList()));
        
        // Plasare comandă
        OrderDto createdOrder = orderService.createOrder(orderDto, userId);
        
        // Golire coș după comandă reușită
        clearCart(userId);
        
        return createdOrder;
    }

    private Cart createNewCart(Long userId) {
        User user = userRepository.findById(userId)
            .orElseThrow(() -> new ResourceNotFoundException("User not found with id: " + userId));
            
        Cart cart = new Cart();
        cart.setUser(user);
        return cartRepository.save(cart);
    }

    private CartDto convertToDto(Cart cart) {
        CartDto dto = new CartDto();
        dto.setId(cart.getId());
        dto.setLastUpdated(cart.getLastUpdated());
        dto.setTotalAmount(cart.getTotalAmount());
        dto.setTotalItems(cart.getItems().stream()
            .mapToInt(CartItem::getQuantity)
            .sum());
        
        dto.setItems(cart.getItems().stream().map(item -> {
            CartItemDto itemDto = new CartItemDto();
            itemDto.setId(item.getId());
            itemDto.setProductId(item.getProduct().getId());
            itemDto.setProductName(item.getProduct().getName());
            itemDto.setProductDescription(item.getProduct().getDescription());
            itemDto.setProductPrice(item.getProduct().getPrice());
            itemDto.setProductStock(item.getProduct().getStockQuantity());
            // itemDto.setProductImageBase64(item.getProduct().getImageBase64());
            itemDto.setQuantity(item.getQuantity());
            itemDto.setSubtotal(item.getProduct().getPrice().multiply(new BigDecimal(item.getQuantity())));
            return itemDto;
        }).collect(Collectors.toList()));
        
        return dto;
    }
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/service/CategoryService.java">
package com.magazincomputere.magazin_api.service;

import com.magazincomputere.magazin_api.dto.CategoryDto;
import com.magazincomputere.magazin_api.exception.ResourceNotFoundException;
import com.magazincomputere.magazin_api.model.Category;
import com.magazincomputere.magazin_api.repository.CategoryRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.stream.Collectors;

@Service
public class CategoryService {

    @Autowired
    private CategoryRepository categoryRepository;

    // --- Metode de conversie DTO <-> Entity ---
    private CategoryDto convertToDto(Category category) {
        CategoryDto dto = new CategoryDto();
        dto.setId(category.getId());
        dto.setName(category.getName());
        dto.setDescription(category.getDescription());
        return dto;
    }

    // Această metodă modifică direct obiectul 'category' pasat
    private void updateEntityFromDto(CategoryDto categoryDto, Category category) {
        category.setName(categoryDto.getName());
        category.setDescription(categoryDto.getDescription());
    }
    // --- Sfârșit metode de conversie ---

    @Transactional(readOnly = true)
    public List<CategoryDto> getAllCategories() {
        return categoryRepository.findAll().stream()
                .map(this::convertToDto)
                .collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public CategoryDto getCategoryById(Long id) {
        Category category = categoryRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Category", "id", id));
        return convertToDto(category);
    }

    @Transactional
    public CategoryDto createCategory(CategoryDto categoryDto) {
        categoryRepository.findByNameIgnoreCase(categoryDto.getName()).ifPresent(existingCategory -> {
            throw new IllegalArgumentException("Category with name '" + existingCategory.getName() + "' already exists.");
        });
        Category category = new Category();
        updateEntityFromDto(categoryDto, category); // Folosim metoda care nu returnează pentru claritate
        Category savedCategory = categoryRepository.save(category);
        return convertToDto(savedCategory);
    }

    @Transactional
    public CategoryDto updateCategory(Long id, CategoryDto categoryDto) {
        // Pasul 1: Găsește entitatea existentă
        Category existingCategory = categoryRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Category", "id", id));

        // Pasul 2: Verifică dacă noul nume este deja folosit de altă categorie
        // Folosim o variabilă finală sau effectively final pentru ID-ul categoriei existente în lambda
        final Long existingCategoryId = existingCategory.getId();
        categoryRepository.findByNameIgnoreCase(categoryDto.getName()).ifPresent(catWithSameName -> {
            if (!catWithSameName.getId().equals(existingCategoryId)) {
                throw new IllegalArgumentException("Another category with name '" + catWithSameName.getName() + "' already exists.");
            }
        });

        // Pasul 3: Actualizează câmpurile entității existente cu datele din DTO
        // Nu re-atribuim existingCategory, ci îi modificăm starea.
        updateEntityFromDto(categoryDto, existingCategory);

        // Pasul 4: Salvează entitatea actualizată
        Category updatedCategory = categoryRepository.save(existingCategory);

        // Pasul 5: Converteste entitatea actualizată în DTO și returneaz-o
        return convertToDto(updatedCategory);
    }

    @Transactional
    public void deleteCategory(Long id) {
        Category category = categoryRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Category", "id", id));
        
        // TODO: Adaugă logica de verificare dacă există produse în această categorie înainte de ștergere
        // De exemplu: if (!productRepository.findByCategoryId(id).isEmpty()) { throw new BadRequestException("Cannot delete category with products."); }
        categoryRepository.delete(category);
    }
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/service/CustomerService.java">
package com.magazincomputere.magazin_api.service;

import com.magazincomputere.magazin_api.dto.CustomerDto;
import com.magazincomputere.magazin_api.exception.ResourceNotFoundException;
import com.magazincomputere.magazin_api.model.Customer;
import com.magazincomputere.magazin_api.repository.CustomerRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.stream.Collectors;

@Service
public class CustomerService {

    @Autowired
    private CustomerRepository customerRepository;
    // @Autowired private UserRepository userRepository; // Dacă e nevoie să legi de User

    private CustomerDto convertToDto(Customer customer) {
        CustomerDto dto = new CustomerDto();
        dto.setId(customer.getId());
        if (customer.getUser() != null) {
            dto.setUserId(customer.getUser().getId());
        }
        dto.setFirstName(customer.getFirstName());
        dto.setLastName(customer.getLastName());
        dto.setEmail(customer.getEmail());
        dto.setPhone(customer.getPhone());
        dto.setAddress(customer.getAddressDetails());
        return dto;
    }

    private Customer convertToEntity(CustomerDto dto, Customer customer) {
        // Nu setăm User aici, se face la creare/asociere
        customer.setFirstName(dto.getFirstName());
        customer.setLastName(dto.getLastName());
        customer.setEmail(dto.getEmail());
        customer.setPhone(dto.getPhone());
        customer.setAddressDetails(dto.getAddress());
        return customer;
    }

    @Transactional(readOnly = true)
    public List<CustomerDto> findAllCustomers() {
        return customerRepository.findAll().stream().map(this::convertToDto).collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public CustomerDto findCustomerById(Long id) {
        Customer customer = customerRepository.findById(id)
            .orElseThrow(() -> new ResourceNotFoundException("Customer not found with id: " + id));
        return convertToDto(customer);
    }

    // Crearea de Customer se poate face și implicit la prima comandă a unui User,
    // sau explicit de către un admin.
    // @Transactional
    // public CustomerDto createCustomer(CustomerDto customerDto) {
    //     Customer customer = new Customer();
    //     // Dacă se trimite userId, asociază-l
    //     if (customerDto.getUserId() != null) {
    //         User user = userRepository.findById(customerDto.getUserId()).orElse(null);
    //         customer.setUser(user);
    //     }
    //     customer = convertToEntity(customerDto, customer);
    //     return convertToDto(customerRepository.save(customer));
    // }

    // @Transactional
    // public CustomerDto updateCustomer(Long id, CustomerDto customerDto) {
    //     Customer existingCustomer = customerRepository.findById(id)
    //         .orElseThrow(() -> new ResourceNotFoundException("Customer not found with id: " + id));
    //     existingCustomer = convertToEntity(customerDto, existingCustomer);
    //     return convertToDto(customerRepository.save(existingCustomer));
    // }

    // @Transactional
    // public void deleteCustomer(Long id){
    //      if(!customerRepository.existsById(id)){
    //          throw new ResourceNotFoundException("Customer not found with id: " + id);
    //      }
    //      // Verifică dacă clientul are comenzi înainte de ștergere
    //      customerRepository.deleteById(id);
    // }

}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/service/ReviewService.java">
// backend/src/main/java/com/magazincomputere/magazin_api/service/ReviewService.java
package com.magazincomputere.magazin_api.service;

import com.magazincomputere.magazin_api.dto.*;
import com.magazincomputere.magazin_api.exception.BadRequestException;
import com.magazincomputere.magazin_api.exception.ResourceNotFoundException;
import com.magazincomputere.magazin_api.model.*;
import com.magazincomputere.magazin_api.repository.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Service
public class ReviewService {

    @Autowired
    private ReviewRepository reviewRepository;
    
    @Autowired
    private ProductRepository productRepository;
    
    @Autowired
    private UserRepository userRepository;

    @Transactional
    public ReviewDto createReview(CreateReviewRequest request, Long userId) {
        // Check if user already reviewed this product
        if (reviewRepository.existsByProductIdAndUserId(request.getProductId(), userId)) {
            throw new BadRequestException("Ai deja o recenzie pentru acest produs");
        }
        
        Product product = productRepository.findById(request.getProductId())
            .orElseThrow(() -> new ResourceNotFoundException("Produsul nu a fost găsit"));
            
        User user = userRepository.findById(userId)
            .orElseThrow(() -> new ResourceNotFoundException("Utilizatorul nu a fost găsit"));
        
        Review review = new Review();
        review.setProduct(product);
        review.setUser(user);
        review.setRating(request.getRating());
        review.setTitle(request.getTitle());
        review.setComment(request.getComment());
        
        Review savedReview = reviewRepository.save(review);
        return convertToDto(savedReview);
    }
    
    @Transactional
    public ReviewDto updateReview(Long reviewId, CreateReviewRequest request, Long userId) {
        Review review = reviewRepository.findById(reviewId)
            .orElseThrow(() -> new ResourceNotFoundException("Recenzia nu a fost găsită"));
            
        if (!review.getUser().getId().equals(userId)) {
            throw new BadRequestException("Nu poți modifica recenzia altui utilizator");
        }
        
        review.setRating(request.getRating());
        review.setTitle(request.getTitle());
        review.setComment(request.getComment());
        
        Review updatedReview = reviewRepository.save(review);
        return convertToDto(updatedReview);
    }
    
    @Transactional
    public void deleteReview(Long reviewId, Long userId, boolean isAdmin) {
        Review review = reviewRepository.findById(reviewId)
            .orElseThrow(() -> new ResourceNotFoundException("Recenzia nu a fost găsită"));
            
        if (!isAdmin && !review.getUser().getId().equals(userId)) {
            throw new BadRequestException("Nu poți șterge recenzia altui utilizator");
        }
        
        reviewRepository.delete(review);
    }
    
    public Page<ReviewDto> getProductReviews(Long productId, int page, int size) {
        Pageable pageable = PageRequest.of(page, size);
        Page<Review> reviews = reviewRepository.findByProductIdOrderByCreatedAtDesc(productId, pageable);
        return reviews.map(this::convertToDto);
    }
    
    public ReviewDto getUserReviewForProduct(Long productId, Long userId) {
        Review review = reviewRepository.findByProductIdAndUserId(productId, userId)
            .orElse(null);
        return review != null ? convertToDto(review) : null;
    }
    
    public ProductReviewSummary getProductReviewSummary(Long productId) {
        ProductReviewSummary summary = new ProductReviewSummary();
        
        Double avgRating = reviewRepository.calculateAverageRatingByProductId(productId);
        summary.setAverageRating(avgRating != null ? avgRating : 0.0);
        
        Integer totalReviews = reviewRepository.countByProductId(productId);
        summary.setTotalReviews(totalReviews != null ? totalReviews : 0);
        
        Map<Integer, Integer> distribution = new HashMap<>();
        for (int i = 1; i <= 5; i++) {
            distribution.put(i, 0);
        }
        
        List<Object[]> ratingCounts = reviewRepository.getRatingDistributionByProductId(productId);
        for (Object[] row : ratingCounts) {
            Integer rating = (Integer) row[0];
            Long count = (Long) row[1];
            distribution.put(rating, count.intValue());
        }
        
        summary.setRatingDistribution(distribution);
        return summary;
    }
    
    private ReviewDto convertToDto(Review review) {
        ReviewDto dto = new ReviewDto();
        dto.setId(review.getId());
        dto.setProductId(review.getProduct().getId());
        dto.setProductName(review.getProduct().getName());
        dto.setUserId(review.getUser().getId());
        dto.setUsername(review.getUser().getUsername());
        dto.setRating(review.getRating());
        dto.setTitle(review.getTitle());
        dto.setComment(review.getComment());
        dto.setCreatedAt(review.getCreatedAt());
        dto.setUpdatedAt(review.getUpdatedAt());
        return dto;
    }
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/service/SpecificationService.java">
package com.magazincomputere.magazin_api.service;

import com.magazincomputere.magazin_api.dto.SpecificationDefinitionDto;
import com.magazincomputere.magazin_api.exception.ResourceNotFoundException;
import com.magazincomputere.magazin_api.model.SpecificationDefinition;
import com.magazincomputere.magazin_api.repository.SpecificationDefinitionRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.stream.Collectors;

@Service
public class SpecificationService {

    @Autowired
    private SpecificationDefinitionRepository definitionRepository;

    private SpecificationDefinitionDto convertToDto(SpecificationDefinition definition) {
        return new SpecificationDefinitionDto(definition.getId(), definition.getName(), definition.getUnit());
    }

    // Metodă pentru a actualiza câmpurile unei entități existente dintr-un DTO
    private void updateEntityFromDto(SpecificationDefinitionDto dto, SpecificationDefinition definition) {
        definition.setName(dto.getName());
        definition.setUnit(dto.getUnit());
    }

    @Transactional(readOnly = true)
    public List<SpecificationDefinitionDto> getAllDefinitions() {
        return definitionRepository.findAll().stream().map(this::convertToDto).collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public SpecificationDefinitionDto getDefinitionById(Long id) {
        SpecificationDefinition def = definitionRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("SpecificationDefinition", "id", id));
        return convertToDto(def);
    }

    @Transactional
    public SpecificationDefinitionDto createDefinition(SpecificationDefinitionDto definitionDto) {
         definitionRepository.findByNameIgnoreCase(definitionDto.getName()).ifPresent(existingDef -> {
            throw new IllegalArgumentException("Specification definition with name '" + existingDef.getName() + "' already exists.");
        });
        SpecificationDefinition definition = new SpecificationDefinition();
        updateEntityFromDto(definitionDto, definition); // Folosim metoda care nu returnează pentru claritate
        SpecificationDefinition saved = definitionRepository.save(definition);
        return convertToDto(saved);
    }

    @Transactional
    public SpecificationDefinitionDto updateDefinition(Long id, SpecificationDefinitionDto definitionDto) {
        // Pasul 1: Găsește entitatea existentă
        SpecificationDefinition existingDef = definitionRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("SpecificationDefinition", "id", id));
        
        // Pasul 2: Verifică dacă noul nume este deja folosit de altă definiție
        // Folosim o variabilă finală sau effectively final pentru ID-ul definiției existente în lambda
        final Long existingDefId = existingDef.getId();
        definitionRepository.findByNameIgnoreCase(definitionDto.getName()).ifPresent(defWithSameName -> {
            if(!defWithSameName.getId().equals(existingDefId)){
                 throw new IllegalArgumentException("Another specification definition with name '" + defWithSameName.getName() + "' already exists.");
            }
        });

        // Pasul 3: Actualizează câmpurile entității existente cu datele din DTO
        // Nu re-atribuim existingDef, ci îi modificăm starea.
        updateEntityFromDto(definitionDto, existingDef);

        // Pasul 4: Salvează entitatea actualizată
        SpecificationDefinition updated = definitionRepository.save(existingDef);

        // Pasul 5: Converteste entitatea actualizată în DTO și returneaz-o
        return convertToDto(updated);
    }

    @Transactional
    public void deleteDefinition(Long id) {
        SpecificationDefinition definition = definitionRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("SpecificationDefinition", "id", id));
        
        // TODO: Verifică dacă această definiție este folosită în ProductSpecificationValue înainte de ștergere.
        // De exemplu: if (!productSpecificationValueRepository.findBySpecificationDefinitionId(id).isEmpty()) {
        // throw new BadRequestException("Cannot delete specification definition that is in use by products.");
        // }
        definitionRepository.delete(definition);
    }
}
</file>

<file path="backend/src/test/java/com/magazincomputere/magazin_api/MagazinApiApplicationTests.java">
package com.magazincomputere.magazin_api;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class MagazinApiApplicationTests {

	@Test
	void contextLoads() {
	}

}
</file>

<file path="frontend/.editorconfig">
# Editor configuration, see https://editorconfig.org
root = true

[*]
charset = utf-8
indent_style = space
indent_size = 2
insert_final_newline = true
trim_trailing_whitespace = true

[*.ts]
quote_type = single
ij_typescript_use_double_quotes = false

[*.md]
max_line_length = off
trim_trailing_whitespace = false
</file>

<file path="frontend/.gitignore">
# See https://docs.github.com/get-started/getting-started-with-git/ignoring-files for more about ignoring files.

# Compiled output
/dist
/tmp
/out-tsc
/bazel-out

# Node
/node_modules
npm-debug.log
yarn-error.log

# IDEs and editors
.idea/
.project
.classpath
.c9/
*.launch
.settings/
*.sublime-workspace

# Visual Studio Code
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json
.history/*

# Miscellaneous
/.angular/cache
.sass-cache/
/connect.lock
/coverage
/libpeerconnection.log
testem.log
/typings

# System files
.DS_Store
Thumbs.db
</file>

<file path="frontend/.vscode/extensions.json">
{
  // For more information, visit: https://go.microsoft.com/fwlink/?linkid=827846
  "recommendations": ["angular.ng-template"]
}
</file>

<file path="frontend/.vscode/launch.json">
{
  // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
  "version": "0.2.0",
  "configurations": [
    {
      "name": "ng serve",
      "type": "chrome",
      "request": "launch",
      "preLaunchTask": "npm: start",
      "url": "http://localhost:4200/"
    },
    {
      "name": "ng test",
      "type": "chrome",
      "request": "launch",
      "preLaunchTask": "npm: test",
      "url": "http://localhost:9876/debug.html"
    }
  ]
}
</file>

<file path="frontend/.vscode/tasks.json">
{
  // For more information, visit: https://go.microsoft.com/fwlink/?LinkId=733558
  "version": "2.0.0",
  "tasks": [
    {
      "type": "npm",
      "script": "start",
      "isBackground": true,
      "problemMatcher": {
        "owner": "typescript",
        "pattern": "$tsc",
        "background": {
          "activeOnStart": true,
          "beginsPattern": {
            "regexp": "(.*?)"
          },
          "endsPattern": {
            "regexp": "bundle generation complete"
          }
        }
      }
    },
    {
      "type": "npm",
      "script": "test",
      "isBackground": true,
      "problemMatcher": {
        "owner": "typescript",
        "pattern": "$tsc",
        "background": {
          "activeOnStart": true,
          "beginsPattern": {
            "regexp": "(.*?)"
          },
          "endsPattern": {
            "regexp": "bundle generation complete"
          }
        }
      }
    }
  ]
}
</file>

<file path="frontend/proxy.conf.json">
{
  "/api": {
    "target": "http://localhost:8080",
    "secure": false,
    "changeOrigin": true,
    "logLevel": "debug"
  }
}
</file>

<file path="frontend/README.md">
# MagazinCalculatoare

This project was generated using [Angular CLI](https://github.com/angular/angular-cli) version 19.2.10.

## Development server

To start a local development server, run:

```bash
ng serve
```

Once the server is running, open your browser and navigate to `http://localhost:4200/`. The application will automatically reload whenever you modify any of the source files.

## Code scaffolding

Angular CLI includes powerful code scaffolding tools. To generate a new component, run:

```bash
ng generate component component-name
```

For a complete list of available schematics (such as `components`, `directives`, or `pipes`), run:

```bash
ng generate --help
```

## Building

To build the project run:

```bash
ng build
```

This will compile your project and store the build artifacts in the `dist/` directory. By default, the production build optimizes your application for performance and speed.

## Running unit tests

To execute unit tests with the [Karma](https://karma-runner.github.io) test runner, use the following command:

```bash
ng test
```

## Running end-to-end tests

For end-to-end (e2e) testing, run:

```bash
ng e2e
```

Angular CLI does not come with an end-to-end testing framework by default. You can choose one that suits your needs.

## Additional Resources

For more information on using the Angular CLI, including detailed command references, visit the [Angular CLI Overview and Command Reference](https://angular.dev/tools/cli) page.
</file>

<file path="frontend/src/app/app.component.spec.ts">
import { TestBed } from '@angular/core/testing';
import { AppComponent } from './app.component';

describe('AppComponent', () => {
  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [AppComponent],
    }).compileComponents();
  });

  it('should create the app', () => {
    const fixture = TestBed.createComponent(AppComponent);
    const app = fixture.componentInstance;
    expect(app).toBeTruthy();
  });

  it(`should have the 'magazin-calculatoare' title`, () => {
    const fixture = TestBed.createComponent(AppComponent);
    const app = fixture.componentInstance;
    expect(app.title).toEqual('magazin-calculatoare');
  });

  it('should render title', () => {
    const fixture = TestBed.createComponent(AppComponent);
    fixture.detectChanges();
    const compiled = fixture.nativeElement as HTMLElement;
    expect(compiled.querySelector('h1')?.textContent).toContain('Hello, magazin-calculatoare');
  });
});
</file>

<file path="frontend/src/app/app.config.server.ts">
import { mergeApplicationConfig, ApplicationConfig } from '@angular/core';
import { provideServerRendering }                     from '@angular/platform-server';
import { provideServerRouting }                      from '@angular/ssr';
import { appConfig }                                 from './app.config';
import { serverRoutes }                              from './app.routes.server';

const serverConfig: ApplicationConfig = {
  providers: [
    provideServerRendering(),
    provideServerRouting(serverRoutes)
    // **nu** importa InMemoryWebApi aici!
  ]
};

export const config = mergeApplicationConfig(appConfig, serverConfig);
</file>

<file path="frontend/src/app/app.routes.server.ts">
import { RenderMode, ServerRoute } from '@angular/ssr';

export const serverRoutes: ServerRoute[] = [
  {
    path: '**',
    renderMode: RenderMode.Prerender
  }
];
</file>

<file path="frontend/src/app/auth/inactivity.service.ts">
import { Injectable, inject } from '@angular/core';
import { AuthService } from './auth.service';
import { Router } from '@angular/router';
import { Subject, fromEvent, merge, timer } from 'rxjs';
import { debounceTime, takeUntil } from 'rxjs/operators';

@Injectable({
  providedIn: 'root'
})
export class InactivityService {
  private authService = inject(AuthService);
  private router = inject(Router);
  
  private inactivityTime = 30 * 60 * 1000; // 30 minutes
  private destroy$ = new Subject<void>();
  private timer$ = new Subject<void>();

  startWatching(): void {
    if (!this.authService.isLoggedIn()) {
      return;
    }

    // Events to track user activity
    const activityEvents$ = merge(
      fromEvent(document, 'mousemove'),
      fromEvent(document, 'click'),
      fromEvent(document, 'keypress'),
      fromEvent(document, 'scroll'),
      fromEvent(document, 'touchstart')
    );

    // Reset timer on any activity
    activityEvents$
      .pipe(
        debounceTime(1000),
        takeUntil(this.destroy$)
      )
      .subscribe(() => {
        this.resetTimer();
      });

    this.resetTimer();
  }

  stopWatching(): void {
    this.destroy$.next();
    this.destroy$.complete();
    this.timer$.next();
    this.timer$.complete();
  }

  private resetTimer(): void {
    this.timer$.next();

    timer(this.inactivityTime)
      .pipe(takeUntil(this.timer$), takeUntil(this.destroy$))
      .subscribe(() => {
        console.log('User inactive for 30 minutes, logging out...');
        this.authService.logout();
        this.router.navigate(['/login'], { 
          queryParams: { reason: 'inactivity' } 
        });
      });
  }
}
</file>

<file path="frontend/src/app/auth/token-storage.service.ts">
// Cale: frontend/src/app/auth/token-storage.service.ts
import { Injectable } from '@angular/core';

const TOKEN_KEY = 'auth-token';
const USER_KEY = 'auth-user';

@Injectable({
  providedIn: 'root'
})
export class TokenStorageService {

  constructor() { }

  signOut(): void {
    window.sessionStorage.clear();
  }

  public saveToken(token: string): void {
    window.sessionStorage.removeItem(TOKEN_KEY);
    window.sessionStorage.setItem(TOKEN_KEY, token);
  }

  public getToken(): string | null {
    return window.sessionStorage.getItem(TOKEN_KEY);
  }

  public saveUser(user: any): void {
    window.sessionStorage.removeItem(USER_KEY);
    window.sessionStorage.setItem(USER_KEY, JSON.stringify(user));
  }

  public getUser(): any {
    const user = window.sessionStorage.getItem(USER_KEY);
    if (user) {
      return JSON.parse(user);
    }
    // Returnează null dacă nu există utilizator
    return null; 
  }
}
</file>

<file path="frontend/src/app/enviornments/environment.prod.ts">
export const environment = {
  production: true,
  apiUrl: '/api'
};
</file>

<file path="frontend/src/app/enviornments/environment.ts">
export const environment = {
  production: false,
  apiUrl: 'http://localhost:8080/api'
};
</file>

<file path="frontend/src/app/features/admin-dashboard/admin-dashboard.component.ts">
// src/app/features/admin-dashboard/admin-dashboard.component.ts
import { Component }      from '@angular/core';
import { CommonModule }   from '@angular/common';
import { RouterModule }   from '@angular/router';
import { MaterialModule } from '../../shared/material.module';
import { AuthService }    from '../../auth/auth.service';

@Component({
  selector: 'app-admin-dashboard',
  standalone: true,
  imports: [CommonModule, RouterModule, MaterialModule],
  templateUrl: './admin-dashboard.component.html',
  styleUrls: ['./admin-dashboard.component.scss']
})
export class AdminDashboardComponent {
  constructor(public auth: AuthService) {}
}
</file>

<file path="frontend/src/app/features/admin/admin-categories/admin-category-form/admin-category-form.component.html">
<div class="admin-category-form-container">
  <mat-card>
    <mat-card-header>
      <mat-card-title>{{ pageTitle }}</mat-card-title>
    </mat-card-header>
    <mat-card-content>
      <div *ngIf="isLoading" class="spinner-container">
        <mat-spinner diameter="50"></mat-spinner>
      </div>

      <form [formGroup]="categoryForm" (ngSubmit)="onSubmit()" *ngIf="!isLoading">
        <mat-form-field appearance="outline" class="full-width">
          <mat-label>Nume Categorie</mat-label>
          <input matInput formControlName="name" placeholder="Ex: Procesoare" required>
          <mat-error *ngIf="f['name'].hasError('required')">
            Numele este obligatoriu.
          </mat-error>
          <mat-error *ngIf="f['name'].hasError('minlength')">
            Numele trebuie să aibă cel puțin 2 caractere.
          </mat-error>
          <mat-error *ngIf="f['name'].hasError('maxlength')">
            Numele nu poate depăși 100 de caractere.
          </mat-error>
        </mat-form-field>

        <mat-form-field appearance="outline" class="full-width">
          <mat-label>Descriere</mat-label>
          <textarea matInput formControlName="description" placeholder="O scurtă descriere a categoriei (opțional)" rows="3"></textarea>
          <mat-error *ngIf="f['description'].hasError('maxlength')">
            Descrierea nu poate depăși 1000 de caractere.
          </mat-error>
        </mat-form-field>

        <div class="form-actions">
          <button mat-stroked-button color="warn" type="button" routerLink="/admin/categories" [disabled]="isLoading">
            <mat-icon>cancel</mat-icon> Anulează
          </button>
          <button mat-raised-button color="primary" type="submit" [disabled]="isLoading || categoryForm.invalid">
            <mat-icon>save</mat-icon> {{ submitButtonText }}
          </button>
        </div>
      </form>
    </mat-card-content>
  </mat-card>
</div>
</file>

<file path="frontend/src/app/features/admin/admin-categories/admin-category-form/admin-category-form.component.ts">
// src/app/features/admin/admin-categories/admin-category-form/admin-category-form.component.ts
import { Component, OnInit, inject } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ReactiveFormsModule, FormBuilder, FormGroup, Validators } from '@angular/forms';
import { ActivatedRoute, Router, RouterModule } from '@angular/router';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { MatButtonModule } from '@angular/material/button';
import { MatCardModule } from '@angular/material/card';
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { MatIconModule } from '@angular/material/icon';
import { HttpErrorResponse } from '@angular/common/http'; // Import HttpErrorResponse

import { Category } from '../../../../shared/models/category.model';
// Calea corectă și numele fișierului serviciului
import { CategoryAdminService } from '../../services/category.admin.service'; // <<<--- CALE ȘI NUME FIȘIER CORECTATE

@Component({
  selector: 'app-admin-category-form',
  standalone: true,
  imports: [
    CommonModule,
    RouterModule,
    ReactiveFormsModule,
    MatFormFieldModule,
    MatInputModule,
    MatButtonModule,
    MatCardModule,
    MatSnackBarModule,
    MatProgressSpinnerModule,
    MatIconModule
  ],
  templateUrl: './admin-category-form.component.html',
  styleUrls: ['./admin-category-form.component.scss']
})
export class AdminCategoryFormComponent implements OnInit {
  categoryForm!: FormGroup;
  isEditMode = false;
  categoryId?: number;
  isLoading = false;
  pageTitle = 'Adaugă Categorie Nouă';
  submitButtonText = 'Salvează';
  error: string | null = null; // Adăugat pentru a stoca mesajul de eroare

  private fb = inject(FormBuilder);
  private categoryService = inject(CategoryAdminService);
  private route = inject(ActivatedRoute);
  private router = inject(Router);
  private snackBar = inject(MatSnackBar);

  ngOnInit(): void {
    this.categoryForm = this.fb.group({
      name: ['', [Validators.required, Validators.minLength(2), Validators.maxLength(100)]],
      description: ['', [Validators.maxLength(1000)]]
    });

    const idFromRoute = this.route.snapshot.paramMap.get('id');
    if (idFromRoute) {
      this.categoryId = +idFromRoute;
      if (!isNaN(this.categoryId) && this.categoryId > 0) {
        this.isEditMode = true;
        this.pageTitle = 'Editează Categorie';
        this.submitButtonText = 'Actualizează';
        this.loadCategoryData(this.categoryId);
      } else {
        this.handleInvalidId('ID categorie invalid din rută.');
      }
    }
  }

  loadCategoryData(id: number): void {
    this.isLoading = true;
    this.categoryService.getById(id).subscribe({
      next: (category: Category) => { // <<<--- TIPARE EXPLICITĂ PENTRU 'category'
        this.categoryForm.patchValue(category);
        this.isLoading = false;
      },
      error: (err: HttpErrorResponse) => this.handleLoadError('Eroare la încărcarea datelor categoriei.', err) // <<<--- TIPARE EXPLICITĂ ȘI REFACUT
    });
  }

  onSubmit(): void {
    if (this.categoryForm.invalid) {
      this.snackBar.open('Formular invalid. Vă rugăm corectați erorile.', 'OK', { duration: 3000 });
      this.categoryForm.markAllAsTouched();
      return;
    }

    this.isLoading = true;
    const categoryData: Category = this.categoryForm.value;

    if (this.isEditMode && this.categoryId) {
      this.categoryService.update(this.categoryId, categoryData).subscribe({
        next: () => {
          this.isLoading = false;
          this.snackBar.open('Categorie actualizată cu succes!', 'OK', { duration: 3000 });
          this.router.navigate(['/admin/categories']);
        },
        error: (err: HttpErrorResponse) => this.handleSubmitError('Eroare la actualizarea categoriei.', err) // <<<--- TIPARE EXPLICITĂ ȘI REFACUT
      });
    } else {
      this.categoryService.create(categoryData).subscribe({
        next: () => {
          this.isLoading = false;
          this.snackBar.open('Categorie creată cu succes!', 'OK', { duration: 3000 });
          this.router.navigate(['/admin/categories']);
        },
        error: (err: HttpErrorResponse) => this.handleSubmitError('Eroare la crearea categoriei.', err) // <<<--- TIPARE EXPLICITĂ ȘI REFACUT
      });
    }
  }

  private handleInvalidId(message: string): void {
    this.isLoading = false;
    this.error = message; // Setează mesajul de eroare
    this.snackBar.open(this.error, 'Închide', { duration: 3000 });
    this.router.navigate(['/admin/categories']);
  }

  private handleLoadError(message: string, err: HttpErrorResponse): void {
    this.isLoading = false;
    // Extrage mesajul de eroare din răspunsul backend-ului dacă există
    const serverErrorMessage = err.error?.message || err.message || 'Eroare necunoscută de la server.';
    this.error = `${message} ${serverErrorMessage}`;
    this.snackBar.open(this.error, 'Închide', { duration: 5000 });
    console.error('Eroare la încărcare:', err);
    this.router.navigate(['/admin/categories']);
  }

  private handleSubmitError(message: string, err: HttpErrorResponse): void {
    this.isLoading = false;
    const serverErrorMessage = err.error?.message || err.message || 'Eroare necunoscută de la server.';
    this.snackBar.open(`${message} ${serverErrorMessage}`, 'Închide', { duration: 5000 });
    console.error('Eroare la submit:', err);
  }


  get f() { return this.categoryForm.controls; }
}
</file>

<file path="frontend/src/app/features/admin/admin-categories/admin-category-list/admin-category-list.component.html">
<!-- src/app/features/admin/admin-categories/admin-category-list/admin-category-list.component.html -->
<div class="admin-category-list-container">
  <div class="header">
    <h2>Administrare Categorii</h2>
    <button mat-raised-button color="primary" routerLink="/admin/categories/new">
      <mat-icon>add</mat-icon> Adaugă Categorie Nouă
    </button>
  </div>

  <div *ngIf="isLoading" class="loading-indicator">
    <p>Se încarcă categoriile...</p>
    <!-- Poți adăuga un spinner Angular Material aici -->
    <!-- <mat-spinner diameter="40"></mat-spinner> -->
  </div>

  <div *ngIf="error && !isLoading" class="error-message">
    <p>{{ error }}</p>
    <button mat-stroked-button color="warn" (click)="loadCategories()">Reîncearcă</button>
  </div>

  <div *ngIf="!isLoading && !error && categories.length === 0" class="no-data">
    <p>Nu există categorii definite.</p>
  </div>

  <mat-list *ngIf="!isLoading && !error && categories.length > 0" role="list">
    <h3 mat-subheader>Categorii Existente</h3>
    <mat-list-item *ngFor="let category of categories" role="listitem" class="category-item">
      <mat-icon matListItemIcon>folder_open</mat-icon>
      <span matListItemTitle>{{ category.name }}</span>
      <span matListItemLine class="description">{{ category.description || 'Fără descriere' }}</span>
      <span matListItemMeta class="actions">
        <button mat-icon-button color="primary" [routerLink]="['/admin/categories/edit', category.id]" aria-label="Editează categoria">
          <mat-icon>edit</mat-icon>
        </button>
        <button mat-icon-button color="warn" (click)="deleteCategory(category.id!)" [disabled]="isLoading" aria-label="Șterge categoria">
          <mat-icon>delete</mat-icon>
        </button>
      </span>
    </mat-list-item>
  </mat-list>
</div>
</file>

<file path="frontend/src/app/features/admin/admin-categories/admin-category-list/admin-category-list.component.ts">
// src/app/features/admin/admin-categories/admin-category-list/admin-category-list.component.ts
import { Component, OnInit, inject } from '@angular/core';
import { CommonModule } from '@angular/common';
import { RouterModule } from '@angular/router';
import { MatListModule } from '@angular/material/list';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar';
import { MatDialog, MatDialogModule } from '@angular/material/dialog';
// Importă un dialog de confirmare generic dacă ai unul, sau creează unul simplu.
// import { ConfirmDialogComponent } from '../../../../shared/components/confirm-dialog/confirm-dialog.component';


import { Category } from '../../../../shared/models/category.model';
import { CategoryAdminService } from '../../services/category.admin.service'; // Asigură-te că numele serviciului este corect

@Component({
  selector: 'app-admin-category-list',
  standalone: true,
  imports: [
    CommonModule,
    RouterModule,
    MatListModule,
    MatButtonModule,
    MatIconModule,
    MatSnackBarModule,
    MatDialogModule
  ],
  templateUrl: './admin-category-list.component.html',
  styleUrls: ['./admin-category-list.component.scss']
})
export class AdminCategoryListComponent implements OnInit {
  categories: Category[] = [];
  isLoading = true;
  error: string | null = null;

  private categoryService = inject(CategoryAdminService);
  private snackBar = inject(MatSnackBar);
  // private dialog = inject(MatDialog); // Decomentează dacă folosești MatDialog

  ngOnInit(): void {
    this.loadCategories();
  }

  /**
   * Încarcă lista de categorii de la server.
   */
  loadCategories(): void {
    this.isLoading = true;
    this.error = null;
    this.categoryService.getAll().subscribe({
      next: (data) => {
        this.categories = data;
        this.isLoading = false;
      },
      error: (err) => {
        this.error = 'Nu s-au putut încărca categoriile.';
        const errMsg = err.error?.message || err.message || 'Eroare necunoscută.';
        console.error('Eroare la încărcarea categoriilor:', err);
        this.isLoading = false;
        this.snackBar.open(`${this.error} ${errMsg}`, 'Închide', { duration: 5000 });
      }
    });
  }

  /**
   * Șterge o categorie după o confirmare.
   * @param categoryId ID-ul categoriei de șters.
   */
  deleteCategory(categoryId: number): void {
    // TODO: Implementează un dialog de confirmare (MatDialog) înainte de ștergere.
    // Exemplu simplu cu window.confirm, dar MatDialog e preferat:
    const confirmation = window.confirm('Sunteți sigur că doriți să ștergeți această categorie? Această acțiune nu poate fi anulată.');
    if (confirmation) {
      this.isLoading = true; // Indică începerea operației
      this.categoryService.delete(categoryId).subscribe({
        next: () => {
          this.isLoading = false;
          this.snackBar.open('Categorie ștearsă cu succes!', 'OK', { duration: 3000 });
          this.loadCategories(); // Reîncarcă lista pentru a reflecta ștergerea
        },
        error: (err) => {
          this.isLoading = false;
          const errMsg = err.error?.message || err.message || 'Eroare la ștergerea categoriei.';
          this.snackBar.open(errMsg, 'Închide', { duration: 5000 });
          console.error('Eroare la ștergerea categoriei:', err);
        }
      });
    }
  }
}
</file>

<file path="frontend/src/app/features/admin/admin-orders/admin-order-detail/admin-order-detail.component.html">
<div class="admin-order-detail-container">
  <button mat-stroked-button routerLink="/admin/orders" class="back-button">
    <mat-icon>arrow_back</mat-icon> Înapoi la Listă Comenzi
  </button>

  <div *ngIf="isLoading" class="loading-indicator">
    <mat-spinner diameter="50"></mat-spinner>
    <p>Se încarcă detaliile comenzii...</p>
  </div>

  <div *ngIf="error && !isLoading" class="error-message">
    <p>{{ error }}</p>
    <button mat-stroked-button color="warn" (click)="loadOrderDetails()">Reîncearcă</button>
  </div>

  <div *ngIf="order && !isLoading" class="order-details">
    <mat-card class="order-summary-card">
      <mat-card-header>
        <mat-card-title>Comanda #{{ order.id }}</mat-card-title>
        <mat-card-subtitle>Plasată la: {{ order.orderDate | date:'dd/MM/yyyy HH:mm:ss' }}</mat-card-subtitle>
      </mat-card-header>
      <mat-card-content>
        <div class="info-grid">
          <div><strong>Client:</strong> {{ order.customerName }}</div>
          <div><strong>Email:</strong> {{ order.customerEmail }}</div>
          <div><strong>Telefon:</strong> {{ order.customerPhone }}</div>
          <div><strong>Utilizator (ID):</strong> {{ order.userId || 'N/A (Guest)' }}</div>
          <div class="full-width"><strong>Adresă Livrare:</strong> {{ order.shippingAddress }}</div>
        </div>
        <mat-divider></mat-divider>
        <div class="status-total">
            <mat-chip-listbox aria-label="Status comandă">
                <mat-chip selected [ngClass]="'status-chip-' + order.status.toLowerCase()">
                    Status: {{ formatStatus(order.status) }}
                </mat-chip>
            </mat-chip-listbox>
          <h3>Total Comandă: {{ order.totalAmount | currency:'RON':'symbol':'1.2-2' }}</h3>
        </div>
      </mat-card-content>
    </mat-card>

    <mat-card class="order-items-card">
      <mat-card-header>
        <mat-card-title>Articole Comandate</mat-card-title>
      </mat-card-header>
      <mat-card-content>
        <mat-list role="list" class="order-items-list">
          <mat-list-item *ngFor="let item of order.orderItems" role="listitem" class="order-item-detail">
            <!-- Secțiunea Imagine Articol - COMENTATĂ TEMPORAR -->
            <!--
            <img matListItemAvatar *ngIf="item.productImageBase64Snapshot" [src]="item.productImageBase64Snapshot" [alt]="item.productNameSnapshot || 'Imagine produs'" class="item-image-small">
            <mat-icon matListItemAvatar *ngIf="!item.productImageBase64Snapshot">inventory_2</mat-icon>
            -->
            <mat-icon matListItemAvatar>inventory_2</mat-icon> <!-- Placeholder generic -->

            <span matListItemTitle>{{ item.productNameSnapshot }} (ID: {{ item.productId }})</span>
            <span matListItemLine>
              Cantitate: {{ item.quantity }} x {{ item.priceAtPurchase | currency:'RON':'symbol':'1.2-2' }}
            </span>
            <span matListItemMeta class="item-subtotal-small">
              Subtotal: {{ calculateItemSubtotal(item) | currency:'RON':'symbol':'1.2-2' }}
            </span>
          </mat-list-item>
        </mat-list>
      </mat-card-content>
    </mat-card>

    <mat-card class="status-update-card">
      <mat-card-header>
        <mat-card-title>Actualizează Status Comandă</mat-card-title>
      </mat-card-header>
      <mat-card-content>
        <form [formGroup]="statusUpdateForm" (ngSubmit)="onUpdateStatus()">
          <mat-form-field appearance="outline" class="full-width">
            <mat-label>Status Nou</mat-label>
            <mat-select formControlName="newStatus" required>
              <mat-option *ngFor="let status of availableStatuses" [value]="status">
                {{ formatStatus(status) }}
              </mat-option>
            </mat-select>
            <mat-error *ngIf="statusUpdateForm.get('newStatus')?.hasError('required')">
              Selectați un status.
            </mat-error>
          </mat-form-field>
          <button mat-raised-button color="primary" type="submit" [disabled]="statusUpdateForm.invalid || isUpdatingStatus">
            <mat-icon *ngIf="!isUpdatingStatus">update</mat-icon>
            <mat-progress-spinner *ngIf="isUpdatingStatus" diameter="20" mode="indeterminate" style="margin-right: 8px;"></mat-progress-spinner>
            {{ isUpdatingStatus ? 'Se actualizează...' : 'Actualizează Status' }}
          </button>
        </form>
      </mat-card-content>
    </mat-card>
  </div>
</div>
</file>

<file path="frontend/src/app/features/admin/admin-orders/admin-order-detail/admin-order-detail.component.ts">
// src/app/features/admin/admin-orders/admin-order-detail/admin-order-detail.component.ts
import { Component, OnInit, inject } from '@angular/core';
import { CommonModule, DatePipe, CurrencyPipe } from '@angular/common';
import { ActivatedRoute, Router, RouterModule } from '@angular/router';
import { ReactiveFormsModule, FormBuilder, FormGroup, Validators } from '@angular/forms';

import { MatCardModule } from '@angular/material/card';
import { MatListModule } from '@angular/material/list';
import { MatDividerModule } from '@angular/material/divider';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatSelectModule } from '@angular/material/select';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar';
import { MatChipsModule } from '@angular/material/chips';
import { HttpErrorResponse } from '@angular/common/http';


import { Order } from '../../../../shared/models/order.model';
import { OrderItem } from '../../../../shared/models/order-item.model'; // <<< CORECTAT
import { OrderStatusUpdate } from '../../../../shared/models/order-status-update.model'; // <<< CORECTAT
import { OrderAdminService } from '../../services/order.admin.service';

@Component({
  selector: 'app-admin-order-detail',
  standalone: true,
  imports: [
    CommonModule,
    RouterModule,
    ReactiveFormsModule,
    MatCardModule,
    MatListModule,
    MatDividerModule,
    MatFormFieldModule,
    MatSelectModule,
    MatButtonModule,
    MatIconModule,
    MatProgressSpinnerModule,
    MatSnackBarModule,
    MatChipsModule,
    DatePipe,
    CurrencyPipe
  ],
  templateUrl: './admin-order-detail.component.html',
  styleUrls: ['./admin-order-detail.component.scss']
})
export class AdminOrderDetailComponent implements OnInit {
  order: Order | null = null;
  isLoading = true;
  error: string | null = null;
  orderId!: number;

  statusUpdateForm!: FormGroup;
  availableStatuses: string[] = ['PENDING_CONFIRMATION', 'APPROVED', 'PROCESSING', 'SHIPPED', 'DELIVERED', 'CANCELED'];
  isUpdatingStatus = false;

  private route = inject(ActivatedRoute);
  private router = inject(Router);
  private orderService = inject(OrderAdminService);
  private snackBar = inject(MatSnackBar);
  private fb = inject(FormBuilder);

  ngOnInit(): void {
    const idFromRoute = this.route.snapshot.paramMap.get('id');
    if (idFromRoute) {
      this.orderId = +idFromRoute;
      if (!isNaN(this.orderId) && this.orderId > 0) {
        this.loadOrderDetails();
        this.statusUpdateForm = this.fb.group({
          newStatus: ['', Validators.required]
        });
      } else {
        this.handleInvalidId();
      }
    } else {
      this.handleInvalidId();
    }
  }

  private handleInvalidId(): void {
    this.isLoading = false;
    this.error = 'ID comandă invalid.';
    this.snackBar.open(this.error, 'Închide', { duration: 3000 });
    this.router.navigate(['/admin/orders']);
  }

  loadOrderDetails(): void {
    this.isLoading = true;
    this.error = null;
    this.orderService.getOrderById(this.orderId).subscribe({
      next: (data: Order) => { // Tipare explicită
        this.order = data;
        this.statusUpdateForm.patchValue({ newStatus: this.order.status });
        this.isLoading = false;
      },
      error: (err: HttpErrorResponse) => { // Tipare explicită
        this.error = 'Nu s-au putut încărca detaliile comenzii.';
        const errMsg = err.error?.message || err.message || 'Eroare necunoscută.';
        console.error('Eroare la încărcarea detaliilor comenzii:', err);
        this.isLoading = false;
        this.snackBar.open(`${this.error} ${errMsg}`, 'Închide', { duration: 5000 });
      }
    });
  }

  onUpdateStatus(): void {
    if (this.statusUpdateForm.invalid || !this.order) {
      this.snackBar.open('Vă rugăm selectați un status valid.', 'OK', { duration: 3000 });
      return;
    }

    this.isUpdatingStatus = true;
    const statusUpdate: OrderStatusUpdate = this.statusUpdateForm.value;

    this.orderService.updateOrderStatus(this.orderId, statusUpdate).subscribe({
      next: (updatedOrder: Order) => { // Tipare explicită
        this.order = updatedOrder;
        this.statusUpdateForm.patchValue({ newStatus: updatedOrder.status });
        this.isUpdatingStatus = false;
        this.snackBar.open('Statusul comenzii a fost actualizat cu succes!', 'OK', { duration: 3000 });
      },
      error: (err: HttpErrorResponse) => { // Tipare explicită
        this.isUpdatingStatus = false;
        const errorMessage = err.error?.message || err.message || 'Eroare la actualizarea statusului comenzii.';
        this.snackBar.open(errorMessage, 'Închide', { duration: 5000 });
        console.error(err);
      }
    });
  }

  formatStatus(status: string): string {
    if (!status) return '';
    return status.replace(/_/g, ' ').toLowerCase().replace(/\b\w/g, l => l.toUpperCase());
  }

  calculateItemSubtotal(item: OrderItem): number {
    return (item.priceAtPurchase || 0) * item.quantity;
  }
}
</file>

<file path="frontend/src/app/features/admin/admin-orders/admin-order-list/admin-order-list.component.html">
<!-- src/app/features/admin/admin-orders/admin-order-list/admin-order-list.component.html -->
<div class="admin-order-list-container">
  <div class="header">
    <h2>Administrare Comenzi</h2>
  </div>

  <div class="filters-container">
    <mat-form-field appearance="outline" class="filter-field">
      <mat-label>Filtrează comenzi (ex: nume client, ID)</mat-label>
      <input matInput (keyup)="applyFilter($event)" placeholder="Caută...">
      <mat-icon matSuffix>search</mat-icon>
    </mat-form-field>

    <mat-form-field appearance="outline" class="status-filter-field">
      <mat-label>Filtrează după Status</mat-label>
      <mat-select [(ngModel)]="statusFilter" (selectionChange)="onStatusFilterChange()">
        <mat-option value="ALL">Toate Statusurile</mat-option>
        <!-- Se iterează peste getter-ul statusesForFilterDropdown -->
        <mat-option *ngFor="let status of statusesForFilterDropdown" [value]="status">
          {{ formatStatus(status) }}
        </mat-option>
      </mat-select>
    </mat-form-field>
  </div>

  <div *ngIf="isLoading" class="loading-indicator">
    <mat-spinner diameter="50"></mat-spinner>
    <p>Se încarcă comenzile...</p>
  </div>

  <div *ngIf="error && !isLoading" class="error-message">
    <p>{{ error }}</p>
    <button mat-stroked-button color="warn" (click)="loadOrders()">Reîncearcă</button>
  </div>

  <div *ngIf="!isLoading && !error && dataSource.data.length === 0" class="no-data">
    <p>Nu există comenzi care să corespundă filtrelor selectate sau nu există comenzi înregistrate.</p>
  </div>

  <div class="table-container" *ngIf="!isLoading && !error && dataSource.data.length > 0">
    <table mat-table [dataSource]="dataSource" matSort class="mat-elevation-z8">

      <!-- ID Column -->
      <ng-container matColumnDef="id">
        <th mat-header-cell *matHeaderCellDef mat-sort-header> ID Comandă </th>
        <td mat-cell *matCellDef="let order"> #{{order.id}} </td>
      </ng-container>

      <!-- Customer Name Column -->
      <ng-container matColumnDef="customerName">
        <th mat-header-cell *matHeaderCellDef mat-sort-header> Nume Client </th>
        <td mat-cell *matCellDef="let order"> {{order.customerName}} </td>
      </ng-container>

      <!-- Order Date Column -->
      <ng-container matColumnDef="orderDate">
        <th mat-header-cell *matHeaderCellDef mat-sort-header> Data Comenzii </th>
        <td mat-cell *matCellDef="let order"> {{order.orderDate | date:'dd/MM/yyyy HH:mm'}} </td>
      </ng-container>

      <!-- Total Amount Column -->
      <ng-container matColumnDef="totalAmount">
        <th mat-header-cell *matHeaderCellDef mat-sort-header> Suma Totală </th>
        <td mat-cell *matCellDef="let order"> {{order.totalAmount | currency:'RON':'symbol':'1.2-2'}} </td>
      </ng-container>

      <!-- Status Column -->
      <ng-container matColumnDef="status">
        <th mat-header-cell *matHeaderCellDef mat-sort-header> Status </th>
        <td mat-cell *matCellDef="let order" [ngClass]="'status-' + order.status.toLowerCase().replace('_', '-')">
          {{ formatStatus(order.status) }}
        </td>
      </ng-container>

      <!-- Actions Column -->
      <ng-container matColumnDef="actions">
        <th mat-header-cell *matHeaderCellDef> Acțiuni </th>
        <td mat-cell *matCellDef="let order">
          <button mat-icon-button color="primary" [routerLink]="['/admin/orders', order.id]" aria-label="Vezi detalii comandă">
            <mat-icon>visibility</mat-icon>
          </button>
        </td>
      </ng-container>

      <tr mat-header-row *matHeaderRowDef="displayedColumns"></tr>
      <tr mat-row *matRowDef="let row; columns: displayedColumns;"></tr>

      <tr class="mat-row" *matNoDataRow>
        <td class="mat-cell" [attr.colspan]="displayedColumns.length">
          Nu s-au găsit comenzi care să corespundă filtrului text "{{dataSource.filter}}".
        </td>
      </tr>
    </table>

    <mat-paginator [pageSizeOptions]="[5, 10, 25, 100]" showFirstLastButtons aria-label="Selectează pagina de comenzi"></mat-paginator>
  </div>
</div>
</file>

<file path="frontend/src/app/features/admin/admin-orders/admin-order-list/admin-order-list.component.ts">
// src/app/features/admin/admin-orders/admin-order-list/admin-order-list.component.ts
import { Component, OnInit, inject, ViewChild, AfterViewInit } from '@angular/core';
import { CommonModule, DatePipe } from '@angular/common';
import { RouterModule } from '@angular/router';
import { MatTableDataSource, MatTableModule } from '@angular/material/table';
import { MatPaginator, MatPaginatorModule } from '@angular/material/paginator';
import { MatSort, MatSortModule } from '@angular/material/sort';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { MatSelectModule } from '@angular/material/select';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar';
import { FormsModule } from '@angular/forms'; // Pentru ngModel

import { Order } from '../../../../shared/models/order.model';
import { OrderAdminService } from '../../services/order.admin.service';

@Component({
  selector: 'app-admin-order-list',
  standalone: true,
  imports: [
    CommonModule,
    RouterModule,
    FormsModule, // Adăugat FormsModule pentru ngModel
    MatTableModule,
    MatPaginatorModule,
    MatSortModule,
    MatFormFieldModule,
    MatInputModule,
    MatSelectModule,
    MatButtonModule,
    MatIconModule,
    MatProgressSpinnerModule,
    MatSnackBarModule,
    DatePipe
  ],
  templateUrl: './admin-order-list.component.html',
  styleUrls: ['./admin-order-list.component.scss']
})
export class AdminOrderListComponent implements OnInit, AfterViewInit {
  displayedColumns: string[] = ['id', 'customerName', 'orderDate', 'totalAmount', 'status', 'actions'];
  dataSource: MatTableDataSource<Order> = new MatTableDataSource();
  isLoading = true;
  error: string | null = null;

  statusFilter: string = ''; // Inițializat cu string gol sau 'ALL'
  // Lista completă de statusuri, inclusiv 'ALL' pentru a reseta filtrul
  readonly availableStatuses: string[] = ['PENDING_CONFIRMATION', 'APPROVED', 'PROCESSING', 'SHIPPED', 'DELIVERED', 'CANCELED', 'ALL'];

  @ViewChild(MatPaginator) paginator!: MatPaginator;
  @ViewChild(MatSort) sort!: MatSort;

  private orderService = inject(OrderAdminService);
  private snackBar = inject(MatSnackBar);

  ngOnInit(): void {
    this.loadOrders();
  }

  ngAfterViewInit(): void {
    this.dataSource.paginator = this.paginator;
    this.dataSource.sort = this.sort;
    // Custom sort pentru data și status (dacă este necesar pentru stringuri complexe)
    this.dataSource.sortingDataAccessor = (item, property) => {
      switch (property) {
        case 'orderDate': return new Date(item.orderDate || 0).getTime();
        case 'status': return this.formatStatus(item.status); // Sortează după statusul formatat
        default: return (item as any)[property];
      }
    };
  }

  /**
   * Getter pentru lista de statusuri care vor fi afișate în dropdown-ul de filtrare.
   * Exclude opțiunea 'ALL' din iterația directă, deoarece este gestionată separat.
   */
  get statusesForFilterDropdown(): string[] {
    return this.availableStatuses.filter(s => s !== 'ALL');
  }

  loadOrders(): void {
    this.isLoading = true;
    this.error = null;
    // Dacă statusFilter este 'ALL', trimitem undefined sau string gol la serviciu
    // pentru a prelua toate comenzile, în funcție de cum este implementat backend-ul/serviciul.
    const filterToSend = (this.statusFilter === 'ALL' || this.statusFilter === '') ? undefined : this.statusFilter;

    this.orderService.getAllOrders(filterToSend).subscribe({
      next: (data) => {
        this.dataSource.data = data;
        // Paginatorul și sortarea sunt deja setate în ngAfterViewInit
        // this.dataSource.paginator = this.paginator; // Nu este nevoie aici dacă e în ngAfterViewInit
        // this.dataSource.sort = this.sort;         // Nu este nevoie aici
        this.isLoading = false;
      },
      error: (err) => {
        this.error = 'Nu s-au putut încărca comenzile.';
        const errMsg = err.error?.message || err.message || 'Eroare necunoscută.';
        console.error('Eroare la încărcarea comenzilor:', err);
        this.isLoading = false;
        this.snackBar.open(`${this.error} ${errMsg}`, 'Închide', { duration: 5000 });
      }
    });
  }

  applyFilter(event: Event): void {
    const filterValue = (event.target as HTMLInputElement).value;
    this.dataSource.filter = filterValue.trim().toLowerCase();

    if (this.dataSource.paginator) {
      this.dataSource.paginator.firstPage();
    }
  }

  onStatusFilterChange(): void {
    this.loadOrders();
    if (this.dataSource.paginator) {
      this.dataSource.paginator.firstPage(); // Resetează paginatorul la schimbarea filtrului
    }
  }

  formatStatus(status: string): string {
    if (!status) return '';
    return status.replace(/_/g, ' ').toLowerCase().replace(/\b\w/g, l => l.toUpperCase());
  }
}
</file>

<file path="frontend/src/app/features/admin/admin-specifications/admin-spec-def-form/admin-spec-def-form.component.html">
<div class="admin-spec-def-form-container">
  <mat-card>
    <mat-card-header>
      <mat-card-title>{{ pageTitle }}</mat-card-title>
    </mat-card-header>
    <mat-card-content>
      <div *ngIf="isLoading && isEditMode" class="spinner-container">
        <mat-progress-spinner diameter="50" mode="indeterminate"></mat-progress-spinner>
        <p>Se încarcă datele...</p>
      </div>

      <form [formGroup]="specDefForm" (ngSubmit)="onSubmit()" *ngIf="!isLoading || !isEditMode">
        <mat-form-field appearance="outline" class="full-width">
          <mat-label>Nume Specificație</mat-label>
          <input matInput formControlName="name" placeholder="Ex: Procesor, Memorie RAM, Culoare" required>
          <mat-error *ngIf="f['name'].hasError('required')">Numele este obligatoriu.</mat-error>
          <mat-error *ngIf="f['name'].hasError('minlength')">Minim 2 caractere.</mat-error>
          <mat-error *ngIf="f['name'].hasError('maxlength')">Maxim 100 caractere.</mat-error>
        </mat-form-field>

        <mat-form-field appearance="outline" class="full-width">
          <mat-label>Unitate de Măsură (Opțional)</mat-label>
          <input matInput formControlName="unit" placeholder="Ex: GB, MHz, cm, kg">
           <mat-error *ngIf="f['unit'].hasError('maxlength')">Maxim 50 caractere.</mat-error>
        </mat-form-field>

        <div class="form-actions">
          <button mat-stroked-button color="warn" type="button" routerLink="/admin/specification-definitions" [disabled]="isLoading">
            <mat-icon>cancel</mat-icon> Anulează
          </button>
          <button mat-raised-button color="primary" type="submit" [disabled]="isLoading || specDefForm.invalid">
            <mat-icon *ngIf="!isLoading">save</mat-icon>
            <mat-progress-spinner *ngIf="isLoading" diameter="20" mode="indeterminate" style="margin-right: 8px; display: inline-block;"></mat-progress-spinner>
            {{ isLoading ? 'Se salvează...' : submitButtonText }}
          </button>
        </div>
      </form>
    </mat-card-content>
  </mat-card>
</div>
</file>

<file path="frontend/src/app/features/admin/admin-specifications/admin-spec-def-form/admin-spec-def-form.component.ts">
// src/app/features/admin/admin-specifications/admin-spec-def-form/admin-spec-def-form.component.ts
import { Component, OnInit, inject } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ReactiveFormsModule, FormBuilder, FormGroup, Validators } from '@angular/forms';
import { ActivatedRoute, Router, RouterModule } from '@angular/router';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { MatButtonModule } from '@angular/material/button';
import { MatCardModule } from '@angular/material/card';
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { MatIconModule } from '@angular/material/icon';

import { SpecificationDefinition } from '../../../../shared/models/specification-definition.model';
import { SpecificationAdminService } from '../../services/specification-admin.service';

@Component({
  selector: 'app-admin-spec-def-form',
  standalone: true,
  imports: [
    CommonModule,
    RouterModule,
    ReactiveFormsModule,
    MatFormFieldModule,
    MatInputModule,
    MatButtonModule,
    MatCardModule,
    MatSnackBarModule,
    MatProgressSpinnerModule,
    MatIconModule
  ],
  templateUrl: './admin-spec-def-form.component.html',
  styleUrls: ['./admin-spec-def-form.component.scss']
})
export class AdminSpecDefFormComponent implements OnInit {
  specDefForm!: FormGroup;
  isEditMode = false;
  specDefId?: number;
  isLoading = false;
  pageTitle = 'Adaugă Definiție Specificație';
  submitButtonText = 'Salvează Definiție';

  private fb = inject(FormBuilder);
  private specAdminService = inject(SpecificationAdminService);
  private route = inject(ActivatedRoute);
  private router = inject(Router);
  private snackBar = inject(MatSnackBar);

  ngOnInit(): void {
    this.specDefForm = this.fb.group({
      name: ['', [Validators.required, Validators.minLength(2), Validators.maxLength(100)]],
      unit: ['', [Validators.maxLength(50)]] // Unitatea este opțională
    });

    const idFromRoute = this.route.snapshot.paramMap.get('id');
    if (idFromRoute) {
      this.specDefId = +idFromRoute;
      if (!isNaN(this.specDefId) && this.specDefId > 0) {
        this.isEditMode = true;
        this.pageTitle = 'Editează Definiție Specificație';
        this.submitButtonText = 'Actualizează Definiție';
        this.loadSpecDefData(this.specDefId);
      } else {
        this.handleInvalidId('ID definiție specificație invalid din rută.');
      }
    }
  }

  loadSpecDefData(id: number): void {
    this.isLoading = true;
    this.specAdminService.getDefinitionById(id).subscribe({
      next: (specDef) => {
        this.specDefForm.patchValue(specDef);
        this.isLoading = false;
      },
      error: (err) => this.handleLoadError('Eroare la încărcarea datelor definiției.', err)
    });
  }

  onSubmit(): void {
    if (this.specDefForm.invalid) {
      this.snackBar.open('Formular invalid. Verificați câmpurile.', 'OK', { duration: 3000 });
      this.specDefForm.markAllAsTouched();
      return;
    }
    this.isLoading = true;
    const specDefData: SpecificationDefinition = this.specDefForm.value;

    const operation = this.isEditMode && this.specDefId
      ? this.specAdminService.updateDefinition(this.specDefId, { ...specDefData, id: this.specDefId })
      : this.specAdminService.createDefinition(specDefData as Omit<SpecificationDefinition, 'id'>);

    operation.subscribe({
      next: () => {
        this.isLoading = false;
        this.snackBar.open(`Definiție specificație ${this.isEditMode ? 'actualizată' : 'creată'} cu succes!`, 'OK', { duration: 3000 });
        this.router.navigate(['/admin/specification-definitions']);
      },
      error: (err) => this.handleSubmitError(`Eroare la ${this.isEditMode ? 'actualizarea' : 'crearea'} definiției.`, err)
    });
  }
  
  private handleInvalidId(message: string): void {
    this.isLoading = false;
    this.snackBar.open(message, 'Închide', { duration: 3000 });
    this.router.navigate(['/admin/specification-definitions']);
  }

  private handleLoadError(message: string, err: any): void {
    this.isLoading = false;
    const errMsg = err.error?.message || err.message || 'Eroare necunoscută.';
    this.snackBar.open(`${message} ${errMsg}`, 'Închide', { duration: 5000 });
    console.error(err);
    this.router.navigate(['/admin/specification-definitions']);
  }

  private handleSubmitError(message: string, err: any): void {
    this.isLoading = false;
    const errMsg = err.error?.message || err.message || 'Eroare necunoscută.';
    this.snackBar.open(`${message} ${errMsg}`, 'Închide', { duration: 5000 });
    console.error(err);
  }

  get f() { return this.specDefForm.controls; }
}
</file>

<file path="frontend/src/app/features/admin/admin-specifications/admin-spec-def-list/admin-spec-def-list.component.html">
<div class="admin-spec-def-list-container">
  <div class="header">
    <h2>Administrare Definiții Specificații</h2>
    <button mat-raised-button color="primary" routerLink="/admin/specification-definitions/new">
      <mat-icon>add_circle_outline</mat-icon> Adaugă Definiție Nouă
    </button>
  </div>

  <mat-form-field appearance="outline" class="filter-field">
    <mat-label>Filtrează definiții</mat-label>
    <input matInput (keyup)="applyFilter($event)" placeholder="Caută după nume, unitate...">
    <mat-icon matSuffix>search</mat-icon>
  </mat-form-field>

  <div *ngIf="isLoading" class="loading-indicator">
    <mat-spinner diameter="50"></mat-spinner>
    <p>Se încarcă definițiile specificațiilor...</p>
  </div>

  <div *ngIf="error && !isLoading" class="error-message">
    <p>{{ error }}</p>
    <button mat-stroked-button color="warn" (click)="loadSpecDefinitions()">Reîncearcă</button>
  </div>

  <div *ngIf="!isLoading && !error && dataSource.data.length === 0" class="no-data">
    <p>Nu există definiții de specificații.</p>
  </div>

  <div class="table-container" *ngIf="!isLoading && !error && dataSource.data.length > 0">
    <table mat-table [dataSource]="dataSource" matSort class="mat-elevation-z8">

      <ng-container matColumnDef="id">
        <th mat-header-cell *matHeaderCellDef mat-sort-header> ID </th>
        <td mat-cell *matCellDef="let specDef"> {{specDef.id}} </td>
      </ng-container>

      <ng-container matColumnDef="name">
        <th mat-header-cell *matHeaderCellDef mat-sort-header> Nume Specificație </th>
        <td mat-cell *matCellDef="let specDef"> {{specDef.name}} </td>
      </ng-container>

      <ng-container matColumnDef="unit">
        <th mat-header-cell *matHeaderCellDef mat-sort-header> Unitate </th>
        <td mat-cell *matCellDef="let specDef"> {{specDef.unit || 'N/A'}} </td>
      </ng-container>

      <ng-container matColumnDef="actions">
        <th mat-header-cell *matHeaderCellDef> Acțiuni </th>
        <td mat-cell *matCellDef="let specDef">
          <button mat-icon-button color="primary" [routerLink]="['/admin/specification-definitions/edit', specDef.id]" aria-label="Editează definiția">
            <mat-icon>edit</mat-icon>
          </button>
          <button mat-icon-button color="warn" (click)="deleteSpecDefinition(specDef.id!)" aria-label="Șterge definiția">
            <mat-icon>delete</mat-icon>
          </button>
        </td>
      </ng-container>

      <tr mat-header-row *matHeaderRowDef="displayedColumns"></tr>
      <tr mat-row *matRowDef="let row; columns: displayedColumns;"></tr>

      <tr class="mat-row" *matNoDataRow>
        <td class="mat-cell" [attr.colspan]="displayedColumns.length">
          Nu s-au găsit definiții care să corespundă filtrului "{{dataSource.filter}}".
        </td>
      </tr>
    </table>
    <mat-paginator [pageSizeOptions]="[5, 10, 25, 50]" showFirstLastButtons aria-label="Selectează pagina de definiții"></mat-paginator>
  </div>
</div>
</file>

<file path="frontend/src/app/features/admin/admin-specifications/admin-spec-def-list/admin-spec-def-list.component.scss">
// src/app/features/admin/admin-specifications/admin-spec-def-list/admin-spec-def-list.component.scss
.admin-spec-def-list-container {
  padding: 20px;
  max-width: 900px; // Lățime adecvată pentru tabel
  margin: auto;
}

.header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
  h2 {
    margin: 0;
  }
  button mat-icon {
    margin-right: 8px;
  }
}

.filter-field {
  width: 100%;
  max-width: 400px;
  margin-bottom: 20px;
}

.loading-indicator,
.error-message,
.no-data {
  text-align: center;
  padding: 20px;
  color: #757575;
  mat-spinner {
    margin: 0 auto 10px auto;
  }
}

.error-message {
  color: #f44336; // Material Red
}

.table-container {
  overflow-x: auto;
  margin-top: 10px;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

table {
  width: 100%;
}

.mat-column-actions {
  width: 120px;
  text-align: right;
}

.mat-column-id {
  max-width: 80px;
}
.mat-column-unit {
  max-width: 150px;
}

.mat-header-cell {
  font-weight: 500;
  color: rgba(0,0,0,0.67);
}

.mat-row:hover {
  background-color: rgba(0,0,0,0.03);
}

.mat-cell, .mat-header-cell {
  padding: 8px 16px;
}
</file>

<file path="frontend/src/app/features/admin/admin-specifications/admin-spec-def-list/admin-spec-def-list.component.ts">
// src/app/features/admin/admin-specifications/admin-spec-def-list/admin-spec-def-list.component.ts
import { Component, OnInit, inject, ViewChild, AfterViewInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { RouterModule } from '@angular/router';
import { MatTableDataSource, MatTableModule } from '@angular/material/table';
import { MatPaginator, MatPaginatorModule } from '@angular/material/paginator';
import { MatSort, MatSortModule } from '@angular/material/sort';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar';
import { MatDialog } from '@angular/material/dialog'; // Pentru confirmare ștergere

import { SpecificationDefinition } from '../../../../shared/models/specification-definition.model';
import { SpecificationAdminService } from '../../services/specification-admin.service';
// import { ConfirmDialogComponent } from '../../../../shared/components/confirm-dialog/confirm-dialog.component'; // Dialog de confirmare

@Component({
  selector: 'app-admin-spec-def-list',
  standalone: true,
  imports: [
    CommonModule,
    RouterModule,
    MatTableModule,
    MatPaginatorModule,
    MatSortModule,
    MatFormFieldModule,
    MatInputModule,
    MatButtonModule,
    MatIconModule,
    MatProgressSpinnerModule,
    MatSnackBarModule
  ],
  templateUrl: './admin-spec-def-list.component.html',
  styleUrls: ['./admin-spec-def-list.component.scss']
})
export class AdminSpecDefListComponent implements OnInit, AfterViewInit {
  displayedColumns: string[] = ['id', 'name', 'unit', 'actions'];
  dataSource: MatTableDataSource<SpecificationDefinition> = new MatTableDataSource();
  isLoading = true;
  error: string | null = null;

  @ViewChild(MatPaginator) paginator!: MatPaginator;
  @ViewChild(MatSort) sort!: MatSort;

  private specAdminService = inject(SpecificationAdminService);
  private snackBar = inject(MatSnackBar);
  // private dialog = inject(MatDialog); // Decomentează dacă folosești MatDialog

  ngOnInit(): void {
    this.loadSpecDefinitions();
  }

  ngAfterViewInit(): void {
    this.dataSource.paginator = this.paginator;
    this.dataSource.sort = this.sort;
  }

  loadSpecDefinitions(): void {
    this.isLoading = true;
    this.error = null;
    this.specAdminService.getAllDefinitions().subscribe({
      next: (data) => {
        this.dataSource.data = data;
        this.isLoading = false;
      },
      error: (err) => {
        this.error = 'Nu s-au putut încărca definițiile specificațiilor.';
        console.error(err);
        this.isLoading = false;
        this.snackBar.open(this.error, 'Închide', { duration: 5000 });
      }
    });
  }

  applyFilter(event: Event): void {
    const filterValue = (event.target as HTMLInputElement).value;
    this.dataSource.filter = filterValue.trim().toLowerCase();
    if (this.dataSource.paginator) {
      this.dataSource.paginator.firstPage();
    }
  }

  deleteSpecDefinition(specDefId: number): void {
    // TODO: Implementează un dialog de confirmare (MatDialog)
    const confirmation = window.confirm('Sunteți sigur că doriți să ștergeți această definiție de specificație? Aceasta ar putea afecta produsele existente.');
    if (confirmation) {
      this.specAdminService.deleteDefinition(specDefId).subscribe({
        next: () => {
          this.snackBar.open('Definiție specificație ștearsă cu succes!', 'OK', { duration: 3000 });
          this.loadSpecDefinitions(); // Reîncarcă lista
        },
        error: (err) => {
          const errMsg = err.error?.message || err.message || 'Eroare la ștergerea definiției specificației.';
          this.snackBar.open(errMsg, 'Închide', { duration: 5000 });
          console.error(err);
        }
      });
    }
  }
}
</file>

<file path="frontend/src/app/features/admin/admin-users/admin-user-form/admin-user-form.component.html">
<!-- src/app/features/admin/admin-users/admin-user-form/admin-user-form.component.html -->
<div class="admin-user-form-container">
  <mat-card>
    <mat-card-header>
      <mat-card-title>{{ pageTitle }}</mat-card-title>
      <!-- Corectat: userToEdit.username deoarece *ngIf="userToEdit" este prezent -->
      <mat-card-subtitle *ngIf="userToEdit">Modifici datele pentru: {{ userToEdit.username }}</mat-card-subtitle>
    </mat-card-header>
    <mat-card-content>
      <div *ngIf="isLoading && userId" class="spinner-container">
        <mat-progress-spinner diameter="50" mode="indeterminate"></mat-progress-spinner>
        <p>Se încarcă datele utilizatorului...</p>
      </div>

      <form [formGroup]="userForm" (ngSubmit)="onSubmit()" *ngIf="!isLoading || !userId">
        <mat-form-field appearance="outline" class="full-width">
          <mat-label>Username</mat-label>
          <input matInput formControlName="username" readonly>
          <mat-icon matSuffix>person_outline</mat-icon>
          <mat-hint>Username-ul nu poate fi modificat.</mat-hint>
        </mat-form-field>

        <mat-form-field appearance="outline" class="full-width">
          <mat-label>Adresă Email</mat-label>
          <input matInput type="email" formControlName="email" required>
          <mat-icon matSuffix>email</mat-icon>
          <mat-error *ngIf="userForm.get('email')?.hasError('required')">Email-ul este obligatoriu.</mat-error>
          <mat-error *ngIf="userForm.get('email')?.hasError('email')">Format email invalid.</mat-error>
          <mat-error *ngIf="userForm.get('email')?.hasError('maxlength')">Email-ul nu poate depăși 100 de caractere.</mat-error>
        </mat-form-field>

        <mat-form-field appearance="outline" class="full-width">
          <mat-label>Roluri Utilizator</mat-label>
          <mat-select formControlName="selectedRoles" multiple>
            <mat-option *ngFor="let role of availableRoles" [value]="role">
              {{ role.replace('ROLE_', '') }}
            </mat-option>
          </mat-select>
          <mat-error *ngIf="userForm.get('selectedRoles')?.hasError('required') && (userForm.get('selectedRoles')?.touched || userForm.get('selectedRoles')?.dirty)">
            Cel puțin un rol trebuie selectat.
          </mat-error>
           <mat-hint *ngIf="userId === currentUserId">Atenție: Nu vă puteți elimina propriul rol de Administrator.</mat-hint>
        </mat-form-field>

        <div class="form-actions">
          <button mat-stroked-button color="warn" type="button" routerLink="/admin/users" [disabled]="isLoading">
            <mat-icon>cancel</mat-icon> Anulează
          </button>
          <button mat-raised-button color="primary" type="submit" [disabled]="isLoading || userForm.invalid">
            <mat-icon *ngIf="!isLoading">save</mat-icon>
            <mat-progress-spinner *ngIf="isLoading" diameter="20" mode="indeterminate" style="margin-right: 8px; display: inline-block;"></mat-progress-spinner>
            {{ isLoading ? 'Se actualizează...' : submitButtonText }}
          </button>
        </div>
      </form>
    </mat-card-content>
  </mat-card>
</div>
</file>

<file path="frontend/src/app/features/admin/admin-users/admin-user-list/admin-user-list.component.html">
<div class="admin-user-list-container">
  <div class="header">
    <h2>Administrare Utilizatori</h2>
    <!-- <button mat-raised-button color="primary" routerLink="/admin/users/new">
      <mat-icon>person_add</mat-icon> Adaugă Utilizator Nou
    </button> -->
  </div>

  <mat-form-field appearance="outline" class="filter-field">
    <mat-label>Filtrează utilizatori</mat-label>
    <input matInput (keyup)="applyFilter($event)" placeholder="Caută după username, email...">
    <mat-icon matSuffix>search</mat-icon>
  </mat-form-field>

  <div *ngIf="isLoading" class="loading-indicator">
    <mat-spinner diameter="50"></mat-spinner>
    <p>Se încarcă utilizatorii...</p>
  </div>

  <div *ngIf="error && !isLoading" class="error-message">
    <p>{{ error }}</p>
    <button mat-stroked-button color="warn" (click)="loadUsers()">Reîncearcă</button>
  </div>

  <div *ngIf="!isLoading && !error && dataSource.data.length === 0" class="no-data">
    <p>Nu există utilizatori înregistrați sau care să corespundă filtrului.</p>
  </div>

  <div class="table-container" *ngIf="!isLoading && !error && dataSource.data.length > 0">
    <table mat-table [dataSource]="dataSource" matSort class="mat-elevation-z8">

      <ng-container matColumnDef="id">
        <th mat-header-cell *matHeaderCellDef mat-sort-header> ID </th>
        <td mat-cell *matCellDef="let user"> {{user.id}} </td>
      </ng-container>

      <ng-container matColumnDef="username">
        <th mat-header-cell *matHeaderCellDef mat-sort-header> Username </th>
        <td mat-cell *matCellDef="let user"> {{user.username}} </td>
      </ng-container>

      <ng-container matColumnDef="email">
        <th mat-header-cell *matHeaderCellDef mat-sort-header> Email </th>
        <td mat-cell *matCellDef="let user"> {{user.email}} </td>
      </ng-container>

      <ng-container matColumnDef="roles">
        <th mat-header-cell *matHeaderCellDef mat-sort-header> Roluri </th>
        <td mat-cell *matCellDef="let user">
          <mat-chip-set aria-label="Roluri utilizator">
            <mat-chip *ngFor="let role of user.roles" [color]="role === 'ROLE_ADMIN' ? 'accent' : 'primary'" selected>
              {{ role.replace('ROLE_', '') }}
            </mat-chip>
          </mat-chip-set>
        </td>
      </ng-container>

      <ng-container matColumnDef="actions">
        <th mat-header-cell *matHeaderCellDef> Acțiuni </th>
        <td mat-cell *matCellDef="let user">
          <button mat-icon-button color="primary" [routerLink]="['/admin/users/edit', user.id]" aria-label="Editează utilizatorul">
            <mat-icon>edit</mat-icon>
          </button>
          <button mat-icon-button color="warn" (click)="deleteUser(user.id!, user.username)" [disabled]="user.id === currentUserId" aria-label="Șterge utilizatorul">
            <mat-icon>delete</mat-icon>
          </button>
        </td>
      </ng-container>

      <tr mat-header-row *matHeaderRowDef="displayedColumns"></tr>
      <tr mat-row *matRowDef="let row; columns: displayedColumns;"></tr>

      <tr class="mat-row" *matNoDataRow>
        <td class="mat-cell" [attr.colspan]="displayedColumns.length">
          Nu s-au găsit utilizatori care să corespundă filtrului "{{dataSource.filter}}".
        </td>
      </tr>
    </table>
    <mat-paginator [pageSizeOptions]="[5, 10, 25, 50]" showFirstLastButtons aria-label="Selectează pagina de utilizatori"></mat-paginator>
  </div>
</div>
</file>

<file path="frontend/src/app/features/admin/admin-users/admin-user-list/admin-user-list.component.ts">
// src/app/features/admin/admin-users/admin-user-list/admin-user-list.component.ts
import { Component, OnInit, inject, ViewChild, AfterViewInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { RouterModule } from '@angular/router';
import { MatTableDataSource, MatTableModule } from '@angular/material/table';
import { MatPaginator, MatPaginatorModule } from '@angular/material/paginator';
import { MatSort, MatSortModule } from '@angular/material/sort';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar';
import { MatChipsModule } from '@angular/material/chips'; // Pentru afișarea rolurilor
import { MatDialog } from '@angular/material/dialog';
// import { ConfirmDialogComponent } from '../../../../shared/components/confirm-dialog/confirm-dialog.component';

import { User } from '../../../../shared/models/user.model';
import { UserAdminService } from '../../services/user-admin.service';
import { AuthService } from '../../../../auth/auth.service'; // Pentru a nu permite ștergerea userului curent

@Component({
  selector: 'app-admin-user-list',
  standalone: true,
  imports: [
    CommonModule,
    RouterModule,
    MatTableModule,
    MatPaginatorModule,
    MatSortModule,
    MatFormFieldModule,
    MatInputModule,
    MatButtonModule,
    MatIconModule,
    MatProgressSpinnerModule,
    MatSnackBarModule,
    MatChipsModule
  ],
  templateUrl: './admin-user-list.component.html',
  styleUrls: ['./admin-user-list.component.scss']
})
export class AdminUserListComponent implements OnInit, AfterViewInit {
  displayedColumns: string[] = ['id', 'username', 'email', 'roles', 'actions'];
  dataSource: MatTableDataSource<User> = new MatTableDataSource();
  isLoading = true;
  error: string | null = null;
  currentUserId: number | null = null;

  @ViewChild(MatPaginator) paginator!: MatPaginator;
  @ViewChild(MatSort) sort!: MatSort;

  private userAdminService = inject(UserAdminService);
  private snackBar = inject(MatSnackBar);
  private authService = inject(AuthService); // Injectează AuthService
  // private dialog = inject(MatDialog);

  ngOnInit(): void {
    this.loadUsers();
    // Obține ID-ul utilizatorului curent pentru a preveni auto-ștergerea
    const currentUser = this.authService.getCurrentUser(); // Presupunând că AuthService are această metodă
    if (currentUser && currentUser.id) {
        this.currentUserId = currentUser.id;
    }
  }

  ngAfterViewInit(): void {
    this.dataSource.paginator = this.paginator;
    this.dataSource.sort = this.sort;
    // Custom sort pentru roluri (array de string-uri)
    this.dataSource.sortingDataAccessor = (item, property) => {
      switch (property) {
        case 'roles': return item.roles.join(', ');
        default: return (item as any)[property];
      }
    };
  }

  loadUsers(): void {
    this.isLoading = true;
    this.error = null;
    this.userAdminService.getAllUsers().subscribe({
      next: (data) => {
        this.dataSource.data = data;
        this.isLoading = false;
      },
      error: (err) => {
        this.error = 'Nu s-au putut încărca utilizatorii.';
        console.error(err);
        this.isLoading = false;
        this.snackBar.open(this.error, 'Închide', { duration: 5000 });
      }
    });
  }

  applyFilter(event: Event): void {
    const filterValue = (event.target as HTMLInputElement).value;
    this.dataSource.filter = filterValue.trim().toLowerCase();
    if (this.dataSource.paginator) {
      this.dataSource.paginator.firstPage();
    }
  }

  deleteUser(userId: number, username: string): void {
    if (userId === this.currentUserId) {
      this.snackBar.open('Nu vă puteți șterge propriul cont de administrator.', 'OK', { duration: 5000 });
      return;
    }

    // TODO: Implementează un dialog de confirmare (MatDialog)
    const confirmation = window.confirm(`Sunteți sigur că doriți să ștergeți utilizatorul "${username}"?`);
    if (confirmation) {
      this.userAdminService.deleteUser(userId).subscribe({
        next: () => {
          this.snackBar.open(`Utilizatorul "${username}" a fost șters cu succes!`, 'OK', { duration: 3000 });
          this.loadUsers(); // Reîncarcă lista
        },
        error: (err) => {
          const errMsg = err.error?.message || err.message || `Eroare la ștergerea utilizatorului "${username}".`;
          this.snackBar.open(errMsg, 'Închide', { duration: 5000 });
          console.error(err);
        }
      });
    }
  }

  formatRoles(roles: string[]): string {
    return roles.map(role => role.replace('ROLE_', '')).join(', ');
  }
}
</file>

<file path="frontend/src/app/features/admin/reports/reports.component.html">
<div class="reports-container">
  <mat-card class="reports-header">
    <mat-card-header>
      <mat-card-title>
        <mat-icon>assessment</mat-icon>
        Generare Rapoarte
      </mat-card-title>
    </mat-card-header>
    <mat-card-content>
      <form [formGroup]="reportForm" class="report-form">
        <mat-form-field appearance="outline">
          <mat-label>Data început</mat-label>
          <input matInput [matDatepicker]="startPicker" formControlName="startDate">
          <mat-datepicker-toggle matIconSuffix [for]="startPicker"></mat-datepicker-toggle>
          <mat-datepicker #startPicker></mat-datepicker>
        </mat-form-field>

        <mat-form-field appearance="outline">
          <mat-label>Data sfârșit</mat-label>
          <input matInput [matDatepicker]="endPicker" formControlName="endDate">
          <mat-datepicker-toggle matIconSuffix [for]="endPicker"></mat-datepicker-toggle>
          <mat-datepicker #endPicker></mat-datepicker>
        </mat-form-field>

        <button mat-raised-button color="primary" (click)="generateReport()" [disabled]="isLoading">
          <mat-icon>play_arrow</mat-icon>
          Generează Raport
        </button>

        <div class="download-buttons" *ngIf="generalReport">
          <button mat-stroked-button color="warn" (click)="downloadReport('pdf')" [disabled]="isLoading">
            <mat-icon>picture_as_pdf</mat-icon>
            Descarcă PDF
          </button>
          <button mat-stroked-button color="accent" (click)="downloadReport('excel')" [disabled]="isLoading">
            <mat-icon>table_chart</mat-icon>
            Descarcă Excel
          </button>
        </div>
      </form>
    </mat-card-content>
  </mat-card>

  <div class="loading-container" *ngIf="isLoading">
    <mat-spinner></mat-spinner>
    <p>Se generează raportul...</p>
  </div>

  <div class="report-content" *ngIf="generalReport && !isLoading">
    <!-- Rezumat General -->
    <div class="summary-cards">
      <mat-card class="summary-card">
        <mat-card-content>
          <div class="summary-icon sales">
            <mat-icon>shopping_cart</mat-icon>
          </div>
          <div class="summary-info">
            <h3>Vânzări Totale</h3>
            <p class="summary-value">{{ generalReport.salesReport.totalSales }}</p>
            <p class="summary-label">comenzi</p>
          </div>
        </mat-card-content>
      </mat-card>

      <mat-card class="summary-card">
        <mat-card-content>
          <div class="summary-icon revenue">
            <mat-icon>attach_money</mat-icon>
          </div>
          <div class="summary-info">
            <h3>Venituri Totale</h3>
            <p class="summary-value">{{ generalReport.salesReport.totalRevenue | currency:'RON':'symbol':'1.2-2' }}</p>
            <p class="summary-label">în perioada selectată</p>
          </div>
        </mat-card-content>
      </mat-card>

      <mat-card class="summary-card">
        <mat-card-content>
          <div class="summary-icon stock">
            <mat-icon>inventory</mat-icon>
          </div>
          <div class="summary-info">
            <h3>Produse în Stoc</h3>
            <p class="summary-value">{{ generalReport.stockReport.totalProducts }}</p>
            <p class="summary-label">produse disponibile</p>
          </div>
        </mat-card-content>
      </mat-card>

      <mat-card class="summary-card">
        <mat-card-content>
          <div class="summary-icon users">
            <mat-icon>people</mat-icon>
          </div>
          <div class="summary-info">
            <h3>Utilizatori Activi</h3>
            <p class="summary-value">{{ generalReport.userReport.activeUsers }}</p>
            <p class="summary-label">din {{ generalReport.userReport.totalUsers }} total</p>
          </div>
        </mat-card-content>
      </mat-card>
    </div>

    <!-- Tabs pentru diferite secțiuni -->
    <mat-tab-group animationDuration="0ms" class="report-tabs">
      <!-- Tab Vânzări -->
      <mat-tab label="Vânzări">
        <div class="tab-content">
          <mat-card>
            <mat-card-header>
              <mat-card-title>Evoluție Vânzări</mat-card-title>
            </mat-card-header>
            <mat-card-content>
              <div class="chart-container">
                <canvas id="salesChart"></canvas>
              </div>
            </mat-card-content>
          </mat-card>

          <mat-card class="mt-3">
            <mat-card-header>
              <mat-card-title>Top Produse Vândute</mat-card-title>
            </mat-card-header>
            <mat-card-content>
              <table mat-table [dataSource]="generalReport.salesReport.topSellingProducts" class="full-width">
                <ng-container matColumnDef="productName">
                  <th mat-header-cell *matHeaderCellDef>Produs</th>
                  <td mat-cell *matCellDef="let product">{{ product.productName }}</td>
                </ng-container>

                <ng-container matColumnDef="category">
                  <th mat-header-cell *matHeaderCellDef>Categorie</th>
                  <td mat-cell *matCellDef="let product">{{ product.category }}</td>
                </ng-container>

                <ng-container matColumnDef="quantitySold">
                  <th mat-header-cell *matHeaderCellDef>Cantitate Vândută</th>
                  <td mat-cell *matCellDef="let product">{{ product.quantitySold }}</td>
                </ng-container>

                <ng-container matColumnDef="revenue">
                  <th mat-header-cell *matHeaderCellDef>Venituri</th>
                  <td mat-cell *matCellDef="let product">{{ product.revenue | currency:'RON' }}</td>
                </ng-container>

                <ng-container matColumnDef="currentStock">
                  <th mat-header-cell *matHeaderCellDef>Stoc Curent</th>
                  <td mat-cell *matCellDef="let product">
                    <mat-chip [color]="getStockStatusColor(product.currentStock)">
                      {{ product.currentStock }}
                    </mat-chip>
                  </td>
                </ng-container>

                <tr mat-header-row *matHeaderRowDef="displayedProductColumns"></tr>
                <tr mat-row *matRowDef="let row; columns: displayedProductColumns;"></tr>
              </table>
            </mat-card-content>
          </mat-card>
        </div>
      </mat-tab>

      <!-- Tab Stoc -->
      <mat-tab label="Stoc">
        <div class="tab-content">
          <div class="stock-overview">
            <mat-card>
              <mat-card-header>
                <mat-card-title>Distribuție Stoc pe Categorii</mat-card-title>
              </mat-card-header>
              <mat-card-content>
                <div class="chart-container">
                  <canvas id="stockChart"></canvas>
                </div>
              </mat-card-content>
            </mat-card>

            <mat-card>
              <mat-card-header>
                <mat-card-title>Rezumat Stoc</mat-card-title>
              </mat-card-header>
              <mat-card-content>
                <div class="stock-stats">
                  <div class="stat-item">
                    <mat-icon color="warn">warning</mat-icon>
                    <div>
                      <p class="stat-value">{{ generalReport.stockReport.outOfStockProducts.length }}</p>
                      <p class="stat-label">Produse Epuizate</p>
                    </div>
                  </div>
                  <div class="stat-item">
                    <mat-icon color="accent">info</mat-icon>
                    <div>
                      <p class="stat-value">{{ generalReport.stockReport.lowStockProducts.length }}</p>
                      <p class="stat-label">Stoc Redus</p>
                    </div>
                  </div>
                  <div class="stat-item">
                    <mat-icon color="primary">attach_money</mat-icon>
                    <div>
                      <p class="stat-value">{{ generalReport.stockReport.totalStockValue | currency:'RON' }}</p>
                      <p class="stat-label">Valoare Totală Stoc</p>
                    </div>
                  </div>
                </div>
              </mat-card-content>
            </mat-card>
          </div>

          <mat-card class="mt-3" *ngIf="generalReport.stockReport.lowStockProducts.length > 0">
            <mat-card-header>
              <mat-card-title>Produse cu Stoc Redus</mat-card-title>
            </mat-card-header>
            <mat-card-content>
              <table mat-table [dataSource]="generalReport.stockReport.lowStockProducts" class="full-width">
                <ng-container matColumnDef="productName">
                  <th mat-header-cell *matHeaderCellDef>Produs</th>
                  <td mat-cell *matCellDef="let product">{{ product.productName }}</td>
                </ng-container>

                <ng-container matColumnDef="category">
                  <th mat-header-cell *matHeaderCellDef>Categorie</th>
                  <td mat-cell *matCellDef="let product">{{ product.category }}</td>
                </ng-container>

                <ng-container matColumnDef="currentStock">
                  <th mat-header-cell *matHeaderCellDef>Stoc Curent</th>
                  <td mat-cell *matCellDef="let product">
                    <mat-chip color="accent">{{ product.currentStock }}</mat-chip>
                  </td>
                </ng-container>

                <ng-container matColumnDef="stockValue">
                  <th mat-header-cell *matHeaderCellDef>Valoare Stoc</th>
                  <td mat-cell *matCellDef="let product">{{ product.stockValue | currency:'RON' }}</td>
                </ng-container>

                <tr mat-header-row *matHeaderRowDef="displayedStockColumns"></tr>
                <tr mat-row *matRowDef="let row; columns: displayedStockColumns;"></tr>
              </table>
            </mat-card-content>
          </mat-card>
        </div>
      </mat-tab>

      <!-- Tab Utilizatori -->
      <mat-tab label="Utilizatori">
        <div class="tab-content">
          <div class="user-stats">
            <mat-card>
              <mat-card-header>
                <mat-card-title>Statistici Utilizatori</mat-card-title>
              </mat-card-header>
              <mat-card-content>
                <div class="user-metrics">
                  <div class="metric">
                    <h4>Total Utilizatori</h4>
                    <p class="metric-value">{{ generalReport.userReport.totalUsers }}</p>
                  </div>
                  <div class="metric">
                    <h4>Utilizatori Activi</h4>
                    <p class="metric-value">{{ generalReport.userReport.activeUsers }}</p>
                  </div>
                  <div class="metric">
                    <h4>Înregistrări Luna Aceasta</h4>
                    <p class="metric-value">{{ generalReport.userReport.newUsersThisMonth }}</p>
                  </div>
                </div>

                <mat-divider class="my-3"></mat-divider>

                <h4>Distribuție pe Roluri</h4>
                <div class="role-distribution">
                  <div *ngFor="let role of generalReport.userReport.usersByRole" class="role-item">
                    <mat-chip [color]="role.role === 'ADMIN' ? 'warn' : 'primary'">
                      {{ role.role === 'ROLE_ADMIN' ? 'Administrator' : 'Utilizator' }}
                    </mat-chip>
                    <span class="role-count">{{ role.count }} utilizatori</span>
                  </div>
                </div>
              </mat-card-content>
            </mat-card>

            <mat-card class="mt-3">
              <mat-card-header>
                <mat-card-title>Înregistrări Recente</mat-card-title>
              </mat-card-header>
              <mat-card-content>
                <table mat-table [dataSource]="generalReport.userReport.recentRegistrations" class="full-width">
                  <ng-container matColumnDef="username">
                    <th mat-header-cell *matHeaderCellDef>Utilizator</th>
                    <td mat-cell *matCellDef="let user">{{ user.username }}</td>
                  </ng-container>

                  <ng-container matColumnDef="email">
                    <th mat-header-cell *matHeaderCellDef>Email</th>
                    <td mat-cell *matCellDef="let user">{{ user.email }}</td>
                  </ng-container>

                  <ng-container matColumnDef="registrationDate">
                    <th mat-header-cell *matHeaderCellDef>Data Înregistrării</th>
                    <td mat-cell *matCellDef="let user">{{ user.registrationDate | date:'dd/MM/yyyy' }}</td>
                  </ng-container>

                  <ng-container matColumnDef="isActive">
                    <th mat-header-cell *matHeaderCellDef>Status</th>
                    <td mat-cell *matCellDef="let user">
                      <mat-chip [color]="user.isActive ? 'primary' : 'warn'">
                        {{ user.isActive ? 'Activ' : 'Inactiv' }}
                      </mat-chip>
                    </td>
                  </ng-container>

                  <tr mat-header-row *matHeaderRowDef="displayedUserColumns"></tr>
                  <tr mat-row *matRowDef="let row; columns: displayedUserColumns;"></tr>
                </table>
              </mat-card-content>
            </mat-card>
          </div>
        </div>
      </mat-tab>
    </mat-tab-group>
  </div>
</div>
</file>

<file path="frontend/src/app/features/admin/reports/reports.component.ts">
import { Component, OnInit, inject } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ReactiveFormsModule, FormBuilder, FormGroup, Validators } from '@angular/forms';
import { MatCardModule } from '@angular/material/card';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatDatepickerModule } from '@angular/material/datepicker';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { MatSelectModule } from '@angular/material/select';
import { MatTabsModule } from '@angular/material/tabs';
import { MatTableModule } from '@angular/material/table';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar';
import { MatNativeDateModule } from '@angular/material/core';
import { MatDividerModule } from '@angular/material/divider';
import { MatChipsModule } from '@angular/material/chips';

import { ReportService } from '../../admin/services/report.service';
import { GeneralReport } from '../../../shared/models/report.model';
import { Chart, registerables } from 'chart.js';

Chart.register(...registerables);

@Component({
  selector: 'app-reports',
  standalone: true,
  imports: [
    CommonModule,
    ReactiveFormsModule,
    MatCardModule,
    MatButtonModule,
    MatIconModule,
    MatDatepickerModule,
    MatNativeDateModule,
    MatFormFieldModule,
    MatInputModule,
    MatSelectModule,
    MatTabsModule,
    MatTableModule,
    MatProgressSpinnerModule,
    MatSnackBarModule,
    MatDividerModule,
    MatChipsModule
  ],
  templateUrl: './reports.component.html',
  styleUrls: ['./reports.component.scss']
})
export class ReportsComponent implements OnInit {
  reportForm!: FormGroup;
  generalReport: GeneralReport | null = null;
  isLoading = false;
  
  // Variabile pentru grafice
  salesChart: Chart | null = null;
  stockChart: Chart | null = null;
  
  // Configurări pentru tabel
  displayedProductColumns = ['productName', 'category', 'quantitySold', 'revenue', 'currentStock'];
  displayedStockColumns = ['productName', 'category', 'currentStock', 'stockValue'];
  displayedUserColumns = ['username', 'email', 'registrationDate', 'isActive'];

  private fb = inject(FormBuilder);
  private reportService = inject(ReportService);
  private snackBar = inject(MatSnackBar);

  ngOnInit(): void {
    const today = new Date();
    const lastMonth = new Date(today.getFullYear(), today.getMonth() - 1, today.getDate());

    this.reportForm = this.fb.group({
      startDate: [lastMonth, Validators.required],
      endDate: [today, Validators.required],
      reportType: ['general', Validators.required]
    });
  }

  generateReport(): void {
    if (this.reportForm.invalid) {
      this.snackBar.open('Selectați perioada pentru raport', 'OK', { duration: 3000 });
      return;
    }

    this.isLoading = true;
    const { startDate, endDate } = this.reportForm.value;

    this.reportService.generateGeneralReport(startDate, endDate).subscribe({
      next: (report) => {
        this.generalReport = report;
        this.isLoading = false;
        this.snackBar.open('Raport generat cu succes!', 'OK', { duration: 3000 });
        
        // Actualizează graficele după primirea datelor
        setTimeout(() => {
          this.updateCharts();
        }, 100);
      },
      error: (err) => {
        this.isLoading = false;
        this.snackBar.open('Eroare la generarea raportului', 'Închide', { duration: 5000 });
        console.error('Report generation error:', err);
      }
    });
  }

  updateCharts(): void {
    if (!this.generalReport) return;

    // Grafic vânzări
    this.createSalesChart();
    
    // Grafic stoc pe categorii
    this.createStockChart();
  }

  createSalesChart(): void {
    const canvas = document.getElementById('salesChart') as HTMLCanvasElement;
    if (!canvas || !this.generalReport) return;

    if (this.salesChart) {
      this.salesChart.destroy();
    }

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    const salesData = this.generalReport.salesReport.dailySales;
    
    this.salesChart = new Chart(ctx, {
      type: 'line',
      data: {
        labels: salesData.map(d => new Date(d.date).toLocaleDateString('ro-RO')),
        datasets: [{
          label: 'Vânzări zilnice (RON)',
          data: salesData.map(d => d.revenue),
          borderColor: '#448AFF',
          backgroundColor: 'rgba(68, 138, 255, 0.1)',
          tension: 0.4
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: {
            display: true,
            labels: {
              color: '#ccc'
            }
          }
        },
        scales: {
          x: {
            grid: {
              color: '#333'
            },
            ticks: {
              color: '#ccc'
            }
          },
          y: {
            grid: {
              color: '#333'
            },
            ticks: {
              color: '#ccc',
              callback: function(value) {
                return value + ' RON';
              }
            }
          }
        }
      }
    });
  }

  createStockChart(): void {
    const canvas = document.getElementById('stockChart') as HTMLCanvasElement;
    if (!canvas || !this.generalReport) return;

    if (this.stockChart) {
      this.stockChart.destroy();
    }

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    const stockData = this.generalReport.stockReport.categoryStock;
    
    this.stockChart = new Chart(ctx, {
      type: 'doughnut',
      data: {
        labels: stockData.map(c => c.category),
        datasets: [{
          data: stockData.map(c => c.totalStock),
          backgroundColor: [
            '#448AFF',
            '#FF6B6B',
            '#4ECDC4',
            '#45B7D1',
            '#F7DC6F',
            '#BB8FCE'
          ]
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: {
            position: 'right',
            labels: {
              color: '#ccc'
            }
          }
        }
      }
    });
  }

  downloadReport(format: 'pdf' | 'excel'): void {
    if (!this.reportForm.valid) {
      this.snackBar.open('Selectați perioada pentru raport', 'OK', { duration: 3000 });
      return;
    }

    this.isLoading = true;
    const { startDate, endDate } = this.reportForm.value;

    this.reportService.downloadReport(format, startDate, endDate).subscribe({
      next: (blob) => {
        const url = window.URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `raport_${new Date().toISOString().split('T')[0]}.${format}`;
        link.click();
        window.URL.revokeObjectURL(url);
        this.isLoading = false;
        this.snackBar.open(`Raport ${format.toUpperCase()} descărcat!`, 'OK', { duration: 3000 });
      },
      error: (err) => {
        this.isLoading = false;
        this.snackBar.open('Eroare la descărcarea raportului', 'Închide', { duration: 5000 });
        console.error('Download error:', err);
      }
    });
  }

  getStockStatusColor(stock: number): string {
    if (stock === 0) return 'warn';
    if (stock < 10) return 'accent';
    return 'primary';
  }

  ngOnDestroy(): void {
    if (this.salesChart) {
      this.salesChart.destroy();
    }
    if (this.stockChart) {
      this.stockChart.destroy();
    }
  }
}
</file>

<file path="frontend/src/app/features/admin/services/category.admin.service.ts">
// src/app/features/admin/services/category.admin.service.ts
import { Injectable } from '@angular/core';
import { HttpClient, HttpErrorResponse } from '@angular/common/http';
import { Observable, throwError } from 'rxjs';
import { catchError } from 'rxjs/operators';
import { Category } from '../../../shared/models/category.model';


@Injectable({
  providedIn: 'root'
})
export class CategoryAdminService {
  private apiUrl = '/api/categories';

  constructor(private http: HttpClient) {}

  getAll(): Observable<Category[]> {
    return this.http.get<Category[]>(this.apiUrl)
      .pipe(catchError(this.handleError));
  }

  getById(id: number): Observable<Category> {
    return this.http.get<Category>(`${this.apiUrl}/${id}`)
      .pipe(catchError(this.handleError));
  }

  create(category: Category): Observable<Category> {
    return this.http.post<Category>(this.apiUrl, category)
      .pipe(catchError(this.handleError));
  }

  update(id: number, category: Category): Observable<Category> {
    return this.http.put<Category>(`${this.apiUrl}/${id}`, category)
      .pipe(catchError(this.handleError));
  }

  delete(id: number): Observable<void> {
    return this.http.delete<void>(`${this.apiUrl}/${id}`)
      .pipe(catchError(this.handleError));
  }

  private handleError(error: HttpErrorResponse) {
  let userFriendlyErrorMessage = 'A apărut o problemă. Vă rugăm încercați din nou mai târziu.';
  let detailedErrorMessage = 'Eroare necunoscută.';

  // Verificăm mai întâi dacă 'error.error' există și este un obiect (răspuns JSON de la server)
  if (error.error && typeof error.error === 'object' && error.error !== null) {
    // Încercăm să extragem un mesaj specific din corpul erorii trimis de backend
    // Acesta ar putea fi error.error.message, error.error.error, error.error.detail etc.
    // Ajustează în funcție de structura răspunsurilor de eroare de la API-ul tău Spring Boot
    detailedErrorMessage = 
        (error.error as any).message ||         // Cel mai comun (ex: MessageResponse din Spring)
        (error.error as any).detail ||          // Alt câmp comun pentru detalii eroare
        (error.error as any).error?.message ||  // Uneori eroarea e imbricată
        JSON.stringify(error.error);            // Fallback la JSON string dacă e un obiect complex

    // Poți încerca să faci mesajul user-friendly mai specific dacă backend-ul trimite un mesaj clar
    if ((error.error as any).message && typeof (error.error as any).message === 'string') {
      userFriendlyErrorMessage = (error.error as any).message;
    }
  } else if (typeof error.error === 'string') {
    // Corpul erorii de la server este un simplu string
    detailedErrorMessage = error.error;
    userFriendlyErrorMessage = error.error; 
  } else if (error.message) {
    // Eroare client-side sau de rețea (ex: HttpErrorResponse fără error.error, dar cu error.message)
    detailedErrorMessage = error.message;
    if (error.status === 0 || error.status === -1) { // Tipic pentru erori de rețea, CORS, sau server oprit
        userFriendlyErrorMessage = 'Eroare de conexiune cu serverul. Verificați rețeaua sau dacă serverul backend rulează.';
    } else {
        userFriendlyErrorMessage = `A apărut o eroare (${error.status}): ${error.statusText}`;
    }
  } else {
    // Fallback dacă structura erorii nu este cea așteptată
    detailedErrorMessage = `Cod eroare server: ${error.status}, status text: ${error.statusText || 'Necunoscut'}`;
    userFriendlyErrorMessage = `A apărut o eroare (${error.status}). Vă rugăm încercați mai târziu.`;
  }

  console.error('------------------------------------');
  console.error(`[SERVICE ERROR ENCOUNTERED]`);
  console.error(`URL: ${error.url}`);
  console.error(`Status: ${error.status} - ${error.statusText}`);
  console.error(`User-Friendly Message: ${userFriendlyErrorMessage}`);
  console.error(`Detailed Error Message/Body: ${detailedErrorMessage}`);
  console.error('Full HttpErrorResponse Object:', error);
  console.error('------------------------------------');

  // Aruncă o eroare care va fi propagată și poate fi prinsă în componentă
  // sau de un error handler global, dacă există.
  // Pentru utilizator, mesajele sunt de obicei afișate prin MatSnackBar în componentă/serviciu.
  return throwError(() => new Error(userFriendlyErrorMessage));
}
}
</file>

<file path="frontend/src/app/features/admin/services/order.admin.service.ts">
// src/app/features/admin/services/order.admin.service.ts
import { Injectable, inject } from '@angular/core';
import { HttpClient, HttpErrorResponse, HttpParams } from '@angular/common/http';
import { Observable, throwError } from 'rxjs';
import { catchError } from 'rxjs/operators';
import { Order } from '../../../shared/models/order.model';
import { OrderStatusUpdate } from '../../../shared/models/order-status-update.model'; // <<< CORECTAT

@Injectable({
  providedIn: 'root'
})
export class OrderAdminService {
  private apiUrl = '/api/orders';

  private http = inject(HttpClient);

  getAllOrders(statusFilter?: string): Observable<Order[]> {
    let params = new HttpParams();
    if (statusFilter && statusFilter.trim() !== '') {
      params = params.set('status', statusFilter);
    }
    return this.http.get<Order[]>(this.apiUrl, { params })
      .pipe(catchError(this.handleError));
  }

  getOrderById(orderId: number): Observable<Order> {
    return this.http.get<Order>(`${this.apiUrl}/${orderId}`)
      .pipe(catchError(this.handleError));
  }

  updateOrderStatus(orderId: number, statusUpdate: OrderStatusUpdate): Observable<Order> {
    return this.http.put<Order>(`${this.apiUrl}/${orderId}/status`, statusUpdate)
      .pipe(catchError(this.handleError));
  }

private handleError(error: HttpErrorResponse) {
  let userFriendlyErrorMessage = 'A apărut o problemă. Vă rugăm încercați din nou mai târziu.';
  let detailedErrorMessage = 'Eroare necunoscută.';

  // Verificăm mai întâi dacă 'error.error' există și este un obiect (răspuns JSON de la server)
  if (error.error && typeof error.error === 'object' && error.error !== null) {
    // Încercăm să extragem un mesaj specific din corpul erorii trimis de backend
    // Acesta ar putea fi error.error.message, error.error.error, error.error.detail etc.
    // Ajustează în funcție de structura răspunsurilor de eroare de la API-ul tău Spring Boot
    detailedErrorMessage = 
        (error.error as any).message ||         // Cel mai comun (ex: MessageResponse din Spring)
        (error.error as any).detail ||          // Alt câmp comun pentru detalii eroare
        (error.error as any).error?.message ||  // Uneori eroarea e imbricată
        JSON.stringify(error.error);            // Fallback la JSON string dacă e un obiect complex

    // Poți încerca să faci mesajul user-friendly mai specific dacă backend-ul trimite un mesaj clar
    if ((error.error as any).message && typeof (error.error as any).message === 'string') {
      userFriendlyErrorMessage = (error.error as any).message;
    }
  } else if (typeof error.error === 'string') {
    // Corpul erorii de la server este un simplu string
    detailedErrorMessage = error.error;
    userFriendlyErrorMessage = error.error; 
  } else if (error.message) {
    // Eroare client-side sau de rețea (ex: HttpErrorResponse fără error.error, dar cu error.message)
    detailedErrorMessage = error.message;
    if (error.status === 0 || error.status === -1) { // Tipic pentru erori de rețea, CORS, sau server oprit
        userFriendlyErrorMessage = 'Eroare de conexiune cu serverul. Verificați rețeaua sau dacă serverul backend rulează.';
    } else {
        userFriendlyErrorMessage = `A apărut o eroare (${error.status}): ${error.statusText}`;
    }
  } else {
    // Fallback dacă structura erorii nu este cea așteptată
    detailedErrorMessage = `Cod eroare server: ${error.status}, status text: ${error.statusText || 'Necunoscut'}`;
    userFriendlyErrorMessage = `A apărut o eroare (${error.status}). Vă rugăm încercați mai târziu.`;
  }

  console.error('------------------------------------');
  console.error(`[SERVICE ERROR ENCOUNTERED]`);
  console.error(`URL: ${error.url}`);
  console.error(`Status: ${error.status} - ${error.statusText}`);
  console.error(`User-Friendly Message: ${userFriendlyErrorMessage}`);
  console.error(`Detailed Error Message/Body: ${detailedErrorMessage}`);
  console.error('Full HttpErrorResponse Object:', error);
  console.error('------------------------------------');

  // Aruncă o eroare care va fi propagată și poate fi prinsă în componentă
  // sau de un error handler global, dacă există.
  // Pentru utilizator, mesajele sunt de obicei afișate prin MatSnackBar în componentă/serviciu.
  return throwError(() => new Error(userFriendlyErrorMessage));
}
}
</file>

<file path="frontend/src/app/features/admin/services/report.service.ts">
import { Injectable, inject } from '@angular/core';
import { HttpClient, HttpParams, HttpErrorResponse } from '@angular/common/http';
import { Observable, throwError } from 'rxjs';
import { catchError } from 'rxjs/operators';
import { GeneralReport, SalesReport, StockReport, UserReport } from '../../../shared/models/report.model';

@Injectable({
  providedIn: 'root'
})
export class ReportService {
  private apiUrl = '/api/admin/reports';
  private http = inject(HttpClient);

  generateGeneralReport(startDate: Date, endDate: Date): Observable<GeneralReport> {
    const params = new HttpParams()
      .set('startDate', this.formatDate(startDate))
      .set('endDate', this.formatDate(endDate));
    
    return this.http.get<GeneralReport>(`${this.apiUrl}/general`, { params })
      .pipe(catchError(this.handleError));
  }

  getSalesReport(startDate: Date, endDate: Date): Observable<SalesReport> {
    const params = new HttpParams()
      .set('startDate', this.formatDate(startDate))
      .set('endDate', this.formatDate(endDate));
    
    return this.http.get<SalesReport>(`${this.apiUrl}/sales`, { params })
      .pipe(catchError(this.handleError));
  }

  getStockReport(): Observable<StockReport> {
    return this.http.get<StockReport>(`${this.apiUrl}/stock`)
      .pipe(catchError(this.handleError));
  }

  getUserReport(): Observable<UserReport> {
    return this.http.get<UserReport>(`${this.apiUrl}/users`)
      .pipe(catchError(this.handleError));
  }

  downloadReport(reportType: 'pdf' | 'excel', startDate: Date, endDate: Date): Observable<Blob> {
    const params = new HttpParams()
      .set('startDate', this.formatDate(startDate))
      .set('endDate', this.formatDate(endDate))
      .set('format', reportType);
    
    return this.http.get(`${this.apiUrl}/download`, { 
      params, 
      responseType: 'blob' 
    }).pipe(catchError(this.handleError));
  }

  private formatDate(date: Date): string {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
  }

  private handleError(error: HttpErrorResponse) {
    let errorMessage = 'A apărut o eroare la generarea raportului.';
    if (error.error instanceof ErrorEvent) {
      errorMessage = `Eroare: ${error.error.message}`;
    } else {
      errorMessage = error.error?.message || `Cod eroare: ${error.status}`;
    }
    console.error('Report service error:', error);
    return throwError(() => new Error(errorMessage));
  }
}
</file>

<file path="frontend/src/app/features/admin/services/specification-admin.service.ts">
// src/app/features/admin/services/specification-admin.service.ts
import { Injectable, inject } from '@angular/core';
import { HttpClient, HttpErrorResponse } from '@angular/common/http';
import { Observable, throwError } from 'rxjs';
import { catchError } from 'rxjs/operators';
import { SpecificationDefinition } from '../../../shared/models/specification-definition.model';

@Injectable({
  providedIn: 'root'
})
export class SpecificationAdminService {
  private apiUrl = '/api/specifications/definitions';

  private http = inject(HttpClient);

  getAllDefinitions(): Observable<SpecificationDefinition[]> {
    return this.http.get<SpecificationDefinition[]>(this.apiUrl)
      .pipe(catchError(this.handleError));
  }

  getDefinitionById(id: number): Observable<SpecificationDefinition> {
    return this.http.get<SpecificationDefinition>(`${this.apiUrl}/${id}`)
      .pipe(catchError(this.handleError));
  }

  createDefinition(definition: Omit<SpecificationDefinition, 'id'>): Observable<SpecificationDefinition> {
    return this.http.post<SpecificationDefinition>(this.apiUrl, definition)
      .pipe(catchError(this.handleError));
  }

  updateDefinition(id: number, definition: SpecificationDefinition): Observable<SpecificationDefinition> {
    return this.http.put<SpecificationDefinition>(`${this.apiUrl}/${id}`, definition)
      .pipe(catchError(this.handleError));
  }

  deleteDefinition(id: number): Observable<void> {
    return this.http.delete<void>(`${this.apiUrl}/${id}`)
      .pipe(catchError(this.handleError));
  }

private handleError(error: HttpErrorResponse) {
  let userFriendlyErrorMessage = 'A apărut o problemă. Vă rugăm încercați din nou mai târziu.';
  let detailedErrorMessage = 'Eroare necunoscută.';

  // Verificăm mai întâi dacă 'error.error' există și este un obiect (răspuns JSON de la server)
  if (error.error && typeof error.error === 'object' && error.error !== null) {
    // Încercăm să extragem un mesaj specific din corpul erorii trimis de backend
    // Acesta ar putea fi error.error.message, error.error.error, error.error.detail etc.
    // Ajustează în funcție de structura răspunsurilor de eroare de la API-ul tău Spring Boot
    detailedErrorMessage = 
        (error.error as any).message ||         // Cel mai comun (ex: MessageResponse din Spring)
        (error.error as any).detail ||          // Alt câmp comun pentru detalii eroare
        (error.error as any).error?.message ||  // Uneori eroarea e imbricată
        JSON.stringify(error.error);            // Fallback la JSON string dacă e un obiect complex

    // Poți încerca să faci mesajul user-friendly mai specific dacă backend-ul trimite un mesaj clar
    if ((error.error as any).message && typeof (error.error as any).message === 'string') {
      userFriendlyErrorMessage = (error.error as any).message;
    }
  } else if (typeof error.error === 'string') {
    // Corpul erorii de la server este un simplu string
    detailedErrorMessage = error.error;
    userFriendlyErrorMessage = error.error; 
  } else if (error.message) {
    // Eroare client-side sau de rețea (ex: HttpErrorResponse fără error.error, dar cu error.message)
    detailedErrorMessage = error.message;
    if (error.status === 0 || error.status === -1) { // Tipic pentru erori de rețea, CORS, sau server oprit
        userFriendlyErrorMessage = 'Eroare de conexiune cu serverul. Verificați rețeaua sau dacă serverul backend rulează.';
    } else {
        userFriendlyErrorMessage = `A apărut o eroare (${error.status}): ${error.statusText}`;
    }
  } else {
    // Fallback dacă structura erorii nu este cea așteptată
    detailedErrorMessage = `Cod eroare server: ${error.status}, status text: ${error.statusText || 'Necunoscut'}`;
    userFriendlyErrorMessage = `A apărut o eroare (${error.status}). Vă rugăm încercați mai târziu.`;
  }

  console.error('------------------------------------');
  console.error(`[SERVICE ERROR ENCOUNTERED]`);
  console.error(`URL: ${error.url}`);
  console.error(`Status: ${error.status} - ${error.statusText}`);
  console.error(`User-Friendly Message: ${userFriendlyErrorMessage}`);
  console.error(`Detailed Error Message/Body: ${detailedErrorMessage}`);
  console.error('Full HttpErrorResponse Object:', error);
  console.error('------------------------------------');

  // Aruncă o eroare care va fi propagată și poate fi prinsă în componentă
  // sau de un error handler global, dacă există.
  // Pentru utilizator, mesajele sunt de obicei afișate prin MatSnackBar în componentă/serviciu.
  return throwError(() => new Error(userFriendlyErrorMessage));
}
}
</file>

<file path="frontend/src/app/features/checkout/checkout.component.html">
<!-- frontend/src/app/features/checkout/checkout.component.html -->
<div class="checkout-container">
  <h1 class="page-title">Finalizare comandă</h1>

  <div *ngIf="isLoading" class="loading-indicator">
    <mat-spinner diameter="50"></mat-spinner>
    <p>Se încarcă...</p>
  </div>

  <div *ngIf="!isLoading && cart" class="checkout-content">
    <form [formGroup]="checkoutForm" (ngSubmit)="onSubmit()">
      <div class="checkout-grid">
        <!-- Left column - Form sections -->
        <div class="checkout-form">
          <!-- Contact Information -->
          <mat-card formGroupName="contactInfo">
            <mat-card-header>
              <mat-card-title>
                <mat-icon>person</mat-icon>
                Informații contact
              </mat-card-title>
              <mat-card-subtitle>Vă vom trimite confirmarea comenzii pe email</mat-card-subtitle>
            </mat-card-header>
            <mat-card-content>
              <mat-form-field appearance="outline" class="full-width">
                <mat-label>Nume complet</mat-label>
                <input matInput formControlName="fullName" placeholder="Ion Popescu">
                <mat-error>{{ getErrorMessage('contactInfo.fullName') }}</mat-error>
              </mat-form-field>

              <div class="form-row">
                <mat-form-field appearance="outline" class="half-width">
                  <mat-label>Email</mat-label>
                  <input matInput type="email" formControlName="email" placeholder="email@example.com">
                  <mat-error>{{ getErrorMessage('contactInfo.email') }}</mat-error>
                </mat-form-field>

                <mat-form-field appearance="outline" class="half-width">
                  <mat-label>Telefon</mat-label>
                  <input matInput formControlName="phone" placeholder="0712345678">
                  <mat-error>{{ getErrorMessage('contactInfo.phone') }}</mat-error>
                </mat-form-field>
              </div>
            </mat-card-content>
          </mat-card>

          <!-- Billing Address -->
          <mat-card formGroupName="billingAddress">
            <mat-card-header>
              <mat-card-title>
                <mat-icon>home</mat-icon>
                Adresă de facturare
              </mat-card-title>
            </mat-card-header>
            <mat-card-content>
              <mat-form-field appearance="outline" class="full-width">
                <mat-label>Adresă</mat-label>
                <textarea matInput formControlName="address" rows="2" 
                          placeholder="Str. Exemplu, Nr. 123, Bl. A, Sc. 1, Ap. 10"></textarea>
                <mat-error>{{ getErrorMessage('billingAddress.address') }}</mat-error>
              </mat-form-field>

              <div class="form-row">
                <mat-form-field appearance="outline" class="half-width">
                  <mat-label>Oraș</mat-label>
                  <input matInput formControlName="city" placeholder="București">
                  <mat-error>{{ getErrorMessage('billingAddress.city') }}</mat-error>
                </mat-form-field>

                <mat-form-field appearance="outline" class="half-width">
                  <mat-label>Cod poștal</mat-label>
                  <input matInput formControlName="postalCode" placeholder="123456">
                  <mat-error>{{ getErrorMessage('billingAddress.postalCode') }}</mat-error>
                </mat-form-field>
              </div>
            </mat-card-content>
          </mat-card>

          <!-- Shipping Address -->
          <mat-card formGroupName="shippingAddress">
            <mat-card-header>
              <mat-card-title>
                <mat-icon>local_shipping</mat-icon>
                Adresă de livrare
              </mat-card-title>
            </mat-card-header>
            <mat-card-content>
              <mat-checkbox formControlName="sameAsBilling">
                Aceeași cu adresa de facturare
              </mat-checkbox>

              <div *ngIf="differentShippingAddress" class="shipping-fields">
                <mat-form-field appearance="outline" class="full-width">
                  <mat-label>Adresă livrare</mat-label>
                  <textarea matInput formControlName="address" rows="2"></textarea>
                  <mat-error>{{ getErrorMessage('shippingAddress.address') }}</mat-error>
                </mat-form-field>

                <div class="form-row">
                  <mat-form-field appearance="outline" class="half-width">
                    <mat-label>Oraș</mat-label>
                    <input matInput formControlName="city">
                    <mat-error>{{ getErrorMessage('shippingAddress.city') }}</mat-error>
                  </mat-form-field>

                  <mat-form-field appearance="outline" class="half-width">
                    <mat-label>Cod poștal</mat-label>
                    <input matInput formControlName="postalCode">
                    <mat-error>{{ getErrorMessage('shippingAddress.postalCode') }}</mat-error>
                  </mat-form-field>
                </div>
              </div>
            </mat-card-content>
          </mat-card>

          <!-- Payment Method -->
          <mat-card formGroupName="payment">
            <mat-card-header>
              <mat-card-title>
                <mat-icon>payment</mat-icon>
                Metodă de plată
              </mat-card-title>
            </mat-card-header>
            <mat-card-content>
              <mat-radio-group formControlName="paymentMethod" class="payment-options">
                <mat-radio-button value="CASH_ON_DELIVERY">
                  <mat-icon>local_shipping</mat-icon>
                  Plata la livrare (Cash on Delivery)
                  <span class="payment-note">Plătești cash când primești comanda</span>
                </mat-radio-button>
                
                <mat-radio-button value="BANK_TRANSFER">
                  <mat-icon>account_balance</mat-icon>
                  Transfer bancar
                  <span class="payment-note">Vei primi detaliile după plasarea comenzii</span>
                </mat-radio-button>
                
                <mat-radio-button value="CARD" disabled>
                  <mat-icon>credit_card</mat-icon>
                  Card bancar (În curând)
                  <span class="payment-note">Opțiune disponibilă în curând</span>
                </mat-radio-button>
              </mat-radio-group>

              <mat-form-field appearance="outline" class="full-width notes-field">
                <mat-label>Note comandă (opțional)</mat-label>
                <textarea matInput formControlName="orderNotes" rows="3" 
                          placeholder="Adaugă orice informații suplimentare despre comandă..."></textarea>
              </mat-form-field>
            </mat-card-content>
          </mat-card>

          <!-- Terms and Conditions -->
          <mat-card class="terms-card">
            <mat-card-content>
              <mat-checkbox formControlName="agreeToTerms" required>
                Am citit și sunt de acord cu 
                <a href="/terms" target="_blank">Termenii și Condițiile</a> și 
                <a href="/privacy" target="_blank">Politica de Confidențialitate</a>
              </mat-checkbox>
            </mat-card-content>
          </mat-card>
        </div>

        <!-- Right column - Order Summary -->
        <div class="order-summary">
          <mat-card>
            <mat-card-header>
              <mat-card-title>Sumar comandă</mat-card-title>
            </mat-card-header>
            <mat-card-content>
              <div class="summary-items">
                <div *ngFor="let item of cart.items" class="summary-item">
                  <span class="item-name">{{ item.productName }} × {{ item.quantity }}</span>
                  <span class="item-price">{{ item.subtotal | currency:'RON':'symbol':'1.2-2' }}</span>
                </div>
              </div>
              
              <mat-divider></mat-divider>
              
              <div class="summary-totals">
                <div class="summary-row">
                  <span>Subtotal</span>
                  <span>{{ cart.totalAmount | currency:'RON':'symbol':'1.2-2' }}</span>
                </div>
                <div class="summary-row">
                  <span>Transport</span>
                  <span class="free-shipping">GRATUIT</span>
                </div>
                <div class="summary-row total">
                  <span>Total</span>
                  <span>{{ cart.totalAmount | currency:'RON':'symbol':'1.2-2' }}</span>
                </div>
              </div>
              
              <div class="secure-payment">
                <mat-icon>lock</mat-icon>
                <span>Plată securizată</span>
              </div>
            </mat-card-content>
            <mat-card-actions>
              <button mat-raised-button 
                      color="primary" 
                      type="submit" 
                      class="place-order-button"
                      [disabled]="isProcessing || checkoutForm.invalid">
                <mat-spinner *ngIf="isProcessing" diameter="20"></mat-spinner>
                <span *ngIf="!isProcessing">
                  <mat-icon>check_circle</mat-icon>
                  Plasează comanda
                </span>
              </button>
              
              <button mat-stroked-button 
                      type="button" 
                      routerLink="/cart"
                      [disabled]="isProcessing">
                <mat-icon>arrow_back</mat-icon>
                Înapoi la coș
              </button>
            </mat-card-actions>
          </mat-card>
        </div>
      </div>
    </form>
  </div>
</div>
</file>

<file path="frontend/src/app/features/checkout/checkout.component.ts">
// frontend/src/app/features/checkout/checkout.component.ts
import { Component, OnInit, inject } from '@angular/core';
import { CommonModule, CurrencyPipe } from '@angular/common';
import { Router, RouterModule } from '@angular/router';
import { ReactiveFormsModule, FormBuilder, FormGroup, Validators } from '@angular/forms';
import { MatCardModule } from '@angular/material/card';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { MatSelectModule } from '@angular/material/select';
import { MatCheckboxModule } from '@angular/material/checkbox';
import { MatDividerModule } from '@angular/material/divider';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar';
import { MatRadioModule } from '@angular/material/radio';
import { MatStepperModule } from '@angular/material/stepper';

import { Cart } from '../../shared/models/cart.model';
import { CartService } from '../shopping-cart/cart.service';
import { AuthService } from '../../auth/auth.service';

@Component({
  selector: 'app-checkout',
  standalone: true,
  imports: [
    CommonModule,
    RouterModule,
    ReactiveFormsModule,
    CurrencyPipe,
    MatCardModule,
    MatButtonModule,
    MatIconModule,
    MatFormFieldModule,
    MatInputModule,
    MatSelectModule,
    MatCheckboxModule,
    MatDividerModule,
    MatProgressSpinnerModule,
    MatSnackBarModule,
    MatRadioModule,
    MatStepperModule
  ],
  templateUrl: './checkout.component.html',
  styleUrls: ['./checkout.component.scss']
})
export class CheckoutComponent implements OnInit {
  checkoutForm!: FormGroup;
  cart: Cart | null = null;
  isLoading = true;
  isProcessing = false;
  differentShippingAddress = false;

  private fb = inject(FormBuilder);
  private cartService = inject(CartService);
  private authService = inject(AuthService);
  private router = inject(Router);
  private snackBar = inject(MatSnackBar);

  ngOnInit(): void {
    if (!this.authService.isLoggedIn()) {
      this.router.navigate(['/login'], { queryParams: { returnUrl: '/checkout' } });
      return;
    }

    this.initializeForm();
    this.loadCart();
    this.prefillUserData();
  }

  initializeForm(): void {
    this.checkoutForm = this.fb.group({
      contactInfo: this.fb.group({
        fullName: ['', [Validators.required, Validators.minLength(3)]],
        email: ['', [Validators.required, Validators.email]],
        phone: ['', [Validators.required, Validators.pattern('^[0-9]{10,15}$')]]
      }),
      billingAddress: this.fb.group({
        address: ['', [Validators.required, Validators.minLength(10)]],
        city: ['', Validators.required],
        postalCode: ['', [Validators.required, Validators.pattern('^[0-9]{6}$')]]
      }),
      shippingAddress: this.fb.group({
        sameAsBilling: [true],
        address: [''],
        city: [''],
        postalCode: ['']
      }),
      payment: this.fb.group({
        paymentMethod: ['CASH_ON_DELIVERY', Validators.required],
        orderNotes: ['']
      }),
      agreeToTerms: [false, Validators.requiredTrue]
    });

    // Watch for shipping address changes
    this.checkoutForm.get('shippingAddress.sameAsBilling')?.valueChanges.subscribe(same => {
      this.differentShippingAddress = !same;
      const shippingGroup = this.checkoutForm.get('shippingAddress');
      
      if (!same) {
        shippingGroup?.get('address')?.setValidators([Validators.required, Validators.minLength(10)]);
        shippingGroup?.get('city')?.setValidators(Validators.required);
        shippingGroup?.get('postalCode')?.setValidators([Validators.required, Validators.pattern('^[0-9]{6}$')]);
      } else {
        shippingGroup?.get('address')?.clearValidators();
        shippingGroup?.get('city')?.clearValidators();
        shippingGroup?.get('postalCode')?.clearValidators();
      }
      
      shippingGroup?.get('address')?.updateValueAndValidity();
      shippingGroup?.get('city')?.updateValueAndValidity();
      shippingGroup?.get('postalCode')?.updateValueAndValidity();
    });
  }

  prefillUserData(): void {
    const currentUser = this.authService.getCurrentUser();
    if (currentUser) {
      this.checkoutForm.patchValue({
        contactInfo: {
          email: currentUser.email,
          fullName: currentUser.username // You might want to store full name separately
        }
      });
    }
  }

  loadCart(): void {
    this.isLoading = true;
    this.cartService.loadCart().subscribe({
      next: (cart) => {
        this.cart = cart;
        if (!cart || cart.items.length === 0) {
          this.router.navigate(['/cart']);
          this.snackBar.open('Coșul este gol', 'OK', { duration: 3000 });
        }
        this.isLoading = false;
      },
      error: (err) => {
        this.isLoading = false;
        this.snackBar.open('Eroare la încărcarea coșului', 'Închide', { duration: 3000 });
        this.router.navigate(['/cart']);
      }
    });
  }

  onSubmit(): void {
    if (this.checkoutForm.invalid) {
      this.checkoutForm.markAllAsTouched();
      this.snackBar.open('Vă rugăm completați toate câmpurile obligatorii', 'OK', { duration: 3000 });
      return;
    }

    if (!this.cart || this.cart.items.length === 0) {
      this.snackBar.open('Coșul este gol', 'OK', { duration: 3000 });
      return;
    }

    this.isProcessing = true;
    const formValue = this.checkoutForm.value;
    
    const checkoutData = {
      fullName: formValue.contactInfo.fullName,
      email: formValue.contactInfo.email,
      phone: formValue.contactInfo.phone,
      billingAddress: `${formValue.billingAddress.address}, ${formValue.billingAddress.city}, ${formValue.billingAddress.postalCode}`,
      shippingAddress: formValue.shippingAddress.sameAsBilling ? 
        undefined : 
        `${formValue.shippingAddress.address}, ${formValue.shippingAddress.city}, ${formValue.shippingAddress.postalCode}`,
      paymentMethod: formValue.payment.paymentMethod,
      orderNotes: formValue.payment.orderNotes,
      agreeToTerms: formValue.agreeToTerms
    };

    this.cartService.checkout(checkoutData).subscribe({
      next: (order) => {
        this.isProcessing = false;
        this.snackBar.open('Comandă plasată cu succes!', 'OK', { duration: 3000 });
        this.router.navigate(['/order-success', order.id]);
      },
      error: (err) => {
        this.isProcessing = false;
        this.snackBar.open(err.message || 'Eroare la plasarea comenzii', 'Închide', { duration: 5000 });
      }
    });
  }

  getErrorMessage(fieldPath: string): string {
    const control = this.checkoutForm.get(fieldPath);
    if (control?.hasError('required')) {
      return 'Acest câmp este obligatoriu';
    }
    if (control?.hasError('email')) {
      return 'Email invalid';
    }
    if (control?.hasError('pattern')) {
      if (fieldPath.includes('phone')) {
        return 'Număr de telefon invalid (10-15 cifre)';
      }
      if (fieldPath.includes('postalCode')) {
        return 'Cod poștal invalid (6 cifre)';
      }
    }
    if (control?.hasError('minlength')) {
      const minLength = control.errors?.['minlength'].requiredLength;
      return `Minim ${minLength} caractere`;
    }
    return '';
  }
}
</file>

<file path="frontend/src/app/features/home/home-page/home-page.component.html">
<div class="home-container">

  <section class="hero-section">
    <div class="hero-overlay"></div>
    <div class="hero-content">
      <div class="text-content">
        <h1>Dive into immersive gaming</h1>
        <p>Feel every explosion, every step, and every sound detail with the new VipeX gaming headsets.</p>
        <button mat-flat-button color="primary">Vezi oferta</button>
      </div>
    </div>
  </section>

  <main class="selection-section">
    <h2 class="section-title">Our selection</h2>

    <div *ngIf="isLoading" class="loading-indicator">
      <mat-spinner diameter="60"></mat-spinner>
    </div>

    <div class="product-grid" *ngIf="!isLoading && products.length > 0">
      <mat-card *ngFor="let product of products" class="product-card" [routerLink]="['/products', product.id]">
        <div class="product-image-container">
           <mat-icon>inventory_2</mat-icon>
        </div>
        <mat-card-header>
          <mat-card-title>{{ product.name }}</mat-card-title>
        </mat-card-header>
        <mat-card-content>
          <p class="product-price">{{ product.price | currency:'RON' }}</p>
        </mat-card-content>
        <mat-card-actions>
          <button mat-stroked-button color="primary">Add to cart</button>
        </mat-card-actions>
      </mat-card>
    </div>
  </main>

  <section class="social-section">
    <h2 class="section-title">Be connected. Be VipeX.</h2>
    <div class="social-icons">
      <a href="#" class="social-icon-box">X</a>
      <a href="#" class="social-icon-box">O</a>
      <a href="#" class="social-icon-box">f</a>
    </div>
  </section>

</div>
</file>

<file path="frontend/src/app/features/home/home-page/home-page.component.spec.ts">
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { HomePageComponent } from './home-page.component';

describe('HomePageComponent', () => {
  let component: HomePageComponent;
  let fixture: ComponentFixture<HomePageComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [HomePageComponent]
    })
    .compileComponents();

    fixture = TestBed.createComponent(HomePageComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});
</file>

<file path="frontend/src/app/features/home/home-page/home-page.component.ts">
import { Component, OnInit, inject } from '@angular/core';
import { CommonModule, CurrencyPipe } from '@angular/common';
import { RouterModule } from '@angular/router';
import { MatCardModule } from '@angular/material/card';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';

import { Product } from '../../../shared/models/product.model';
import { ProductService } from '../../products/product.service';

@Component({
  selector: 'app-home-page',
  standalone: true,
  imports: [
    CommonModule,
    RouterModule,
    CurrencyPipe,
    MatCardModule,
    MatButtonModule,
    MatIconModule,
    MatProgressSpinnerModule
  ],
  templateUrl: './home-page.component.html',
  styleUrls: ['./home-page.component.scss']
})
export class HomePageComponent implements OnInit {
  products: Product[] = [];
  isLoading = true;
  error: string | null = null;

  private productService = inject(ProductService);

  ngOnInit(): void {
    this.loadProducts();
  }

  loadProducts(): void {
    this.isLoading = true;
    this.error = null;
    this.productService.getAll().subscribe({
      next: (data) => {
        this.products = data;
        this.isLoading = false;
      },
      error: (err) => {
        this.error = 'Nu s-au putut încărca produsele.';
        console.error(err);
        this.isLoading = false;
      }
    });
  }
}
</file>

<file path="frontend/src/app/features/products/products.module.ts">
// src/app/features/products/products.module.ts
import { NgModule }            from '@angular/core';
import { CommonModule }        from '@angular/common';
import { RouterModule }        from '@angular/router';
import { ReactiveFormsModule } from '@angular/forms';

import { ProductListComponent }   from './product-list/product-list.component';
import { ProductDetailComponent } from './product-detail/product-detail.component';
import { ProductFormComponent }   from './product-form/product-form.component';

@NgModule({
  // elimină complet `declarations`
  imports: [
    CommonModule,
    RouterModule,            // pentru directivele routerLink, outlet etc.
    ReactiveFormsModule,

    // importă aici componentele standalone
    ProductListComponent,
    ProductDetailComponent,
    ProductFormComponent
  ]
})
export class ProductsModule {}
</file>

<file path="frontend/src/app/features/products/user-product-list/user-product-list.component.spec.ts">
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { UserProductListComponent } from './user-product-list.component';

describe('UserProductListComponent', () => {
  let component: UserProductListComponent;
  let fixture: ComponentFixture<UserProductListComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [UserProductListComponent]
    })
    .compileComponents();

    fixture = TestBed.createComponent(UserProductListComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});
</file>

<file path="frontend/src/app/features/reviews/review-form-dialog/review-form-dialog.component.ts">
// frontend/src/app/features/reviews/review-form-dialog/review-form-dialog.component.ts
import { Component, Inject, OnInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ReactiveFormsModule, FormBuilder, FormGroup, Validators } from '@angular/forms';
import { MAT_DIALOG_DATA, MatDialogRef, MatDialogModule } from '@angular/material/dialog';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar';

import { Review, CreateReviewRequest } from '../../../shared/models/review.model';
import { ReviewService } from '../review.service';
import { StarRatingComponent } from '../../../shared/components/star-rating/star-rating.component';

@Component({
  selector: 'app-review-form-dialog',
  standalone: true,
  imports: [
    CommonModule,
    ReactiveFormsModule,
    MatDialogModule,
    MatFormFieldModule,
    MatInputModule,
    MatButtonModule,
    MatIconModule,
    MatSnackBarModule,
    StarRatingComponent
  ],
  template: `
    <h2 mat-dialog-title>{{ data.review ? 'Editează recenzia' : 'Scrie o recenzie' }}</h2>
    <mat-dialog-content>
      <form [formGroup]="reviewForm">
        <div class="rating-section">
          <label>Evaluarea ta:</label>
          <app-star-rating 
            [rating]="reviewForm.get('rating')?.value || 0"
            (ratingChange)="onRatingChange($event)">
          </app-star-rating>
          <mat-error *ngIf="reviewForm.get('rating')?.touched && reviewForm.get('rating')?.errors?.['required']">
            Te rugăm să selectezi o evaluare
          </mat-error>
        </div>

        <mat-form-field appearance="outline" class="full-width">
          <mat-label>Titlu recenzie (opțional)</mat-label>
          <input matInput formControlName="title" placeholder="Rezumă experiența ta">
          <mat-error *ngIf="reviewForm.get('title')?.errors?.['maxlength']">
            Titlul nu poate depăși 100 de caractere
          </mat-error>
        </mat-form-field>

        <mat-form-field appearance="outline" class="full-width">
          <mat-label>Comentariu (opțional)</mat-label>
          <textarea matInput formControlName="comment" rows="5" 
                    placeholder="Descrie experiența ta cu acest produs"></textarea>
          <mat-error *ngIf="reviewForm.get('comment')?.errors?.['maxlength']">
            Comentariul nu poate depăși 1000 de caractere
          </mat-error>
        </mat-form-field>
      </form>
    </mat-dialog-content>
    <mat-dialog-actions align="end">
      <button mat-button (click)="onCancel()">Anulează</button>
      <button mat-raised-button color="primary" 
              (click)="onSubmit()" 
              [disabled]="reviewForm.invalid || isSubmitting">
        {{ isSubmitting ? 'Se salvează...' : 'Salvează' }}
      </button>
    </mat-dialog-actions>
  `,
  styles: [`
    mat-dialog-content {
      min-width: 500px;
      
      @media (max-width: 600px) {
        min-width: auto;
      }
    }
    
    .rating-section {
      margin-bottom: 20px;
      
      label {
        display: block;
        margin-bottom: 10px;
        font-weight: 500;
      }
      
      mat-error {
        display: block;
        margin-top: 5px;
      }
    }
    
    .full-width {
      width: 100%;
      margin-bottom: 16px;
    }
  `]
})
export class ReviewFormDialogComponent implements OnInit {
  reviewForm!: FormGroup;
  isSubmitting = false;

  constructor(
    private fb: FormBuilder,
    private reviewService: ReviewService,
    private snackBar: MatSnackBar,
    public dialogRef: MatDialogRef<ReviewFormDialogComponent>,
    @Inject(MAT_DIALOG_DATA) public data: { productId: number; review: Review | null }
  ) {}

  ngOnInit(): void {
    this.reviewForm = this.fb.group({
      rating: [this.data.review?.rating || null, Validators.required],
      title: [this.data.review?.title || '', Validators.maxLength(100)],
      comment: [this.data.review?.comment || '', Validators.maxLength(1000)]
    });
  }

  onRatingChange(rating: number): void {
    this.reviewForm.patchValue({ rating });
  }

  onCancel(): void {
    this.dialogRef.close();
  }

  onSubmit(): void {
    if (this.reviewForm.invalid) return;

    this.isSubmitting = true;
    const reviewData: CreateReviewRequest = {
      productId: this.data.productId,
      ...this.reviewForm.value
    };

    const operation = this.data.review
      ? this.reviewService.updateReview(this.data.review.id!, reviewData)
      : this.reviewService.createReview(reviewData);

    operation.subscribe({
      next: () => {
        this.snackBar.open(
          this.data.review ? 'Recenzie actualizată cu succes!' : 'Recenzie adăugată cu succes!',
          'OK',
          { duration: 3000 }
        );
        this.dialogRef.close(true);
      },
      error: (err) => {
        this.isSubmitting = false;
        const errorMessage = err.error?.message || 'A apărut o eroare. Te rugăm să încerci din nou.';
        this.snackBar.open(errorMessage, 'Închide', { duration: 5000 });
      }
    });
  }
}
</file>

<file path="frontend/src/app/features/reviews/review-list/review-list.component.html">
<!-- frontend/src/app/features/reviews/review-list/review-list.component.html -->
<div class="review-section">
  <h3 class="section-title">Recenzii și Evaluări</h3>

  <!-- Review Summary -->
  <div class="review-summary" *ngIf="summary">
    <mat-card>
      <mat-card-content>
        <div class="summary-content">
          <div class="average-rating">
            <div class="rating-number">{{ summary.averageRating.toFixed(1) }}</div>
            <app-star-rating 
              [rating]="summary.averageRating" 
              [readonly]="true"
              [showHalf]="true">
            </app-star-rating>
            <div class="total-reviews">{{ summary.totalReviews }} recenzii</div>
          </div>
          
          <div class="rating-distribution">
            <div *ngFor="let rating of [5, 4, 3, 2, 1]" class="rating-bar">
              <span class="rating-label">{{ rating }} stele</span>
              <div class="bar-container">
                <div class="bar-fill" [style.width.%]="getRatingPercentage(rating)"></div>
              </div>
              <span class="rating-count">{{ summary.ratingDistribution[rating] || 0 }}</span>
            </div>
          </div>
        </div>
      </mat-card-content>
    </mat-card>
  </div>

  <!-- Write Review Button -->
  <div class="review-actions" *ngIf="authService.isLoggedIn()">
    <button mat-raised-button color="primary" (click)="openReviewDialog()">
      <mat-icon>{{ myReview ? 'edit' : 'rate_review' }}</mat-icon>
      {{ myReview ? 'Editează recenzia ta' : 'Scrie o recenzie' }}
    </button>
  </div>

  <div class="login-prompt" *ngIf="!authService.isLoggedIn()">
    <p>Trebuie să fii autentificat pentru a scrie o recenzie.</p>
    <button mat-stroked-button color="primary" routerLink="/login">Autentifică-te</button>
  </div>

  <!-- Reviews List -->
  <div class="reviews-list">
    <div *ngIf="isLoading" class="loading-indicator">
      <mat-spinner diameter="40"></mat-spinner>
    </div>

    <div *ngIf="!isLoading && reviews.length === 0" class="no-reviews">
      <p>Nu există recenzii pentru acest produs încă.</p>
      <p *ngIf="authService.isLoggedIn()">Fii primul care scrie o recenzie!</p>
    </div>

    <mat-card *ngFor="let review of reviews" class="review-card">
      <mat-card-header>
        <div class="review-header">
          <div class="review-info">
            <h4 class="reviewer-name">{{ review.username }}</h4>
            <app-star-rating [rating]="review.rating" [readonly]="true"></app-star-rating>
            <span class="review-date">{{ formatDate(review.createdAt) }}</span>
          </div>
          <div class="review-actions" *ngIf="canEditReview(review)">
            <button mat-icon-button (click)="openReviewDialog()" *ngIf="review.userId === authService.getCurrentUser()?.id">
              <mat-icon>edit</mat-icon>
            </button>
            <button mat-icon-button color="warn" (click)="deleteReview(review)">
              <mat-icon>delete</mat-icon>
            </button>
          </div>
        </div>
      </mat-card-header>
      <mat-card-content>
        <h5 class="review-title" *ngIf="review.title">{{ review.title }}</h5>
        <p class="review-comment">{{ review.comment }}</p>
      </mat-card-content>
    </mat-card>

    <!-- Pagination -->
    <mat-paginator *ngIf="totalReviews > pageSize"
      [length]="totalReviews"
      [pageSize]="pageSize"
      [pageSizeOptions]="[5, 10, 25]"
      [pageIndex]="pageIndex"
      (page)="onPageChange($event)">
    </mat-paginator>
  </div>
</div>
</file>

<file path="frontend/src/app/features/reviews/review-list/review-list.component.ts">
// frontend/src/app/features/reviews/review-list/review-list.component.ts
import { Component, Input, OnInit, inject } from '@angular/core';
import { CommonModule } from '@angular/common';
import { MatCardModule } from '@angular/material/card';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { MatPaginatorModule, PageEvent } from '@angular/material/paginator';
import { MatDividerModule } from '@angular/material/divider';
import { MatDialog, MatDialogModule } from '@angular/material/dialog';
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar';

import { Review, ProductReviewSummary } from '../../../shared/models/review.model';
import { ReviewService } from '../review.service';
import { AuthService } from '../../../auth/auth.service';
import { StarRatingComponent } from '../../../shared/components/star-rating/star-rating.component';
import { ReviewFormDialogComponent } from '../review-form-dialog/review-form-dialog.component';

@Component({
  selector: 'app-review-list',
  standalone: true,
  imports: [
    CommonModule,
    MatCardModule,
    MatButtonModule,
    MatIconModule,
    MatProgressSpinnerModule,
    MatPaginatorModule,
    MatDividerModule,
    MatDialogModule,
    MatSnackBarModule,
    StarRatingComponent
  ],
  templateUrl: './review-list.component.html',
  styleUrls: ['./review-list.component.scss']
})
export class ReviewListComponent implements OnInit {
  @Input() productId!: number;
  
  reviews: Review[] = [];
  summary: ProductReviewSummary | null = null;
  myReview: Review | null = null;
  isLoading = true;
  
  // Pagination
  totalReviews = 0;
  pageSize = 10;
  pageIndex = 0;
  
  private reviewService = inject(ReviewService);
  public authService = inject(AuthService);
  private dialog = inject(MatDialog);
  private snackBar = inject(MatSnackBar);

  ngOnInit(): void {
    this.loadReviewSummary();
    this.loadReviews();
    if (this.authService.isLoggedIn()) {
      this.loadMyReview();
    }
  }

  loadReviewSummary(): void {
    this.reviewService.getProductReviewSummary(this.productId).subscribe({
      next: (summary) => {
        this.summary = summary;
      },
      error: (err) => {
        console.error('Error loading review summary:', err);
      }
    });
  }

  loadReviews(): void {
    this.isLoading = true;
    this.reviewService.getProductReviews(this.productId, this.pageIndex, this.pageSize).subscribe({
      next: (page) => {
        this.reviews = page.content;
        this.totalReviews = page.totalElements;
        this.isLoading = false;
      },
      error: (err) => {
        this.isLoading = false;
        console.error('Error loading reviews:', err);
      }
    });
  }

  loadMyReview(): void {
    this.reviewService.getMyReviewForProduct(this.productId).subscribe({
      next: (review) => {
        this.myReview = review;
      },
      error: (err) => {
        console.error('Error loading my review:', err);
      }
    });
  }

  openReviewDialog(): void {
    const dialogRef = this.dialog.open(ReviewFormDialogComponent, {
      width: '600px',
      data: {
        productId: this.productId,
        review: this.myReview
      }
    });

    dialogRef.afterClosed().subscribe(result => {
      if (result) {
        this.loadReviewSummary();
        this.loadReviews();
        this.loadMyReview();
      }
    });
  }

  deleteReview(review: Review): void {
    if (confirm('Sigur dorești să ștergi această recenzie?')) {
      this.reviewService.deleteReview(review.id!).subscribe({
        next: () => {
          this.snackBar.open('Recenzie ștearsă cu succes!', 'OK', { duration: 3000 });
          this.loadReviewSummary();
          this.loadReviews();
          if (review.userId === this.authService.getCurrentUser()?.id) {
            this.myReview = null;
          }
        },
        error: (err) => {
          this.snackBar.open('Eroare la ștergerea recenziei', 'Închide', { duration: 3000 });
        }
      });
    }
  }

  onPageChange(event: PageEvent): void {
    this.pageIndex = event.pageIndex;
    this.pageSize = event.pageSize;
    this.loadReviews();
  }

  canEditReview(review: Review): boolean {
    const currentUser = this.authService.getCurrentUser();
    return currentUser !== null && (review.userId === currentUser.id || this.authService.role === 'admin');
  }

  formatDate(dateString: string): string {
    return new Date(dateString).toLocaleDateString('ro-RO');
  }

  getRatingPercentage(rating: number): number {
    if (!this.summary || this.summary.totalReviews === 0) return 0;
    return (this.summary.ratingDistribution[rating] / this.summary.totalReviews) * 100;
  }
}
</file>

<file path="frontend/src/app/features/shopping-cart/cart.service.ts">
// frontend/src/app/features/shopping-cart/cart.service.ts
import { Injectable, inject } from '@angular/core';
import { HttpClient, HttpErrorResponse } from '@angular/common/http';
import { Observable, BehaviorSubject, throwError, of } from 'rxjs';
import { catchError, tap, map } from 'rxjs/operators';
import { Cart, CartItem, AddToCartRequest, UpdateCartItemRequest, CheckoutRequest } from '../../shared/models/cart.model';
import { Order } from '../../shared/models/order.model';

@Injectable({
  providedIn: 'root'
})
export class CartService {
  private apiUrl = '/api/cart';
  private cartSubject = new BehaviorSubject<Cart | null>(null);
  public cart$ = this.cartSubject.asObservable();

  private http = inject(HttpClient);

  loadCart(): Observable<Cart> {
    return this.http.get<Cart>(this.apiUrl).pipe(
      tap(cart => this.cartSubject.next(cart)),
      catchError(this.handleError)
    );
  }

  addToCart(request: AddToCartRequest): Observable<Cart> {
    return this.http.post<Cart>(`${this.apiUrl}/items`, request).pipe(
      tap(cart => this.cartSubject.next(cart)),
      catchError(this.handleError)
    );
  }

  updateCartItem(productId: number, request: UpdateCartItemRequest): Observable<Cart> {
    return this.http.put<Cart>(`${this.apiUrl}/items/${productId}`, request).pipe(
      tap(cart => this.cartSubject.next(cart)),
      catchError(this.handleError)
    );
  }

  removeFromCart(productId: number): Observable<Cart> {
    return this.http.delete<Cart>(`${this.apiUrl}/items/${productId}`).pipe(
      tap(cart => this.cartSubject.next(cart)),
      catchError(this.handleError)
    );
  }

  clearCart(): Observable<void> {
    return this.http.delete<void>(`${this.apiUrl}/clear`).pipe(
      tap(() => this.cartSubject.next(null)),
      catchError(this.handleError)
    );
  }

  checkout(request: CheckoutRequest): Observable<Order> {
    return this.http.post<Order>(`${this.apiUrl}/checkout`, request).pipe(
      tap(() => this.cartSubject.next(null)), // Clear local cart after checkout
      catchError(this.handleError)
    );
  }

  getCartItemCount(): Observable<number> {
    return this.cart$.pipe(
      map(cart => cart ? cart.totalItems : 0)
    );
  }

  getCartTotal(): Observable<number> {
    return this.cart$.pipe(
      map(cart => cart ? cart.totalAmount : 0)
    );
  }

  private handleError(error: HttpErrorResponse) {
    let errorMessage = 'A apărut o eroare la procesarea coșului.';
    if (error.error instanceof ErrorEvent) {
      errorMessage = `Eroare: ${error.error.message}`;
    } else {
      errorMessage = error.error?.message || `Cod eroare: ${error.status}`;
    }
    console.error('Cart service error:', error);
    return throwError(() => new Error(errorMessage));
  }
}
</file>

<file path="frontend/src/app/features/shopping-cart/shopping-cart.component.html">
<!-- frontend/src/app/features/shopping-cart/shopping-cart.component.html -->
<div class="shopping-cart-container">
  <h1 class="page-title">
    <mat-icon>shopping_cart</mat-icon>
    Coșul tău de cumpărături
  </h1>

  <div *ngIf="isLoading" class="loading-indicator">
    <mat-spinner diameter="50"></mat-spinner>
    <p>Se încarcă coșul...</p>
  </div>

  <div *ngIf="!isLoading && (!cart || cart.items.length === 0)" class="empty-cart">
    <mat-card>
      <mat-card-content>
        <mat-icon class="empty-icon">shopping_cart</mat-icon>
        <h2>Coșul tău este gol</h2>
        <p>Adaugă produse pentru a continua cumpărăturile.</p>
        <button mat-raised-button color="primary" (click)="continueShopping()">
          <mat-icon>storefront</mat-icon>
          Vezi produsele
        </button>
      </mat-card-content>
    </mat-card>
  </div>

  <div *ngIf="!isLoading && cart && cart.items.length > 0" class="cart-content">
    <div class="cart-items">
      <mat-card>
        <mat-card-header>
          <mat-card-title>Produse în coș ({{ cart.totalItems }})</mat-card-title>
          <button mat-button color="warn" (click)="clearCart()" [disabled]="isUpdating">
            <mat-icon>delete_sweep</mat-icon>
            Golește coșul
          </button>
        </mat-card-header>
        <mat-card-content>
          <div class="item-list">
            <div *ngFor="let item of cart.items" class="cart-item">
              <div class="item-image">
                <mat-icon *ngIf="!item.productImageBase64">inventory_2</mat-icon>
                <img *ngIf="item.productImageBase64" [src]="item.productImageBase64" [alt]="item.productName">
              </div>
              
              <div class="item-details">
                <h3>{{ item.productName }}</h3>
                <p class="item-description">{{ item.productDescription }}</p>
                <p class="item-stock" [class.low-stock]="item.productStock < 5">
                  Stoc disponibil: {{ item.productStock }} buc.
                </p>
              </div>

              <div class="item-quantity">
                <mat-form-field appearance="outline">
                  <mat-label>Cantitate</mat-label>
                  <input matInput type="number" 
                         [(ngModel)]="item.quantity" 
                         (blur)="updateQuantity(item, item.quantity)"
                         [disabled]="isUpdating && updatingItemId === item.productId"
                         min="1" 
                         [max]="item.productStock">
                </mat-form-field>
              </div>

              <div class="item-price">
                <p class="unit-price">{{ item.productPrice | currency:'RON':'symbol':'1.2-2' }}/buc</p>
                <p class="subtotal">{{ item.subtotal | currency:'RON':'symbol':'1.2-2' }}</p>
              </div>

              <div class="item-actions">
                <button mat-icon-button color="warn" 
                        (click)="removeItem(item.productId)"
                        [disabled]="isUpdating">
                  <mat-icon>delete</mat-icon>
                </button>
              </div>
            </div>
          </div>
        </mat-card-content>
      </mat-card>
    </div>

    <div class="cart-summary">
      <mat-card>
        <mat-card-header>
          <mat-card-title>Sumar comandă</mat-card-title>
        </mat-card-header>
        <mat-card-content>
          <div class="summary-row">
            <span>Subtotal ({{ cart.totalItems }} produse)</span>
            <span>{{ cart.totalAmount | currency:'RON':'symbol':'1.2-2' }}</span>
          </div>
          <div class="summary-row">
            <span>Transport</span>
            <span class="free-shipping">GRATUIT</span>
          </div>
          <mat-divider></mat-divider>
          <div class="summary-row total">
            <span>Total</span>
            <span>{{ cart.totalAmount | currency:'RON':'symbol':'1.2-2' }}</span>
          </div>
        </mat-card-content>
        <mat-card-actions>
          <button mat-raised-button color="primary" class="checkout-button" 
                  (click)="proceedToCheckout()"
                  [disabled]="isUpdating">
            <mat-icon>payment</mat-icon>
            Finalizează comanda
          </button>
          <button mat-stroked-button (click)="continueShopping()">
            <mat-icon>arrow_back</mat-icon>
            Continuă cumpărăturile
          </button>
        </mat-card-actions>
      </mat-card>
    </div>
  </div>
</div>
</file>

<file path="frontend/src/app/features/user-dashboard/services/client-order.service.ts">
// src/app/features/user-dashboard/services/client-order.service.ts
import { Injectable, inject } from '@angular/core';
import { HttpClient, HttpErrorResponse } from '@angular/common/http';
import { Observable, throwError } from 'rxjs';
import { catchError } from 'rxjs/operators';
import { Order } from '../../../shared/models/order.model'; // Modelul partajat

/**
 * Serviciu pentru operațiunile clientului legate de comenzi
 * (plasare comandă, vizualizare istoric).
 */
@Injectable({
  providedIn: 'root'
})
export class ClientOrderService {
  // Endpoint-ul pentru comenzile clientului (plasare, istoric propriu)
  private ordersApiUrl = '/api/orders';

  private http = inject(HttpClient);

  /**
   * Plasează o nouă comandă.
   * @param orderData Obiectul Order ce conține detaliile comenzii.
   * @returns Un Observable care emite comanda creată.
   */
  placeOrder(orderData: Order): Observable<Order> {
    // Backend-ul se așteaptă la un OrderDto.
    // Asigură-te că orderData (construit în CheckoutComponent) respectă structura.
    return this.http.post<Order>(this.ordersApiUrl, orderData)
      .pipe(catchError(this.handleError));
  }

  /**
   * Preia istoricul comenzilor pentru utilizatorul autentificat.
   * Backend-ul folosește token-ul JWT pentru a identifica utilizatorul.
   * @returns Un Observable care emite un array cu comenzile utilizatorului.
   */
  getMyOrderHistory(): Observable<Order[]> {
    return this.http.get<Order[]>(`${this.ordersApiUrl}/my-history`)
      .pipe(catchError(this.handleError));
  }

  /**
   * Preia detaliile unei comenzi specifice din istoricul utilizatorului.
   * (Opțional, dacă backend-ul oferă un astfel de endpoint specific pentru 'my-history/:id')
   * Momentan, backend-ul pare să aibă doar GET /api/orders/{id} (admin) și GET /api/orders/my-history (user)
   * @param orderId ID-ul comenzii.
   * @returns Un Observable care emite comanda găsită.
   */
  // getMyOrderById(orderId: number): Observable<Order> {
  //   return this.http.get<Order>(`${this.ordersApiUrl}/my-history/${orderId}`) // Verifică endpoint-ul în backend
  //     .pipe(catchError(this.handleError));
  // }

  private handleError(error: HttpErrorResponse) {
    let errorMessage = 'A apărut o eroare la procesarea comenzii.';
    if (error.error instanceof ErrorEvent) {
      errorMessage = `Eroare client: ${error.error.message}`;
    } else {
      errorMessage = `Cod eroare server: ${error.status}, mesaj: ${error.error?.message || error.message}`;
    }
    console.error(errorMessage, error);
    return throwError(() => new Error(errorMessage));
  }
}
</file>

<file path="frontend/src/app/features/user-dashboard/user-order-history/user-order-history.component.html">
<!-- src/app/features/user-dashboard/user-order-history/user-order-history.component.html -->
<div class="user-order-history-container">
  <div class="header">
    <h2>Comenzile Mele</h2>
  </div>

  <div *ngIf="isLoading" class="loading-indicator">
    <mat-spinner diameter="50"></mat-spinner>
    <p>Se încarcă istoricul comenzilor...</p>
  </div>

  <div *ngIf="error && !isLoading" class="error-message">
    <p>{{ error }}</p>
    <button mat-stroked-button color="warn" (click)="loadOrderHistory()">Reîncearcă</button>
  </div>

  <div *ngIf="!isLoading && !error && orders.length === 0" class="no-data">
    <p>Nu ai plasat nicio comandă încă.</p>
    <button mat-flat-button color="primary" routerLink="/products">Vezi Produse</button>
  </div>

  <mat-accordion multi="true" *ngIf="!isLoading && !error && orders.length > 0" class="order-accordion">
    <mat-expansion-panel *ngFor="let order of orders; let i = index"
                         (opened)="panelOpenState[i] = true"
                         (closed)="panelOpenState[i] = false"
                         class="order-panel">
      <mat-expansion-panel-header>
        <mat-panel-title>
          Comanda #{{ order.id }} - {{ order.orderDate | date:'dd/MM/yyyy' }}
        </mat-panel-title>
        <mat-panel-description fxLayoutAlign="space-between center">
          <span>Total: {{ order.totalAmount | currency:'RON':'symbol':'1.2-2' }}</span>
          <mat-chip-listbox aria-label="Status comandă">
            <mat-chip selected [ngClass]="'status-chip-' + order.status.toLowerCase().replace('_', '-')">
                {{ formatStatus(order.status) }}
            </mat-chip>
          </mat-chip-listbox>
        </mat-panel-description>
      </mat-expansion-panel-header>

      <div class="order-details-content">
        <h4>Detalii Comandă:</h4>
        <p><strong>Data plasării:</strong> {{ order.orderDate | date:'dd/MM/yyyy HH:mm:ss' }}</p>
        <p><strong>Nume client (livrare):</strong> {{ order.customerName }}</p>
        <p><strong>Adresă livrare:</strong> {{ order.shippingAddress }}</p>
        <p><strong>Email contact:</strong> {{ order.customerEmail }}</p>
        <p><strong>Telefon contact:</strong> {{ order.customerPhone }}</p>

        <mat-divider></mat-divider>
        <h4>Articole Comandate:</h4>
        <mat-list role="list" class="order-items-list">
          <mat-list-item *ngFor="let item of order.orderItems" role="listitem" class="order-item-detail">
            <!-- Secțiunea Imagine Articol - COMENTATĂ TEMPORAR -->
            <!--
            <img matListItemAvatar *ngIf="item.productImageBase64Snapshot" [src]="item.productImageBase64Snapshot" [alt]="item.productNameSnapshot" class="item-image-small">
            <mat-icon matListItemAvatar *ngIf="!item.productImageBase64Snapshot">inventory_2</mat-icon>
            -->
            <mat-icon matListItemAvatar>inventory_2</mat-icon> <!-- Placeholder generic -->

            <span matListItemTitle>{{ item.productNameSnapshot }} (ID: {{ item.productId }})</span>
            <span matListItemLine>
              Cantitate: {{ item.quantity }} x {{ item.priceAtPurchase | currency:'RON':'symbol':'1.2-2' }}
            </span>
            <span matListItemMeta class="item-subtotal-small">
              Subtotal: {{ calculateItemSubtotal(item) | currency:'RON':'symbol':'1.2-2' }}
            </span>
          </mat-list-item>
        </mat-list>
      </div>
    </mat-expansion-panel>
  </mat-accordion>
</div>
</file>

<file path="frontend/src/app/features/user-dashboard/user-order-history/user-order-history.component.ts">
// src/app/features/user-dashboard/user-order-history/user-order-history.component.ts
import { Component, OnInit, inject } from '@angular/core';
import { CommonModule, DatePipe, CurrencyPipe } from '@angular/common';
import { RouterModule } from '@angular/router';
import { MatCardModule } from '@angular/material/card';
import { MatListModule } from '@angular/material/list';
import { MatDividerModule } from '@angular/material/divider';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar';
import { MatExpansionModule } from '@angular/material/expansion';
import { MatIconModule } from '@angular/material/icon';
import { MatChipsModule } from '@angular/material/chips';
import { HttpErrorResponse } from '@angular/common/http';


import { Order } from '../../../shared/models/order.model';
import { OrderItem } from '../../../shared/models/order-item.model'; // <<< CORECTAT
import { ClientOrderService } from '../services/client-order.service';

@Component({
  selector: 'app-user-order-history',
  standalone: true,
  imports: [
    CommonModule,
    RouterModule,
    MatCardModule,
    MatListModule,
    MatDividerModule,
    MatProgressSpinnerModule,
    MatSnackBarModule,
    MatExpansionModule,
    MatIconModule,
    MatChipsModule,
    DatePipe,
    CurrencyPipe
  ],
  templateUrl: './user-order-history.component.html',
  styleUrls: ['./user-order-history.component.scss']
})
export class UserOrderHistoryComponent implements OnInit {
  orders: Order[] = [];
  isLoading = true;
  error: string | null = null;
  panelOpenState: boolean[] = [];

  private clientOrderService = inject(ClientOrderService);
  private snackBar = inject(MatSnackBar);

  ngOnInit(): void {
    this.loadOrderHistory();
  }

  loadOrderHistory(): void {
    this.isLoading = true;
    this.error = null;
    this.clientOrderService.getMyOrderHistory().subscribe({
      next: (data: Order[]) => { // Tipare explicită
        this.orders = data.sort((a, b) => new Date(b.orderDate!).getTime() - new Date(a.orderDate!).getTime());
        this.panelOpenState = new Array(this.orders.length).fill(false);
        this.isLoading = false;
      },
      error: (err: HttpErrorResponse) => { // Tipare explicită
        this.error = 'Nu s-a putut încărca istoricul comenzilor.';
        const errMsg = err.error?.message || err.message || 'Eroare necunoscută.';
        console.error('Eroare la încărcarea istoricului comenzilor:', err);
        this.isLoading = false;
        this.snackBar.open(`${this.error} ${errMsg}`, 'Închide', { duration: 5000 });
      }
    });
  }

  formatStatus(status: string): string {
    if (!status) return '';
    return status.replace(/_/g, ' ').toLowerCase().replace(/\b\w/g, l => l.toUpperCase());
  }

  calculateItemSubtotal(item: OrderItem): number {
    return (item.priceAtPurchase || 0) * item.quantity;
  }

  togglePanel(index: number): void {
    this.panelOpenState[index] = !this.panelOpenState[index];
  }
}
</file>

<file path="frontend/src/app/features/user-profile/user-profile.component.html">
<!-- frontend/src/app/features/user-profile/user-profile.component.html -->
<div class="user-profile-container">
  <div class="profile-header">
    <h1>Profilul Meu</h1>
    <button mat-stroked-button routerLink="/products-list">
      <mat-icon>arrow_back</mat-icon>
      Înapoi la produse
    </button>
  </div>

  <div *ngIf="isLoading" class="loading-container">
    <mat-spinner diameter="50"></mat-spinner>
    <p>Se încarcă profilul...</p>
  </div>

  <mat-tab-group *ngIf="!isLoading" animationDuration="300ms">
    <!-- Profile Information Tab -->
    <mat-tab label="Informații Profil">
      <div class="tab-content">
        <mat-card class="profile-card">
          <mat-card-header>
            <div class="profile-avatar-section">
              <div class="avatar-placeholder">
                <mat-icon>account_circle</mat-icon>
              </div>
              <div class="profile-header-info">
                <mat-card-title>{{ user?.username }}</mat-card-title>
                <mat-card-subtitle>Membru din {{ formatDate('2024-01-01') }}</mat-card-subtitle>
              </div>
            </div>
            <button mat-icon-button (click)="toggleEditMode()" *ngIf="!isEditMode">
              <mat-icon>edit</mat-icon>
            </button>
          </mat-card-header>

          <mat-card-content>
            <form [formGroup]="profileForm">
              <div class="profile-section">
                <h3>Informații de bază</h3>
                <mat-divider></mat-divider>
                
                <div class="form-grid">
                  <mat-form-field appearance="outline">
                    <mat-label>Nume utilizator</mat-label>
                    <input matInput formControlName="username" readonly>
                    <mat-icon matSuffix>person</mat-icon>
                  </mat-form-field>

                  <mat-form-field appearance="outline">
                    <mat-label>Email</mat-label>
                    <input matInput type="email" formControlName="email" [readonly]="!isEditMode">
                    <mat-icon matSuffix>email</mat-icon>
                    <mat-error *ngIf="profileForm.get('email')?.errors?.['email']">
                      Email invalid
                    </mat-error>
                  </mat-form-field>

                  <mat-form-field appearance="outline">
                    <mat-label>Nume complet</mat-label>
                    <input matInput formControlName="fullName" [readonly]="!isEditMode" placeholder="Adaugă numele complet">
                    <mat-icon matSuffix>badge</mat-icon>
                  </mat-form-field>

                  <mat-form-field appearance="outline">
                    <mat-label>Telefon</mat-label>
                    <input matInput formControlName="phone" [readonly]="!isEditMode" placeholder="Adaugă număr de telefon">
                    <mat-icon matSuffix>phone</mat-icon>
                  </mat-form-field>
                </div>

                <mat-form-field appearance="outline" class="full-width">
                  <mat-label>Adresă</mat-label>
                  <textarea matInput formControlName="address" rows="3" [readonly]="!isEditMode" placeholder="Adaugă adresa de livrare"></textarea>
                  <mat-icon matSuffix>location_on</mat-icon>
                </mat-form-field>
              </div>

              <div class="profile-section">
                <h3>Preferințe cont</h3>
                <mat-divider></mat-divider>
                
                <div class="preferences-grid">
                  <div class="preference-item">
                    <mat-icon>security</mat-icon>
                    <div>
                      <h4>Securitate</h4>
                      <p>Autentificare în doi pași: <strong>Dezactivată</strong></p>
                    </div>
                  </div>
                  
                  <div class="preference-item">
                    <mat-icon>notifications</mat-icon>
                    <div>
                      <h4>Notificări</h4>
                      <p>Primește notificări email: <strong>Activat</strong></p>
                    </div>
                  </div>

                  <div class="preference-item">
                    <mat-icon>language</mat-icon>
                    <div>
                      <h4>Limbă</h4>
                      <p>Limba preferată: <strong>Română</strong></p>
                    </div>
                  </div>
                </div>
              </div>
            </form>

            <div class="action-buttons" *ngIf="isEditMode">
              <button mat-stroked-button (click)="toggleEditMode()">
                <mat-icon>cancel</mat-icon>
                Anulează
              </button>
              <button mat-raised-button color="primary" (click)="saveProfile()" [disabled]="profileForm.invalid">
                <mat-icon>save</mat-icon>
                Salvează modificările
              </button>
            </div>
          </mat-card-content>
        </mat-card>
      </div>
    </mat-tab>

    <!-- Reviews Tab -->
    <mat-tab label="Recenziile mele">
      <div class="tab-content">
        <mat-card class="reviews-summary-card">
          <mat-card-content>
            <div class="reviews-stats">
              <div class="stat-item">
                <h3>{{ totalReviews }}</h3>
                <p>Total recenzii</p>
              </div>
              <div class="stat-item">
                <h3>{{ averageRating.toFixed(1) }}</h3>
                <p>Rating mediu acordat</p>
                <app-star-rating [rating]="averageRating" [readonly]="true" [showHalf]="true"></app-star-rating>
              </div>
            </div>
          </mat-card-content>
        </mat-card>

        <div *ngIf="isLoadingReviews" class="loading-container">
          <mat-spinner diameter="40"></mat-spinner>
          <p>Se încarcă recenziile...</p>
        </div>

        <div *ngIf="!isLoadingReviews && userReviews.length === 0" class="no-reviews">
          <mat-icon>rate_review</mat-icon>
          <p>Nu ai scris încă nicio recenzie</p>
          <button mat-raised-button color="primary" routerLink="/products-list">
            Explorează produsele
          </button>
        </div>

        <div class="reviews-list" *ngIf="!isLoadingReviews && userReviews.length > 0">
          <mat-card *ngFor="let review of userReviews" class="review-card">
            <mat-card-header>
              <mat-card-title>{{ review.productName }}</mat-card-title>
              <mat-card-subtitle>
                <app-star-rating [rating]="review.rating" [readonly]="true"></app-star-rating>
                <span class="review-date">{{ formatDate(review.createdAt) }}</span>
              </mat-card-subtitle>
            </mat-card-header>
            <mat-card-content>
              <h4 *ngIf="review.title" class="review-title">{{ review.title }}</h4>
              <p class="review-comment">{{ review.comment || 'Fără comentariu' }}</p>
            </mat-card-content>
            <mat-card-actions>
              <button mat-button [routerLink]="['/products', review.productId]">
                <mat-icon>visibility</mat-icon>
                Vezi produsul
              </button>
              <button mat-button color="primary">
                <mat-icon>edit</mat-icon>
                Editează
              </button>
              <button mat-button color="warn">
                <mat-icon>delete</mat-icon>
                Șterge
              </button>
            </mat-card-actions>
          </mat-card>
        </div>
      </div>
    </mat-tab>

    <!-- Orders Tab (Optional) -->
    <mat-tab label="Comenzile mele">
      <div class="tab-content">
        <div class="orders-placeholder">
          <mat-icon>shopping_bag</mat-icon>
          <p>Pentru a vedea comenzile tale, accesează</p>
          <button mat-raised-button color="primary" routerLink="/my-orders">
            <mat-icon>history</mat-icon>
            Istoric comenzi
          </button>
        </div>
      </div>
    </mat-tab>
  </mat-tab-group>
</div>
</file>

<file path="frontend/src/app/features/user-profile/user-profile.component.scss">
.user-profile-container {
  max-width: 1200px;
  margin: 0 auto;
  padding: 20px;
  min-height: calc(100vh - 64px);
}

.profile-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 30px;

  h1 {
    margin: 0;
    font-size: 2em;
  }

  button {
    mat-icon {
      margin-right: 8px;
    }
  }
}

.loading-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 400px;

  p {
    margin-top: 20px;
  }
}

::ng-deep .mat-mdc-tab-group {
  background-color: transparent;

  .mat-mdc-tab-label {
    font-weight: 500;

    &.mat-mdc-tab-label-active {
      color: var(--mdc-theme-primary, #673ab7);
    }
  }

  .mat-ink-bar {
    background-color: var(--mdc-theme-primary, #673ab7);
  }
}

.tab-content {
  padding: 24px 0;
}

// Profile Card Styles
.profile-card {
  // Remove dark background
  
  mat-card-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 24px;
  }

  .profile-avatar-section {
    display: flex;
    align-items: center;
    gap: 20px;

    .avatar-placeholder {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background-color: rgba(0,0,0,0.1);
      display: flex;
      align-items: center;
      justify-content: center;
      border: 3px solid var(--mdc-theme-primary, #673ab7);

      mat-icon {
        font-size: 48px;
        width: 48px;
        height: 48px;
        color: var(--mdc-theme-primary, #673ab7);
      }
    }

    .profile-header-info {
      mat-card-title {
        font-size: 1.5em;
        margin-bottom: 4px;
      }

      mat-card-subtitle {
        opacity: 0.7;
      }
    }
  }
}

.profile-section {
  margin-bottom: 32px;

  h3 {
    color: var(--mdc-theme-primary, #673ab7);
    margin-bottom: 16px;
    font-size: 1.2em;
  }

  mat-divider {
    margin-bottom: 24px;
  }
}

.form-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: 16px;
  margin-bottom: 16px;
}

.full-width {
  width: 100%;
}

.preferences-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: 20px;
  margin-top: 20px;

  .preference-item {
    display: flex;
    align-items: flex-start;
    gap: 16px;
    padding: 16px;
    background-color: rgba(0,0,0,0.04);
    border-radius: 8px;

    mat-icon {
      color: var(--mdc-theme-primary, #673ab7);
      margin-top: 4px;
    }

    h4 {
      margin: 0 0 4px 0;
      font-size: 1em;
    }

    p {
      margin: 0;
      font-size: 0.9em;
      opacity: 0.7;

      strong {
        color: #4CAF50;
      }
    }
  }
}

.action-buttons {
  display: flex;
  justify-content: flex-end;
  gap: 12px;
  margin-top: 24px;
  padding-top: 24px;
  border-top: 1px solid rgba(0,0,0,0.12);

  button {
    mat-icon {
      margin-right: 8px;
    }
  }
}

// Reviews Section Styles
.reviews-summary-card {
  // Remove dark background
  margin-bottom: 24px;

  .reviews-stats {
    display: flex;
    justify-content: space-around;
    align-items: center;
    padding: 20px 0;

    .stat-item {
      text-align: center;

      h3 {
        margin: 0 0 8px 0;
        font-size: 2.5em;
        color: var(--mdc-theme-primary, #673ab7);
        font-weight: 500;
      }

      p {
        margin: 0 0 8px 0;
        font-size: 1.1em;
        opacity: 0.7;
      }
    }
  }
}

.no-reviews {
  text-align: center;
  padding: 60px 20px;

  mat-icon {
    font-size: 80px;
    width: 80px;
    height: 80px;
    margin: 0 auto 20px;
    opacity: 0.3;
  }

  p {
    font-size: 1.2em;
    margin-bottom: 20px;
    opacity: 0.7;
  }
}

.reviews-list {
  display: grid;
  gap: 16px;
}

.review-card {
  // Remove dark background
  
  mat-card-header {
    mat-card-title {
      color: var(--mdc-theme-primary, #673ab7);
      font-size: 1.1em;
    }

    mat-card-subtitle {
      display: flex;
      align-items: center;
      gap: 16px;
      margin-top: 8px;

      .review-date {
        font-size: 0.9em;
        opacity: 0.7;
      }
    }
  }

  mat-card-content {
    .review-title {
      margin: 16px 0 8px 0;
      font-size: 1.05em;
    }

    .review-comment {
      line-height: 1.6;
      margin: 0;
      opacity: 0.87;
    }
  }

  mat-card-actions {
    button {
      mat-icon {
        margin-right: 4px;
        font-size: 20px;
      }
    }
  }
}

.orders-placeholder {
  text-align: center;
  padding: 80px 20px;

  mat-icon {
    font-size: 80px;
    width: 80px;
    height: 80px;
    margin: 0 auto 20px;
    opacity: 0.3;
  }

  p {
    font-size: 1.1em;
    margin-bottom: 20px;
    opacity: 0.7;
  }

  button {
    mat-icon {
      margin-right: 8px;
    }
  }
}

// Responsive styles
@media (max-width: 768px) {
  .profile-header {
    flex-direction: column;
    align-items: stretch;
    gap: 16px;

    button {
      width: 100%;
    }
  }

  .form-grid {
    grid-template-columns: 1fr;
  }

  .preferences-grid {
    grid-template-columns: 1fr;
  }

  .reviews-stats {
    flex-direction: column;
    gap: 24px;
  }
}
</file>

<file path="frontend/src/app/shared/components/star-rating/star-rating.component.ts">
// frontend/src/app/shared/components/star-rating/star-rating.component.ts
import { Component, Input, Output, EventEmitter } from '@angular/core';
import { CommonModule } from '@angular/common';
import { MatIconModule } from '@angular/material/icon';

@Component({
  selector: 'app-star-rating',
  standalone: true,
  imports: [CommonModule, MatIconModule],
  template: `
    <div class="star-rating" [class.readonly]="readonly">
      <mat-icon 
        *ngFor="let star of stars; let i = index"
        [class.filled]="i < displayRating"
        [class.half-filled]="showHalf && i === Math.floor(displayRating) && displayRating % 1 !== 0"
        (click)="!readonly && rate(i + 1)"
        (mouseenter)="!readonly && setHoverRating(i + 1)"
        (mouseleave)="!readonly && clearHoverRating()">
        {{ getStarIcon(i) }}
      </mat-icon>
      <span class="rating-text" *ngIf="showText">
        {{ displayRating.toFixed(1) }} / 5.0
        <span *ngIf="reviewCount !== undefined"> ({{ reviewCount }} {{ reviewCount === 1 ? 'recenzie' : 'recenzii' }})</span>
      </span>
    </div>
  `,
  styles: [`
    .star-rating {
      display: inline-flex;
      align-items: center;
      gap: 2px;
      
      &.readonly {
        pointer-events: none;
      }
      
      mat-icon {
        color: #ddd;
        font-size: 24px;
        width: 24px;
        height: 24px;
        cursor: pointer;
        transition: color 0.2s;
        
        &.filled {
          color: #ffc107;
        }
        
        &.half-filled {
          position: relative;
          
          &::after {
            content: 'star_half';
            position: absolute;
            left: 0;
            color: #ffc107;
          }
        }
        
        &:hover {
          transform: scale(1.1);
        }
      }
      
      .rating-text {
        margin-left: 8px;
        color: #666;
        font-size: 0.9em;
      }
    }
    
    :host-context(.readonly) mat-icon {
      cursor: default;
      
      &:hover {
        transform: none;
      }
    }
  `]
})
export class StarRatingComponent {
  @Input() rating: number = 0;
  @Input() readonly: boolean = false;
  @Input() showText: boolean = false;
  @Input() showHalf: boolean = true;
  @Input() reviewCount?: number;
  @Output() ratingChange = new EventEmitter<number>();

  stars: number[] = [1, 2, 3, 4, 5];
  hoverRating: number = 0;
  Math = Math;

  get displayRating(): number {
    return this.hoverRating || this.rating;
  }

  rate(rating: number): void {
    if (!this.readonly) {
      this.rating = rating;
      this.ratingChange.emit(rating);
    }
  }

  setHoverRating(rating: number): void {
    if (!this.readonly) {
      this.hoverRating = rating;
    }
  }

  clearHoverRating(): void {
    this.hoverRating = 0;
  }

  getStarIcon(index: number): string {
    const rating = this.displayRating;
    if (index < Math.floor(rating)) {
      return 'star';
    } else if (this.showHalf && index === Math.floor(rating) && rating % 1 >= 0.5) {
      return 'star_half';
    } else {
      return 'star_border';
    }
  }
}
</file>

<file path="frontend/src/app/shared/models/cart.model.ts">
// frontend/src/app/shared/models/cart.model.ts
export interface Cart {
  id?: number;
  items: CartItem[];
  totalAmount: number;
  lastUpdated?: string;
  totalItems: number;
}

export interface CartItem {
  id?: number;
  productId: number;
  productName: string;
  productDescription?: string;
  productPrice: number;
  productStock: number;
  productImageBase64?: string;
  quantity: number;
  subtotal: number;
}

export interface AddToCartRequest {
  productId: number;
  quantity: number;
}

export interface UpdateCartItemRequest {
  quantity: number;
}

export interface CheckoutRequest {
  fullName: string;
  email: string;
  phone: string;
  billingAddress: string;
  shippingAddress?: string;
  paymentMethod: 'CARD' | 'CASH_ON_DELIVERY' | 'BANK_TRANSFER';
  orderNotes?: string;
  agreeToTerms: boolean;
}
</file>

<file path="frontend/src/app/shared/models/category.model.ts">
export interface Category {
  id?: number;
  name: string;
  description?: string;
}
</file>

<file path="frontend/src/app/shared/models/order-item.model.ts">
// src/app/shared/models/order-item.model.ts

export interface OrderItem {
  id?: number;
  productId: number;
  productNameSnapshot?: string;         // Corect
  //productImageBase64Snapshot?: string;  // Corect
  quantity: number;
  priceAtPurchase?: number;
  lineTotal?: number;
}
</file>

<file path="frontend/src/app/shared/models/order-status-update.model.ts">
export interface OrderStatusUpdate {
  newStatus: string;
}
</file>

<file path="frontend/src/app/shared/models/order.model.ts">
// src/app/shared/models/order.model.ts
import { OrderItem } from './order-item.model'; // <<< CORECTAT: Importă OrderItem

/**
 * Interfață pentru reprezentarea unei comenzi,
 * aliniată cu OrderDto din backend.
 */
export interface Order {
  id?: number;
  userId?: number;
  username?: string;
  orderDate?: string;
  status: string;
  totalAmount?: number;
  customerName: string;
  shippingAddress: string;
  customerEmail: string;
  customerPhone: string;
  orderItems: OrderItem[]; // Acum OrderItem este cunoscut
}
</file>

<file path="frontend/src/app/shared/models/report.model.ts">
export interface SalesReport {
  totalSales: number;
  totalRevenue: number;
  periodStart: Date;
  periodEnd: Date;
  dailySales: DailySales[];
  topSellingProducts: ProductSales[];
  categorySales: CategorySales[];
}

export interface DailySales {
  date: string;
  salesCount: number;
  revenue: number;
}

export interface ProductSales {
  productId: number;
  productName: string;
  category: string;
  quantitySold: number;
  revenue: number;
  currentStock: number;
}

export interface CategorySales {
  category: string;
  quantitySold: number;
  revenue: number;
}

export interface StockReport {
  totalProducts: number;
  totalStockValue: number;
  lowStockProducts: StockItem[];
  outOfStockProducts: StockItem[];
  categoryStock: CategoryStock[];
}

export interface StockItem {
  productId: number;
  productName: string;
  category: string;
  currentStock: number;
  price: number;
  stockValue: number;
}

export interface CategoryStock {
  category: string;
  totalProducts: number;
  totalStock: number;
  stockValue: number;
}

export interface UserReport {
  totalUsers: number;
  activeUsers: number;
  newUsersThisMonth: number;
  usersByRole: UserRoleCount[];
  recentRegistrations: UserInfo[];
}

export interface UserRoleCount {
  role: string;
  count: number;
}

export interface UserInfo {
  id: number;
  username: string;
  email: string;
  registrationDate: Date;
  lastLoginDate: Date;
  isActive: boolean;
}

export interface GeneralReport {
  generatedAt: Date;
  reportPeriod: ReportPeriod;
  salesReport: SalesReport;
  stockReport: StockReport;
  userReport: UserReport;
}

export interface ReportPeriod {
  startDate: Date;
  endDate: Date;
  type: 'daily' | 'weekly' | 'monthly' | 'yearly' | 'custom';
}
</file>

<file path="frontend/src/app/shared/models/review.model.ts">
// frontend/src/app/shared/models/review.model.ts
export interface Review {
  id?: number;
  productId: number;
  productName?: string;
  userId: number;
  username: string;
  rating: number;
  title?: string;
  comment?: string;
  createdAt: string;
  updatedAt?: string;
}

export interface CreateReviewRequest {
  productId: number;
  rating: number;
  title?: string;
  comment?: string;
}

export interface ProductReviewSummary {
  averageRating: number;
  totalReviews: number;
  ratingDistribution: { [key: number]: number };
}

export interface ReviewPage {
  content: Review[];
  totalElements: number;
  totalPages: number;
  size: number;
  number: number;
}
</file>

<file path="frontend/src/app/shared/models/specification-definition.model.ts">
export interface SpecificationDefinition {
  id: number;
  name: string;
  unit?: string;
}
</file>

<file path="frontend/src/app/shared/models/specification-value.model.ts">
export interface SpecificationValue {
  definitionId?: number;
  name?: string;
  value: string;
  unit?: string;
}
</file>

<file path="frontend/src/app/shared/models/user.model.ts">
export interface User {
  id: number;
  username: string;
  email: string;
  roles: string[];
}

export interface UserUpdateDto {
  email: string;
  roles: string[];
}

// Ar putea fi util să ai și un model pentru răspunsul JWT de la login
export interface JwtResponse {
    token: string;
    type?: string; // Usually 'Bearer'
    id: number;
    username: string;
    email: string;
    roles: string[];
}

// Model pentru LoginRequest (dacă vrei să-l typezi explicit în AuthService)
export interface LoginRequest {
    username?: string; // Optional dacă folosești un DTO mai generic
    password?: string;
}

// Model pentru SignupRequest (dacă vrei să-l typezi explicit în AuthService/SignupComponent)
export interface SignupRequest {
    username?: string;
    email?: string;
    password?: string;
    role?: string[]; // Poate fi un set de roluri la înregistrare
}
</file>

<file path="frontend/src/app/shared/pipes/nl2br.pipe.ts">
// src/app/shared/pipes/nl2br.pipe.ts
import { Pipe, PipeTransform } from '@angular/core';
import { DomSanitizer, SafeHtml } from '@angular/platform-browser';

@Pipe({
  name: 'nl2br',
  standalone: true // Fă-l standalone pentru importare ușoară
})
export class Nl2brPipe implements PipeTransform {
  constructor(private sanitizer: DomSanitizer) {}

  transform(value: string | null | undefined): SafeHtml {
    if (value === null || value === undefined) {
      return '';
    }
    // Înlocuiește secvențele de linie nouă (\n, \r\n, \r) cu <br />
    // și sanitizează HTML-ul rezultat pentru securitate.
    return this.sanitizer.bypassSecurityTrustHtml(value.replace(/(\r\n|\n|\r)/gm, '<br />'));
  }
}
</file>

<file path="frontend/src/app/signup/signup.component.html">
<div class="signup-container">
  <mat-card class="signup-card">
    <mat-card-header>
      <mat-card-title>Înregistrare</mat-card-title>
      <mat-card-subtitle>Creează un cont nou</mat-card-subtitle>
    </mat-card-header>
    <mat-card-content>
      <form [formGroup]="signupForm" (ngSubmit)="onSubmit()">
        <mat-form-field appearance="outline" class="full-width">
          <mat-label>Nume de Utilizator</mat-label>
          <input matInput formControlName="username" placeholder="Ex: ion.popescu" required>
          <mat-icon matSuffix>person_outline</mat-icon>
          <mat-error *ngIf="f['username'].hasError('required')">
            Numele de utilizator este obligatoriu.
          </mat-error>
          <mat-error *ngIf="f['username'].hasError('minlength')">
            Minim 3 caractere.
          </mat-error>
          <mat-error *ngIf="f['username'].hasError('maxlength')">
            Maxim 20 de caractere.
          </mat-error>
        </mat-form-field>

        <mat-form-field appearance="outline" class="full-width">
          <mat-label>Adresă Email</mat-label>
          <input matInput type="email" formControlName="email" placeholder="email@example.com" required>
          <mat-icon matSuffix>email</mat-icon>
          <mat-error *ngIf="f['email'].hasError('required')">
            Email-ul este obligatoriu.
          </mat-error>
          <mat-error *ngIf="f['email'].hasError('email')">
            Format email invalid.
          </mat-error>
          <mat-error *ngIf="f['email'].hasError('maxlength')">
            Maxim 50 de caractere.
          </mat-error>
        </mat-form-field>

        <mat-form-field appearance="outline" class="full-width">
          <mat-label>Parolă</mat-label>
          <input matInput [type]="hidePassword ? 'password' : 'text'" formControlName="password" required>
          <button mat-icon-button matSuffix (click)="togglePasswordVisibility()" type="button" 
                  [attr.aria-label]="'Ascunde/Arată parola'" [attr.aria-pressed]="hidePassword">
            <mat-icon>{{hidePassword ? 'visibility_off' : 'visibility'}}</mat-icon>
          </button>
          <mat-error *ngIf="f['password'].hasError('required')">
            Parola este obligatorie.
          </mat-error>
          <mat-error *ngIf="f['password'].hasError('minlength')">
            Minim 6 caractere.
          </mat-error>
          <mat-error *ngIf="f['password'].hasError('maxlength')">
            Maxim 40 de caractere.
          </mat-error>
        </mat-form-field>

        <mat-form-field appearance="outline" class="full-width">
          <mat-label>Confirmă Parola</mat-label>
          <input matInput [type]="hideConfirmPassword ? 'password' : 'text'" formControlName="confirmPassword" required>
          <button mat-icon-button matSuffix (click)="toggleConfirmPasswordVisibility()" type="button"
                  [attr.aria-label]="'Ascunde/Arată parola'" [attr.aria-pressed]="hideConfirmPassword">
            <mat-icon>{{hideConfirmPassword ? 'visibility_off' : 'visibility'}}</mat-icon>
          </button>
          <mat-error *ngIf="f['confirmPassword'].hasError('required')">
            Confirmarea parolei este obligatorie.
          </mat-error>
          <mat-error *ngIf="f['confirmPassword'].hasError('passwordMismatch')">
            Parolele nu se potrivesc.
          </mat-error>
        </mat-form-field>

        <button mat-raised-button color="primary" type="submit" class="full-width signup-button" 
                [disabled]="isLoading || signupForm.invalid">
          <mat-spinner *ngIf="isLoading" diameter="20" mode="indeterminate" class="button-spinner"></mat-spinner>
          <span *ngIf="!isLoading">Creează Cont</span>
        </button>
      </form>
    </mat-card-content>
    <mat-card-actions class="signup-card-actions-center">
      <p class="login-link">
        Ai deja un cont? <a routerLink="/login">Autentifică-te aici!</a>
      </p>
    </mat-card-actions>
  </mat-card>
</div>
</file>

<file path="frontend/src/app/signup/signup.component.ts">
import { Component, OnInit, inject } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ReactiveFormsModule, FormBuilder, FormGroup, Validators, AbstractControl } from '@angular/forms';
import { Router, RouterModule } from '@angular/router';
import { MatCardModule } from '@angular/material/card';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';

import { AuthService } from '../auth/auth.service';
import { SignupRequest } from '../shared/models/user.model';

@Component({
  selector: 'app-signup',
  standalone: true,
  imports: [
    CommonModule,
    RouterModule,
    ReactiveFormsModule,
    MatCardModule,
    MatFormFieldModule,
    MatInputModule,
    MatButtonModule,
    MatIconModule,
    MatSnackBarModule,
    MatProgressSpinnerModule
  ],
  templateUrl: './signup.component.html',
  styleUrls: ['./signup.component.scss']
})
export class SignupComponent implements OnInit {
  signupForm!: FormGroup;
  isLoading = false;
  hidePassword = true;
  hideConfirmPassword = true;

  private fb = inject(FormBuilder);
  private authService = inject(AuthService);
  private router = inject(Router);
  private snackBar = inject(MatSnackBar);

  ngOnInit(): void {
    this.signupForm = this.fb.group({
      username: ['', [Validators.required, Validators.minLength(3), Validators.maxLength(20)]],
      email: ['', [Validators.required, Validators.email, Validators.maxLength(50)]],
      password: ['', [Validators.required, Validators.minLength(6), Validators.maxLength(40)]],
      confirmPassword: ['', [Validators.required]]
    }, { validators: this.passwordMatchValidator });

    // Dacă utilizatorul este deja logat, redirecționează
    if (this.authService.isLoggedIn()) {
      const userRole = this.authService.role;
      if (userRole === 'admin') {
        this.router.navigate(['/admin']);
      } else {
        this.router.navigate(['/']);
      }
    }
  }

  // Custom validator pentru verificarea potrivirii parolelor
  passwordMatchValidator(control: AbstractControl): {[key: string]: boolean} | null {
    const password = control.get('password');
    const confirmPassword = control.get('confirmPassword');
    
    if (!password || !confirmPassword) {
      return null;
    }
    
    if (password.value !== confirmPassword.value) {
      confirmPassword.setErrors({ passwordMismatch: true });
      return { passwordMismatch: true };
    } else {
      // Dacă parolele se potrivesc, eliminăm eroarea passwordMismatch
      const errors = confirmPassword.errors;
      if (errors) {
        delete errors['passwordMismatch'];
        // Dacă nu mai sunt alte erori, setăm errors la null
        if (Object.keys(errors).length === 0) {
          confirmPassword.setErrors(null);
        }
      }
      return null;
    }
  }

  onSubmit(): void {
    if (this.signupForm.invalid) {
      this.snackBar.open('Vă rugăm completați corect toate câmpurile.', 'OK', { duration: 3000 });
      this.signupForm.markAllAsTouched();
      return;
    }

    this.isLoading = true;
    const { username, email, password } = this.signupForm.value;
    
    const signupData: SignupRequest = {
      username,
      email,
      password,
      // Nu trimitem roluri - backend-ul va seta automat ROLE_USER
    };

    this.authService.signup(signupData).subscribe({
      next: (response) => {
        this.isLoading = false;
        this.snackBar.open('Cont creat cu succes! Te poți autentifica acum.', 'OK', { duration: 3000 });
        this.router.navigate(['/login']);
      },
      error: (err) => {
        this.isLoading = false;
        let errorMessage = 'Înregistrare eșuată. Vă rugăm încercați din nou.';
        
        if (err.error?.message) {
          errorMessage = err.error.message;
        } else if (err.message) {
          errorMessage = err.message;
        }
        
        this.snackBar.open(errorMessage, 'Închide', { duration: 5000 });
        console.error('Signup error:', err);
      }
    });
  }

  togglePasswordVisibility(): void {
    this.hidePassword = !this.hidePassword;
  }

  toggleConfirmPasswordVisibility(): void {
    this.hideConfirmPassword = !this.hideConfirmPassword;
  }

  get f() { return this.signupForm.controls; }
}
</file>

<file path="frontend/src/index.html">
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>MagazinCalculatoare</title>
  <base href="/">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" type="image/x-icon" href="favicon.ico">
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
</head>
<body class="mat-typography">
  <app-root></app-root>
</body>
</html>
</file>

<file path="frontend/src/main.server.ts">
import { bootstrapApplication } from '@angular/platform-browser';
import { AppComponent } from './app/app.component';
import { config } from './app/app.config.server';

const bootstrap = () => bootstrapApplication(AppComponent, config);

export default bootstrap;
</file>

<file path="frontend/src/main.ts">
import { bootstrapApplication } from '@angular/platform-browser';
import { AppComponent }         from './app/app.component';
import { appConfig }            from './app/app.config';

bootstrapApplication(AppComponent, appConfig)
  .catch(err => console.error('Bootstrap error:', err));
</file>

<file path="frontend/src/server.ts">
import {
  AngularNodeAppEngine,
  createNodeRequestHandler,
  isMainModule,
  writeResponseToNodeResponse,
} from '@angular/ssr/node';
import express from 'express';
import { dirname, resolve } from 'node:path';
import { fileURLToPath } from 'node:url';

const serverDistFolder = dirname(fileURLToPath(import.meta.url));
const browserDistFolder = resolve(serverDistFolder, '../browser');

const app = express();
const angularApp = new AngularNodeAppEngine();

/**
 * Example Express Rest API endpoints can be defined here.
 * Uncomment and define endpoints as necessary.
 *
 * Example:
 * ```ts
 * app.get('/api/**', (req, res) => {
 *   // Handle API request
 * });
 * ```
 */

/**
 * Serve static files from /browser
 */
app.use(
  express.static(browserDistFolder, {
    maxAge: '1y',
    index: false,
    redirect: false,
  }),
);

/**
 * Handle all other requests by rendering the Angular application.
 */
app.use('/**', (req, res, next) => {
  angularApp
    .handle(req)
    .then((response) =>
      response ? writeResponseToNodeResponse(response, res) : next(),
    )
    .catch(next);
});

/**
 * Start the server if this module is the main entry point.
 * The server listens on the port defined by the `PORT` environment variable, or defaults to 4000.
 */
if (isMainModule(import.meta.url)) {
  const port = process.env['PORT'] || 4000;
  app.listen(port, () => {
    console.log(`Node Express server listening on http://localhost:${port}`);
  });
}

/**
 * Request handler used by the Angular CLI (for dev-server and during build) or Firebase Cloud Functions.
 */
export const reqHandler = createNodeRequestHandler(app);
</file>

<file path="frontend/tsconfig.app.json">
/* To learn more about Typescript configuration file: https://www.typescriptlang.org/docs/handbook/tsconfig-json.html. */
/* To learn more about Angular compiler options: https://angular.dev/reference/configs/angular-compiler-options. */
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "outDir": "./out-tsc/app",
    "types": [
      "node"
    ]
  },
  "files": [
    "src/main.ts",
    "src/main.server.ts",
    "src/server.ts"
  ],
  "include": [
    "src/**/*.d.ts"
  ]
}
</file>

<file path="frontend/tsconfig.json">
/* To learn more about Typescript configuration file: https://www.typescriptlang.org/docs/handbook/tsconfig-json.html. */
/* To learn more about Angular compiler options: https://angular.dev/reference/configs/angular-compiler-options. */
{
  "compileOnSave": false,
  "compilerOptions": {
    "outDir": "./dist/out-tsc",
    "strict": true,
    "noImplicitOverride": true,
    "noPropertyAccessFromIndexSignature": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "skipLibCheck": true,
    "isolatedModules": true,
    "esModuleInterop": true,
    "experimentalDecorators": true,
    "moduleResolution": "bundler",
    "importHelpers": true,
    "target": "ES2022",
    "module": "ES2022"
  },
  "angularCompilerOptions": {
    "enableI18nLegacyMessageIdFormat": false,
    "strictInjectionParameters": true,
    "strictInputAccessModifiers": true,
    "strictTemplates": true
  }
}
</file>

<file path="frontend/tsconfig.spec.json">
/* To learn more about Typescript configuration file: https://www.typescriptlang.org/docs/handbook/tsconfig-json.html. */
/* To learn more about Angular compiler options: https://angular.dev/reference/configs/angular-compiler-options. */
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "outDir": "./out-tsc/spec",
    "types": [
      "jasmine"
    ]
  },
  "include": [
    "src/**/*.spec.ts",
    "src/**/*.d.ts"
  ]
}
</file>

<file path="package.json">
{
  "dependencies": {
    "repomix": "^0.3.9"
  }
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/config/WebConfig.java">
package com.magazincomputere.magazin_api.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class WebConfig implements WebMvcConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**") // Se aplică tuturor endpoint-urilor
                // MODIFICARE: Specificăm explicit originea permisă în loc de "*"
                .allowedOrigins("http://localhost:4200", "http://localhost:8080") 
                .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS") // Metodele HTTP permise
                .allowedHeaders("*") // Permite toate headerele
                .allowCredentials(true); // Permite trimiterea de credentials (cookies, token-uri etc.)
    }
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/controller/CartController.java">
// backend/src/main/java/com/magazincomputere/magazin_api/controller/CartController.java
package com.magazincomputere.magazin_api.controller;

import com.magazincomputere.magazin_api.dto.*;
import com.magazincomputere.magazin_api.security.services.UserDetailsImpl;
import com.magazincomputere.magazin_api.service.CartService;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/cart")
public class CartController {

    @Autowired
    private CartService cartService;

    @GetMapping
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<CartDto> getCart() {
        Long userId = getCurrentUserId();
        CartDto cart = cartService.getCartByUserId(userId);
        return ResponseEntity.ok(cart);
    }

    @PostMapping("/items")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<CartDto> addToCart(@Valid @RequestBody AddToCartRequest request) {
        Long userId = getCurrentUserId();
        CartDto cart = cartService.addToCart(userId, request);
        return new ResponseEntity<>(cart, HttpStatus.CREATED);
    }

    @PutMapping("/items/{productId}")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<CartDto> updateCartItem(
            @PathVariable Long productId,
            @Valid @RequestBody UpdateCartItemRequest request) {
        Long userId = getCurrentUserId();
        CartDto cart = cartService.updateCartItem(userId, productId, request);
        return ResponseEntity.ok(cart);
    }

    @DeleteMapping("/items/{productId}")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<CartDto> removeFromCart(@PathVariable Long productId) {
        Long userId = getCurrentUserId();
        CartDto cart = cartService.removeFromCart(userId, productId);
        return ResponseEntity.ok(cart);
    }

    @DeleteMapping("/clear")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<Void> clearCart() {
        Long userId = getCurrentUserId();
        cartService.clearCart(userId);
        return ResponseEntity.noContent().build();
    }

    @PostMapping("/checkout")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<OrderDto> checkout(@Valid @RequestBody CheckoutRequest request) {
        Long userId = getCurrentUserId();
        OrderDto order = cartService.checkout(userId, request);
        return new ResponseEntity<>(order, HttpStatus.CREATED);
    }

    private Long getCurrentUserId() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        UserDetailsImpl userDetails = (UserDetailsImpl) authentication.getPrincipal();
        return userDetails.getId();
    }
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/controller/UserController.java">
// backend/src/main/java/com/magazincomputere/magazin_api/controller/UserController.java
package com.magazincomputere.magazin_api.controller;

import com.magazincomputere.magazin_api.dto.UserDto;
import com.magazincomputere.magazin_api.dto.UserUpdateDto;
import com.magazincomputere.magazin_api.service.UserService;
import com.magazincomputere.magazin_api.security.services.UserDetailsImpl;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.*;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/users")
public class UserController {

    @Autowired
    private UserService userService;

    // New endpoint for users to get their own profile
    @GetMapping("/me")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<UserDto> getMyProfile() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        UserDetailsImpl userDetails = (UserDetailsImpl) authentication.getPrincipal();
        UserDto userDto = userService.findUserById(userDetails.getId());
        return ResponseEntity.ok(userDto);
    }

    // New endpoint for users to update their own profile
    @PutMapping("/me")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<?> updateMyProfile(
            @Valid @RequestBody UserUpdateDto userUpdateDto,
            BindingResult bindingResult) {
        
        if (bindingResult.hasErrors()) {
            Map<String, String> fieldErrors = new HashMap<>();
            bindingResult.getFieldErrors().forEach(error -> 
                fieldErrors.put(error.getField(), error.getDefaultMessage())
            );
            
            Map<String, Object> errorResponse = new HashMap<>();
            errorResponse.put("message", "Input data validation failed");
            errorResponse.put("fieldErrors", fieldErrors);
            
            return ResponseEntity.badRequest().body(errorResponse);
        }
        
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        UserDetailsImpl userDetails = (UserDetailsImpl) authentication.getPrincipal();
        
        try {
            // For user's own profile update, don't allow role changes
            userUpdateDto.setRoles(null); // Clear any role changes
            UserDto updatedUser = userService.updateUser(userDetails.getId(), userUpdateDto);
            return ResponseEntity.ok(updatedUser);
        } catch (Exception e) {
            Map<String, String> errorResponse = new HashMap<>();
            errorResponse.put("message", e.getMessage());
            return ResponseEntity.badRequest().body(errorResponse);
        }
    }

    // Existing admin endpoints remain unchanged
    @GetMapping
    @PreAuthorize("hasRole('ADMIN')")
    public List<UserDto> getAllUsers() {
        return userService.findAllUsers();
    }

    @GetMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<UserDto> getUserById(@PathVariable Long id) {
        UserDto userDto = userService.findUserById(id);
        return ResponseEntity.ok(userDto);
    }

    @PutMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<?> updateUser(
            @PathVariable Long id, 
            @Valid @RequestBody UserUpdateDto userUpdateDto,
            BindingResult bindingResult) {
        
        if (bindingResult.hasErrors()) {
            Map<String, String> fieldErrors = new HashMap<>();
            bindingResult.getFieldErrors().forEach(error -> 
                fieldErrors.put(error.getField(), error.getDefaultMessage())
            );
            
            Map<String, Object> errorResponse = new HashMap<>();
            errorResponse.put("message", "Input data validation failed");
            errorResponse.put("fieldErrors", fieldErrors);
            
            return ResponseEntity.badRequest().body(errorResponse);
        }
        
        try {
            System.out.println("Updating user " + id + " with data: " + userUpdateDto);
            UserDto updatedUser = userService.updateUser(id, userUpdateDto);
            return ResponseEntity.ok(updatedUser);
        } catch (Exception e) {
            Map<String, String> errorResponse = new HashMap<>();
            errorResponse.put("message", e.getMessage());
            return ResponseEntity.badRequest().body(errorResponse);
        }
    }

    @DeleteMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<Void> deleteUser(@PathVariable Long id) {
        userService.deleteUser(id);
        return ResponseEntity.noContent().build();
    }
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/dto/OrderItemDto.java">
// src/main/java/com/magazincomputere/magazin_api/dto/OrderItemDto.java
package com.magazincomputere.magazin_api.dto;

import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotNull;
import lombok.Data;
import java.math.BigDecimal;

@Data
public class OrderItemDto {
    private Long id;

    @NotNull(message = "ID-ul produsului este obligatoriu")
    private Long productId; // ID-ul produsului original

    private String productNameSnapshot;
    // private String productImageBase64Snapshot; // COMENTAT TEMPORAR

    @NotNull(message = "Cantitatea este obligatorie")
    @Min(value = 1, message = "Cantitatea trebuie să fie cel puțin 1")
    private Integer quantity;

    private BigDecimal priceAtPurchase;
    private BigDecimal lineTotal;
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/model/OrderItem.java">
// src/main/java/com/magazincomputere/magazin_api/model/OrderItem.java
package com.magazincomputere.magazin_api.model;

import java.math.BigDecimal;

import jakarta.persistence.*;
import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Entity
@Table(name = "order_items")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class OrderItem {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "order_id", nullable = false)
    private Order order;

    @NotNull(message = "ID-ul produsului este obligatoriu pentru un articol de comandă")
    @Column(nullable = false)
    private Long productIdSnapshot;

    @NotNull(message = "Numele produsului este obligatoriu")
    @Column(nullable = false)
    private String productNameSnapshot;

    // @Lob
    // @Column(columnDefinition = "TEXT")
    // private String productImageBase64Snapshot; // COMENTAT TEMPORAR

    @NotNull(message = "Cantitatea este obligatorie")
    @Min(value = 1, message = "Cantitatea trebuie să fie cel puțin 1")
    @Column(nullable = false)
    private Integer quantity;

    @NotNull(message = "Prețul la achiziție este obligatoriu")
    @Column(nullable = false)
    private BigDecimal priceAtPurchase;

    @NotNull(message = "Totalul liniei este obligatoriu")
    @Column(nullable = false)
    private BigDecimal lineTotal;
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/model/Role.java">
// src/main/java/com/magazincomputere/magazin_api/model/Role.java
package com.magazincomputere.magazin_api.model;

import jakarta.persistence.*;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import org.hibernate.annotations.JdbcTypeCode; // << IMPORTĂ ACEASTA
import org.hibernate.type.SqlTypes;           // << IMPORTĂ ACEASTA

@Entity
@Table(name = "roles")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Role {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;

    @Enumerated(EnumType.STRING)
    @JdbcTypeCode(SqlTypes.VARCHAR) // << ADAUGĂ ACEASTĂ ADNOTARE
    @Column(length = 20, unique = true, nullable = false)
    private ERole name;
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/repository/CartRepository.java">
package com.magazincomputere.magazin_api.repository;

import com.magazincomputere.magazin_api.model.Cart;
import com.magazincomputere.magazin_api.model.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

@Repository
public interface CartRepository extends JpaRepository<Cart, Long> {
    Optional<Cart> findByUser(User user);
    
    Optional<Cart> findByUserId(Long userId);
    
    Optional<Cart> findBySessionId(String sessionId);
    
    
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/repository/OrderRepository.java">
// src/main/java/com/magazincomputere/magazin_api/repository/OrderRepository.java
package com.magazincomputere.magazin_api.repository;

import com.magazincomputere.magazin_api.model.Order;
import com.magazincomputere.magazin_api.model.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface OrderRepository extends JpaRepository<Order, Long> {

    /**
     * Găsește toate comenzile pentru un utilizator specific, ordonate descrescător după data comenzii.
     * @param user Utilizatorul pentru care se caută comenzile.
     * @return O listă de comenzi.
     */
    List<Order> findByUserOrderByOrderDateDesc(User user);

    /**
     * Găsește toate comenzile cu un anumit status, ordonate descrescător după data comenzii.
     * @param status Statusul comenzii.
     * @return O listă de comenzi.
     */
    List<Order> findByStatusOrderByOrderDateDesc(String status);

    /**
     * Găsește toate comenzile, ordonate descrescător după data comenzii.
     * @return O listă cu toate comenzile ordonate.
     */
    List<Order> findAllByOrderByOrderDateDesc();

    // Poți adăuga și alte metode custom de interogare aici dacă este necesar.
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/service/OrderService.java">
// src/main/java/com/magazincomputere/magazin_api/service/OrderService.java
package com.magazincomputere.magazin_api.service;

import com.magazincomputere.magazin_api.dto.OrderDto;
import com.magazincomputere.magazin_api.dto.OrderItemDto;
import com.magazincomputere.magazin_api.dto.OrderStatusUpdateDto;
import com.magazincomputere.magazin_api.exception.BadRequestException;
import com.magazincomputere.magazin_api.exception.ResourceNotFoundException;
import com.magazincomputere.magazin_api.model.*;
import com.magazincomputere.magazin_api.repository.*;
import jakarta.transaction.Transactional;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

@Service
public class OrderService {

    @Autowired
    private OrderRepository orderRepository;

    // @Autowired // Comentat - presupunem salvare prin cascadă din Order
    // private OrderItemRepository orderItemRepository; 

    @Autowired
    private ProductRepository productRepository;

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private CustomerRepository customerRepository;

    private OrderDto convertToDto(Order order) {
        OrderDto orderDto = new OrderDto();
        orderDto.setId(order.getId());
        if (order.getUser() != null) {
            orderDto.setUserId(order.getUser().getId());
            orderDto.setUsername(order.getUser().getUsername());
        } else if (order.getCustomer() != null) {
             orderDto.setUsername(order.getCustomer().getFirstName() + " " + order.getCustomer().getLastName());
        }
        orderDto.setOrderDate(order.getOrderDate());
        orderDto.setStatus(order.getStatus());
        orderDto.setTotalAmount(order.getTotalAmount()); // Direct BigDecimal to BigDecimal


        orderDto.setCustomerName(order.getShippingCustomerName());
        orderDto.setShippingAddress(order.getShippingAddress());
        orderDto.setCustomerEmail(order.getShippingCustomerEmail());
        orderDto.setCustomerPhone(order.getShippingCustomerPhone());

        if (order.getOrderItems() != null) {
            orderDto.setOrderItems(order.getOrderItems().stream()
                    .map(this::convertOrderItemToDto)
                    .collect(Collectors.toList()));
        }
        return orderDto;
    }

    private OrderItemDto convertOrderItemToDto(OrderItem orderItem) {
        OrderItemDto dto = new OrderItemDto();
        dto.setId(orderItem.getId());
        dto.setProductId(orderItem.getProductIdSnapshot());
        dto.setProductNameSnapshot(orderItem.getProductNameSnapshot());
        dto.setQuantity(orderItem.getQuantity());
        dto.setPriceAtPurchase(orderItem.getPriceAtPurchase()); // Direct BigDecimal to BigDecimal
        dto.setLineTotal(orderItem.getLineTotal()); // Direct BigDecimal to BigDecimal
        return dto;
    }


    @Transactional
    public OrderDto createOrder(OrderDto orderDto, Long userId) {
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new ResourceNotFoundException("User not found with id: " + userId));

        Customer customer = customerRepository.findByUserId(userId).orElseGet(() -> {
            Customer newCustomer = new Customer();
            newCustomer.setUser(user);
            newCustomer.setEmail(orderDto.getCustomerEmail());
            String[] nameParts = orderDto.getCustomerName().split(" ", 2);
            newCustomer.setFirstName(nameParts.length > 0 ? nameParts[0] : orderDto.getCustomerName());
            if (nameParts.length > 1) newCustomer.setLastName(nameParts[1]); else newCustomer.setLastName("");
            newCustomer.setPhone(orderDto.getCustomerPhone());
            newCustomer.setAddressDetails(orderDto.getShippingAddress());
            return customerRepository.save(newCustomer);
        });

        Order order = new Order();
        order.setUser(user);
        order.setCustomer(customer);
        order.setShippingCustomerName(orderDto.getCustomerName());
        order.setShippingAddress(orderDto.getShippingAddress());
        order.setShippingCustomerEmail(orderDto.getCustomerEmail());
        order.setShippingCustomerPhone(orderDto.getCustomerPhone());

        List<OrderItem> orderItemsList = new ArrayList<>();
        BigDecimal totalOrderAmount = BigDecimal.ZERO;

        if (orderDto.getOrderItems() == null || orderDto.getOrderItems().isEmpty()) {
            throw new BadRequestException("Order must contain at least one item.");
        }

        for (OrderItemDto itemDto : orderDto.getOrderItems()) {
            Product product = productRepository.findById(itemDto.getProductId())
                    .orElseThrow(() -> new ResourceNotFoundException("Product not found with id: " + itemDto.getProductId()));

            if (product.getStockQuantity() < itemDto.getQuantity()) {
                throw new BadRequestException("Insufficient stock for product: " + product.getName());
            }

            OrderItem orderItem = new OrderItem();
            orderItem.setOrder(order);
            orderItem.setProductIdSnapshot(product.getId());
            orderItem.setProductNameSnapshot(product.getName());
            orderItem.setQuantity(itemDto.getQuantity());
            
            // Acum `product.getPrice()` este deja BigDecimal
            BigDecimal itemPrice = product.getPrice(); 
            orderItem.setPriceAtPurchase(itemPrice); // Setează direct BigDecimal

            BigDecimal quantity = new BigDecimal(itemDto.getQuantity());
            BigDecimal lineTotal = itemPrice.multiply(quantity); 
            
            orderItem.setLineTotal(lineTotal); // Setează direct BigDecimal

            orderItemsList.add(orderItem);
            totalOrderAmount = totalOrderAmount.add(lineTotal);

            product.setStockQuantity(product.getStockQuantity() - itemDto.getQuantity());
            productRepository.save(product);
        }

        order.setOrderItems(orderItemsList);
        order.setTotalAmount(totalOrderAmount); // Setează direct BigDecimal

        Order savedOrder = orderRepository.save(order);
        return convertToDto(savedOrder);
    }

    public List<OrderDto> getOrdersByUser(Long userId) {
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new ResourceNotFoundException("User not found with id: " + userId));
        return orderRepository.findByUserOrderByOrderDateDesc(user)
                .stream()
                .map(this::convertToDto)
                .collect(Collectors.toList());
    }

    public List<OrderDto> getAllOrders(String status) {
        List<Order> orders;
        if (status != null && !status.trim().isEmpty()) {
            orders = orderRepository.findByStatusOrderByOrderDateDesc(status);
        } else {
            orders = orderRepository.findAllByOrderByOrderDateDesc();
        }
        return orders.stream().map(this::convertToDto).collect(Collectors.toList());
    }
     public OrderDto getOrderById(Long orderId) {
        Order order = orderRepository.findById(orderId)
                .orElseThrow(() -> new ResourceNotFoundException("Order not found with id: " + orderId));
        return convertToDto(order);
    }

    @Transactional
    public OrderDto updateOrderStatus(Long orderId, OrderStatusUpdateDto statusUpdateDto) {
        Order order = orderRepository.findById(orderId)
                .orElseThrow(() -> new ResourceNotFoundException("Order not found with id: " + orderId));

        // TODO: Adaugă validare pentru tranzițiile de status permise, dacă e necesar
        order.setStatus(statusUpdateDto.getNewStatus().toUpperCase());
        Order updatedOrder = orderRepository.save(order);
        return convertToDto(updatedOrder);
    }
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/service/UserService.java">
package com.magazincomputere.magazin_api.service;

import com.magazincomputere.magazin_api.dto.UserDto;
import com.magazincomputere.magazin_api.dto.UserUpdateDto; // Import the new DTO
import com.magazincomputere.magazin_api.exception.ResourceNotFoundException;
import com.magazincomputere.magazin_api.model.User;
import com.magazincomputere.magazin_api.model.Role;
import com.magazincomputere.magazin_api.model.ERole;
import com.magazincomputere.magazin_api.repository.UserRepository;
import com.magazincomputere.magazin_api.repository.RoleRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

@Service
public class UserService {

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private RoleRepository roleRepository;

    @Autowired
    private PasswordEncoder passwordEncoder;

    private UserDto convertToDto(User user) {
        UserDto dto = new UserDto();
        dto.setId(user.getId());
        dto.setUsername(user.getUsername());
        dto.setEmail(user.getEmail());
        if (user.getRoles() != null) {
            dto.setRoles(user.getRoles().stream()
                .map(role -> role.getName().name())
                .collect(Collectors.toSet()));
        }
        return dto;
    }

    @Transactional(readOnly = true)
    public List<UserDto> findAllUsers() {
        return userRepository.findAll().stream()
            .map(this::convertToDto)
            .collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public UserDto findUserById(Long id) {
        User user = userRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("User not found with id: " + id));
        return convertToDto(user);
    }

    @Transactional
    public UserDto updateUser(Long id, UserUpdateDto userUpdateDto) { // Accept UserUpdateDto
        User existingUser = userRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("User not found with id: " + id));

        // Log for debugging
        System.out.println("Existing user: " + existingUser.getUsername());
        System.out.println("Update data - email: " + userUpdateDto.getEmail());
        System.out.println("Update data - roles: " + userUpdateDto.getRoles());

        // Update email
        existingUser.setEmail(userUpdateDto.getEmail());

        // Update roles if provided
        if (userUpdateDto.getRoles() != null && !userUpdateDto.getRoles().isEmpty()) {
            Set<Role> newRoles = new HashSet<>();
            for (String roleName : userUpdateDto.getRoles()) {
                // Handle both with and without ROLE_ prefix
                String normalizedRoleName = roleName.startsWith("ROLE_") ? roleName : "ROLE_" + roleName;
                
                try {
                    ERole eRole = ERole.valueOf(normalizedRoleName);
                    Role role = roleRepository.findByName(eRole)
                            .orElseThrow(() -> new RuntimeException("Error: Role " + normalizedRoleName + " is not found."));
                    newRoles.add(role);
                } catch (IllegalArgumentException e) {
                    throw new RuntimeException("Error: Invalid role name " + roleName);
                }
            }
            existingUser.setRoles(newRoles);
        }

        User updatedUser = userRepository.save(existingUser);
        return convertToDto(updatedUser);
    }

    @Transactional
    public void deleteUser(Long id) {
        if (!userRepository.existsById(id)) {
            throw new ResourceNotFoundException("User not found with id: " + id);
        }
        userRepository.deleteById(id);
    }
}
</file>

<file path="backend/src/main/resources/application.properties">
# Server Port
server.port=8080

# MySQL Datasource Configuration
# Înlocuiește 'magazin_computere_db' cu numele bazei tale de date create în MySQL Workbench.
# Înlocuiește 'root' și 'parola_ta_mysql' cu userul și parola ta MySQL.
spring.datasource.url=jdbc:mysql://localhost:3306/licenta?useSSL=false&serverTimezone=UTC&allowPublicKeyRetrieval=true
spring.datasource.username=root
spring.datasource.password=wx9ec8rv7
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

# JPA and Hibernate Configuration for MySQL
# Pentru MySQL 8+, dialectul este org.hibernate.dialect.MySQLDialect sau org.hibernate.dialect.MySQL8Dialect (mai nou)
# Pentru versiuni mai vechi de MySQL (ex: 5.7), poți folosi org.hibernate.dialect.MySQL57Dialect
spring.jpa.database-platform=org.hibernate.dialect.MySQLDialect

# Strategia DDL (Data Definition Language)
# RECOMANDAT: 'validate' - Hibernate verifică dacă schema din DB corespunde cu entitățile. Eșuează la pornire dacă sunt nepotriviri.
# SAU: 'none' - Hibernate nu face nimic cu schema. Tu ești responsabil pentru crearea și actualizarea ei manuală.
# EVITĂ: 'update' pe termen lung sau în producție cu MySQL, deoarece poate fi imprevizibil.
# NICIODATĂ: 'create' sau 'create-drop' dacă vrei să păstrezi datele între reporniri.
spring.jpa.hibernate.ddl-auto=validate

# Afișare SQL generat de Hibernate (util pentru debugging)
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true
# spring.jpa.properties.hibernate.use_sql_comments=true # Opțional, adaugă comentarii în SQL-ul logat

# JWT Properties (rămân la fel)
app.jwtSecret=ThisIsMySuperLongAndVerySecureSecretKeyForMagazinComputereLicentaProject2025
app.jwtExpirationMs=86400000

# SpringDoc OpenAPI (Swagger UI) (rămân la fel)
springdoc.api-docs.path=/api-docs
springdoc.swagger-ui.path=/swagger-ui.html
springdoc.swagger-ui.operationsSorter=method
springdoc.swagger-ui.tagsSorter=alpha
# springdoc.swagger-ui.doc-expansion=none # Opțional, controlează cum se expandează documentația

# H2 Console (dezactivează-l când folosești MySQL sau PostgreSQL)
spring.h2.console.enabled=false
# spring.h2.console.path=/h2-console
# spring.h2.console.settings.trace=false
# spring.h2.console.settings.web-allow-others=false
</file>

<file path="frontend/src/app/app.config.ts">
// src/app/app.config.ts
import { ApplicationConfig, importProvidersFrom } from '@angular/core';
import { provideRouter, withComponentInputBinding, withInMemoryScrolling, withViewTransitions } from '@angular/router';
import { provideHttpClient, withFetch, withInterceptors, withInterceptorsFromDi, HTTP_INTERCEPTORS } from '@angular/common/http';
import { provideAnimations } from '@angular/platform-browser/animations';

// Comentează sau elimină HttpClientInMemoryWebApiModule pentru a folosi backend-ul real
// import { HttpClientInMemoryWebApiModule } from 'angular-in-memory-web-api';
// import { InMemoryDataService } from './shared/in-memory-data.service'; // Comentat

import { routes } from './app.routes';
import { AuthInterceptor } from './auth/auth.interceptor'; // <<<--- CALE CORECTATĂ

export const appConfig: ApplicationConfig = {
  providers: [
    provideRouter(
      routes,
      withComponentInputBinding(),
      withInMemoryScrolling({
        scrollPositionRestoration: 'enabled',
        anchorScrolling: 'enabled',
      }),
      withViewTransitions()
    ),

    provideAnimations(),

    provideHttpClient(
      withFetch(),
      withInterceptorsFromDi()
    ),

    { provide: HTTP_INTERCEPTORS, useClass: AuthInterceptor, multi: true },

    /*
    importProvidersFrom(
      HttpClientInMemoryWebApiModule.forRoot(InMemoryDataService, {
        dataEncapsulation: false,
        passThruUnknownUrl: true,
        delay: 300
      })
    )
    */
  ]
};
</file>

<file path="frontend/src/app/auth/admin.guard.ts">
// src/app/auth/admin.guard.ts
import { inject } from '@angular/core';
import { CanActivateFn, Router, UrlTree, ActivatedRouteSnapshot, RouterStateSnapshot } from '@angular/router';
import { AuthService } from './auth.service';

export const adminGuard: CanActivateFn = (route: ActivatedRouteSnapshot, state: RouterStateSnapshot): boolean | UrlTree => {
  const authService = inject(AuthService);
  const router = inject(Router);

  if (authService.isLoggedIn() && authService.role === 'admin') {
    return true;
  } else if (authService.isLoggedIn() && authService.role !== 'admin') {
    // Utilizator logat dar nu e admin, redirecționează la pagina lui de user
    console.warn('AdminGuard: User is logged in but not an admin. Redirecting to /user');
    return router.createUrlTree(['/user']); // Sau o pagină 'unauthorized' dedicată
  } else {
    // Utilizator nelogat
    console.warn('AdminGuard: User not logged in. Redirecting to /login with returnUrl:', state.url);
    return router.createUrlTree(['/login'], { queryParams: { returnUrl: state.url } });
  }
};
</file>

<file path="frontend/src/app/auth/auth.guard.ts">
// src/app/auth/auth.guard.ts
import { inject } from '@angular/core';
import { CanActivateFn, Router, UrlTree, ActivatedRouteSnapshot, RouterStateSnapshot } from '@angular/router';
import { AuthService } from './auth.service';
// Nu mai este nevoie de Observable, map, tap dacă nu facem operații asincrone complexe aici

export const authGuard: CanActivateFn = (route: ActivatedRouteSnapshot, state: RouterStateSnapshot): boolean | UrlTree => {
  const authService = inject(AuthService);
  const router = inject(Router);

  if (authService.isLoggedIn()) {
    return true;
  } else {
    // Redirecționează la pagina de login, salvând URL-ul curent pentru redirectare după login
    console.warn('AuthGuard: User not logged in. Redirecting to /login with returnUrl:', state.url);
    return router.createUrlTree(['/login'], { queryParams: { returnUrl: state.url } });
  }
};
</file>

<file path="frontend/src/app/auth/auth.interceptor.ts">
import { Injectable, inject } from '@angular/core';
import {
  HttpEvent,
  HttpInterceptor,
  HttpHandler,
  HttpRequest,
  HttpErrorResponse
} from '@angular/common/http';
import { Observable, throwError } from 'rxjs';
import { catchError } from 'rxjs/operators';
import { AuthService } from './auth.service';
import { Router } from '@angular/router';

@Injectable()
export class AuthInterceptor implements HttpInterceptor {
  private authService = inject(AuthService);
  private router = inject(Router);

  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    const authToken = this.authService.getToken();

    if (authToken && req.url.startsWith('/api')) {
      // Check token expiration
      if (this.isTokenExpired(authToken)) {
        this.authService.logout();
        this.router.navigate(['/login'], { queryParams: { sessionExpired: 'true' } });
        return throwError(() => new Error('Token expired'));
      }

      const authReq = req.clone({
        headers: req.headers.set('Authorization', `Bearer ${authToken}`)
      });

      return next.handle(authReq).pipe(
        catchError((error: HttpErrorResponse) => {
          if (error.status === 401) {
            this.authService.logout();
            this.router.navigate(['/login'], { queryParams: { sessionExpired: 'true' } });
            console.error('AuthInterceptor: Unauthorized request (401). Logging out.');
          }
          return throwError(() => error);
        })
      );
    }

    return next.handle(req);
  }

  private isTokenExpired(token: string): boolean {
    try {
      const payload = JSON.parse(atob(token.split('.')[1]));
      const expiry = payload.exp;
      return Math.floor(new Date().getTime() / 1000) >= expiry;
    } catch (e) {
      return true;
    }
  }
}
</file>

<file path="frontend/src/app/auth/user.guard.ts">
// src/app/auth/user.guard.ts
import { inject } from '@angular/core';
import { CanActivateFn, Router, UrlTree, ActivatedRouteSnapshot, RouterStateSnapshot } from '@angular/router';
import { AuthService } from './auth.service';

export const userGuard: CanActivateFn = (route: ActivatedRouteSnapshot, state: RouterStateSnapshot): boolean | UrlTree => {
  const authService = inject(AuthService);
  const router = inject(Router);

  if (authService.isLoggedIn() && authService.role === 'user') {
    return true;
  } else if (authService.isLoggedIn() && authService.role !== 'user') {
    // Utilizator logat dar nu e 'user' (ex: admin)
    console.warn('UserGuard: User is logged in but not a regular user. Role:', authService.role);
    if (authService.role === 'admin') {
      // Poți decide să permiți adminilor accesul sau să îi redirecționezi
      // return true; // Permite adminului să acceseze și paginile de user
      return router.createUrlTree(['/admin']); // Redirecționează adminul la panoul său
    }
    // Alt rol necunoscut, redirecționează la login
    return router.createUrlTree(['/login'], { queryParams: { returnUrl: state.url } });
  } else {
    // Utilizator nelogat
    console.warn('UserGuard: User not logged in. Redirecting to /login with returnUrl:', state.url);
    return router.createUrlTree(['/login'], { queryParams: { returnUrl: state.url } });
  }
};
</file>

<file path="frontend/src/app/features/admin/admin-categories/admin-category-form/admin-category-form.component.scss">
.admin-category-form-container {
  padding: 20px;
  max-width: 600px;
  margin: 20px auto;
}

mat-card-header {
  padding-bottom: 16px;
}

.full-width {
  width: 100%;
  margin-bottom: 16px;
}

.spinner-container {
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 200px;
}

.form-actions {
  display: flex;
  justify-content: flex-end;
  gap: 10px;
  margin-top: 20px;

  button {
    min-width: 120px;
    mat-icon {
      margin-right: 8px;
    }
  }
}

mat-error {
  font-size: 0.85em;
}
</file>

<file path="frontend/src/app/features/admin/admin-categories/admin-category-list/admin-category-list.component.scss">
.admin-category-list-container {
  padding: 20px;
  max-width: 800px;
  margin: 20px auto;
  border-radius: 8px;
  box-shadow: 0 2px 10px rgba(0,0,0,0.1);
}

.header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 24px;
  padding-bottom: 16px;
  border-bottom: 1px solid rgba(0,0,0,0.12);

  h2 {
    margin: 0;
    font-size: 1.6em;
  }
  button[mat-raised-button] mat-icon {
    margin-right: 8px;
  }
}

.loading-indicator,
.error-message,
.no-data {
  text-align: center;
  padding: 30px 20px;
  margin-top: 20px;
  font-size: 1.1em;

  mat-spinner {
    margin: 0 auto 15px auto;
  }
}

.error-message {
  color: #d32f2f;
  background-color: #ffebee;
  border: 1px solid #ffcdd2;
  border-radius: 4px;
  p {
    margin-bottom: 10px;
  }
}

mat-list {
  padding-top: 0;
}

h3[mat-subheader] {
  font-size: 1.2em;
  font-weight: 500;
  opacity: 0.87;
  margin-bottom: 8px;
}

.category-item {
  border-bottom: 1px solid rgba(0,0,0,0.08);
  padding: 12px 0;

  &:last-child {
    border-bottom: none;
  }

  &:hover {
    background-color: rgba(0,0,0,0.02);
  }

  mat-icon[matListItemIcon] {
    opacity: 0.54;
  }

  .description {
    font-size: 0.9em;
    opacity: 0.7;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 400px;
    padding-left: 16px;
  }

  .actions {
    button[mat-icon-button] {
      margin-left: 8px;
    }
  }
}
</file>

<file path="frontend/src/app/features/admin/admin-orders/admin-order-detail/admin-order-detail.component.scss">
.admin-order-detail-container {
  padding: 20px;
  max-width: 900px;
  margin: 20px auto;
}

.back-button {
  margin-bottom: 20px;
  mat-icon {
    margin-right: 8px;
  }
}

.loading-indicator,
.error-message {
  text-align: center;
  padding: 20px;
  mat-spinner {
    margin: 0 auto 10px auto;
  }
}

.order-details {
  display: grid;
  gap: 20px;
}

mat-card {
  width: 100%;
}

mat-card-header {
  padding-bottom: 16px;
}

.info-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: 10px 20px;
  margin-bottom: 16px;

  .full-width {
    grid-column: 1 / -1;
  }

  strong {
    font-weight: 500;
  }
}

.status-total {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-top: 16px;

  h3 {
    margin: 0;
    font-size: 1.1em;
    font-weight: 500;
  }
}

.status-chip-pending_confirmation { 
  background-color: #FFECB3 !important; 
  color: #795548 !important; 
}
.status-chip-approved { 
  background-color: #C8E6C9 !important; 
  color: #2E7D32 !important; 
}
.status-chip-processing { 
  background-color: #BBDEFB !important; 
  color: #1565C0 !important; 
}
.status-chip-shipped { 
  background-color: #B2EBF2 !important; 
  color: #006064 !important; 
}
.status-chip-delivered { 
  background-color: #DCEDC8 !important; 
  color: #558B2F !important; 
}
.status-chip-canceled { 
  background-color: #FFCDD2 !important; 
  color: #C62828 !important; 
}

.order-items-card {
  .order-item {
    border-bottom: 1px solid rgba(0,0,0,0.08);
    &:last-child {
      border-bottom: none;
    }
  }
  .item-subtotal {
    font-weight: 500;
  }
}

.status-update-card {
  .full-width {
    width: 100%;
    margin-bottom: 16px;
  }
  button[mat-raised-button] {
    display: inline-flex;
    align-items: center;
  }
}
</file>

<file path="frontend/src/app/features/admin/admin-orders/admin-order-list/admin-order-list.component.scss">
.admin-order-list-container {
  padding: 20px;
  max-width: 1200px;
  margin: auto;
}

.header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;

  h2 {
    margin: 0;
  }
}

.filter-field, .status-filter-field {
  width: 100%;
  max-width: 400px;
  margin-right: 16px;
  margin-bottom: 16px;
}

.status-filter-field {
   min-width: 200px;
}

.loading-indicator,
.error-message,
.no-data {
  text-align: center;
  padding: 20px;
  mat-spinner {
    margin: 0 auto 10px auto;
  }
}

.table-container {
  overflow-x: auto;
  margin-top: 20px;
}

table {
  width: 100%;
}

.mat-column-actions {
  width: 120px;
  text-align: right;
}

.mat-column-id {
  width: 100px;
}
.mat-column-totalAmount {
  width: 150px;
  text-align: right;
}
.mat-column-status {
  width: 200px;
  font-weight: 500;
}

.status-pending_confirmation { color: #FFC107; }
.status-approved { color: #4CAF50; }
.status-processing { color: #2196F3; }
.status-shipped { color: #00BCD4; }
.status-delivered { color: #8BC34A; }
.status-canceled { color: #F44336; }

.mat-row:hover {
  background-color: rgba(0,0,0,0.04);
}
</file>

<file path="frontend/src/app/features/admin/admin-specifications/admin-spec-def-form/admin-spec-def-form.component.scss">
.admin-spec-def-form-container {
  padding: 20px;
  max-width: 600px;
  margin: 20px auto;
}

mat-card-header {
  padding-bottom: 16px;
}

.full-width {
  width: 100%;
  margin-bottom: 16px;
}

.spinner-container {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  min-height: 150px;
  p {
    margin-top: 10px;
    opacity: 0.7;
  }
}

.form-actions {
  display: flex;
  justify-content: flex-end;
  gap: 10px;
  margin-top: 20px;
  button {
    min-width: 120px;
    mat-icon {
      margin-right: 8px;
    }
  }
}

mat-error {
  font-size: 0.85em;
}
</file>

<file path="frontend/src/app/features/admin/admin-users/admin-user-form/admin-user-form.component.scss">
.admin-user-form-container {
  padding: 20px;
  max-width: 700px;
  margin: 20px auto;
}

mat-card-header {
  padding-bottom: 16px;
}

.full-width {
  width: 100%;
  margin-bottom: 16px;
}

.spinner-container {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  min-height: 150px;
  p {
    margin-top: 10px;
    opacity: 0.7;
  }
}

.roles-checkbox-group {
  margin-bottom: 16px;
  .roles-label {
    display: block;
    margin-bottom: 8px;
    font-weight: 500;
    opacity: 0.7;
  }
  .role-checkbox {
    margin-right: 16px;
  }
}

.form-actions {
  display: flex;
  justify-content: flex-end;
  gap: 10px;
  margin-top: 20px;
  button {
    min-width: 120px;
    mat-icon {
      margin-right: 8px;
    }
  }
}

mat-error {
  font-size: 0.85em;
}
</file>

<file path="frontend/src/app/features/admin/admin-users/admin-user-form/admin-user-form.component.ts">
// src/app/features/admin/admin-users/admin-user-form/admin-user-form.component.ts
import { Component, OnInit, inject } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ReactiveFormsModule, FormBuilder, FormGroup, Validators, FormControl } from '@angular/forms'; // Import FormControl
import { ActivatedRoute, Router, RouterModule } from '@angular/router';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { MatButtonModule } from '@angular/material/button';
import { MatCardModule } from '@angular/material/card';
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { MatIconModule } from '@angular/material/icon';
import { MatSelectModule } from '@angular/material/select';
import { MatCheckboxModule } from '@angular/material/checkbox';
import { HttpErrorResponse } from '@angular/common/http';


import { User, UserUpdateDto } from '../../../../shared/models/user.model';
import { UserAdminService } from '../../services/user-admin.service';
import { AuthService } from '../../../../auth/auth.service';

@Component({
  selector: 'app-admin-user-form',
  standalone: true,
  imports: [
    CommonModule,
    RouterModule,
    ReactiveFormsModule,
    MatFormFieldModule,
    MatInputModule,
    MatButtonModule,
    MatCardModule,
    MatSnackBarModule,
    MatProgressSpinnerModule,
    MatIconModule,
    MatSelectModule,
    MatCheckboxModule
  ],
  templateUrl: './admin-user-form.component.html',
  styleUrls: ['./admin-user-form.component.scss']
})
export class AdminUserFormComponent implements OnInit {
  userForm!: FormGroup;
  userId!: number;
  isLoading = false;
  pageTitle = 'Editează Utilizator';
  submitButtonText = 'Actualizează Utilizator';
  userToEdit: User | null = null;
  error: string | null = null; // Adăugat pentru a stoca mesajul de eroare

  availableRoles: string[] = ['ROLE_USER', 'ROLE_ADMIN'];
  currentUserId: number | null = null;

  private fb = inject(FormBuilder);
  private userAdminService = inject(UserAdminService);
  private route = inject(ActivatedRoute);
  private router = inject(Router);
  private snackBar = inject(MatSnackBar);
  private authService = inject(AuthService);

  ngOnInit(): void {
    this.userForm = this.fb.group({
      username: [{ value: '', disabled: true }],
      email: ['', [Validators.required, Validators.email, Validators.maxLength(100)]],
      // Folosim un FormControl care va ține un array de string-uri pentru MatSelect multiple
      selectedRoles: new FormControl([] as string[], Validators.required) // <<< CORECTAT
    });

    const idFromRoute = this.route.snapshot.paramMap.get('id');
    if (idFromRoute) {
      this.userId = +idFromRoute;
      if (!isNaN(this.userId) && this.userId > 0) {
        this.loadUserData(this.userId);
      } else {
        this.handleInvalidId('ID utilizator invalid din rută.');
      }
    } else {
      this.handleInvalidId('ID utilizator lipsă din rută.');
    }

    const currentUser = this.authService.getCurrentUser();
     if (currentUser && currentUser.id) {
        this.currentUserId = currentUser.id;
    }
  }

  loadUserData(id: number): void {
    this.isLoading = true;
    this.userAdminService.getUserById(id).subscribe({
      next: (user: User) => { // Tipare explicită
        this.userToEdit = user;
        this.userForm.patchValue({
          username: user.username,
          email: user.email,
          // Setează valoarea pentru FormControl-ul de roluri
          selectedRoles: user.roles || [] // <<< CORECTAT
        });
        this.isLoading = false;
      },
      error: (err: HttpErrorResponse) => this.handleLoadError('Eroare la încărcarea datelor utilizatorului.', err) // Tipare explicită
    });
  }

  onSubmit(): void {
    if (this.userForm.invalid) {
      this.snackBar.open('Formular invalid. Verificați câmpurile.', 'OK', { duration: 3000 });
      this.userForm.markAllAsTouched();
      return;
    }

    const selectedRolesValue = this.userForm.get('selectedRoles')?.value as string[];

    if (this.userId === this.currentUserId) {
        if (!selectedRolesValue.includes('ROLE_ADMIN')) {
            this.snackBar.open('Nu vă puteți elimina propriul rol de Administrator.', 'OK', {duration: 5000});
            return;
        }
    }

    this.isLoading = true;
    const userData: UserUpdateDto = {
      email: this.userForm.get('email')?.value,
      roles: selectedRolesValue
    };

    // Log the data being sent
    console.log('Sending update data:', JSON.stringify(userData));
    console.log('User ID:', this.userId);

    this.userAdminService.updateUser(this.userId, userData).subscribe({
      next: () => {
        this.isLoading = false;
        this.snackBar.open('Utilizator actualizat cu succes!', 'OK', { duration: 3000 });
        this.router.navigate(['/admin/users']);
      },
      error: (err: HttpErrorResponse) => this.handleSubmitError('Eroare la actualizarea utilizatorului.', err)
    });
  }
  
  private handleInvalidId(message: string): void {
    this.isLoading = false;
    this.error = message;
    this.snackBar.open(this.error, 'Închide', { duration: 3000 });
    this.router.navigate(['/admin/users']);
  }

  private handleLoadError(message: string, err: HttpErrorResponse): void {
    this.isLoading = false;
    const serverErrorMessage = err.error?.message || err.message || 'Eroare necunoscută.';
    this.error = `${message} ${serverErrorMessage}`;
    this.snackBar.open(this.error, 'Închide', { duration: 5000 });
    console.error(err);
    this.router.navigate(['/admin/users']);
  }

  private handleSubmitError(message: string, err: HttpErrorResponse): void {
    this.isLoading = false;
    const serverErrorMessage = err.error?.message || err.message || 'Eroare necunoscută.';
    this.snackBar.open(`${message} ${serverErrorMessage}`, 'Închide', { duration: 5000 });
    console.error(err);
  }

  get f() { return this.userForm.controls; }
}
</file>

<file path="frontend/src/app/features/admin/admin-users/admin-user-list/admin-user-list.component.scss">
.admin-user-list-container {
  padding: 20px;
  max-width: 1000px;
  margin: auto;
}

.header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
  h2 {
    margin: 0;
  }
}

.filter-field {
  width: 100%;
  max-width: 400px;
  margin-bottom: 20px;
}

.loading-indicator,
.error-message,
.no-data {
  text-align: center;
  padding: 20px;
  mat-spinner {
    margin: 0 auto 10px auto;
  }
}

.error-message {
  color: #f44336;
}

.table-container {
  overflow-x: auto;
  margin-top: 10px;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

table {
  width: 100%;
}

.mat-column-actions {
  width: 120px;
  text-align: right;
}

.mat-column-id {
  max-width: 80px;
}
.mat-column-roles {
  min-width: 150px;
  mat-chip {
    margin-right: 4px;
    margin-bottom: 4px;
    font-size: 0.85em;
    padding: 4px 8px;
    height: 24px;
  }
}

.mat-header-cell {
  font-weight: 500;
  opacity: 0.87;
}

.mat-row:hover {
  background-color: rgba(0,0,0,0.03);
}

.mat-cell, .mat-header-cell {
  padding: 8px 16px;
}
</file>

<file path="frontend/src/app/features/admin/reports/reports.component.scss">
.reports-container {
  padding: 20px;
  max-width: 1400px;
  margin: 0 auto;
}

.reports-header {
  margin-bottom: 24px;

  mat-card-header {
    mat-card-title {
      display: flex;
      align-items: center;
      gap: 12px;
      font-size: 1.5em;

      mat-icon {
        font-size: 1.2em;
      }
    }
  }
}

.report-form {
  display: flex;
  gap: 16px;
  align-items: center;
  flex-wrap: wrap;

  mat-form-field {
    flex: 1;
    min-width: 200px;
  }

  button {
    height: 56px;
  }

  .download-buttons {
    display: flex;
    gap: 12px;
    margin-left: auto;
  }
}

.loading-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 400px;

  p {
    margin-top: 16px;
    font-size: 1.1em;
    opacity: 0.7;
  }
}

.summary-cards {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: 20px;
  margin-bottom: 24px;

  .summary-card {
    transition: transform 0.2s;

    &:hover {
      transform: translateY(-4px);
    }

    mat-card-content {
      display: flex;
      align-items: center;
      gap: 20px;
      padding: 24px;
    }

    .summary-icon {
      width: 64px;
      height: 64px;
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;

      mat-icon {
        font-size: 32px;
        color: white;
      }

      &.sales {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      }

      &.revenue {
        background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
      }

      &.stock {
        background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
      }

      &.users {
        background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
      }
    }

    .summary-info {
      flex: 1;

      h3 {
        margin: 0 0 8px 0;
        font-size: 0.9em;
        opacity: 0.7;
        font-weight: 400;
      }

      .summary-value {
        margin: 0;
        font-size: 2em;
        font-weight: 500;
      }

      .summary-label {
        margin: 0;
        font-size: 0.85em;
        opacity: 0.6;
      }
    }
  }
}

.report-tabs {
  background-color: transparent;
}

.tab-content {
  padding: 24px 0;
}

.chart-container {
  position: relative;
  height: 300px;
  margin: 20px 0;
}

.full-width {
  width: 100%;
}

.mt-3 {
  margin-top: 24px;
}

.my-3 {
  margin: 24px 0;
}

.stock-overview {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 20px;

  @media (max-width: 1024px) {
    grid-template-columns: 1fr;
  }
}

.stock-stats {
  display: flex;
  flex-direction: column;
  gap: 16px;

  .stat-item {
    display: flex;
    align-items: center;
    gap: 16px;
    padding: 16px;
    background: rgba(0, 0, 0, 0.02);
    border-radius: 8px;

    mat-icon {
      font-size: 32px;
    }

    .stat-value {
      margin: 0;
      font-size: 1.5em;
      font-weight: 500;
    }

    .stat-label {
      margin: 0;
      font-size: 0.9em;
      opacity: 0.7;
    }
  }
}

.user-metrics {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 20px;
  margin-bottom: 24px;

  .metric {
    text-align: center;
    padding: 20px;
    background: rgba(0, 0, 0, 0.02);
    border-radius: 8px;

    h4 {
      margin: 0 0 12px 0;
      opacity: 0.7;
      font-weight: 400;
    }

    .metric-value {
      margin: 0;
      font-size: 2.5em;
      font-weight: 500;
    }
  }
}

.role-distribution {
  display: flex;
  flex-direction: column;
  gap: 12px;
  margin-top: 16px;

  .role-item {
    display: flex;
    align-items: center;
    gap: 12px;

    .role-count {
      opacity: 0.7;
      font-size: 0.9em;
    }
  }
}

table {
  background-color: transparent;

  th {
    font-weight: 500;
    opacity: 0.7;
    font-size: 0.9em;
  }

  tr:hover {
    background-color: rgba(0, 0, 0, 0.02);
  }
}

mat-chip {
  font-size: 0.85em;
}

// Responsive
@media (max-width: 768px) {
  .report-form {
    flex-direction: column;

    mat-form-field,
    button {
      width: 100%;
    }

    .download-buttons {
      width: 100%;
      margin-left: 0;
      margin-top: 12px;

      button {
        flex: 1;
      }
    }
  }

  .summary-cards {
    grid-template-columns: 1fr;
  }

  .user-metrics {
    grid-template-columns: 1fr;
  }
}
</file>

<file path="frontend/src/app/features/admin/services/user-admin.service.ts">
import { Injectable, inject } from '@angular/core';
import { HttpClient, HttpErrorResponse } from '@angular/common/http';
import { Observable, throwError } from 'rxjs';
import { catchError } from 'rxjs/operators';
import { User, UserUpdateDto } from '../../../shared/models/user.model';

@Injectable({
  providedIn: 'root'
})
export class UserAdminService {
  private apiUrl = '/api/users'; // This will be proxied to localhost:8080

  private http = inject(HttpClient);

  getAllUsers(): Observable<User[]> {
    return this.http.get<User[]>(this.apiUrl)
      .pipe(catchError(this.handleError));
  }

  getUserById(userId: number): Observable<User> {
    return this.http.get<User>(`${this.apiUrl}/${userId}`)
      .pipe(catchError(this.handleError));
  }

  updateUser(userId: number, userData: UserUpdateDto): Observable<User> {
    // Log the data being sent for debugging
    console.log('Updating user with data:', userData);
    
    return this.http.put<User>(`${this.apiUrl}/${userId}`, userData)
      .pipe(catchError(this.handleError));
  }

  deleteUser(userId: number): Observable<void> {
    return this.http.delete<void>(`${this.apiUrl}/${userId}`)
      .pipe(catchError(this.handleError));
  }

  private handleError(error: HttpErrorResponse) {
    let userFriendlyErrorMessage = 'A apărut o problemă. Vă rugăm încercați din nou mai târziu.';
    let detailedErrorMessage = 'Eroare necunoscută.';

    if (error.error && typeof error.error === 'object' && error.error !== null) {
      // Check for validation errors structure
      if (error.error.fieldErrors) {
        // Spring Boot validation error response
        const fieldErrors = error.error.fieldErrors;
        const errorMessages = Object.entries(fieldErrors)
          .map(([field, message]) => `${field}: ${message}`)
          .join(', ');
        userFriendlyErrorMessage = `Erori de validare: ${errorMessages}`;
        detailedErrorMessage = errorMessages;
      } else {
        detailedErrorMessage = 
            (error.error as any).message ||
            (error.error as any).detail ||
            (error.error as any).error?.message ||
            JSON.stringify(error.error);

        if ((error.error as any).message && typeof (error.error as any).message === 'string') {
          userFriendlyErrorMessage = (error.error as any).message;
        }
      }
    } else if (typeof error.error === 'string') {
      detailedErrorMessage = error.error;
      userFriendlyErrorMessage = error.error; 
    } else if (error.message) {
      detailedErrorMessage = error.message;
      if (error.status === 0 || error.status === -1) {
        userFriendlyErrorMessage = 'Eroare de conexiune cu serverul. Verificați rețeaua sau dacă serverul backend rulează.';
      } else {
        userFriendlyErrorMessage = `A apărut o eroare (${error.status}): ${error.statusText}`;
      }
    } else {
      detailedErrorMessage = `Cod eroare server: ${error.status}, status text: ${error.statusText || 'Necunoscut'}`;
      userFriendlyErrorMessage = `A apărut o eroare (${error.status}). Vă rugăm încercați mai târziu.`;
    }

    console.error('------------------------------------');
    console.error(`[SERVICE ERROR ENCOUNTERED]`);
    console.error(`URL: ${error.url}`);
    console.error(`Status: ${error.status} - ${error.statusText}`);
    console.error(`User-Friendly Message: ${userFriendlyErrorMessage}`);
    console.error(`Detailed Error Message/Body: ${detailedErrorMessage}`);
    console.error('Full HttpErrorResponse Object:', error);
    console.error('------------------------------------');

    return throwError(() => new Error(userFriendlyErrorMessage));
  }
}
</file>

<file path="frontend/src/app/features/checkout/checkout.component.scss">
.checkout-container {
  max-width: 1200px;
  margin: 0 auto;
  padding: 20px;
}

.page-title {
  margin-bottom: 30px;
  font-size: 2em;
}

.loading-indicator {
  text-align: center;
  padding: 60px 20px;
  
  mat-spinner {
    margin: 0 auto 20px;
  }
}

.checkout-grid {
  display: grid;
  grid-template-columns: 1fr 400px;
  gap: 20px;
  align-items: start;
  
  @media (max-width: 968px) {
    grid-template-columns: 1fr;
  }
}

.checkout-form {
  mat-card {
    margin-bottom: 20px;
    
    mat-card-header {
      margin-bottom: 20px;
      
      mat-card-title {
        display: flex;
        align-items: center;
        gap: 10px;
        
        mat-icon {
          opacity: 0.7;
        }
      }
      
      mat-card-subtitle {
        margin-top: 5px;
        opacity: 0.7;
      }
    }
  }
  
  .full-width {
    width: 100%;
    margin-bottom: 16px;
  }
  
  .half-width {
    width: calc(50% - 8px);
  }
  
  .form-row {
    display: flex;
    gap: 16px;
    
    @media (max-width: 600px) {
      flex-direction: column;
      
      .half-width {
        width: 100%;
      }
    }
  }
  
  .shipping-fields {
    margin-top: 20px;
  }
  
  .payment-options {
    display: flex;
    flex-direction: column;
    gap: 15px;
    margin-bottom: 20px;
    
    mat-radio-button {
      display: flex;
      align-items: center;
      padding: 15px;
      border: 1px solid rgba(0,0,0,0.12);
      border-radius: 8px;
      
      &:hover:not([disabled]) {
        background: rgba(0,0,0,0.04);
      }
      
      &.mat-mdc-radio-checked {
        border-color: var(--mdc-theme-primary, #673ab7);
        background: rgba(103, 58, 183, 0.08);
      }
      
      mat-icon {
        margin-right: 10px;
        opacity: 0.7;
      }
      
      .payment-note {
        display: block;
        font-size: 0.85em;
        opacity: 0.7;
        margin-top: 5px;
        margin-left: 34px;
      }
    }
  }
  
  .notes-field {
    margin-top: 20px;
  }
  
  .terms-card {
    mat-checkbox {
      font-size: 0.95em;
      
      a {
        color: var(--mdc-theme-primary, #673ab7);
        text-decoration: none;
        
        &:hover {
          text-decoration: underline;
        }
      }
    }
  }
}

.order-summary {
  position: sticky;
  top: 80px;
  
  mat-card-header {
    padding-bottom: 16px;
    border-bottom: 1px solid rgba(0,0,0,0.12);
  }
  
  .summary-items {
    padding: 16px 0;
    
    .summary-item {
      display: flex;
      justify-content: space-between;
      margin-bottom: 10px;
      font-size: 0.9em;
      
      .item-name {
        flex: 1;
        margin-right: 10px;
        opacity: 0.8;
      }
      
      .item-price {
        white-space: nowrap;
      }
    }
  }
  
  mat-divider {
    margin: 16px 0;
  }
  
  .summary-totals {
    padding: 16px 0;
    
    .summary-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 10px;
      
      &.total {
        margin-top: 16px;
        padding-top: 16px;
        border-top: 1px solid rgba(0,0,0,0.12);
        font-size: 1.2em;
        font-weight: 500;
      }
      
      .free-shipping {
        color: #4CAF50;
        font-weight: 500;
      }
    }
  }
  
  .secure-payment {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    padding: 16px;
    background: rgba(103, 58, 183, 0.08);
    border-radius: 4px;
    margin-top: 16px;
    
    mat-icon {
      font-size: 20px;
    }
    
    span {
      font-size: 0.9em;
    }
  }
  
  mat-card-actions {
    flex-direction: column;
    padding: 16px;
    
    button {
      width: 100%;
      margin-bottom: 10px !important;
      
      &.place-order-button {
        padding: 12px;
        font-size: 1.1em;
        
        mat-spinner {
          display: inline-block;
          margin-right: 8px;
        }
        
        mat-icon {
          margin-right: 8px;
        }
      }
    }
  }
}
</file>

<file path="frontend/src/app/features/home/home-page/home-page.component.scss">
:host {
  display: block;
}

.home-container {
  width: 100%;
}

.section-title {
  font-size: 2.5rem;
  font-weight: bold;
  text-align: center;
  margin-bottom: 40px;
}

/* Hero Section */
.hero-section {
  min-height: 80vh;
  padding: 40px;
  display: flex;
  align-items: center;
  justify-content: center;
  position: relative;
  text-align: center;
  background: linear-gradient(135deg, rgba(0,0,0,0.05) 0%, rgba(0,0,0,0.1) 100%);

  .hero-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(to top, rgba(255,255,255,0.05) 5%, transparent 60%);
  }
  
  .hero-content {
    position: relative;
    z-index: 1;
    
    h1 {
      font-size: 3.5rem;
      font-weight: bold;
      margin-bottom: 1rem;
    }
    
    p {
      font-size: 1.2rem;
      margin: 20px 0 30px;
      opacity: 0.9;
    }
    
    button {
      padding: 12px 35px;
      font-size: 1.1rem;
      font-weight: bold;
    }
  }
}

/* Products Section */
.selection-section {
  padding: 60px 40px;
  max-width: 1400px;
  margin: 0 auto;
}

.loading-indicator {
  display: flex;
  justify-content: center;
  padding: 40px;
}

.product-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
  gap: 30px;
}

.product-card {
  cursor: pointer;
  transition: transform 0.3s ease, box-shadow 0.3s ease;
  // Remove dark background - let Material theme handle it
  
  &:hover {
    transform: translateY(-5px);
    box-shadow: 0 8px 16px rgba(0,0,0,0.2);
  }
  
  .product-image-container {
    height: 220px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(0,0,0,0.05);
    
    mat-icon {
      font-size: 70px;
      width: 70px;
      height: 70px;
      opacity: 0.3;
    }
  }
  
  mat-card-header {
    justify-content: center;
    text-align: center;
  }
  
  mat-card-content {
    text-align: center;
    
    .product-price {
      font-size: 1.2rem;
      font-weight: 500;
      margin: 10px 0;
    }
  }
  
  mat-card-actions {
    justify-content: center;
    padding-bottom: 16px;
  }
}

/* Social Section */
.social-section {
  padding: 60px 40px;
  background: rgba(0,0,0,0.02);
  
  .social-icons {
    display: flex;
    justify-content: center;
    gap: 20px;
    
    .social-icon-box {
      width: 120px;
      height: 120px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 4rem;
      font-weight: bold;
      text-decoration: none;
      border: 2px solid currentColor;
      border-radius: 8px;
      transition: transform 0.2s;
      
      &:hover {
        transform: scale(1.05);
      }
    }
  }
}
</file>

<file path="frontend/src/app/features/products/product-list/product-list.component.html">
<div class="admin-product-list-container">
  <div class="header">
    <h2>Administrare Produse</h2>
    <button mat-raised-button color="primary" routerLink="/admin/products/new">
      <mat-icon>add_circle_outline</mat-icon> Adaugă Produs Nou
    </button>
  </div>

  <mat-form-field appearance="outline" class="filter-field">
    <mat-label>Filtrează produse</mat-label>
    <input matInput (keyup)="applyFilter($event)" placeholder="Caută după nume, categorie...">
    <mat-icon matSuffix>search</mat-icon>
  </mat-form-field>

  <div *ngIf="isLoading" class="loading-indicator">
    <mat-spinner diameter="50"></mat-spinner>
    <p>Se încarcă produsele...</p>
  </div>

  <div *ngIf="error && !isLoading" class="error-message">
    <p>{{ error }}</p>
    <button mat-stroked-button color="warn" (click)="loadProducts()">Reîncearcă</button>
  </div>

  <div *ngIf="!isLoading && !error && dataSource.data.length === 0" class="no-data">
    <p>Nu există produse definite sau care să corespundă filtrului.</p>
  </div>

  <div class="table-container" *ngIf="!isLoading && !error && dataSource.data.length > 0">
    <table mat-table [dataSource]="dataSource" matSort class="mat-elevation-z8">

      <ng-container matColumnDef="id">
        <th mat-header-cell *matHeaderCellDef mat-sort-header> ID </th>
        <td mat-cell *matCellDef="let product"> {{product.id}} </td>
      </ng-container>

      <ng-container matColumnDef="name">
        <th mat-header-cell *matHeaderCellDef mat-sort-header> Nume Produs </th>
        <td mat-cell *matCellDef="let product"> {{product.name}} </td>
      </ng-container>

      <ng-container matColumnDef="categoryName">
        <th mat-header-cell *matHeaderCellDef mat-sort-header> Categorie </th>
        <td mat-cell *matCellDef="let product"> {{product.categoryName || 'N/A'}} </td>
      </ng-container>

      <ng-container matColumnDef="price">
        <th mat-header-cell *matHeaderCellDef mat-sort-header> Preț </th>
        <td mat-cell *matCellDef="let product"> {{product.price | currency:'RON':'symbol':'1.2-2'}} </td>
      </ng-container>

      <ng-container matColumnDef="stockQuantity">
        <th mat-header-cell *matHeaderCellDef mat-sort-header> Stoc </th>
        <td mat-cell *matCellDef="let product"> {{product.stockQuantity}} buc. </td>
      </ng-container>

      <ng-container matColumnDef="actions">
        <th mat-header-cell *matHeaderCellDef> Acțiuni </th>
        <td mat-cell *matCellDef="let product">
          <button mat-icon-button color="primary" [routerLink]="['/admin/products/edit', product.id]" aria-label="Editează produsul">
            <mat-icon>edit</mat-icon>
          </button>
          <button mat-icon-button routerLink="/products/{{product.id}}" aria-label="Vezi detalii publice produs">
             <mat-icon>visibility</mat-icon>
          </button>
          <button mat-icon-button color="warn" (click)="deleteProduct(product.id!)" aria-label="Șterge produsul">
            <mat-icon>delete</mat-icon>
          </button>
        </td>
      </ng-container>

      <tr mat-header-row *matHeaderRowDef="displayedColumns"></tr>
      <tr mat-row *matRowDef="let row; columns: displayedColumns;"></tr>

      <tr class="mat-row" *matNoDataRow>
        <td class="mat-cell" [attr.colspan]="displayedColumns.length">
          Nu s-au găsit produse care să corespundă filtrului "{{dataSource.filter}}".
        </td>
      </tr>
    </table>
    <mat-paginator [pageSizeOptions]="[5, 10, 20, 50]" showFirstLastButtons aria-label="Selectează pagina de produse"></mat-paginator>
  </div>
</div>
</file>

<file path="frontend/src/app/features/products/product-list/product-list.component.ts">
// src/app/features/products/product-list/product-list.component.ts
import { Component, OnInit, inject, ViewChild, AfterViewInit } from '@angular/core';
import { CommonModule, CurrencyPipe } from '@angular/common';
import { RouterModule } from '@angular/router';
import { MatTableDataSource, MatTableModule } from '@angular/material/table';
import { MatPaginator, MatPaginatorModule } from '@angular/material/paginator';
import { MatSort, MatSortModule } from '@angular/material/sort';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar';
import { MatDialog } from '@angular/material/dialog';

import { Product } from '../../../shared/models/product.model';
import { ProductService } from '../product.service';

@Component({
  selector: 'app-product-list',
  standalone: true,
  imports: [
    CommonModule,
    RouterModule,
    MatTableModule,
    MatPaginatorModule,
    MatSortModule,
    MatFormFieldModule,
    MatInputModule,
    MatButtonModule,
    MatIconModule,
    MatProgressSpinnerModule,
    MatSnackBarModule,
    CurrencyPipe
  ],
  templateUrl: './product-list.component.html',
  styleUrls: ['./product-list.component.scss']
})
export class ProductListComponent implements OnInit, AfterViewInit {
  displayedColumns: string[] = ['id', 'name', 'categoryName', 'price', 'stockQuantity', 'actions'];
  dataSource: MatTableDataSource<Product> = new MatTableDataSource();
  isLoading = true;
  error: string | null = null;

  @ViewChild(MatPaginator) paginator!: MatPaginator;
  @ViewChild(MatSort) sort!: MatSort;

  private productService = inject(ProductService);
  private snackBar = inject(MatSnackBar);

  ngOnInit(): void {
    this.loadProducts();
  }

  ngAfterViewInit(): void {
    this.dataSource.paginator = this.paginator;
    this.dataSource.sort = this.sort;
     // Custom sort pentru categoryName, care e un string
    this.dataSource.sortingDataAccessor = (item, property) => {
      switch (property) {
        case 'categoryName': return item.categoryName || '';
        default: return (item as any)[property];
      }
    };
  }

  loadProducts(): void {
    this.isLoading = true;
    this.error = null;
    this.productService.getAll().subscribe({
      next: (data) => {
        this.dataSource.data = data;
        this.isLoading = false;
      },
      error: (err) => {
        this.error = 'Nu s-au putut încărca produsele.';
        console.error(err);
        this.isLoading = false;
        this.snackBar.open(this.error, 'Închide', { duration: 5000 });
      }
    });
  }

  applyFilter(event: Event): void {
    const filterValue = (event.target as HTMLInputElement).value;
    this.dataSource.filter = filterValue.trim().toLowerCase();
    if (this.dataSource.paginator) {
      this.dataSource.paginator.firstPage();
    }
  }

  deleteProduct(productId: number): void {
    const confirmation = window.confirm('Sunteți sigur că doriți să ștergeți acest produs?');
    if (confirmation) {
      this.productService.delete(productId).subscribe({
        next: () => {
          this.snackBar.open('Produs șters cu succes!', 'OK', { duration: 3000 });
          this.loadProducts();
        },
        error: (err) => {
          this.snackBar.open('Eroare la ștergerea produsului.', 'Închide', { duration: 5000 });
          console.error(err);
        }
      });
    }
  }
}
</file>

<file path="frontend/src/app/features/products/product.service.ts">
// src/app/features/products/product.service.ts
import { Injectable, inject } from '@angular/core';
import { HttpClient, HttpErrorResponse } from '@angular/common/http';
import { Observable, throwError } from 'rxjs';
import { catchError } from 'rxjs/operators';
import { Product } from '../../shared/models/product.model';

@Injectable({
  providedIn: 'root'
})
export class ProductService {
  private apiUrl = '/api/products';

  private http = inject(HttpClient);

  getAll(): Observable<Product[]> {
    return this.http.get<Product[]>(this.apiUrl)
      .pipe(catchError(this.handleError));
  }

  getById(id: number): Observable<Product> {
    return this.http.get<Product>(`${this.apiUrl}/${id}`)
      .pipe(catchError(this.handleError));
  }

  create(product: Product): Observable<Product> {
    return this.http.post<Product>(this.apiUrl, product)
      .pipe(catchError(this.handleError));
  }

  update(id: number, product: Product): Observable<Product> {
    return this.http.put<Product>(`${this.apiUrl}/${id}`, product)
      .pipe(catchError(this.handleError));
  }

  delete(id: number): Observable<void> {
    return this.http.delete<void>(`${this.apiUrl}/${id}`)
      .pipe(catchError(this.handleError));
  }

 private handleError(error: HttpErrorResponse) {
  let userFriendlyErrorMessage = 'A apărut o problemă. Vă rugăm încercați din nou mai târziu.';
  let detailedErrorMessage = 'Eroare necunoscută.';

  if (error.error) {
    // Caz 1: Eroare este un HttpErrorResponse cu un obiect 'error'
    if (typeof error.error === 'object' && error.error !== null) {
      // Încercăm să extragem un mesaj specific din corpul erorii trimis de backend
      // Acesta ar putea fi error.error.message, error.error.error, error.error.detail, etc.
      // Ajustează în funcție de structura răspunsurilor de eroare de la API-ul tău Spring Boot
      detailedErrorMessage = (error.error as any).message ||  // Cel mai comun
                             (error.error as any).error?.message || // Uneori e imbricat
                             (error.error as any).detail ||
                             JSON.stringify(error.error); // Fallback la JSON string dacă e un obiect complex

      // Poți încerca să faci mesajul user-friendly mai specific dacă backend-ul trimite un mesaj clar
      if ((error.error as any).message && typeof (error.error as any).message === 'string') {
        userFriendlyErrorMessage = (error.error as any).message;
      }

    } else if (typeof error.error === 'string') {
      // Caz 2: Corpul erorii este un simplu string
      detailedErrorMessage = error.error;
      userFriendlyErrorMessage = error.error; // Poate fi afișat direct dacă e relevant
    }
  } else if (error.message) {
    // Caz 3: Eroare client-side sau de rețea (ex: HttpErrorResponse fără error.error, dar cu error.message)
    detailedErrorMessage = error.message;
    if (error.status === 0 || error.status === -1) { // Tipic pentru erori de rețea sau CORS
        userFriendlyErrorMessage = 'Eroare de conexiune cu serverul. Verificați rețeaua.';
    } else {
        userFriendlyErrorMessage = 'A apărut o eroare la procesarea cererii.';
    }
  }

  // Logare detaliată în consola dezvoltatorului
  console.error('------------------------------------');
  console.error(`[SERVICE ERROR] Status: ${error.status} - URL: ${error.url}`);
  console.error('Mesaj detaliat:', detailedErrorMessage);
  console.error('Obiect eroare complet:', error);
  console.error('------------------------------------');

  // Aruncă o eroare care va fi propagată și poate fi prinsă în componentă
  // sau de un error handler global, dacă există.
  // Pentru utilizator, mesajele sunt de obicei afișate prin MatSnackBar în componentă/serviciu.
  return throwError(() => new Error(userFriendlyErrorMessage)); // Trimite un mesaj mai general către UI
}
}
</file>

<file path="frontend/src/app/features/products/user-product-list/user-product-list.component.ts">
// frontend/src/app/features/products/user-product-list/user-product-list.component.ts
import { Component, OnInit, inject, ViewChild } from '@angular/core';
import { CommonModule, CurrencyPipe, SlicePipe } from '@angular/common';
import { RouterModule } from '@angular/router';
import { FormsModule } from '@angular/forms';
import { MatCardModule } from '@angular/material/card';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { MatSelectModule } from '@angular/material/select'; // Add this import
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar';
import { MatPaginator, MatPaginatorModule, PageEvent } from '@angular/material/paginator';

import { Product } from '../../../shared/models/product.model';
import { Category } from '../../../shared/models/category.model'; // Add this import
import { ProductService } from '../product.service';
import { CartService } from '../../shopping-cart/cart.service';
import { CategoryAdminService } from '../../admin/services/category.admin.service'; // Add this import
import { AddToCartRequest } from '../../../shared/models/cart.model';

@Component({
  selector: 'app-user-product-list',
  standalone: true,
  imports: [
    CommonModule,
    RouterModule,
    FormsModule,
    MatCardModule,
    MatButtonModule,
    MatIconModule,
    MatFormFieldModule,
    MatInputModule,
    MatSelectModule, // Add this import
    MatProgressSpinnerModule,
    MatSnackBarModule,
    MatPaginatorModule,
    CurrencyPipe,
    SlicePipe
  ],
  templateUrl: './user-product-list.component.html',
  styleUrls: ['./user-product-list.component.scss']
})
export class UserProductListComponent implements OnInit {
  products: Product[] = [];
  filteredProducts: Product[] = [];
  categories: Category[] = []; // Add categories array
  selectedCategoryId: number | null = null; // Add selected category tracking
  searchText: string = ''; // Add search text tracking
  isLoading = true;
  error: string | null = null;
  isAddingToCart: { [key: number]: boolean } = {};
  
  // Pagination
  pageSize = 12;
  pageIndex = 0;

  @ViewChild(MatPaginator) paginator!: MatPaginator;

  private productService = inject(ProductService);
  private cartService = inject(CartService);
  private categoryService = inject(CategoryAdminService); // Inject category service
  private snackBar = inject(MatSnackBar);

  ngOnInit(): void {
    this.loadCategories(); // Load categories first
    this.loadProducts();
  }

  loadCategories(): void {
    this.categoryService.getAll().subscribe({
      next: (data) => {
        this.categories = data;
      },
      error: (err) => {
        console.error('Failed to load categories:', err);
        // Don't show error to user as categories are optional for filtering
      }
    });
  }

  loadProducts(): void {
    this.isLoading = true;
    this.error = null;
    this.productService.getAll().subscribe({
      next: (data) => {
        this.products = data;
        this.applyFilters(); // Apply filters after loading
        this.isLoading = false;
      },
      error: (err) => {
        this.error = 'Nu s-au putut încărca produsele.';
        console.error(err);
        this.isLoading = false;
        this.snackBar.open(this.error, 'Închide', { duration: 5000 });
      }
    });
  }

  applyFilter(event: Event): void {
    const filterValue = (event.target as HTMLInputElement).value.trim().toLowerCase();
    this.searchText = filterValue;
    this.applyFilters();
  }

  applyCategoryFilter(): void {
    this.applyFilters();
  }

  applyFilters(): void {
    let filtered = this.products;

    // Apply text filter
    if (this.searchText) {
      filtered = filtered.filter(product => 
        product.name.toLowerCase().includes(this.searchText) ||
        product.categoryName?.toLowerCase().includes(this.searchText) ||
        product.description?.toLowerCase().includes(this.searchText)
      );
    }

    // Apply category filter
    if (this.selectedCategoryId !== null) {
      filtered = filtered.filter(product => 
        product.categoryId === this.selectedCategoryId
      );
    }

    this.filteredProducts = filtered;

    // Reset to first page when filtering
    this.pageIndex = 0;
    if (this.paginator) {
      this.paginator.firstPage();
    }
  }

  onPageChange(event: PageEvent): void {
    this.pageSize = event.pageSize;
    this.pageIndex = event.pageIndex;
  }

  getPaginatedProducts(): Product[] {
    const startIndex = this.pageIndex * this.pageSize;
    const endIndex = startIndex + this.pageSize;
    return this.filteredProducts.slice(startIndex, endIndex);
  }

  addToCart(product: Product): void {
    if (!product || typeof product.id === 'undefined') {
      this.snackBar.open('Detaliile produsului sunt incomplete.', 'Închide', { duration: 3000 });
      return;
    }

    this.isAddingToCart[product.id] = true;

    const request: AddToCartRequest = {
      productId: product.id,
      quantity: 1
    };

    this.cartService.addToCart(request).subscribe({
      next: () => {
        this.isAddingToCart[product.id!] = false;
        this.snackBar.open(`"${product.name}" a fost adăugat în coș!`, 'OK', {
          duration: 3000,
        });
      },
      error: (err) => {
        this.isAddingToCart[product.id!] = false;
        const errorMessage = err.error?.message || 'A apărut o eroare la adăugarea produsului în coș.';
        this.snackBar.open(errorMessage, 'Închide', {
          duration: 5000
        });
        console.error('Error adding to cart:', err);
      }
    });
  }
}
</file>

<file path="frontend/src/app/features/reviews/review-list/review-list.component.scss">
.review-section {
  margin-top: 40px;
  
  .section-title {
    font-size: 1.5em;
    margin-bottom: 20px;
  }
}

.review-summary {
  margin-bottom: 30px;
  
  .summary-content {
    display: grid;
    grid-template-columns: 1fr 2fr;
    gap: 40px;
    
    @media (max-width: 768px) {
      grid-template-columns: 1fr;
      gap: 20px;
    }
  }
  
  .average-rating {
    text-align: center;
    
    .rating-number {
      font-size: 3em;
      font-weight: 500;
      margin-bottom: 10px;
    }
    
    .total-reviews {
      margin-top: 10px;
      opacity: 0.7;
    }
  }
  
  .rating-distribution {
    .rating-bar {
      display: grid;
      grid-template-columns: 60px 1fr 40px;
      align-items: center;
      gap: 10px;
      margin-bottom: 8px;
      
      .rating-label {
        text-align: right;
        font-size: 0.9em;
        opacity: 0.7;
      }
      
      .bar-container {
        background-color: rgba(0,0,0,0.1);
        height: 8px;
        border-radius: 4px;
        overflow: hidden;
        
        .bar-fill {
          height: 100%;
          background-color: #ffc107;
          transition: width 0.3s;
        }
      }
      
      .rating-count {
        text-align: left;
        font-size: 0.9em;
        opacity: 0.7;
      }
    }
  }
}

.review-actions {
  margin: 20px 0;
  text-align: center;
}

.login-prompt {
  text-align: center;
  padding: 20px;
  background-color: rgba(0,0,0,0.02);
  border-radius: 8px;
  margin: 20px 0;
  
  p {
    margin-bottom: 10px;
    opacity: 0.7;
  }
}

.loading-indicator {
  text-align: center;
  padding: 40px;
}

.no-reviews {
  text-align: center;
  padding: 40px;
  opacity: 0.7;
  
  p {
    margin-bottom: 10px;
  }
}

.reviews-list {
  margin-top: 30px;
}

.review-card {
  margin-bottom: 20px;
  
  .review-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    width: 100%;
    
    .review-info {
      display: flex;
      flex-direction: column;
      gap: 5px;
      
      .reviewer-name {
        margin: 0;
        font-size: 1.1em;
        font-weight: 500;
      }
      
      .review-date {
        font-size: 0.85em;
        opacity: 0.7;
      }
    }
  }
  
  .review-title {
    font-size: 1.1em;
    font-weight: 500;
    margin-bottom: 10px;
  }
  
  .review-comment {
    line-height: 1.6;
    opacity: 0.87;
  }
}
</file>

<file path="frontend/src/app/features/reviews/review.service.ts">
// frontend/src/app/features/reviews/review.service.ts
import { Injectable, inject } from '@angular/core';
import { HttpClient, HttpParams } from '@angular/common/http';
import { Observable } from 'rxjs';
import { Review, CreateReviewRequest, ProductReviewSummary, ReviewPage } from '../../shared/models/review.model';

@Injectable({
  providedIn: 'root'
})
export class ReviewService {
  private apiUrl = '/api/reviews';
  private http = inject(HttpClient);

  createReview(review: CreateReviewRequest): Observable<Review> {
    return this.http.post<Review>(this.apiUrl, review);
  }

  updateReview(reviewId: number, review: CreateReviewRequest): Observable<Review> {
    return this.http.put<Review>(`${this.apiUrl}/${reviewId}`, review);
  }

  deleteReview(reviewId: number): Observable<void> {
    return this.http.delete<void>(`${this.apiUrl}/${reviewId}`);
  }

  getProductReviews(productId: number, page: number = 0, size: number = 10): Observable<ReviewPage> {
    const params = new HttpParams()
      .set('page', page.toString())
      .set('size', size.toString());
    return this.http.get<ReviewPage>(`${this.apiUrl}/product/${productId}`, { params });
  }

  getProductReviewSummary(productId: number): Observable<ProductReviewSummary> {
    return this.http.get<ProductReviewSummary>(`${this.apiUrl}/product/${productId}/summary`);
  }

  getMyReviewForProduct(productId: number): Observable<Review | null> {
    return this.http.get<Review | null>(`${this.apiUrl}/product/${productId}/my-review`);
  }
  getUserReviews(): Observable<Review[]> {
  return this.http.get<Review[]>(`${this.apiUrl}/user/my-reviews`);
}
}
</file>

<file path="frontend/src/app/features/shopping-cart/shopping-cart.component.scss">
.shopping-cart-container {
  max-width: 1200px;
  margin: 0 auto;
  padding: 20px;
}

.page-title {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 30px;
  
  mat-icon {
    font-size: 32px;
    width: 32px;
    height: 32px;
  }
}

.loading-indicator {
  text-align: center;
  padding: 40px;
  
  mat-spinner {
    margin: 0 auto 20px;
  }
}

.empty-cart {
  mat-card {
    max-width: 500px;
    margin: 40px auto;
    text-align: center;
    padding: 40px;
  }
  
  .empty-icon {
    font-size: 80px;
    width: 80px;
    height: 80px;
    margin: 0 auto 20px;
    opacity: 0.3;
  }
  
  h2 {
    margin-bottom: 10px;
  }
  
  p {
    margin-bottom: 30px;
    opacity: 0.7;
  }
}

.cart-content {
  display: grid;
  grid-template-columns: 1fr 350px;
  gap: 20px;
  
  @media (max-width: 768px) {
    grid-template-columns: 1fr;
  }
}

.cart-items {
  mat-card-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
  }
}

.item-list {
  display: flex;
  flex-direction: column;
  gap: 20px;
}

.cart-item {
  display: grid;
  grid-template-columns: 100px 1fr 120px 150px 50px;
  gap: 15px;
  padding: 20px;
  border: 1px solid rgba(0,0,0,0.12);
  border-radius: 8px;
  background: rgba(0,0,0,0.02);
  align-items: center;
  
  @media (max-width: 768px) {
    grid-template-columns: 80px 1fr;
    gap: 10px;
    
    .item-quantity,
    .item-price,
    .item-actions {
      grid-column: 1 / -1;
    }
  }
  
  .item-image {
    width: 100px;
    height: 100px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: white;
    border: 1px solid rgba(0,0,0,0.12);
    border-radius: 4px;
    overflow: hidden;
    
    mat-icon {
      font-size: 40px;
      width: 40px;
      height: 40px;
      opacity: 0.3;
    }
    
    img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
  }
  
  .item-details {
    h3 {
      margin: 0 0 5px;
      font-size: 1.1em;
    }
    
    .item-description {
      margin: 0 0 5px;
      font-size: 0.9em;
      opacity: 0.7;
      overflow: hidden;
      text-overflow: ellipsis;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
    }
    
    .item-stock {
      margin: 0;
      font-size: 0.85em;
      color: #4CAF50;
      
      &.low-stock {
        color: #f44336;
      }
    }
  }
  
  .item-quantity {
    mat-form-field {
      width: 100px;
    }
  }
  
  .item-price {
    text-align: right;
    
    .unit-price {
      margin: 0 0 5px;
      font-size: 0.9em;
      opacity: 0.7;
    }
    
    .subtotal {
      margin: 0;
      font-size: 1.1em;
      font-weight: 500;
    }
  }
}

.cart-summary {
  position: sticky;
  top: 80px;
  
  mat-card-header {
    padding-bottom: 16px;
  }
  
  .summary-row {
    display: flex;
    justify-content: space-between;
    margin-bottom: 10px;
    
    &.total {
      margin-top: 16px;
      font-size: 1.2em;
      font-weight: 500;
    }
    
    .free-shipping {
      color: #4CAF50;
      font-weight: 500;
    }
  }
  
  mat-divider {
    margin: 16px 0;
  }
  
  mat-card-actions {
    flex-direction: column;
    padding: 16px;
    
    button {
      width: 100%;
      margin-bottom: 10px !important;
      
      &.checkout-button {
        padding: 12px;
        font-size: 1.1em;
      }
    }
  }
}
</file>

<file path="frontend/src/app/features/user-profile/user-profile.component.ts">
// frontend/src/app/features/user-profile/user-profile.component.ts
import { Component, OnInit, inject } from '@angular/core';
import { CommonModule } from '@angular/common';
import { Router, RouterModule } from '@angular/router';
import { MatCardModule } from '@angular/material/card';
import { MatTabsModule } from '@angular/material/tabs';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatDividerModule } from '@angular/material/divider';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar';
import { MatChipsModule } from '@angular/material/chips';
import { MatDialogModule } from '@angular/material/dialog';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { ReactiveFormsModule, FormBuilder, FormGroup, Validators } from '@angular/forms';

import { AuthService } from '../../auth/auth.service';
import { ReviewService } from '../reviews/review.service';
import { UserProfileService } from './user-profile.service'; // New service
import { User } from '../../shared/models/user.model';
import { Review } from '../../shared/models/review.model';
import { StarRatingComponent } from '../../shared/components/star-rating/star-rating.component';

@Component({
  selector: 'app-user-profile',
  standalone: true,
  imports: [
    CommonModule,
    RouterModule,
    ReactiveFormsModule,
    MatCardModule,
    MatTabsModule,
    MatButtonModule,
    MatIconModule,
    MatDividerModule,
    MatProgressSpinnerModule,
    MatSnackBarModule,
    MatChipsModule,
    MatDialogModule,
    MatFormFieldModule,
    MatInputModule,
    StarRatingComponent
  ],
  templateUrl: './user-profile.component.html',
  styleUrls: ['./user-profile.component.scss']
})
export class UserProfileComponent implements OnInit {
  user: User | null = null;
  userReviews: Review[] = [];
  isLoading = true;
  isLoadingReviews = true;
  isEditMode = false;
  profileForm!: FormGroup;
  totalReviews = 0;
  averageRating = 0;

  private authService = inject(AuthService);
  private reviewService = inject(ReviewService);
  private userProfileService = inject(UserProfileService); // Use new service
  private snackBar = inject(MatSnackBar);
  private fb = inject(FormBuilder);
  private router = inject(Router);

  ngOnInit(): void {
    if (!this.authService.isLoggedIn()) {
      this.snackBar.open('Sesiunea a expirat. Te rugăm să te autentifici din nou.', 'OK', { duration: 3000 });
      this.router.navigate(['/login'], { queryParams: { returnUrl: '/my-profile' } });
      return;
    }
    
    this.initializeForm();
    this.loadUserProfile();
    this.loadUserReviews();
  }

  initializeForm(): void {
    this.profileForm = this.fb.group({
      username: [{ value: '', disabled: true }],
      email: ['', [Validators.required, Validators.email]],
      fullName: [''],
      phone: [''],
      address: ['']
    });
  }

  loadUserProfile(): void {
    this.isLoading = true;
    
    // Use the new service to get profile data
    this.userProfileService.getMyProfile().subscribe({
      next: (user) => {
        this.user = user;
        this.profileForm.patchValue({
          username: user.username,
          email: user.email
        });
        this.isLoading = false;
      },
      error: (err) => {
        this.isLoading = false;
        
        // Check if it's an authentication error
        if (err.message.includes('Sesiunea a expirat')) {
          this.snackBar.open(err.message, 'Login', { duration: 5000 })
            .onAction().subscribe(() => {
              this.router.navigate(['/login'], { queryParams: { returnUrl: '/my-profile' } });
            });
        } else {
          // For other errors, use cached data if available
          const cachedUser = this.authService.getCurrentUser();
          if (cachedUser) {
            this.user = cachedUser;
            this.profileForm.patchValue({
              username: cachedUser.username,
              email: cachedUser.email
            });
            this.snackBar.open('Folosind datele din cache. Reconectează-te pentru date actualizate.', 'OK', { duration: 3000 });
          } else {
            this.snackBar.open(err.message, 'Închide', { duration: 5000 });
            this.router.navigate(['/']);
          }
        }
      }
    });
  }

  loadUserReviews(): void {
    this.isLoadingReviews = true;
    this.reviewService.getUserReviews().subscribe({
      next: (reviews) => {
        this.userReviews = reviews;
        this.calculateReviewStats();
        this.isLoadingReviews = false;
      },
      error: (err) => {
        this.isLoadingReviews = false;
        console.error('Error loading reviews:', err);
        this.userReviews = [];
        this.calculateReviewStats();
      }
    });
  }

  calculateReviewStats(): void {
    this.totalReviews = this.userReviews.length;
    if (this.totalReviews > 0) {
      const totalRating = this.userReviews.reduce((sum, review) => sum + review.rating, 0);
      this.averageRating = totalRating / this.totalReviews;
    }
  }

  toggleEditMode(): void {
    this.isEditMode = !this.isEditMode;
    if (!this.isEditMode) {
      this.loadUserProfile();
    }
  }

  saveProfile(): void {
    if (this.profileForm.invalid || !this.user) return;

    const updatedData = {
      email: this.profileForm.get('email')?.value,
      roles: undefined // Don't send roles for own profile update
    };

    this.userProfileService.updateMyProfile(updatedData).subscribe({
      next: () => {
        this.snackBar.open('Profil actualizat cu succes!', 'OK', { duration: 3000 });
        this.isEditMode = false;
        this.loadUserProfile();
      },
      error: (err) => {
        this.snackBar.open(err.message || 'Eroare la actualizarea profilului', 'Închide', { duration: 5000 });
      }
    });
  }

  formatDate(dateString: string): string {
    return new Date(dateString).toLocaleDateString('ro-RO', {
      year: 'numeric',
      month: 'long',
      day: 'numeric'
    });
  }
}
</file>

<file path="frontend/src/app/shared/in-memory-data.service.ts">
// src/app/shared/in-memory-data.service.ts
import { Injectable } from '@angular/core';
import { InMemoryDbService, RequestInfo } from 'angular-in-memory-web-api';
import { Observable } from 'rxjs';
import { Product } from './models/product.model'; // Asigură-te că modelul Product e corect
// Importă și alte modele dacă vrei să le mock-uiești (Category, etc.)

@Injectable({
  providedIn: 'root'
})
export class InMemoryDataService implements InMemoryDbService {
  createDb(reqInfo?: RequestInfo): {} | Observable<{}> | Promise<{}> {
    const products: Product[] = [
      // Date mock pentru produse (folosește modelul Product actualizat)
      {
        id: 1,
        name: 'Laptop Gaming X1',
        description: 'Un laptop puternic pentru jocuri și sarcini intensive.',
        price: 5500.99,
        stockQuantity: 15,
        categoryId: 1, // Presupunând că există o categorie cu ID 1
        categoryName: 'Laptopuri',
        imageBase64: null, // Sau un string base64 valid
        specifications: [
          { definitionId: 1, name: 'Procesor', value: 'Intel Core i7-12700H', unit: '' },
          { definitionId: 2, name: 'RAM', value: '16', unit: 'GB' },
          { definitionId: 3, name: 'Stocare SSD', value: '1', unit: 'TB' }
        ]
      },
      {
        id: 2,
        name: 'Monitor LED UltraWide',
        description: 'Monitor curbat pentru o experiență vizuală imersivă.',
        price: 1800.00,
        stockQuantity: 25,
        categoryId: 2, // Presupunând că există o categorie cu ID 2
        categoryName: 'Monitoare',
        imageBase64: null,
        specifications: [
          { definitionId: 4, name: 'Diagonală', value: '34', unit: 'inch' },
          { definitionId: 5, name: 'Rezoluție', value: '3440x1440', unit: 'pixeli' }
        ]
      },
      // Adaugă mai multe produse mock aici
    ];

    const categories = [
        { id: 1, name: 'Laptopuri', description: 'Portabile performante'},
        { id: 2, name: 'Monitoare', description: 'Display-uri pentru PC'},
        { id: 3, name: 'Componente PC', description: 'Piese pentru asamblare PC'}
    ];

    const specificationDefinitions = [
        {id: 1, name: 'Procesor', unit: ''},
        {id: 2, name: 'RAM', unit: 'GB'},
        {id: 3, name: 'Stocare SSD', unit: 'TB'},
        {id: 4, name: 'Diagonală', unit: 'inch'},
        {id: 5, name: 'Rezoluție', unit: 'pixeli'},
        {id: 6, name: 'Tip Placă Video', unit: ''},
    ];


    // Returnează un obiect cu colecțiile tale. Numele proprietăților
    // (ex: 'products') vor fi folosite ca segmente de URL pentru API-ul mock.
    return { products, categories, specificationDefinitions /* , alteColecții */ };
  }

  // Suprascrie genId pentru a te asigura că un produs nou primește un ID.
  // Dacă colecția este goală, această metodă returnează numărul inițial (11).
  // Dacă colecția nu este goală, metoda returnează cel mai mare ID + 1.
  genId<T extends { id?: number }>(collection: T[], collectionName: string): number {
    // Verifică dacă `id` este definit și este un număr pentru fiecare element
    const validIds = collection.map(item => item.id).filter(id => typeof id === 'number') as number[];
    return validIds.length > 0 ? Math.max(...validIds) + 1 : 1;
  }
}
</file>

<file path="frontend/src/app/shared/material.module.ts">
// src/app/shared/material.module.ts
import { NgModule } from '@angular/core';
import { MatButtonModule } from '@angular/material/button';
import { MatCardModule } from '@angular/material/card';
import { MatCheckboxModule } from '@angular/material/checkbox';
import { MatChipsModule } from '@angular/material/chips';
import { MatDialogModule } from '@angular/material/dialog';
import { MatDividerModule } from '@angular/material/divider';
import { MatExpansionModule } from '@angular/material/expansion';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatIconModule } from '@angular/material/icon';
import { MatInputModule } from '@angular/material/input';
import { MatListModule } from '@angular/material/list';
import { MatMenuModule } from '@angular/material/menu';
import { MatPaginatorModule } from '@angular/material/paginator';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { MatSelectModule } from '@angular/material/select';
import { MatSidenavModule } from '@angular/material/sidenav';
import { MatSnackBarModule } from '@angular/material/snack-bar';
import { MatSortModule } from '@angular/material/sort';
import { MatTableModule } from '@angular/material/table';
import { MatToolbarModule } from '@angular/material/toolbar';
import { MatTooltipModule } from '@angular/material/tooltip'; // Util pentru hint-uri

const materialModules = [
  MatButtonModule,
  MatCardModule,
  MatCheckboxModule,
  MatChipsModule,
  MatDialogModule,
  MatDividerModule,
  MatExpansionModule,
  MatFormFieldModule,
  MatIconModule,
  MatInputModule,
  MatListModule,
  MatMenuModule,
  MatPaginatorModule,
  MatProgressSpinnerModule,
  MatSelectModule,
  MatSidenavModule,
  MatSnackBarModule,
  MatSortModule,
  MatTableModule,
  MatToolbarModule,
  MatTooltipModule,
];

@NgModule({
  imports: materialModules,
  exports: materialModules
})
export class MaterialModule { }
</file>

<file path="frontend/src/app/signup/signup.component.scss">
.signup-container {
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: calc(100vh - 128px);
  padding: 20px;
}

.signup-card {
  width: 100%;
  max-width: 450px;
  padding: 20px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  border-radius: 8px;
  // Remove dark background
}

mat-card-header {
  text-align: center;
  padding-bottom: 20px;
  mat-card-title {
    font-size: 1.8em;
  }
  mat-card-subtitle {
    font-size: 1em;
    opacity: 0.7;
  }
}

.full-width {
  width: 100%;
  margin-bottom: 18px;
}

.signup-button {
  padding: 10px 0;
  font-size: 1.05em;
  display: flex;
  align-items: center;
  justify-content: center;
  margin-top: 10px;

  .button-spinner {
    margin-right: 8px;
  }
}

.signup-card-actions-center {
  display: flex;
  justify-content: center;
  margin-top: 16px;
  padding-top: 16px;
  border-top: 1px solid rgba(0,0,0,0.12);
}

.login-link {
  text-align: center;
  font-size: 0.9em;
  opacity: 0.7;
  a {
    color: var(--mdc-theme-primary, #673ab7);
    text-decoration: none;
    font-weight: 500;
    &:hover {
      text-decoration: underline;
    }
  }
}

mat-form-field .mat-icon-button[matSuffix] {
  display: flex;
  align-items: center;
  justify-content: center;
}

::ng-deep .mat-mdc-form-field-error {
  font-size: 0.85em;
}
</file>

<file path="backend/pom.xml">
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
                             https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.2.5</version>
        <relativePath/>
    </parent>

    <groupId>com.magazincomputere</groupId>
    <artifactId>magazin-api</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>magazin-api</name>
    <description>API pentru Magazin Computere</description>

    <properties>
        <java.version>17</java.version>
        <!-- păstrăm doar springdoc aici; jjwt îl setăm direct în dependențe -->
        <springdoc.version>2.3.0</springdoc.version>
    </properties>

    <dependencies>
        <!-- Spring Boot starters – toate pe 3.2.5 -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
            <version>3.2.5</version>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
            <version>3.2.5</version>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
            <version>3.2.5</version>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
            <version>3.2.5</version>
        </dependency>

        <!-- Baze de date -->
        <dependency>
            <groupId>com.h2database</groupId>
            <artifactId>h2</artifactId>
            <version>2.2.224</version>
            <scope>runtime</scope>
        </dependency>

        <dependency>
            <groupId>com.mysql</groupId>
            <artifactId>mysql-connector-j</artifactId>
            <version>8.3.0</version>
            <scope>runtime</scope>
        </dependency>

        <!-- Utility -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>1.18.32</version>
            <optional>true</optional>
        </dependency>

        <!-- JJWT 0.12.6 -->
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-api</artifactId>
            <version>0.11.5</version>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-impl</artifactId>
            <version>0.11.5</version>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-jackson</artifactId>
            <version>0.11.5</version>
            <scope>runtime</scope>
        </dependency>

        <!-- SpringDoc OpenAPI (lasă proprietatea) -->
        <dependency>
            <groupId>org.springdoc</groupId>
            <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
            <version>${springdoc.version}</version>
        </dependency>
        <!-- Apache POI for Excel generation -->
        <dependency>
             <groupId>org.apache.poi</groupId>
             <artifactId>poi</artifactId>
             <version>5.2.5</version>
        </dependency>
        <dependency>
             <groupId>org.apache.poi</groupId>
             <artifactId>poi-ooxml</artifactId>
             <version>5.2.5</version>
        </dependency>

        <!-- iText for PDF generation -->
        <dependency>
             <groupId>com.itextpdf</groupId>
             <artifactId>itext7-core</artifactId>
             <version>8.0.2</version>
             <type>pom</type>
        </dependency>

        <!-- Teste -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <version>3.2.5</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-test</artifactId>
            <version>6.2.4</version>
            <scope>test</scope>
        </dependency>
        <dependency>
    <groupId>org.postgresql</groupId>
    <artifactId>postgresql</artifactId>
    <scope>runtime</scope>
</dependency>
<dependency>
    <groupId>com.mysql</groupId>
    <artifactId>mysql-connector-j</artifactId>
    <scope>runtime</scope>
</dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <excludes>
                        <exclude>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                        </exclude>
                    </excludes>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/controller/OrderController.java">
// src/main/java/com/magazincomputere/magazin_api/controller/OrderController.java
package com.magazincomputere.magazin_api.controller;

import com.magazincomputere.magazin_api.dto.OrderDto;
import com.magazincomputere.magazin_api.dto.OrderStatusUpdateDto; // Asigură-te că acest DTO este importat
import com.magazincomputere.magazin_api.model.User; // Nu este folosit direct, dar poate rămâne
import com.magazincomputere.magazin_api.repository.UserRepository; // Nu este folosit direct, dar poate rămâne
import com.magazincomputere.magazin_api.security.services.UserDetailsImpl;
import com.magazincomputere.magazin_api.service.OrderService;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/orders")
public class OrderController {

    @Autowired
    private OrderService orderService;

    // @Autowired // Nu este folosit direct aici, poate fi eliminat dacă nu e necesar pentru altceva
    // private UserRepository userRepository;

    @PostMapping
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<OrderDto> createOrder(@Valid @RequestBody OrderDto orderDto) {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        UserDetailsImpl userDetails = (UserDetailsImpl) authentication.getPrincipal();
        Long userId = userDetails.getId();

        OrderDto createdOrder = orderService.createOrder(orderDto, userId);
        return new ResponseEntity<>(createdOrder, HttpStatus.CREATED);
    }

    @GetMapping("/my-history")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<List<OrderDto>> getMyOrderHistory() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        UserDetailsImpl userDetails = (UserDetailsImpl) authentication.getPrincipal();
        Long userId = userDetails.getId();
        // Folosește numele corect al metodei din OrderService
        List<OrderDto> orders = orderService.getOrdersByUser(userId); // <<< CORECTAT AICI
        return ResponseEntity.ok(orders);
    }

    @GetMapping
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<List<OrderDto>> getAllOrders(@RequestParam(required = false) String status) {
        List<OrderDto> orders = orderService.getAllOrders(status);
        return ResponseEntity.ok(orders);
    }

    @GetMapping("/{orderId}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<OrderDto> getOrderById(@PathVariable Long orderId) {
        OrderDto orderDto = orderService.getOrderById(orderId);
        return ResponseEntity.ok(orderDto);
    }

    @PutMapping("/{orderId}/status")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<OrderDto> updateOrderStatus(
            @PathVariable Long orderId,
            @Valid @RequestBody OrderStatusUpdateDto statusUpdateDto) { // <<< CORECTAT AICI: Primește DTO-ul
        // Transmite DTO-ul la serviciu
        OrderDto updatedOrder = orderService.updateOrderStatus(orderId, statusUpdateDto); // <<< CORECTAT AICI
        return ResponseEntity.ok(updatedOrder);
    }
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/controller/ReportController.java">
package com.magazincomputere.magazin_api.controller;

import com.magazincomputere.magazin_api.dto.report.*;
import com.magazincomputere.magazin_api.service.ReportService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDate;
import java.time.format.DateTimeFormatter;

@RestController
// Am actualizat ruta de bază pentru a se potrivi cu celelalte controllere de admin
@RequestMapping("/api/admin/reports") 
@PreAuthorize("hasRole('ADMIN')")
public class ReportController {

    @Autowired
    private ReportService reportService;

    // Endpoint pentru a vedea datele raportului în format JSON (util pentru debugging)
    @GetMapping("/general")
    public ResponseEntity<GeneralReportDto> generateGeneralReport(
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate startDate,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate endDate) {
        
        GeneralReportDto report = reportService.generateGeneralReport(startDate, endDate);
        return ResponseEntity.ok(report);
    }
    
    // Endpoint unic și robust pentru descărcarea rapoartelor
    @GetMapping("/download")
    public ResponseEntity<byte[]> downloadReport(
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate startDate,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate endDate,
            @RequestParam String format) {
        
        byte[] reportData;
        String contentType;
        String fileName;

        // Construim un nume de fișier dinamic, care include perioada
        String dateSuffix = startDate.toString() + "_to_" + endDate.toString();

        if ("pdf".equalsIgnoreCase(format)) {
            reportData = reportService.generatePdfReport(startDate, endDate);
            contentType = MediaType.APPLICATION_PDF_VALUE;
            fileName = "Raport_" + dateSuffix + ".pdf";
        } else if ("excel".equalsIgnoreCase(format)) {
            reportData = reportService.generateExcelReport(startDate, endDate);
            contentType = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
            fileName = "Raport_" + dateSuffix + ".xlsx";
        } else {
            // Dacă formatul nu este nici pdf, nici excel, returnăm o eroare
            return ResponseEntity.badRequest().body("Format invalid. Folosiți 'pdf' sau 'excel'.".getBytes());
        }

        // Setăm antetele HTTP corecte pentru a forța descărcarea
        return ResponseEntity.ok()
                .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\"" + fileName + "\"")
                .contentType(MediaType.parseMediaType(contentType))
                .body(reportData);
    }
    
    // Am eliminat celelalte endpoint-uri individuale (/sales, /stock, /users) pentru a simplifica.
    // Acum totul se gestionează prin /general (pentru vizualizare JSON) și /download (pentru descărcare).
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/dto/ProductDto.java">
// src/main/java/com/magazincomputere/magazin_api/dto/ProductDto.java
package com.magazincomputere.magazin_api.dto;

import jakarta.validation.constraints.*;
import lombok.Data;
import java.util.List;
import java.math.BigDecimal;


@Data
public class ProductDto {
    private Long id;

    @NotBlank(message = "Numele produsului este obligatoriu")
    @Size(min = 3, max = 255, message = "Numele produsului trebuie să aibă între 3 și 255 de caractere")
    private String name;

    private String description;

    @NotNull(message = "Prețul este obligatoriu")
    @DecimalMin(value = "0.01", message = "Prețul trebuie să fie pozitiv")
    private BigDecimal price;

    @NotNull(message = "Cantitatea în stoc este obligatorie")
    @Min(value = 0, message = "Stocul nu poate fi negativ")
    private Integer stockQuantity;

    // private String imageBase64; // COMENTAT TEMPORAR

    @NotNull(message = "ID-ul categoriei este obligatoriu")
    private Long categoryId;
    private String categoryName;

    private List<SpecificationDto> specifications;
    private Double averageRating;
    private Integer reviewCount;
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/model/Product.java">
// src/main/java/com/magazincomputere/magazin_api/model/Product.java
package com.magazincomputere.magazin_api.model;

import jakarta.persistence.*;
import jakarta.validation.constraints.DecimalMin;
import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.ToString;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "products")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class Product {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @NotBlank(message = "Numele produsului este obligatoriu")
    @Size(min = 3, max = 255, message = "Numele produsului trebuie să aibă între 3 și 255 de caractere")
    @Column(nullable = false)
    private String name;

    @Column(columnDefinition = "TEXT")
    private String description;

    @NotNull(message = "Prețul este obligatoriu")
    @DecimalMin(value = "0.01", message = "Prețul trebuie să fie pozitiv")
    @Column(nullable = false)
   private BigDecimal price;

    @NotNull(message = "Cantitatea în stoc este obligatorie")
    @Min(value = 0, message = "Stocul nu poate fi negativ")
    @Column(nullable = false)
    private Integer stockQuantity;

    // @Lob // Adnotarea @Lob este importantă pentru câmpuri mari de tip TEXT în unele baze de date
    // @Column(columnDefinition = "TEXT") // Asigură-te că tipul de coloană este adecvat pentru base64
    // private String imageBase64; // COMENTAT TEMPORAR

    @ManyToOne(fetch = FetchType.EAGER)
    @JoinColumn(name = "category_id", nullable = false)
    @NotNull(message = "Categoria este obligatorie")
    private Category category;

    @OneToMany(mappedBy = "product", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private List<ProductSpecificationValue> specifications;

    public Product(Long id) {
        this.id = id;
    }
    @OneToMany(mappedBy = "product", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
@ToString.Exclude
@EqualsAndHashCode.Exclude
private List<Review> reviews = new ArrayList<>();

@Transient
private Double averageRating;

@Transient
private Integer reviewCount;

// Add a method to calculate average rating
public Double calculateAverageRating() {
    if (reviews == null || reviews.isEmpty()) {
        return 0.0;
    }
    return reviews.stream()
        .mapToInt(Review::getRating)
        .average()
        .orElse(0.0);
}

public Integer getReviewCount() {
    return reviews != null ? reviews.size() : 0;
}
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/service/ReportService.java">
package com.magazincomputere.magazin_api.service;

import com.magazincomputere.magazin_api.dto.report.*;
import com.magazincomputere.magazin_api.model.*;
import com.magazincomputere.magazin_api.repository.*;

// Excel imports
import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.apache.poi.ss.util.CellRangeAddress;

// PDF imports
import com.itextpdf.kernel.pdf.PdfDocument;
import com.itextpdf.kernel.pdf.PdfWriter;
import com.itextpdf.layout.Document;
import com.itextpdf.layout.element.Paragraph;
import com.itextpdf.layout.element.Table;
// Not importing com.itextpdf.layout.element.Cell to avoid conflicts
import com.itextpdf.layout.properties.TextAlignment;
import com.itextpdf.layout.properties.UnitValue;
import com.itextpdf.kernel.colors.ColorConstants;
import com.itextpdf.kernel.font.PdfFont;
import com.itextpdf.kernel.font.PdfFontFactory;
import com.itextpdf.io.font.constants.StandardFonts;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.YearMonth;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.stream.Collectors;
@Service
@Transactional(readOnly = true)
public class ReportService {

    @Autowired
    private OrderRepository orderRepository;
    
    @Autowired
    private ProductRepository productRepository;
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private CategoryRepository categoryRepository;

    public GeneralReportDto generateGeneralReport(LocalDate startDate, LocalDate endDate) {
        GeneralReportDto report = new GeneralReportDto();
        report.setGeneratedAt(LocalDateTime.now());
        
        ReportPeriodDto period = new ReportPeriodDto();
        period.setStartDate(startDate);
        period.setEndDate(endDate);
        period.setType("custom");
        report.setReportPeriod(period);
        
        report.setSalesReport(generateSalesReport(startDate, endDate));
        report.setStockReport(generateStockReport());
        report.setUserReport(generateUserReport());
        
        return report;
    }

    public SalesReportDto generateSalesReport(LocalDate startDate, LocalDate endDate) {
        SalesReportDto salesReport = new SalesReportDto();
        salesReport.setPeriodStart(startDate);
        salesReport.setPeriodEnd(endDate);
        
        // Obține toate comenzile din perioada specificată
        List<Order> orders = orderRepository.findAll().stream()
            .filter(order -> {
                LocalDate orderDate = order.getOrderDate().toLocalDate();
                return !orderDate.isBefore(startDate) && !orderDate.isAfter(endDate);
            })
            .filter(order -> !"CANCELED".equals(order.getStatus()))
            .collect(Collectors.toList());
        
        // Calculează totaluri
        salesReport.setTotalSales(orders.size());
        BigDecimal totalRevenue = orders.stream()
            .map(Order::getTotalAmount)
            .reduce(BigDecimal.ZERO, BigDecimal::add);
        salesReport.setTotalRevenue(totalRevenue);
        
        // Vânzări zilnice
        Map<LocalDate, List<Order>> ordersByDate = orders.stream()
            .collect(Collectors.groupingBy(order -> order.getOrderDate().toLocalDate()));
        
        List<DailySalesDto> dailySales = new ArrayList<>();
        LocalDate currentDate = startDate;
        while (!currentDate.isAfter(endDate)) {
            List<Order> dayOrders = ordersByDate.getOrDefault(currentDate, new ArrayList<>());
            DailySalesDto dailySale = new DailySalesDto();
            dailySale.setDate(currentDate);
            dailySale.setSalesCount(dayOrders.size());
            dailySale.setRevenue(dayOrders.stream()
                .map(Order::getTotalAmount)
                .reduce(BigDecimal.ZERO, BigDecimal::add));
            dailySales.add(dailySale);
            currentDate = currentDate.plusDays(1);
        }
        salesReport.setDailySales(dailySales);
        
        // Top produse vândute
        Map<Product, Integer> productSales = new HashMap<>();
        Map<Product, BigDecimal> productRevenue = new HashMap<>();
        
        for (Order order : orders) {
            for (OrderItem item : order.getOrderItems()) {
                Product product = productRepository.findById(item.getProductIdSnapshot()).orElse(null);
                if (product != null) {
                    productSales.merge(product, item.getQuantity(), Integer::sum);
                    productRevenue.merge(product, item.getLineTotal(), BigDecimal::add);
                }
            }
        }
        
        List<ProductSalesDto> topProducts = productSales.entrySet().stream()
            .sorted(Map.Entry.<Product, Integer>comparingByValue().reversed())
            .limit(10)
            .map(entry -> {
                Product product = entry.getKey();
                ProductSalesDto dto = new ProductSalesDto();
                dto.setProductId(product.getId());
                dto.setProductName(product.getName());
                dto.setCategory(product.getCategory().getName());
                dto.setQuantitySold(entry.getValue());
                dto.setRevenue(productRevenue.get(product));
                dto.setCurrentStock(product.getStockQuantity());
                return dto;
            })
            .collect(Collectors.toList());
        salesReport.setTopSellingProducts(topProducts);
        
        // Vânzări pe categorii
        Map<String, Integer> categorySales = new HashMap<>();
        Map<String, BigDecimal> categoryRevenue = new HashMap<>();
        
        for (Map.Entry<Product, Integer> entry : productSales.entrySet()) {
            String categoryName = entry.getKey().getCategory().getName();
            categorySales.merge(categoryName, entry.getValue(), Integer::sum);
            categoryRevenue.merge(categoryName, productRevenue.get(entry.getKey()), BigDecimal::add);
        }
        
        List<CategorySalesDto> categorySalesList = categorySales.entrySet().stream()
            .map(entry -> {
                CategorySalesDto dto = new CategorySalesDto();
                dto.setCategory(entry.getKey());
                dto.setQuantitySold(entry.getValue());
                dto.setRevenue(categoryRevenue.get(entry.getKey()));
                return dto;
            })
            .collect(Collectors.toList());
        salesReport.setCategorySales(categorySalesList);
        
        return salesReport;
    }

    public StockReportDto generateStockReport() {
        StockReportDto stockReport = new StockReportDto();
        
        List<Product> allProducts = productRepository.findAll();
        
        // Total produse și valoare stoc
        stockReport.setTotalProducts(allProducts.size());
        BigDecimal totalStockValue = allProducts.stream()
            .map(p -> p.getPrice().multiply(new BigDecimal(p.getStockQuantity())))
            .reduce(BigDecimal.ZERO, BigDecimal::add);
        stockReport.setTotalStockValue(totalStockValue);
        
        // Produse cu stoc redus (< 10)
        List<StockItemDto> lowStock = allProducts.stream()
            .filter(p -> p.getStockQuantity() > 0 && p.getStockQuantity() < 10)
            .map(this::productToStockItem)
            .collect(Collectors.toList());
        stockReport.setLowStockProducts(lowStock);
        
        // Produse fără stoc
        List<StockItemDto> outOfStock = allProducts.stream()
            .filter(p -> p.getStockQuantity() == 0)
            .map(this::productToStockItem)
            .collect(Collectors.toList());
        stockReport.setOutOfStockProducts(outOfStock);
        
        // Stoc pe categorii
        Map<Category, List<Product>> productsByCategory = allProducts.stream()
            .collect(Collectors.groupingBy(Product::getCategory));
        
        List<CategoryStockDto> categoryStocks = productsByCategory.entrySet().stream()
            .map(entry -> {
                CategoryStockDto dto = new CategoryStockDto();
                dto.setCategory(entry.getKey().getName());
                dto.setTotalProducts(entry.getValue().size());
                dto.setTotalStock(entry.getValue().stream()
                    .mapToInt(Product::getStockQuantity)
                    .sum());
                dto.setStockValue(entry.getValue().stream()
                    .map(p -> p.getPrice().multiply(new BigDecimal(p.getStockQuantity())))
                    .reduce(BigDecimal.ZERO, BigDecimal::add));
                return dto;
            })
            .collect(Collectors.toList());
        stockReport.setCategoryStock(categoryStocks);
        
        return stockReport;
    }

    public UserReportDto generateUserReport() {
        UserReportDto userReport = new UserReportDto();
        
        List<User> allUsers = userRepository.findAll();
        userReport.setTotalUsers(allUsers.size());
        
        // Pentru active users - considerăm toți utilizatorii ca activi momentan
        // În producție, ai putea avea un câmp lastLoginDate în User
        userReport.setActiveUsers(allUsers.size());
        
        // Utilizatori noi luna aceasta
        YearMonth currentMonth = YearMonth.now();
        LocalDateTime startOfMonth = currentMonth.atDay(1).atStartOfDay();
        long newUsersCount = allUsers.stream()
            .filter(user -> {
                // Presupunem că avem un câmp createdDate în User
                // Pentru moment, returnăm un număr estimativ
                return true; // Înlocuiește cu logica reală
            })
            .count();
        userReport.setNewUsersThisMonth((int) newUsersCount);
        
        // Utilizatori pe roluri
        Map<String, Long> usersByRole = allUsers.stream()
            .flatMap(user -> user.getRoles().stream())
            .collect(Collectors.groupingBy(role -> role.getName().name(), Collectors.counting()));
        
        List<UserRoleCountDto> roleCountList = usersByRole.entrySet().stream()
            .map(entry -> {
                UserRoleCountDto dto = new UserRoleCountDto();
                dto.setRole(entry.getKey());
                dto.setCount(entry.getValue().intValue());
                return dto;
            })
            .collect(Collectors.toList());
        userReport.setUsersByRole(roleCountList);
        
        // Înregistrări recente (ultimii 10 utilizatori)
        List<UserInfoDto> recentUsers = allUsers.stream()
            .sorted((u1, u2) -> Long.compare(u2.getId(), u1.getId())) // Sortare inversă după ID
            .limit(10)
            .map(user -> {
                UserInfoDto dto = new UserInfoDto();
                dto.setId(user.getId());
                dto.setUsername(user.getUsername());
                dto.setEmail(user.getEmail());
                dto.setRegistrationDate(LocalDateTime.now()); // Placeholder
                dto.setLastLoginDate(LocalDateTime.now()); // Placeholder
                dto.setIsActive(true);
                return dto;
            })
            .collect(Collectors.toList());
        userReport.setRecentRegistrations(recentUsers);
        
        return userReport;
    }

    private StockItemDto productToStockItem(Product product) {
        StockItemDto dto = new StockItemDto();
        dto.setProductId(product.getId());
        dto.setProductName(product.getName());
        dto.setCategory(product.getCategory().getName());
        dto.setCurrentStock(product.getStockQuantity());
        dto.setPrice(product.getPrice());
        dto.setStockValue(product.getPrice().multiply(new BigDecimal(product.getStockQuantity())));
        return dto;
    }

    public byte[] generatePdfReport(LocalDate startDate, LocalDate endDate) {
        try (ByteArrayOutputStream baos = new ByteArrayOutputStream()) {
            PdfWriter writer = new PdfWriter(baos);
            PdfDocument pdf = new PdfDocument(writer);
            Document document = new Document(pdf);
            
            PdfFont titleFont = PdfFontFactory.createFont(StandardFonts.HELVETICA_BOLD);
            PdfFont normalFont = PdfFontFactory.createFont(StandardFonts.HELVETICA);
            PdfFont headerFont = PdfFontFactory.createFont(StandardFonts.HELVETICA_BOLD);
            
            document.add(new Paragraph("RAPORT GENERAL - MAGAZIN CALCULATOARE")
                .setFont(titleFont).setFontSize(18).setTextAlignment(TextAlignment.CENTER).setMarginBottom(20));
            
            document.add(new Paragraph(String.format("Perioada: %s - %s", 
                startDate.format(DateTimeFormatter.ofPattern("dd/MM/yyyy")),
                endDate.format(DateTimeFormatter.ofPattern("dd/MM/yyyy"))))
                .setFont(normalFont).setTextAlignment(TextAlignment.CENTER).setMarginBottom(20));
            
            GeneralReportDto report = generateGeneralReport(startDate, endDate);
            
            // SALES SUMMARY
            document.add(new Paragraph("1. REZUMAT VÂNZĂRI").setFont(titleFont).setFontSize(14).setMarginTop(20).setMarginBottom(10));
            Table salesSummaryTable = new Table(2).setWidth(UnitValue.createPercentValue(100));
            salesSummaryTable.addCell(createHeaderCell("Total Vânzări:", headerFont));
            salesSummaryTable.addCell(createCell(report.getSalesReport().getTotalSales().toString() + " comenzi", normalFont));
            salesSummaryTable.addCell(createHeaderCell("Venituri Totale:", headerFont));
            salesSummaryTable.addCell(createCell(formatCurrency(report.getSalesReport().getTotalRevenue()), normalFont));
            document.add(salesSummaryTable);
            
            // TOP SELLING PRODUCTS
            document.add(new Paragraph("2. TOP PRODUSE VÂNDUTE").setFont(titleFont).setFontSize(14).setMarginTop(20).setMarginBottom(10));
            Table topProductsTable = new Table(new float[]{3, 2, 1, 2, 1}).setWidth(UnitValue.createPercentValue(100));
            topProductsTable.addHeaderCell(createHeaderCell("Produs", headerFont));
            topProductsTable.addHeaderCell(createHeaderCell("Categorie", headerFont));
            topProductsTable.addHeaderCell(createHeaderCell("Cantitate", headerFont));
            topProductsTable.addHeaderCell(createHeaderCell("Venituri", headerFont));
            topProductsTable.addHeaderCell(createHeaderCell("Stoc", headerFont));
            for (ProductSalesDto product : report.getSalesReport().getTopSellingProducts()) {
                topProductsTable.addCell(createCell(product.getProductName(), normalFont));
                topProductsTable.addCell(createCell(product.getCategory(), normalFont));
                topProductsTable.addCell(createCell(product.getQuantitySold().toString(), normalFont));
                topProductsTable.addCell(createCell(formatCurrency(product.getRevenue()), normalFont));
                topProductsTable.addCell(createCell(product.getCurrentStock().toString(), normalFont));
            }
            document.add(topProductsTable);
            
            // STOCK SUMMARY
            document.add(new Paragraph("3. REZUMAT STOC").setFont(titleFont).setFontSize(14).setMarginTop(20).setMarginBottom(10));
            Table stockSummaryTable = new Table(2).setWidth(UnitValue.createPercentValue(100));
            stockSummaryTable.addCell(createHeaderCell("Total Produse:", headerFont));
            stockSummaryTable.addCell(createCell(report.getStockReport().getTotalProducts().toString(), normalFont));
            stockSummaryTable.addCell(createHeaderCell("Valoare Totală Stoc:", headerFont));
            stockSummaryTable.addCell(createCell(formatCurrency(report.getStockReport().getTotalStockValue()), normalFont));
            stockSummaryTable.addCell(createHeaderCell("Produse Fără Stoc:", headerFont));
            stockSummaryTable.addCell(createCell(String.valueOf(report.getStockReport().getOutOfStockProducts().size()), normalFont));
            stockSummaryTable.addCell(createHeaderCell("Produse Stoc Redus:", headerFont));
            stockSummaryTable.addCell(createCell(String.valueOf(report.getStockReport().getLowStockProducts().size()), normalFont));
            document.add(stockSummaryTable);

            document.close();
            return baos.toByteArray();
        } catch (IOException e) {
            throw new RuntimeException("Eroare la generarea PDF", e);
        }
    }

     public byte[] generateExcelReport(LocalDate startDate, LocalDate endDate) {
        try (XSSFWorkbook workbook = new XSSFWorkbook();
             ByteArrayOutputStream baos = new ByteArrayOutputStream()) {
            
            GeneralReportDto report = generateGeneralReport(startDate, endDate);
            
            CellStyle headerStyle = createHeaderStyle(workbook);
            CellStyle titleStyle = createTitleStyle(workbook);
            CellStyle currencyStyle = createCurrencyStyle(workbook);
            CellStyle dateStyle = createDateStyle(workbook);
            
            // SUMMARY SHEET
            Sheet summarySheet = workbook.createSheet("Rezumat");
            int rowNum = 0;
            
            // Title
            Row titleRow = summarySheet.createRow(rowNum++);
            Cell titleCell = titleRow.createCell(0);
            titleCell.setCellValue("RAPORT GENERAL - MAGAZIN CALCULATOARE");
            titleCell.setCellStyle(titleStyle);
            summarySheet.addMergedRegion(new CellRangeAddress(0, 0, 0, 3));
            
            // Period
            Row periodRow = summarySheet.createRow(rowNum++);
            periodRow.createCell(0).setCellValue("Perioada: " + startDate + " - " + endDate);
            rowNum++; // Empty row
            
            // Sales Summary
            Row salesHeaderRow = summarySheet.createRow(rowNum++);
            salesHeaderRow.createCell(0).setCellValue("REZUMAT VÂNZĂRI");
            salesHeaderRow.getCell(0).setCellStyle(headerStyle);
            
            Row totalSalesRow = summarySheet.createRow(rowNum++);
            totalSalesRow.createCell(0).setCellValue("Total Vânzări:");
            totalSalesRow.createCell(1).setCellValue(report.getSalesReport().getTotalSales());
            
            Row totalRevenueRow = summarySheet.createRow(rowNum++);
            totalRevenueRow.createCell(0).setCellValue("Venituri Totale:");
            Cell revenueCell = totalRevenueRow.createCell(1);
            revenueCell.setCellValue(report.getSalesReport().getTotalRevenue().doubleValue());
            revenueCell.setCellStyle(currencyStyle);
            
            rowNum++; // Empty row
            
            // Stock Summary
            Row stockHeaderRow = summarySheet.createRow(rowNum++);
            stockHeaderRow.createCell(0).setCellValue("REZUMAT STOC");
            stockHeaderRow.getCell(0).setCellStyle(headerStyle);
            
            Row totalProductsRow = summarySheet.createRow(rowNum++);
            totalProductsRow.createCell(0).setCellValue("Total Produse:");
            totalProductsRow.createCell(1).setCellValue(report.getStockReport().getTotalProducts());
            
            Row stockValueRow = summarySheet.createRow(rowNum++);
            stockValueRow.createCell(0).setCellValue("Valoare Stoc:");
            Cell stockValueCell = stockValueRow.createCell(1);
            stockValueCell.setCellValue(report.getStockReport().getTotalStockValue().doubleValue());
            stockValueCell.setCellStyle(currencyStyle);
            
            // Auto-size columns
            for (int i = 0; i < 4; i++) {
                summarySheet.autoSizeColumn(i);
            }
            
            // 2. SALES DETAILS SHEET
            Sheet salesSheet = workbook.createSheet("Vânzări Detaliate");
            createSalesDetailsSheet(salesSheet, report.getSalesReport(), headerStyle, currencyStyle);
            
            // 3. TOP PRODUCTS SHEET
            Sheet topProductsSheet = workbook.createSheet("Top Produse");
            createTopProductsSheet(topProductsSheet, report.getSalesReport().getTopSellingProducts(), headerStyle, currencyStyle);
            
            // 4. STOCK DETAILS SHEET
            Sheet stockSheet = workbook.createSheet("Detalii Stoc");
            createStockDetailsSheet(stockSheet, report.getStockReport(), headerStyle, currencyStyle);
            
            // 5. USER DETAILS SHEET
            Sheet userSheet = workbook.createSheet("Utilizatori");
            createUserDetailsSheet(userSheet, report.getUserReport(), headerStyle, dateStyle);
            
            workbook.write(baos);
            return baos.toByteArray();
            
        } catch (IOException e) {
            throw new RuntimeException("Eroare la generarea Excel", e);
        }
    }
    
    private void createSalesDetailsSheet(Sheet sheet, SalesReportDto salesReport, CellStyle headerStyle, CellStyle currencyStyle) {
        int rowNum = 0;
        
        // Headers
        Row headerRow = sheet.createRow(rowNum++);
        String[] headers = {"Data", "Nr. Vânzări", "Venituri"};
        for (int i = 0; i < headers.length; i++) {
            Cell cell = headerRow.createCell(i);
            cell.setCellValue(headers[i]);
            cell.setCellStyle(headerStyle);
        }
        
        // Data
        for (DailySalesDto dailySale : salesReport.getDailySales()) {
            Row row = sheet.createRow(rowNum++);
            row.createCell(0).setCellValue(dailySale.getDate().toString());
            row.createCell(1).setCellValue(dailySale.getSalesCount());
            Cell revenueCell = row.createCell(2);
            revenueCell.setCellValue(dailySale.getRevenue().doubleValue());
            revenueCell.setCellStyle(currencyStyle);
        }
        
        // Auto-size columns
        for (int i = 0; i < headers.length; i++) {
            sheet.autoSizeColumn(i);
        }
    }
    
    private void createTopProductsSheet(Sheet sheet, List<ProductSalesDto> products, CellStyle headerStyle, CellStyle currencyStyle) {
        int rowNum = 0;
        
        // Headers
        Row headerRow = sheet.createRow(rowNum++);
        String[] headers = {"Produs", "Categorie", "Cantitate Vândută", "Venituri", "Stoc Curent"};
        for (int i = 0; i < headers.length; i++) {
            Cell cell = headerRow.createCell(i);
            cell.setCellValue(headers[i]);
            cell.setCellStyle(headerStyle);
        }
        
        // Data
        for (ProductSalesDto product : products) {
            Row row = sheet.createRow(rowNum++);
            row.createCell(0).setCellValue(product.getProductName());
            row.createCell(1).setCellValue(product.getCategory());
            row.createCell(2).setCellValue(product.getQuantitySold());
            Cell revenueCell = row.createCell(3);
            revenueCell.setCellValue(product.getRevenue().doubleValue());
            revenueCell.setCellStyle(currencyStyle);
            row.createCell(4).setCellValue(product.getCurrentStock());
        }
        
        // Auto-size columns
        for (int i = 0; i < headers.length; i++) {
            sheet.autoSizeColumn(i);
        }
    }
    
    private void createStockDetailsSheet(Sheet sheet, StockReportDto stockReport, CellStyle headerStyle, CellStyle currencyStyle) {
        int rowNum = 0;
        
        // Low Stock Products Section
        Row lowStockHeader = sheet.createRow(rowNum++);
        lowStockHeader.createCell(0).setCellValue("PRODUSE CU STOC REDUS");
        lowStockHeader.getCell(0).setCellStyle(headerStyle);
        rowNum++;
        
        if (!stockReport.getLowStockProducts().isEmpty()) {
            // Headers
            Row headerRow = sheet.createRow(rowNum++);
            String[] headers = {"Produs", "Categorie", "Stoc", "Preț", "Valoare Stoc"};
            for (int i = 0; i < headers.length; i++) {
                Cell cell = headerRow.createCell(i);
                cell.setCellValue(headers[i]);
                cell.setCellStyle(headerStyle);
            }
            
            // Data
            for (StockItemDto item : stockReport.getLowStockProducts()) {
                Row row = sheet.createRow(rowNum++);
                row.createCell(0).setCellValue(item.getProductName());
                row.createCell(1).setCellValue(item.getCategory());
                row.createCell(2).setCellValue(item.getCurrentStock());
                Cell priceCell = row.createCell(3);
                priceCell.setCellValue(item.getPrice().doubleValue());
                priceCell.setCellStyle(currencyStyle);
                Cell valueCell = row.createCell(4);
                valueCell.setCellValue(item.getStockValue().doubleValue());
                valueCell.setCellStyle(currencyStyle);
            }
        }
        
        rowNum += 2; // Empty rows
        
        // Out of Stock Products Section
        Row outOfStockHeader = sheet.createRow(rowNum++);
        outOfStockHeader.createCell(0).setCellValue("PRODUSE FĂRĂ STOC");
        outOfStockHeader.getCell(0).setCellStyle(headerStyle);
        rowNum++;
        
        if (!stockReport.getOutOfStockProducts().isEmpty()) {
            // Headers
            Row headerRow = sheet.createRow(rowNum++);
            String[] headers = {"Produs", "Categorie", "Preț"};
            for (int i = 0; i < headers.length; i++) {
                Cell cell = headerRow.createCell(i);
                cell.setCellValue(headers[i]);
                cell.setCellStyle(headerStyle);
            }
            
            // Data
            for (StockItemDto item : stockReport.getOutOfStockProducts()) {
                Row row = sheet.createRow(rowNum++);
                row.createCell(0).setCellValue(item.getProductName());
                row.createCell(1).setCellValue(item.getCategory());
                Cell priceCell = row.createCell(2);
                priceCell.setCellValue(item.getPrice().doubleValue());
                priceCell.setCellStyle(currencyStyle);
            }
        }
        
        // Auto-size columns
        for (int i = 0; i < 5; i++) {
            sheet.autoSizeColumn(i);
        }
    }
    
    private void createUserDetailsSheet(Sheet sheet, UserReportDto userReport, CellStyle headerStyle, CellStyle dateStyle) {
        int rowNum = 0;
        
        // Summary
        Row summaryHeader = sheet.createRow(rowNum++);
        summaryHeader.createCell(0).setCellValue("REZUMAT UTILIZATORI");
        summaryHeader.getCell(0).setCellStyle(headerStyle);
        rowNum++;
        
        Row totalUsersRow = sheet.createRow(rowNum++);
        totalUsersRow.createCell(0).setCellValue("Total Utilizatori:");
        totalUsersRow.createCell(1).setCellValue(userReport.getTotalUsers());
        
        Row activeUsersRow = sheet.createRow(rowNum++);
        activeUsersRow.createCell(0).setCellValue("Utilizatori Activi:");
        activeUsersRow.createCell(1).setCellValue(userReport.getActiveUsers());
        
        Row newUsersRow = sheet.createRow(rowNum++);
        newUsersRow.createCell(0).setCellValue("Utilizatori Noi (luna aceasta):");
        newUsersRow.createCell(1).setCellValue(userReport.getNewUsersThisMonth());
        
        rowNum += 2; // Empty rows
        
        // Users by Role
        Row rolesHeader = sheet.createRow(rowNum++);
        rolesHeader.createCell(0).setCellValue("UTILIZATORI PE ROLURI");
        rolesHeader.getCell(0).setCellStyle(headerStyle);
        rowNum++;
        
        for (UserRoleCountDto roleCount : userReport.getUsersByRole()) {
            Row row = sheet.createRow(rowNum++);
            row.createCell(0).setCellValue(roleCount.getRole());
            row.createCell(1).setCellValue(roleCount.getCount());
        }
        
        // Auto-size columns
        for (int i = 0; i < 4; i++) {
            sheet.autoSizeColumn(i);
        }
    }
    
    // --- PDF HELPER METHODS ---
    private com.itextpdf.layout.element.Cell createCell(String content, PdfFont font) {
        return new com.itextpdf.layout.element.Cell().add(new Paragraph(content).setFont(font));
    }
    
    private com.itextpdf.layout.element.Cell createHeaderCell(String content, PdfFont font) {
        return new com.itextpdf.layout.element.Cell()
            .add(new Paragraph(content).setFont(font))
            .setBackgroundColor(ColorConstants.LIGHT_GRAY);
    }
    
    private String formatCurrency(BigDecimal amount) {
        return String.format("RON %.2f", amount);
    }
    
    // Helper methods for Excel styles
    private CellStyle createHeaderStyle(Workbook workbook) {
        CellStyle style = workbook.createCellStyle();
        Font font = workbook.createFont();
        font.setBold(true);
        style.setFont(font);
        style.setFillForegroundColor(IndexedColors.GREY_25_PERCENT.getIndex());
        style.setFillPattern(FillPatternType.SOLID_FOREGROUND);
        style.setBorderBottom(BorderStyle.THIN);
        style.setBorderTop(BorderStyle.THIN);
        style.setBorderLeft(BorderStyle.THIN);
        style.setBorderRight(BorderStyle.THIN);
        return style;
    }
    
    private CellStyle createTitleStyle(Workbook workbook) {
        CellStyle style = workbook.createCellStyle();
        Font font = workbook.createFont();
        font.setBold(true);
        font.setFontHeightInPoints((short) 16);
        style.setFont(font);
        style.setAlignment(HorizontalAlignment.CENTER);
        return style;
    }
    
    private CellStyle createCurrencyStyle(Workbook workbook) {
        CellStyle style = workbook.createCellStyle();
        DataFormat format = workbook.createDataFormat();
        style.setDataFormat(format.getFormat("RON #,##0.00"));
        return style;
    }
    
    private CellStyle createDateStyle(Workbook workbook) {
        CellStyle style = workbook.createCellStyle();
        DataFormat format = workbook.createDataFormat();
        style.setDataFormat(format.getFormat("dd/mm/yyyy"));
        return style;
    }
}
</file>

<file path="frontend/src/app/auth/auth.service.ts">
import { Injectable, Inject, PLATFORM_ID, inject } from '@angular/core';
import { isPlatformBrowser } from '@angular/common';
import { Router } from '@angular/router';
import { HttpClient, HttpErrorResponse } from '@angular/common/http';
import { Observable, BehaviorSubject, throwError, of } from 'rxjs';
import { catchError, map, tap } from 'rxjs/operators';
import { User, JwtResponse, LoginRequest, SignupRequest } from '../shared/models/user.model';

export type Role = 'admin' | 'user';

interface StoredUser extends User {
  token?: string;
}

@Injectable({ providedIn: 'root' })
export class AuthService {
  private apiUrl = '/api/auth';
  private currentUserSubject: BehaviorSubject<StoredUser | null>;
  public user$: Observable<StoredUser | null>;

  private readonly TOKEN_KEY = 'authToken';
  private readonly USER_KEY = 'currentUserDetails';
  private readonly REMEMBER_KEY = 'rememberMe';

  constructor(
    private router: Router,
    private http: HttpClient,
    @Inject(PLATFORM_ID) private platformId: Object
  ) {
    let initialUser: StoredUser | null = null;
    if (isPlatformBrowser(this.platformId)) {
      // Check if user chose to be remembered
      const rememberMe = localStorage.getItem(this.REMEMBER_KEY) === 'true';
      const storage = rememberMe ? localStorage : sessionStorage;
      
      const storedToken = storage.getItem(this.TOKEN_KEY);
      const storedUserJson = storage.getItem(this.USER_KEY);
      
      if (storedToken && storedUserJson) {
        try {
          // Check token expiration
          if (!this.isTokenExpired(storedToken)) {
            initialUser = JSON.parse(storedUserJson) as StoredUser;
            initialUser.token = storedToken;
          } else {
            // Token expired, clear storage
            this.clearStorage();
          }
        } catch (e) {
          console.error('Eroare la parsarea datelor utilizatorului din storage', e);
          this.clearStorage();
        }
      }
    }
    this.currentUserSubject = new BehaviorSubject<StoredUser | null>(initialUser);
    this.user$ = this.currentUserSubject.asObservable();
  }

  private isTokenExpired(token: string): boolean {
    try {
      const payload = JSON.parse(atob(token.split('.')[1]));
      const expiry = payload.exp;
      return Math.floor(new Date().getTime() / 1000) >= expiry;
    } catch (e) {
      return true;
    }
  }

  private clearStorage(): void {
    if (isPlatformBrowser(this.platformId)) {
      // Clear from both storages
      localStorage.removeItem(this.TOKEN_KEY);
      localStorage.removeItem(this.USER_KEY);
      localStorage.removeItem(this.REMEMBER_KEY);
      sessionStorage.removeItem(this.TOKEN_KEY);
      sessionStorage.removeItem(this.USER_KEY);
    }
  }

  login(username: string, password: string, rememberMe: boolean = false): Observable<boolean> {
    const loginRequest: LoginRequest = { username, password };
    return this.http.post<JwtResponse>(`${this.apiUrl}/login`, loginRequest)
      .pipe(
        tap(response => {
          if (response && response.token && response.username) {
            const userDetails: StoredUser = {
              id: response.id,
              username: response.username,
              email: response.email,
              roles: response.roles,
              token: response.token
            };
            if (isPlatformBrowser(this.platformId)) {
              const storage = rememberMe ? localStorage : sessionStorage;
              storage.setItem(this.TOKEN_KEY, response.token);
              storage.setItem(this.USER_KEY, JSON.stringify(userDetails));
              
              // Store remember me preference
              if (rememberMe) {
                localStorage.setItem(this.REMEMBER_KEY, 'true');
              } else {
                localStorage.removeItem(this.REMEMBER_KEY);
              }
            }
            this.currentUserSubject.next(userDetails);
          } else {
            this.handleLoginError(new Error('Răspuns invalid de la server la login.'));
          }
        }),
        map(response => !!(response && response.token)),
        catchError(error => {
          this.handleLoginError(error);
          return of(false);
        })
      );
  }

  signup(signupData: SignupRequest): Observable<any> {
    return this.http.post<any>(`${this.apiUrl}/signup`, signupData)
      .pipe(catchError(this.handleError));
  }

  logout(): void {
    this.clearStorage();
    this.currentUserSubject.next(null);
    this.router.navigate(['/login']);
  }

  isLoggedIn(): boolean {
    return !!this.currentUserSubject.value && !this.isTokenExpired(this.getToken() || '');
  }

  get role(): Role | null {
    const user = this.currentUserSubject.value;
    if (user && user.roles && user.roles.length > 0) {
      if (user.roles.includes('ROLE_ADMIN')) {
        return 'admin';
      }
      if (user.roles.includes('ROLE_USER')) {
        return 'user';
      }
    }
    return null;
  }

  getCurrentUser(): StoredUser | null {
    return this.currentUserSubject.value;
  }

  getToken(): string | null {
    if (isPlatformBrowser(this.platformId)) {
      // Check both storages
      return localStorage.getItem(this.TOKEN_KEY) || sessionStorage.getItem(this.TOKEN_KEY);
    }
    return null;
  }

  private handleLoginError(error: HttpErrorResponse | Error): void {
    let detailedErrorMessage = 'Eroare necunoscută la login.';
    let userFriendlyMessage = 'Autentificare eșuată. Verificați credențialele sau încercați mai târziu.';

    if (error instanceof HttpErrorResponse) {
        if (error.error && typeof error.error === 'object' && error.error !== null) {
            detailedErrorMessage = (error.error as any).message || JSON.stringify(error.error);
            if ((error.error as any).message) {
                userFriendlyMessage = (error.error as any).message;
            }
        } else if (typeof error.error === 'string') {
            detailedErrorMessage = error.error;
            userFriendlyMessage = error.error;
        } else {
            detailedErrorMessage = `Status: ${error.status}, Mesaj: ${error.message}`;
        }
         if (error.status === 401) {
            userFriendlyMessage = 'Nume de utilizator sau parolă incorectă.';
        } else if (error.status === 0 || error.status === -1) {
            userFriendlyMessage = 'Eroare de conexiune cu serverul de autentificare.';
        }

    } else if (error instanceof Error) {
        detailedErrorMessage = error.message;
        userFriendlyMessage = error.message;
    }

    console.error('------------------------------------');
    console.error('[LOGIN ERROR] Mesaj detaliat:', detailedErrorMessage);
    console.error('Obiect eroare complet:', error);
    console.error('------------------------------------');

    this.clearStorage();
    this.currentUserSubject.next(null);
  }

  private handleError(error: HttpErrorResponse) {
    let userFriendlyErrorMessage = 'A apărut o problemă. Vă rugăm încercați din nou mai târziu.';
    let detailedErrorMessage = 'Eroare necunoscută.';

    if (error.error && typeof error.error === 'object' && error.error !== null) {
      detailedErrorMessage = 
          (error.error as any).message ||
          (error.error as any).detail ||
          (error.error as any).error?.message ||
          JSON.stringify(error.error);

      if ((error.error as any).message && typeof (error.error as any).message === 'string') {
        userFriendlyErrorMessage = (error.error as any).message;
      }
    } else if (typeof error.error === 'string') {
      detailedErrorMessage = error.error;
      userFriendlyErrorMessage = error.error; 
    } else if (error.message) {
      detailedErrorMessage = error.message;
      if (error.status === 0 || error.status === -1) {
          userFriendlyErrorMessage = 'Eroare de conexiune cu serverul. Verificați rețeaua sau dacă serverul backend rulează.';
      } else {
          userFriendlyErrorMessage = `A apărut o eroare (${error.status}): ${error.statusText}`;
      }
    } else {
      detailedErrorMessage = `Cod eroare server: ${error.status}, status text: ${error.statusText || 'Necunoscut'}`;
      userFriendlyErrorMessage = `A apărut o eroare (${error.status}). Vă rugăm încercați mai târziu.`;
    }

    console.error('------------------------------------');
    console.error(`[SERVICE ERROR ENCOUNTERED]`);
    console.error(`URL: ${error.url}`);
    console.error(`Status: ${error.status} - ${error.statusText}`);
    console.error(`User-Friendly Message: ${userFriendlyErrorMessage}`);
    console.error(`Detailed Error Message/Body: ${detailedErrorMessage}`);
    console.error('Full HttpErrorResponse Object:', error);
    console.error('------------------------------------');

    return throwError(() => new Error(userFriendlyErrorMessage));
  }
}
</file>

<file path="frontend/src/app/features/admin-dashboard/admin-dashboard.component.html">
<mat-sidenav-container class="admin-dashboard-container">
  <mat-sidenav #sidenav mode="side" opened class="admin-sidenav">
    <div class="sidenav-header">
      <h3>Panou Admin</h3>
    </div>
    <mat-nav-list>
      <a mat-list-item routerLink="/admin/products" routerLinkActive="active-link">
        <mat-icon matListItemIcon>inventory_2</mat-icon>
        <span matListItemTitle>Produse</span>
      </a>
      <a mat-list-item routerLink="/admin/categories" routerLinkActive="active-link">
        <mat-icon matListItemIcon>category</mat-icon>
        <span matListItemTitle>Categorii</span>
      </a>
      <a mat-list-item routerLink="/admin/orders" routerLinkActive="active-link">
        <mat-icon matListItemIcon>shopping_cart</mat-icon>
        <span matListItemTitle>Comenzi</span>
      </a>
      <a mat-list-item routerLink="/admin/specification-definitions" routerLinkActive="active-link">
        <mat-icon matListItemIcon>tune</mat-icon>
        <span matListItemTitle>Def. Specificații</span>
      </a>
      <a mat-list-item routerLink="/admin/users" routerLinkActive="active-link"> <mat-icon matListItemIcon>people</mat-icon>
        <span matListItemTitle>Utilizatori</span>
      </a>
      <a mat-list-item routerLink="/admin/reports" routerLinkActive="active-link">
        <mat-icon matListItemIcon>assessment</mat-icon>
         <span matListItemTitle>Rapoarte</span>
      </a>
      <mat-divider></mat-divider>
      <a mat-list-item (click)="auth.logout()">
        <mat-icon matListItemIcon>logout</mat-icon>
        <span matListItemTitle>Deconectare</span>
      </a>
    </mat-nav-list>
  </mat-sidenav>

  <mat-sidenav-content class="admin-content">
    <router-outlet></router-outlet>
  </mat-sidenav-content>
</mat-sidenav-container>
</file>

<file path="frontend/src/app/features/admin-dashboard/admin-dashboard.component.scss">
.admin-dashboard-container {
  height: 100vh;
  display: flex;
}

.admin-sidenav {
  width: 250px;
  border-right: 1px solid rgba(0, 0, 0, 0.12);

  .sidenav-header {
    padding: 16px;
    text-align: center;
    border-bottom: 1px solid rgba(0, 0, 0, 0.12);
    
    h3 {
      margin: 0;
      font-size: 1.2em;
    }
  }

  mat-nav-list {
    padding-top: 8px;
  }

  a[mat-list-item] {
    border-left: 4px solid transparent;
    transition: background-color 0.3s, border-left-color 0.3s;

    &:hover {
      background-color: rgba(0, 0, 0, 0.04);
    }

    &.active-link {
      background-color: rgba(0, 0, 0, 0.08);
      border-left-color: var(--mdc-theme-primary, #673ab7);
      font-weight: 500;

      mat-icon {
        color: var(--mdc-theme-primary, #673ab7);
      }
    }

    mat-icon[matListItemIcon] {
      margin-right: 16px;
      opacity: 0.7;
    }
  }

  mat-divider {
    margin: 8px 0;
  }
}

.admin-content {
  flex-grow: 1;
  padding: 20px;
  overflow-y: auto;
  background-color: rgba(0, 0, 0, 0.02);
}
</file>

<file path="frontend/src/app/features/products/product-form/product-form.component.html">
<div class="admin-product-form-container">
  <mat-card>
    <mat-card-header>
      <mat-card-title>{{ pageTitle }}</mat-card-title>
    </mat-card-header>
    <mat-card-content>
      <div *ngIf="isLoading" class="spinner-container">
        <mat-progress-spinner diameter="50" mode="indeterminate"></mat-progress-spinner>
        <p>Se încarcă datele...</p>
      </div>

      <form [formGroup]="productForm" (ngSubmit)="onSubmit()" *ngIf="!isLoading">
        <mat-form-field appearance="outline" class="full-width">
          <mat-label>Nume Produs</mat-label>
          <input matInput formControlName="name" required>
          <mat-error *ngIf="f['name'].hasError('required')">Numele este obligatoriu.</mat-error>
          <mat-error *ngIf="f['name'].hasError('minlength')">Minim 3 caractere.</mat-error>
        </mat-form-field>

        <mat-form-field appearance="outline" class="full-width">
          <mat-label>Descriere</mat-label>
          <textarea matInput formControlName="description" rows="4"></textarea>
        </mat-form-field>

        <div class="form-row">
          <mat-form-field appearance="outline" class="form-row-item">
            <mat-label>Preț (RON)</mat-label>
            <input matInput type="number" formControlName="price" required min="0.01">
            <mat-error *ngIf="f['price'].hasError('required')">Prețul este obligatoriu.</mat-error>
            <mat-error *ngIf="f['price'].hasError('min')">Prețul trebuie să fie pozitiv.</mat-error>
          </mat-form-field>

          <mat-form-field appearance="outline" class="form-row-item">
            <mat-label>Cantitate Stoc</mat-label>
            <input matInput type="number" formControlName="stockQuantity" required min="0">
            <mat-error *ngIf="f['stockQuantity'].hasError('required')">Stocul este obligatoriu.</mat-error>
            <mat-error *ngIf="f['stockQuantity'].hasError('min')">Stocul nu poate fi negativ.</mat-error>
             <mat-error *ngIf="f['stockQuantity'].hasError('pattern')">Stocul trebuie să fie un număr întreg.</mat-error>
          </mat-form-field>
        </div>

        <mat-form-field appearance="outline" class="full-width">
          <mat-label>Categorie</mat-label>
          <mat-select formControlName="categoryId" required>
            <!-- MODIFICARE: Iterăm peste array-ul simplu 'categories' -->
            <mat-option *ngFor="let category of categories" [value]="category.id">
              {{ category.name }}
            </mat-option>
          </mat-select>
          <mat-error *ngIf="f['categoryId'].hasError('required')">Categoria este obligatorie.</mat-error>
        </mat-form-field>

        <div formArrayName="specifications" class="specifications-section">
          <h3>Specificații Produs</h3>
          <div *ngFor="let specGroup of specificationsFormArray.controls; let i = index" [formGroupName]="i" class="specification-item">
            <mat-form-field appearance="outline" class="spec-name-select">
              <mat-label>Specificație</mat-label>
              <!-- MODIFICARE: Iterăm peste array-ul simplu 'specDefinitions' -->
              <mat-select formControlName="definitionId" required>
                <mat-option *ngFor="let def of specDefinitions" [value]="def.id">
                  {{ def.name }} {{ def.unit ? '(' + def.unit + ')' : '' }}
                </mat-option>
              </mat-select>
               <mat-error *ngIf="specGroup.get('definitionId')?.hasError('required')">Selectați o specificație.</mat-error>
            </mat-form-field>

            <mat-form-field appearance="outline" class="spec-value-input">
              <mat-label>Valoare</mat-label>
              <input matInput formControlName="value" required>
              <mat-error *ngIf="specGroup.get('value')?.hasError('required')">Valoarea este obligatorie.</mat-error>
            </mat-form-field>

            <button mat-icon-button color="warn" type="button" (click)="removeSpecification(i)" aria-label="Șterge specificația">
              <mat-icon>remove_circle_outline</mat-icon>
            </button>
          </div>
          <button mat-stroked-button color="accent" type="button" (click)="addSpecification()" class="add-spec-button">
            <mat-icon>add</mat-icon> Adaugă Specificație
          </button>
        </div>

        <mat-divider></mat-divider>
        <div class="form-actions">
          <button mat-stroked-button color="warn" type="button" routerLink="/admin/products" [disabled]="isLoading">
            <mat-icon>cancel</mat-icon> Anulează
          </button>
          <!-- MODIFICARE: Am reintrodus verificarea pentru 'pristine' în modul de editare -->
          <button mat-raised-button color="primary" type="submit" [disabled]="isLoading || productForm.invalid || (isEditMode && productForm.pristine)">
             <mat-icon *ngIf="!isLoading">save</mat-icon>
             <mat-progress-spinner *ngIf="isLoading" diameter="20" mode="indeterminate" style="margin-right: 8px; display: inline-block;"></mat-progress-spinner>
            {{ isLoading ? 'Se salvează...' : submitButtonText }}
          </button>
        </div>
      </form>
    </mat-card-content>
  </mat-card>
</div>
</file>

<file path="frontend/src/app/features/products/product-form/product-form.component.scss">
.admin-product-form-container {
  padding: 20px;
  max-width: 800px;
  margin: 20px auto;
}

mat-card-header {
  padding-bottom: 16px;
}

.full-width {
  width: 100%;
  margin-bottom: 16px;
}

.form-row {
  display: flex;
  gap: 16px;
  margin-bottom: 16px;
  .form-row-item {
    flex: 1;
  }
}

.spinner-container {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  min-height: 200px;
  p {
    margin-top: 10px;
    opacity: 0.7;
  }
}

.specifications-section {
  margin-top: 20px;
  margin-bottom: 20px;
  padding: 16px;
  border: 1px solid rgba(0,0,0,0.12);
  border-radius: 8px;
  background-color: rgba(0,0,0,0.02);

  h3 {
    margin-top: 0;
    margin-bottom: 16px;
    font-size: 1.1em;
    opacity: 0.87;
  }
  
  .specification-item {
    display: flex;
    align-items: flex-start;
    gap: 10px;
    margin-bottom: 12px;
    padding-bottom: 12px;
    border-bottom: 1px dotted rgba(0,0,0,0.12);

    &:last-child {
      margin-bottom: 0;
      padding-bottom: 0;
      border-bottom: none;
    }

    .spec-name-select {
      flex: 2;
    }
    .spec-value-input {
      flex: 3;
    }
    button[mat-icon-button] {
      flex-shrink: 0;
      margin-top: 8px;
    }
  }
  
  .add-spec-button {
    margin-top: 10px;
    mat-icon {
      margin-right: 8px;
    }
  }
}

.form-actions {
 display: flex;
 justify-content: flex-end;
 gap: 10px;
 margin-top: 24px;
 button {
   min-width: 120px;
   mat-icon {
     margin-right: 8px;
   }
 }
}

mat-error {
 font-size: 0.85em;
}
</file>

<file path="frontend/src/app/features/products/product-form/product-form.component.ts">
import { Component, OnInit, inject } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ReactiveFormsModule, FormBuilder, FormGroup, Validators, FormArray } from '@angular/forms';
import { ActivatedRoute, Router, RouterModule } from '@angular/router';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { MatButtonModule } from '@angular/material/button';
import { MatCardModule } from '@angular/material/card';
import { MatSelectModule } from '@angular/material/select';
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { MatIconModule } from '@angular/material/icon';
import { MatDividerModule } from '@angular/material/divider';
import { HttpErrorResponse } from '@angular/common/http';

import { Product, SpecificationValue } from '../../../shared/models/product.model';
import { Category } from '../../../shared/models/category.model';
import { SpecificationDefinition } from '../../../shared/models/specification-definition.model';

import { ProductService } from '../product.service';
import { CategoryAdminService } from '../../admin/services/category.admin.service';
import { SpecificationAdminService } from '../../admin/services/specification-admin.service';
import { Observable, of, forkJoin } from 'rxjs';
import { catchError } from 'rxjs/operators';

@Component({
  selector: 'app-product-form',
  standalone: true,
  imports: [
    CommonModule, RouterModule, ReactiveFormsModule, MatFormFieldModule, MatInputModule,
    MatButtonModule, MatCardModule, MatSelectModule, MatSnackBarModule,
    MatProgressSpinnerModule, MatIconModule, MatDividerModule
  ],
  templateUrl: './product-form.component.html',
  styleUrls: ['./product-form.component.scss']
})
export class ProductFormComponent implements OnInit {
  productForm!: FormGroup;
  isEditMode = false;
  productId?: number;
  isLoading = true;
  pageTitle = 'Adaugă Produs Nou';
  submitButtonText = 'Salvează Produs';
  error: string | null = null;

  // Vom popula aceste array-uri pentru o gestionare mai sigură
  categories: Category[] = [];
  specDefinitions: SpecificationDefinition[] = [];

  private fb = inject(FormBuilder);
  private productService = inject(ProductService);
  private categoryAdminService = inject(CategoryAdminService);
  private specAdminService = inject(SpecificationAdminService);
  private route = inject(ActivatedRoute);
  private router = inject(Router);
  private snackBar = inject(MatSnackBar);

  ngOnInit(): void {
    this.productForm = this.fb.group({
      name: ['', [Validators.required, Validators.minLength(3), Validators.maxLength(255)]],
      description: ['', [Validators.maxLength(5000)]],
      // AICI ESTE PRIMA MODIFICARE CHEIE: Am eliminat validatorul de pattern
      price: [null, [Validators.required, Validators.min(0.01)]],
      stockQuantity: [0, [Validators.required, Validators.min(0), Validators.pattern(/^[0-9]*$/)]],
      categoryId: [null, Validators.required],
      specifications: this.fb.array([])
    });

    this.loadInitialData();
  }

  // A DOUA MODIFICARE CHEIE: Folosim forkJoin pentru a încărca totul sincronizat
  loadInitialData(): void {
    this.isLoading = true;
    const idFromRoute = this.route.snapshot.paramMap.get('id');
    this.isEditMode = !!idFromRoute;
    this.productId = idFromRoute ? +idFromRoute : undefined;

    // Definim sursele de date
    const categories$ = this.categoryAdminService.getAll();
    const specDefinitions$ = this.specAdminService.getAllDefinitions();
    const product$ = this.isEditMode && this.productId
      ? this.productService.getById(this.productId)
      : of(null);

    forkJoin({
      categories: categories$,
      specDefinitions: specDefinitions$,
      product: product$
    }).pipe(
      catchError(err => {
        this.handleLoadError('Eroare la încărcarea datelor necesare pentru formular.', err);
        return of(null);
      })
    ).subscribe(result => {
      if (result) {
        this.categories = result.categories;
        this.specDefinitions = result.specDefinitions;
        
        if (this.isEditMode) {
          this.pageTitle = 'Editează Produs';
          this.submitButtonText = 'Actualizează Produs';
          if (result.product) {
            this.populateForm(result.product);
          } else {
             this.handleInvalidId('Produsul nu a putut fi încărcat.');
          }
        }
      }
      this.isLoading = false;
    });
  }

  populateForm(product: Product): void {
    this.productForm.patchValue({
      name: product.name,
      description: product.description,
      price: product.price,
      stockQuantity: product.stockQuantity,
      categoryId: product.categoryId,
    });
    
    this.specificationsFormArray.clear();
    product.specifications?.forEach(spec => this.addSpecification(spec));
  }

  get specificationsFormArray(): FormArray {
    return this.productForm.get('specifications') as FormArray;
  }

  createSpecificationGroup(spec?: SpecificationValue): FormGroup {
    return this.fb.group({
      definitionId: [spec?.definitionId || null, Validators.required],
      value: [spec?.value || '', Validators.required],
    });
  }

  addSpecification(spec?: SpecificationValue): void {
    this.specificationsFormArray.push(this.createSpecificationGroup(spec));
  }

  removeSpecification(index: number): void {
    this.specificationsFormArray.removeAt(index);
  }

  onSubmit(): void {
    if (this.isEditMode && this.productForm.pristine) {
      this.snackBar.open('Nu ați făcut nicio modificare pentru a salva.', 'OK', { duration: 3000 });
      return;
    }
      
    if (this.productForm.invalid) {
      this.snackBar.open('Formular invalid. Verificați câmpurile marcate cu roșu.', 'OK', { duration: 4000 });
      this.productForm.markAllAsTouched();
      return;
    }

    this.isLoading = true;
    const formValue = this.productForm.getRawValue();
    const productData: Omit<Product, 'id'> = {
        ...formValue,
        specifications: formValue.specifications.map((spec: any) => ({
            definitionId: spec.definitionId,
            value: spec.value
        }))
    };
    
    const operation = this.isEditMode && this.productId
      ? this.productService.update(this.productId, productData as Product)
      : this.productService.create(productData as Product);

    operation.subscribe({
      next: () => {
        this.isLoading = false;
        this.snackBar.open(`Produs ${this.isEditMode ? 'actualizat' : 'creat'} cu succes!`, 'OK', { duration: 3000 });
        this.router.navigate(['/admin/products']);
      },
      error: (err: HttpErrorResponse) => this.handleSubmitError(`Eroare la ${this.isEditMode ? 'actualizarea' : 'crearea'} produsului.`, err)
    });
  }
  
  private handleInvalidId(message: string): void {
    this.isLoading = false;
    this.error = message;
    this.snackBar.open(this.error, 'Închide', { duration: 3000 });
    this.router.navigate(['/admin/products']);
  }

  private handleLoadError(message: string, err: HttpErrorResponse): void {
    this.isLoading = false;
    const serverErrorMessage = err.error?.message || err.message || 'Eroare necunoscută.';
    this.error = `${message} ${serverErrorMessage}`;
    this.snackBar.open(this.error, 'Închide', { duration: 5000 });
    console.error(err);
    this.router.navigate(['/admin/products']);
  }

  private handleSubmitError(message: string, err: HttpErrorResponse): void {
    this.isLoading = false;
    const serverErrorMessage = err.error?.message || err.message || 'Eroare necunoscută.';
    this.snackBar.open(`${message} ${serverErrorMessage}`, 'Închide', { duration: 5000 });
    console.error(err);
  }

  get f() { return this.productForm.controls; }
}
</file>

<file path="frontend/src/app/features/products/product-list/product-list.component.scss">
.admin-product-list-container {
  padding: 20px;
  max-width: 1200px;
  margin: auto;
}

.header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
  h2 {
    margin: 0;
  }
  button mat-icon {
    margin-right: 8px;
  }
}

.filter-field {
  width: 100%;
  max-width: 500px;
  margin-bottom: 20px;
}

.loading-indicator,
.error-message,
.no-data {
  text-align: center;
  padding: 20px;
  mat-spinner {
    margin: 0 auto 10px auto;
  }
}

.table-container {
  overflow-x: auto;
  margin-top: 10px;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

table {
  width: 100%;
}

.mat-column-actions {
  width: 150px;
  text-align: right;
}

.mat-column-id {
  max-width: 80px;
}
.mat-column-price, .mat-column-stockQuantity {
  max-width: 120px;
  text-align: right;
}
.mat-header-cell {
  font-weight: 500;
  opacity: 0.87;
}

.mat-row:hover {
  background-color: rgba(0,0,0,0.04);
}

.mat-cell, .mat-header-cell {
  padding: 8px 16px;
}
</file>

<file path="frontend/src/app/features/products/user-product-list/user-product-list.component.html">
<!-- frontend/src/app/features/products/user-product-list/user-product-list.component.html -->
<div class="user-product-list-container">
  <div class="header">
    <h2>Produsele Noastre</h2>
    <div class="filters-container">
      <mat-form-field appearance="outline" class="filter-field search-field">
        <mat-label>Caută produse</mat-label>
        <input matInput (keyup)="applyFilter($event)" placeholder="Caută după nume, categorie...">
        <mat-icon matSuffix>search</mat-icon>
      </mat-form-field>
      
      <mat-form-field appearance="outline" class="filter-field category-field">
        <mat-label>Filtrează după categorie</mat-label>
        <mat-select [(ngModel)]="selectedCategoryId" (selectionChange)="applyCategoryFilter()">
          <mat-option [value]="null">Toate categoriile</mat-option>
          <mat-option *ngFor="let category of categories" [value]="category.id">
            {{ category.name }}
          </mat-option>
        </mat-select>
      </mat-form-field>
    </div>
  </div>

  <div *ngIf="isLoading" class="loading-indicator">
    <mat-spinner diameter="50"></mat-spinner>
    <p>Se încarcă produsele...</p>
  </div>

  <div *ngIf="error && !isLoading" class="error-message">
    <p>{{ error }}</p>
    <button mat-stroked-button color="warn" (click)="loadProducts()">Reîncearcă</button>
  </div>

  <div *ngIf="!isLoading && !error && filteredProducts.length === 0" class="no-data">
    <p>Nu există produse disponibile momentan.</p>
  </div>

  <!-- Grid View for Products -->
  <div class="products-grid" *ngIf="!isLoading && !error && filteredProducts.length > 0">
    <mat-card *ngFor="let product of getPaginatedProducts()" class="product-card">
      <div class="product-image" [routerLink]="['/products', product.id]">
        <mat-icon>inventory_2</mat-icon>
      </div>
      
      <mat-card-header [routerLink]="['/products', product.id]">
        <mat-card-title>{{ product.name }}</mat-card-title>
        <mat-card-subtitle>{{ product.categoryName }}</mat-card-subtitle>
      </mat-card-header>
      
      <mat-card-content>
        <div class="product-info">
          <p class="price">{{ product.price | currency:'RON':'symbol':'1.2-2' }}</p>
          <p class="stock" [class.in-stock]="product.stockQuantity > 0" [class.out-of-stock]="product.stockQuantity === 0">
            {{ product.stockQuantity > 0 ? 'În stoc: ' + product.stockQuantity + ' buc.' : 'Stoc epuizat' }}
          </p>
        </div>
        
        <div class="product-description" *ngIf="product.description">
          <p>{{ product.description | slice:0:100 }}{{ product.description.length > 100 ? '...' : '' }}</p>
        </div>
      </mat-card-content>
      
      <mat-card-actions>
        <button mat-button color="primary" [routerLink]="['/products', product.id]">
          <mat-icon>visibility</mat-icon>
          Vezi detalii
        </button>
        <button mat-raised-button color="accent" 
                (click)="addToCart(product)" 
                [disabled]="product.stockQuantity === 0 || isAddingToCart[product.id!]">
          <mat-spinner *ngIf="isAddingToCart[product.id!]" diameter="20" style="display: inline-block; margin-right: 5px;"></mat-spinner>
          <mat-icon *ngIf="!isAddingToCart[product.id!]">add_shopping_cart</mat-icon>
          {{ product.stockQuantity === 0 ? 'Stoc epuizat' : 'Adaugă în coș' }}
        </button>
      </mat-card-actions>
    </mat-card>
  </div>

  <!-- Pagination -->
  <div class="pagination-container" *ngIf="!isLoading && !error && filteredProducts.length > 0">
    <mat-paginator [length]="filteredProducts.length"
                   [pageSize]="pageSize"
                   [pageSizeOptions]="[6, 12, 24, 48]"
                   [pageIndex]="pageIndex"
                   (page)="onPageChange($event)"
                   showFirstLastButtons>
    </mat-paginator>
  </div>
</div>
</file>

<file path="frontend/src/app/features/products/user-product-list/user-product-list.component.scss">
.user-product-list-container {
  padding: 20px;
  max-width: 1400px;
  margin: 0 auto;
  min-height: calc(100vh - 64px);
}

.header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: 30px;
  flex-wrap: wrap;
  gap: 20px;

  h2 {
    margin: 0;
    font-size: 2em;
    flex-shrink: 0;
  }

  .filters-container {
    display: flex;
    gap: 16px;
    align-items: center;
    flex-wrap: wrap;
    flex: 1;
    justify-content: flex-end;

    .filter-field {
      &.search-field {
        min-width: 250px;
        max-width: 400px;
      }
      
      &.category-field {
        min-width: 200px;
        max-width: 300px;
      }
    }
  }
}

.loading-indicator,
.error-message,
.no-data {
  text-align: center;
  padding: 40px 20px;

  mat-spinner {
    margin: 0 auto 20px;
  }
}

.products-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
  gap: 24px;
  margin-bottom: 30px;
}

.product-card {
  transition: all 0.3s ease;
  display: flex;
  flex-direction: column;
  height: 100%;
  // Remove dark background

  &:hover {
    transform: translateY(-4px);
    box-shadow: 0 8px 16px rgba(0,0,0,0.2);
  }

  .product-image {
    height: 200px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    background: rgba(0,0,0,0.05);
    border-bottom: 1px solid rgba(0,0,0,0.1);

    mat-icon {
      font-size: 80px;
      width: 80px;
      height: 80px;
      opacity: 0.3;
    }
  }

  mat-card-header {
    cursor: pointer;
    padding: 16px;

    mat-card-title {
      font-size: 1.2em;
      margin-bottom: 4px;
    }

    mat-card-subtitle {
      opacity: 0.7;
      font-size: 0.9em;
    }
  }

  mat-card-content {
    flex: 1;
    padding: 0 16px 16px;

    .product-info {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;

      .price {
        font-size: 1.5em;
        font-weight: 500;
        margin: 0;
      }

      .stock {
        font-size: 0.9em;
        padding: 4px 8px;
        border-radius: 4px;
        
        &.in-stock {
          background-color: rgba(76, 175, 80, 0.1);
          color: #4CAF50;
        }
        
        &.out-of-stock {
          background-color: rgba(244, 67, 54, 0.1);
          color: #f44336;
        }
      }
    }

    .product-description {
      p {
        margin: 0;
        font-size: 0.9em;
        line-height: 1.5;
        opacity: 0.8;
      }
    }
  }

  mat-card-actions {
    padding: 16px;
    display: flex;
    justify-content: space-between;
    gap: 8px;
    border-top: 1px solid rgba(0,0,0,0.1);

    button {
      flex: 1;
    }
  }
}

.pagination-container {
  display: flex;
  justify-content: center;
  margin-top: 30px;
}

/* Responsive styles */
@media (max-width: 1024px) {
  .header {
    flex-direction: column;
    align-items: stretch;
    
    .filters-container {
      justify-content: stretch;
      
      .filter-field {
        flex: 1;
      }
    }
  }
}

@media (max-width: 768px) {
  .filters-container {
    flex-direction: column;
    
    .filter-field {
      width: 100%;
      max-width: unset !important;
      
      &.search-field,
      &.category-field {
        min-width: unset;
      }
    }
  }
  
  .products-grid {
    grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
    gap: 16px;
  }
}

@media (max-width: 480px) {
  .products-grid {
    grid-template-columns: 1fr;
  }
}
</file>

<file path="frontend/src/app/features/shopping-cart/shopping-cart.component.ts">
// frontend/src/app/features/shopping-cart/shopping-cart.component.ts
import { Component, OnInit, inject } from '@angular/core';
import { CommonModule, CurrencyPipe } from '@angular/common';
import { RouterModule, Router } from '@angular/router';
import { FormsModule } from '@angular/forms';
import { MatCardModule } from '@angular/material/card';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatDividerModule } from '@angular/material/divider';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar';
import { MatInputModule } from '@angular/material/input';
import { MatFormFieldModule } from '@angular/material/form-field';

import { Cart, CartItem } from '../../shared/models/cart.model';
import { CartService } from './cart.service';
import { AuthService } from '../../auth/auth.service';

@Component({
  selector: 'app-shopping-cart',
  standalone: true,
  imports: [
    CommonModule,
    RouterModule,
    FormsModule,
    CurrencyPipe,
    MatCardModule,
    MatButtonModule,
    MatIconModule,
    MatDividerModule,
    MatProgressSpinnerModule,
    MatSnackBarModule,
    MatInputModule,
    MatFormFieldModule
  ],
  templateUrl: './shopping-cart.component.html',
  styleUrls: ['./shopping-cart.component.scss']
})
export class ShoppingCartComponent implements OnInit {
  cart: Cart | null = null;
  isLoading = true;
  isUpdating = false;
  updatingItemId: number | null = null;

  private cartService = inject(CartService);
  private authService = inject(AuthService);
  private router = inject(Router);
  private snackBar = inject(MatSnackBar);

  ngOnInit(): void {
    if (!this.authService.isLoggedIn) {
      this.router.navigate(['/login'], { queryParams: { returnUrl: '/cart' } });
      return;
    }
    this.loadCart();
  }

  loadCart(): void {
    this.isLoading = true;
    this.cartService.loadCart().subscribe({
      next: (cart) => {
        this.cart = cart;
        this.isLoading = false;
      },
      error: (err) => {
        this.isLoading = false;
        this.snackBar.open('Eroare la încărcarea coșului', 'Închide', { duration: 3000 });
        console.error(err);
      }
    });
  }

  updateQuantity(item: CartItem, newQuantity: number): void {
    if (newQuantity < 1) return;
    if (newQuantity > item.productStock) {
      this.snackBar.open(`Stoc disponibil: ${item.productStock} buc.`, 'OK', { duration: 3000 });
      return;
    }

    this.isUpdating = true;
    this.updatingItemId = item.productId;
    
    this.cartService.updateCartItem(item.productId, { quantity: newQuantity }).subscribe({
      next: (cart) => {
        this.cart = cart;
        this.isUpdating = false;
        this.updatingItemId = null;
      },
      error: (err) => {
        this.isUpdating = false;
        this.updatingItemId = null;
        this.snackBar.open('Eroare la actualizarea cantității', 'Închide', { duration: 3000 });
        console.error(err);
      }
    });
  }

  removeItem(productId: number): void {
    this.isUpdating = true;
    this.cartService.removeFromCart(productId).subscribe({
      next: (cart) => {
        this.cart = cart;
        this.isUpdating = false;
        this.snackBar.open('Produs eliminat din coș', 'OK', { duration: 2000 });
      },
      error: (err) => {
        this.isUpdating = false;
        this.snackBar.open('Eroare la eliminarea produsului', 'Închide', { duration: 3000 });
        console.error(err);
      }
    });
  }

  clearCart(): void {
    if (confirm('Sigur doriți să goliți coșul?')) {
      this.isUpdating = true;
      this.cartService.clearCart().subscribe({
        next: () => {
          this.cart = null;
          this.isUpdating = false;
          this.snackBar.open('Coșul a fost golit', 'OK', { duration: 2000 });
        },
        error: (err) => {
          this.isUpdating = false;
          this.snackBar.open('Eroare la golirea coșului', 'Închide', { duration: 3000 });
          console.error(err);
        }
      });
    }
  }

  proceedToCheckout(): void {
    if (this.cart && this.cart.items.length > 0) {
      this.router.navigate(['/checkout']);
    }
  }

  continueShopping(): void {
    this.router.navigate(['/products-list']);
  }
}
</file>

<file path="frontend/src/app/features/user-dashboard/user-dashboard.component.html">
<mat-sidenav-container class="user-dashboard-container">
  <mat-sidenav #sidenav mode="side" opened class="user-sidenav">
    <div class="sidenav-header">
      <mat-icon>account_circle</mat-icon>
      <h3>Salut, {{ authService.getCurrentUser()?.username || 'Client' }}!</h3>
    </div>
    <mat-nav-list>
      <a mat-list-item routerLink="/user/profile" routerLinkActive="active-link">
        <mat-icon matListItemIcon>person</mat-icon>
        <span matListItemTitle>Profilul Meu</span>
      </a>
      <a mat-list-item routerLink="/user/orders" routerLinkActive="active-link">
        <mat-icon matListItemIcon>history</mat-icon>
        <span matListItemTitle>Comenzile Mele</span>
      </a>
      <a mat-list-item routerLink="/products" routerLinkActive="active-link">
        <mat-icon matListItemIcon>storefront</mat-icon>
        <span matListItemTitle>Vezi Produse</span>
      </a>
      <mat-divider></mat-divider>
      <a mat-list-item (click)="authService.logout()">
        <mat-icon matListItemIcon>logout</mat-icon>
        <span matListItemTitle>Deconectare</span>
      </a>
    </mat-nav-list>
  </mat-sidenav>

  <mat-sidenav-content class="user-content">

    <div *ngIf="router.url === '/user' || router.url === '/user/'">

      <section class="hero-section">
        <div class="hero-overlay"></div>
        <div class="hero-content">
          <div class="text-content">
            <h1>Dive into immersive gaming</h1>
            <p>Feel every explosion, every step, and every sound detail with the new VipeX gaming headsets.</p>
            <button mat-flat-button color="primary">Buy now</button>
          </div>
        </div>
      </section>

      <section class="selection-section">
        <h2 class="section-title">Our selection</h2>

        <div *ngIf="isLoadingRecommendations" class="loading-indicator">
          <mat-spinner diameter="60"></mat-spinner>
        </div>

        <div class="product-grid" *ngIf="!isLoadingRecommendations && recommendedProducts.length > 0">
          <mat-card *ngFor="let product of recommendedProducts" class="product-card" [routerLink]="['/products', product.id]">
            
            <div class="product-image-container">
               <mat-icon>inventory_2</mat-icon>
            </div>
      
            <mat-card-header>
              <mat-card-title>{{ product.name }}</mat-card-title>
            </mat-card-header>
            <mat-card-content>
              <p class="product-price">{{ product.price | currency:'RON':'symbol':'1.2-2' }}</p>
            </mat-card-content>
            <mat-card-actions>
              <button mat-stroked-button color="primary" (click)="$event.stopPropagation()">Add to cart</button>
            </mat-card-actions>
          </mat-card>
        </div>
      </section>

      <section class="social-section">
        <h2 class="section-title">Be connected. Be VipeX.</h2>
        <div class="social-icons">
          <a href="#" class="social-icon-box">X</a>
          <a href="#" class="social-icon-box">O</a>
          <a href="#" class="social-icon-box">f</a>
          <a href="#" class="social-icon-box">B</a>
        </div>
      </section>
    </div>

    <router-outlet></router-outlet>
    
  </mat-sidenav-content>
</mat-sidenav-container>
</file>

<file path="frontend/src/app/features/user-dashboard/user-dashboard.component.ts">
// src/app/features/user-dashboard/user-dashboard.component.ts
import { Component, OnInit, inject } from '@angular/core';
import { CommonModule, CurrencyPipe } from '@angular/common'; // CurrencyPipe pentru preț
import { Router, RouterModule, RouterOutlet } from '@angular/router'; // Router pentru a verifica URL-ul curent
import { MatSidenavModule } from '@angular/material/sidenav';
import { MatListModule } from '@angular/material/list';
import { MatIconModule } from '@angular/material/icon';
import { MatButtonModule } from '@angular/material/button';
import { MatCardModule } from '@angular/material/card'; // Pentru produsele recomandate
import { MatDividerModule } from '@angular/material/divider';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { AuthService } from '../../auth/auth.service';
import { Product } from '../../shared/models/product.model'; // Modelul de produs
import { ProductService } from '../products/product.service'; // Serviciul de produse

@Component({
  selector: 'app-user-dashboard',
  standalone: true,
  imports: [
    CommonModule,
    RouterModule,
    RouterOutlet,
    MatSidenavModule,
    MatListModule,
    MatIconModule,
    MatButtonModule,
    MatCardModule,
    MatDividerModule,
    CurrencyPipe,
    MatProgressSpinnerModule
  ],
  templateUrl: './user-dashboard.component.html',
  styleUrls: ['./user-dashboard.component.scss']
})
export class UserDashboardComponent implements OnInit {
  public authService = inject(AuthService); // Public pentru a fi accesibil în template
  public router = inject(Router); // Public pentru a verifica URL-ul
  private productService = inject(ProductService);

  recommendedProducts: Product[] = [];
  isLoadingRecommendations = false;

  ngOnInit(): void {
    this.loadRecommendedProducts();
  }

  loadRecommendedProducts(): void {
    this.isLoadingRecommendations = true;
    // Exemplu: preia primele câteva produse sau o listă specială de recomandări
    this.productService.getAll().subscribe({ // S-ar putea să vrei un endpoint dedicat pentru recomandări
      next: (products) => {
        this.recommendedProducts = products.slice(0, 4); // Afișează primele 4 ca exemplu
        this.isLoadingRecommendations = false;
      },
      error: (err) => {
        console.error('Eroare la încărcarea produselor recomandate:', err);
        this.isLoadingRecommendations = false;
      }
    });
  }
}
</file>

<file path="frontend/src/app/features/user-dashboard/user-order-history/user-order-history.component.scss">
.user-order-history-container {
  padding: 20px;
  max-width: 900px;
  margin: auto;
}

.header {
  margin-bottom: 20px;
  h2 {
    margin: 0;
    font-size: 1.8em;
  }
}

.loading-indicator,
.error-message,
.no-data {
  text-align: center;
  padding: 20px;
  margin-top: 20px;
  mat-spinner {
    margin: 0 auto 10px auto;
  }
  button[mat-flat-button] {
    margin-top: 15px;
  }
}

.order-accordion {
  margin-top: 10px;
}

.order-panel {
  margin-bottom: 16px;
  border-radius: 8px !important;
  box-shadow: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24);
  // Remove dark background

  &:first-child {
      border-top-left-radius: 8px;
      border-top-right-radius: 8px;
  }
   &:last-child {
      border-bottom-left-radius: 8px;
      border-bottom-right-radius: 8px;
  }

  mat-expansion-panel-header {
    font-size: 1.05em;
  }

  mat-panel-description {
    justify-content: space-between;
    align-items: center;
    font-size: 0.95em;
    mat-chip-listbox {
        transform: scale(0.9);
    }
  }
}

.status-chip-pending_confirmation { 
  background-color: #FFC107 !important; 
  color: #000 !important; 
}
.status-chip-approved { 
  background-color: #2196F3 !important; 
  color: #fff !important; 
}
.status-chip-processing { 
  background-color: #9C27B0 !important; 
  color: #fff !important; 
}
.status-chip-shipped { 
  background-color: #00BCD4 !important; 
  color: #fff !important; 
}
.status-chip-delivered { 
  background-color: #4CAF50 !important; 
  color: #fff !important; 
}
.status-chip-canceled { 
  background-color: #f44336 !important; 
  color: #fff !important; 
}

.order-details-content {
  padding: 16px 24px 24px 24px;

  h4 {
    margin-top: 16px;
    margin-bottom: 8px;
    font-size: 1.1em;
    font-weight: 500;
  }
  &:first-of-type h4 {
      margin-top: 0;
  }

  p {
    margin-bottom: 6px;
    line-height: 1.5;
    strong {
      font-weight: 500;
      opacity: 0.7;
    }
  }
  mat-divider {
    margin: 16px 0;
  }
}

.order-items-list {
  padding-top: 0;
  .order-item-detail {
    border-bottom: 1px dotted rgba(0,0,0,0.12);
    padding: 8px 0 !important;

    &:last-child {
      border-bottom: none;
    }
  }
  .item-subtotal-small {
    font-weight: 500;
    font-size: 0.9em;
  }
}
</file>

<file path="frontend/src/app/login/login.component.html">
<!-- src/app/login/login.component.html -->
<div class="login-container">
  <mat-card class="login-card">
    <mat-card-header>
      <mat-card-title>Autentificare</mat-card-title>
      <mat-card-subtitle>Intră în contul tău</mat-card-subtitle>
    </mat-card-header>
    <mat-card-content>
      <form [formGroup]="loginForm" (ngSubmit)="onSubmit()">
        <mat-form-field appearance="outline" class="full-width">
          <mat-label>Nume de Utilizator</mat-label>
          <input matInput formControlName="username" placeholder="Ex: ion.popescu" required>
          <mat-icon matSuffix>person_outline</mat-icon>
          <mat-error *ngIf="f['username'].hasError('required')">
            Numele de utilizator este obligatoriu.
          </mat-error>
          <mat-error *ngIf="f['username'].hasError('minlength')">
            Numele de utilizator trebuie să aibă cel puțin 3 caractere.
          </mat-error>
        </mat-form-field>

        <mat-form-field appearance="outline" class="full-width">
          <mat-label>Parolă</mat-label>
          <input matInput [type]="hidePassword ? 'password' : 'text'" formControlName="password" required>
          <button mat-icon-button matSuffix (click)="togglePasswordVisibility()" type="button" [attr.aria-label]="'Ascunde/Arată parola'" [attr.aria-pressed]="hidePassword">
            <mat-icon>{{hidePassword ? 'visibility_off' : 'visibility'}}</mat-icon>
          </button>
          <mat-error *ngIf="f['password'].hasError('required')">
            Parola este obligatorie.
          </mat-error>
          <mat-error *ngIf="f['password'].hasError('minlength')">
            Parola trebuie să aibă cel puțin 6 caractere.
          </mat-error>
        </mat-form-field>
           <mat-checkbox formControlName="rememberMe" class="remember-me-checkbox">
             Ține-mă minte
           </mat-checkbox>
        <button mat-raised-button color="primary" type="submit" class="full-width login-button" [disabled]="isLoading || loginForm.invalid">
          <mat-spinner *ngIf="isLoading" diameter="20" mode="indeterminate" class="button-spinner"></mat-spinner>
          <span *ngIf="!isLoading">Intră în Cont</span>
        </button>
      </form>
    </mat-card-content>
    <mat-card-actions class="login-card-actions-center"> <!-- Am adăugat o clasă pentru centrare CSS -->
      <p class="signup-link">
        Nu ai cont? <a routerLink="/signup">Înregistrează-te aici!</a>
      </p>
    </mat-card-actions>
  </mat-card>
</div>
</file>

<file path="frontend/src/app/login/login.component.ts">
import { registerables } from 'chart.js';
// src/app/login/login.component.ts
import { Component, OnInit, inject } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ReactiveFormsModule, FormBuilder, FormGroup, Validators } from '@angular/forms';
import { Router, RouterModule, ActivatedRoute } from '@angular/router'; // ActivatedRoute pentru returnUrl
import { MatCardModule } from '@angular/material/card';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { MatCheckboxModule } from '@angular/material/checkbox'; 

import { AuthService } from '../auth/auth.service'; // Serviciul de autentificare

@Component({
  selector: 'app-login',
  standalone: true,
  imports: [
    CommonModule,
    RouterModule, // Pentru link-ul de înregistrare
    ReactiveFormsModule,
    MatCardModule,
    MatFormFieldModule,
    MatInputModule,
    MatButtonModule,
    MatIconModule,
    MatSnackBarModule,
    MatProgressSpinnerModule,
    MatCheckboxModule
  ],
  templateUrl: './login.component.html',
  styleUrls: ['./login.component.scss']
})
export class LoginComponent implements OnInit {
  loginForm!: FormGroup;
  isLoading = false;
  hidePassword = true;
  private returnUrl: string = '/'; // Default redirect URL

  private fb = inject(FormBuilder);
  public authService = inject(AuthService); // Public pentru a fi accesibil în template (ex: pentru link signup)
  private router = inject(Router);
  private route = inject(ActivatedRoute); // Pentru a prelua returnUrl
  private snackBar = inject(MatSnackBar);

  ngOnInit(): void {
    this.loginForm = this.fb.group({
      username: ['', [Validators.required, Validators.minLength(3)]],
      password: ['', [Validators.required, Validators.minLength(6)]],
      rememberMe: [false]
    });

    // Preia URL-ul de redirectare din query params, dacă există
    this.returnUrl = this.route.snapshot.queryParams['returnUrl'] || '/';

    // Dacă utilizatorul este deja logat, redirecționează-l
    if (this.authService.isLoggedIn()) {
        const userRole = this.authService.role;
        if (userRole === 'admin') {
            this.router.navigate(['/admin']);
        } else if (userRole === 'user') {
            this.router.navigate(['/user']);
        } else {
            this.router.navigate([this.returnUrl]); // Sau o pagină default
        }
    }
  }

  onSubmit(): void {
    if (this.loginForm.invalid) {
      this.snackBar.open('Nume de utilizator sau parolă invalidă.', 'OK', { duration: 3000 });
      this.loginForm.markAllAsTouched();
      return;
    }

    this.isLoading = true;
    const { username, password, rememberMe } = this.loginForm.value;

    this.authService.login(username, password, rememberMe).subscribe({
      next: (success) => {
        this.isLoading = false;
        if (success) {
          this.snackBar.open('Autentificare reușită!', 'OK', { duration: 2000 });
          const userRole = this.authService.role; // Preia rolul după login reușit
          
          // Redirecționează în funcție de rol sau la returnUrl
          if (this.returnUrl && this.returnUrl !== '/') {
            this.router.navigateByUrl(this.returnUrl);
          } else if (userRole === 'admin') {
            this.router.navigate(['/admin']);
          } else if (userRole === 'user') {
            this.router.navigate(['/user']);
          } else {
            this.router.navigate(['/']); // Fallback la pagina principală
          }
        } else {
          // AuthService gestionează deja afișarea erorii prin snackbar în cazul în care login-ul eșuează
          // dar putem adăuga un mesaj generic aici dacă metoda login returnează doar boolean
          // this.snackBar.open('Autentificare eșuată. Verificați credențialele.', 'Închide', { duration: 3000 });
        }
      },
      error: (err) => {
        // AuthService ar trebui să gestioneze eroarea și să afișeze un snackbar
        // Dacă nu, o facem aici.
        this.isLoading = false;
        const errorMessage = err.error?.message || err.message || 'Autentificare eșuată. Vă rugăm încercați din nou.';
        this.snackBar.open(errorMessage, 'Închide', { duration: 5000 });
        console.error('Login error:', err);
      }
    });
  }

  togglePasswordVisibility(): void {
    this.hidePassword = !this.hidePassword;
  }

  get f() { return this.loginForm.controls; }
}
</file>

<file path="frontend/src/app/shared/models/product.model.ts">
import { SpecificationValue } from "./specification-value.model";

export interface Product {
  id?: number;
  name: string;
  description?: string;
  price: number;
  stockQuantity: number;
 // imageBase64?: string | null;
  categoryId: number;
  categoryName?: string;
  specifications?: SpecificationValue[];
  averageRating?: number;
  reviewCount?: number;
}

export type { SpecificationValue };
</file>

<file path="frontend/src/styles.scss">
/* Global Styles */
html, body { 
  height: 100%; 
  margin: 0;
}

body { 
  font-family: Roboto, "Helvetica Neue", sans-serif; 
}

/* Utility classes */
.full-width {
  width: 100%;
}

.text-center {
  text-align: center;
}

/* Remove all dark theme overrides */
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/config/SecurityConfig.java">
package com.magazincomputere.magazin_api.config;

import com.magazincomputere.magazin_api.security.jwt.AuthEntryPointJwt;
import com.magazincomputere.magazin_api.security.jwt.JwtAuthTokenFilter;
import com.magazincomputere.magazin_api.security.services.UserDetailsServiceImpl;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.security.web.util.matcher.AntPathRequestMatcher;


@Configuration
@EnableWebSecurity
@EnableMethodSecurity(prePostEnabled = true)
public class SecurityConfig {

    @Autowired
    private UserDetailsServiceImpl userDetailsService;

    @Autowired
    private AuthEntryPointJwt unauthorizedHandler;

    @Bean
    public JwtAuthTokenFilter authenticationJwtTokenFilter() {
        return new JwtAuthTokenFilter();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authenticationConfiguration) throws Exception {
        return authenticationConfiguration.getAuthenticationManager();
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .cors(cors -> {})
            .csrf(csrf -> csrf.disable())
            .exceptionHandling(exception -> exception.authenticationEntryPoint(unauthorizedHandler))
            .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            .authorizeHttpRequests(auth -> auth
                // -- ÎNCEPUT: REGULI SPECIFICE (TREBUIE SĂ FIE PRIMELE) --

                // Permite acces liber la autentificare, produse, categorii etc.
                .requestMatchers("/swagger-ui.html", "/swagger-ui/**", "/api-docs/**", "/h2-console/**").permitAll()
                .requestMatchers("/api/auth/**").permitAll()
                .requestMatchers(AntPathRequestMatcher.antMatcher(HttpMethod.GET, "/api/products/**")).permitAll()
                .requestMatchers(AntPathRequestMatcher.antMatcher(HttpMethod.GET, "/api/categories/**")).permitAll()
                .requestMatchers(AntPathRequestMatcher.antMatcher(HttpMethod.GET, "/api/specifications/**")).permitAll()

                // Reguli pentru Coș (Cart)
                .requestMatchers(AntPathRequestMatcher.antMatcher("/api/cart/**")).hasAnyRole("USER", "ADMIN")
                
                // Reguli pentru Produse, Categorii, Specificații (doar Admin poate modifica)
                .requestMatchers(AntPathRequestMatcher.antMatcher(HttpMethod.POST, "/api/products")).hasRole("ADMIN")
                .requestMatchers(AntPathRequestMatcher.antMatcher(HttpMethod.PUT, "/api/products/**")).hasRole("ADMIN")
                .requestMatchers(AntPathRequestMatcher.antMatcher(HttpMethod.DELETE, "/api/products/**")).hasRole("ADMIN")
                .requestMatchers(AntPathRequestMatcher.antMatcher(HttpMethod.POST, "/api/categories")).hasRole("ADMIN")
                .requestMatchers(AntPathRequestMatcher.antMatcher(HttpMethod.PUT, "/api/categories/**")).hasRole("ADMIN")
                .requestMatchers(AntPathRequestMatcher.antMatcher(HttpMethod.DELETE, "/api/categories/**")).hasRole("ADMIN")
                .requestMatchers(AntPathRequestMatcher.antMatcher(HttpMethod.POST, "/api/specifications")).hasRole("ADMIN")
                .requestMatchers(AntPathRequestMatcher.antMatcher(HttpMethod.PUT, "/api/specifications/**")).hasRole("ADMIN")
                .requestMatchers(AntPathRequestMatcher.antMatcher(HttpMethod.DELETE, "/api/specifications/**")).hasRole("ADMIN")

                // Reguli pentru Comenzi (Orders)
                .requestMatchers(AntPathRequestMatcher.antMatcher(HttpMethod.POST, "/api/orders")).hasAnyRole("USER", "ADMIN")
                .requestMatchers(AntPathRequestMatcher.antMatcher(HttpMethod.GET, "/api/orders/my-history")).hasAnyRole("USER", "ADMIN")
                .requestMatchers(AntPathRequestMatcher.antMatcher(HttpMethod.GET, "/api/orders/**")).hasRole("ADMIN")
                .requestMatchers(AntPathRequestMatcher.antMatcher(HttpMethod.PUT, "/api/orders/**/status")).hasRole("ADMIN")

                // Reguli pentru Utilizatori, Clienți și Rapoarte (doar Admin)
                .requestMatchers(AntPathRequestMatcher.antMatcher("/api/users/**")).hasRole("ADMIN")
                .requestMatchers(AntPathRequestMatcher.antMatcher("/api/customers/**")).hasRole("ADMIN")
                .requestMatchers(AntPathRequestMatcher.antMatcher("/api/reports/**")).hasRole("ADMIN")
                
                // Permite fișierele statice pentru frontend
                .requestMatchers("/", "/*.html", "/*.js", "/*.css", "/*.ico", "/*.png", "/*.jpg", "/*.webmanifest", "/assets/**").permitAll()

                // Public access to view reviews
                .requestMatchers(AntPathRequestMatcher.antMatcher(HttpMethod.GET, "/api/reviews/product/**")).permitAll()
                // Authenticated users can create/update/delete reviews
                .requestMatchers(AntPathRequestMatcher.antMatcher(HttpMethod.POST, "/api/reviews")).authenticated()
                .requestMatchers(AntPathRequestMatcher.antMatcher(HttpMethod.PUT, "/api/reviews/**")).authenticated()
                .requestMatchers(AntPathRequestMatcher.antMatcher(HttpMethod.DELETE, "/api/reviews/**")).authenticated()

                // -- FINAL: REGULA GENERALĂ (TREBUIE SĂ FIE ULTIMA) --
                .anyRequest().authenticated()
            );

        // Necesar pentru H2 console
        http.headers(headers -> headers.frameOptions(frameOptions -> frameOptions.sameOrigin()));
        http.addFilterBefore(authenticationJwtTokenFilter(), UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/service/ProductService.java">
package com.magazincomputere.magazin_api.service;

import com.magazincomputere.magazin_api.dto.ProductDto;
import com.magazincomputere.magazin_api.dto.SpecificationDto;
import com.magazincomputere.magazin_api.exception.ResourceNotFoundException;
import com.magazincomputere.magazin_api.model.Category;
import com.magazincomputere.magazin_api.model.Product;
import com.magazincomputere.magazin_api.model.ProductSpecificationValue;
import com.magazincomputere.magazin_api.model.SpecificationDefinition;
import com.magazincomputere.magazin_api.repository.CategoryRepository;
import com.magazincomputere.magazin_api.repository.ProductRepository;
import com.magazincomputere.magazin_api.repository.ProductSpecificationValueRepository;
import com.magazincomputere.magazin_api.repository.SpecificationDefinitionRepository;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

@Service
public class ProductService {

    private final ProductRepository productRepository;
    private final CategoryRepository categoryRepository;
    private final SpecificationDefinitionRepository specDefRepository;
    private final ProductSpecificationValueRepository specValueRepository;

    public ProductService(ProductRepository productRepository, CategoryRepository categoryRepository, SpecificationDefinitionRepository specDefRepository, ProductSpecificationValueRepository specValueRepository) {
        this.productRepository = productRepository;
        this.categoryRepository = categoryRepository;
        this.specDefRepository = specDefRepository;
        this.specValueRepository = specValueRepository;
    }

    public List<ProductDto> getAllProducts() {
        return productRepository.findAll().stream()
                .map(this::mapToDto)
                .collect(Collectors.toList());
    }

    public ProductDto getProductById(Long id) {
        Product product = productRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Product not found with id: " + id));
        return mapToDto(product);
    }

    @Transactional
    public ProductDto createProduct(ProductDto productDto) {
        Product product = new Product();
        product.setName(productDto.getName());
        product.setDescription(productDto.getDescription());
        product.setPrice(productDto.getPrice());
        // MODIFICARE: Adăugăm stockQuantity la creare
        product.setStockQuantity(productDto.getStockQuantity());
        
        Category category = categoryRepository.findById(productDto.getCategoryId())
                .orElseThrow(() -> new ResourceNotFoundException("Category not found"));
        product.setCategory(category);
        
        Product savedProduct = productRepository.save(product);

        if (productDto.getSpecifications() != null) {
            for (SpecificationDto specDto : productDto.getSpecifications()) {
                SpecificationDefinition specDef = specDefRepository.findById(specDto.getDefinitionId())
                        .orElseThrow(() -> new ResourceNotFoundException("Specification Definition not found"));

                ProductSpecificationValue specValue = new ProductSpecificationValue();
                specValue.setProduct(savedProduct);
                specValue.setSpecificationDefinition(specDef);
                specValue.setValue(specDto.getValue());
                
                specValueRepository.save(specValue);
            }
        }
        return mapToDto(productRepository.findById(savedProduct.getId()).get());
    }

    @Transactional
    public ProductDto updateProduct(Long id, ProductDto productDto) {
        Product existingProduct = productRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Product not found with id: " + id));

        existingProduct.setName(productDto.getName());
        existingProduct.setDescription(productDto.getDescription());
        existingProduct.setPrice(productDto.getPrice());
        // MODIFICARE: Adăugăm stockQuantity la actualizare
        existingProduct.setStockQuantity(productDto.getStockQuantity());

        if (!existingProduct.getCategory().getId().equals(productDto.getCategoryId())) {
            Category newCategory = categoryRepository.findById(productDto.getCategoryId())
                    .orElseThrow(() -> new ResourceNotFoundException("Category not found"));
            existingProduct.setCategory(newCategory);
        }
        
        specValueRepository.deleteAll(existingProduct.getSpecifications());
        existingProduct.getSpecifications().clear();
        productRepository.saveAndFlush(existingProduct);

        if (productDto.getSpecifications() != null) {
            for (SpecificationDto specDto : productDto.getSpecifications()) {
                SpecificationDefinition specDef = specDefRepository.findById(specDto.getDefinitionId())
                        .orElseThrow(() -> new ResourceNotFoundException("Specification Definition not found"));
                
                ProductSpecificationValue specValue = new ProductSpecificationValue();
                specValue.setProduct(existingProduct);
                specValue.setSpecificationDefinition(specDef);
                specValue.setValue(specDto.getValue());
                
                existingProduct.getSpecifications().add(specValue);
            }
        }
        
        Product updatedProduct = productRepository.save(existingProduct);
        return mapToDto(updatedProduct);
    }

    public void deleteProduct(Long id) {
        if (!productRepository.existsById(id)) {
            throw new ResourceNotFoundException("Product not found with id: " + id);
        }
        productRepository.deleteById(id);
    }
    
    // Update the mapToDto method in ProductService to include review data:

private ProductDto mapToDto(Product product) {
    ProductDto dto = new ProductDto();
    dto.setId(product.getId());
    dto.setName(product.getName());
    dto.setDescription(product.getDescription());
    dto.setPrice(product.getPrice());
    dto.setStockQuantity(product.getStockQuantity());
    dto.setCategoryId(product.getCategory().getId());
    dto.setCategoryName(product.getCategory().getName());
    
    // Add review data
    dto.setAverageRating(product.calculateAverageRating());
    dto.setReviewCount(product.getReviewCount());

    if (product.getSpecifications() != null) {
        dto.setSpecifications(product.getSpecifications().stream().map(specValue -> {
            SpecificationDto specDto = new SpecificationDto();
            specDto.setDefinitionId(specValue.getSpecificationDefinition().getId());
            specDto.setName(specValue.getSpecificationDefinition().getName());
            specDto.setValue(specValue.getValue());
            return specDto;
        }).collect(Collectors.toList()));
    } else {
        dto.setSpecifications(new ArrayList<>());
    }
    return dto;
}
}
</file>

<file path="frontend/package.json">
{
  "name": "magazin-calculatoare",
  "version": "0.0.0",
  "scripts": {
    "ng": "ng",
    "start": "ng serve",
    "build": "ng build",
    "watch": "ng build --watch --configuration development",
    "test": "ng test",
    "serve:ssr:magazin-calculatoare": "node dist/magazin-calculatoare/server/server.mjs",
    "//": "--- Scripturi adăugate pentru a rula backend și frontend simultan ---",
    "start:backend": "cd ../backend && mvn spring-boot:run",
    "start:frontend": "ng serve",
    "dev": "concurrently \"npm:start:frontend\" \"npm:start:backend\""
  },
  "private": true,
  "dependencies": {
    "@angular/animations": "19.2.9",
    "@angular/cdk": "^19.2.11",
    "@angular/common": "^19.2.0",
    "@angular/compiler": "^19.2.0",
    "@angular/core": "^19.2.0",
    "@angular/forms": "^19.2.0",
    "@angular/material": "^19.2.11",
    "@angular/platform-browser": "^19.2.0",
    "@angular/platform-browser-dynamic": "^19.2.0",
    "@angular/platform-server": "^19.2.0",
    "@angular/router": "^19.2.0",
    "@angular/ssr": "^19.2.10",
    "angular-in-memory-web-api": "^0.19.0",
    "chart.js": "^4.4.9",
    "express": "^4.18.2",
    "rxjs": "~7.8.0",
    "tslib": "^2.3.0",
    "zone.js": "~0.15.0"
  },
  "devDependencies": {
    "@angular-devkit/build-angular": "^19.2.10",
    "@angular/cli": "^19.2.10",
    "@angular/compiler-cli": "^19.2.0",
    "@types/express": "^4.17.17",
    "@types/jasmine": "~5.1.0",
    "@types/node": "^18.18.0",
    "concurrently": "^9.1.2",
    "jasmine-core": "~5.6.0",
    "karma": "~6.4.0",
    "karma-chrome-launcher": "~3.2.0",
    "karma-coverage": "~2.2.0",
    "karma-jasmine": "~5.1.0",
    "karma-jasmine-html-reporter": "~2.1.0",
    "ts-node": "^10.9.2",
    "typescript": "~5.7.2"
  }
}
</file>

<file path="frontend/src/app/app.component.html">
<mat-toolbar color="primary" class="app-toolbar" *ngIf="!hideToolbar">
  <button mat-icon-button routerLink="/" aria-label="Pagina principală">
    <mat-icon>storefront</mat-icon>
  </button>
  <span class="app-title" routerLink="/">{{ title }}</span>

  <span class="toolbar-spacer"></span>

  <button mat-button (click)="navigateToProducts()">
    <mat-icon>list_alt</mat-icon> Produse
  </button>

  <button mat-icon-button routerLink="/cart" aria-label="Coș de cumpărături">
    <mat-icon>shopping_cart</mat-icon>
  </button>

  <ng-container *ngIf="!isLoggedIn">
    <button mat-stroked-button routerLink="/login" class="auth-button">
      <mat-icon>login</mat-icon> Autentificare
    </button>
  </ng-container>

  <ng-container *ngIf="isLoggedIn">
    <button mat-button [matMenuTriggerFor]="userMenu" class="user-menu-button">
      <mat-icon>account_circle</mat-icon>
      <span>{{ username || 'Cont' }}</span>
      <mat-icon>arrow_drop_down</mat-icon>
    </button>
    <mat-menu #userMenu="matMenu">
      <button mat-menu-item routerLink="/my-profile" *ngIf="userRole === 'user'">
        <mat-icon>manage_accounts</mat-icon> Profilul Meu
      </button>
      <button mat-menu-item routerLink="/my-orders" *ngIf="userRole === 'user'">
        <mat-icon>history</mat-icon> Comenzile Mele
      </button>
      <button mat-menu-item routerLink="/admin" *ngIf="userRole === 'admin'">
        <mat-icon>admin_panel_settings</mat-icon> Panou Admin
      </button>
      <mat-divider></mat-divider>
      <button mat-menu-item (click)="logout()">
        <mat-icon>logout</mat-icon> Deconectare
      </button>
    </mat-menu>
  </ng-container>
</mat-toolbar>

<div class="main-content">
  <router-outlet></router-outlet>
</div>
</file>

<file path="frontend/src/app/app.component.scss">
.app-toolbar {
  position: sticky;
  top: 0;
  z-index: 1000;
  
  .app-title {
    margin-left: 8px;
    cursor: pointer;
    font-size: 1.25em;
  }

  .toolbar-spacer {
    flex: 1 1 auto;
  }

  button[mat-button], button[mat-stroked-button], button[mat-icon-button] {
    margin: 0 4px;
  }
}

.main-content {
  min-height: calc(100vh - 64px);
}
</file>

<file path="frontend/src/app/app.component.ts">
// frontend/src/app/app.component.ts
import { Component, inject, OnInit, OnDestroy } from '@angular/core';
import { CommonModule } from '@angular/common';
import { RouterOutlet, RouterModule, Router, NavigationEnd } from '@angular/router';
import { MatToolbarModule } from '@angular/material/toolbar';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatMenuModule } from '@angular/material/menu';
import { MatBadgeModule } from '@angular/material/badge';
import { MatDividerModule } from '@angular/material/divider';
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar';
import { InactivityService } from './auth/inactivity.service';
import { AuthService } from './auth/auth.service';
import { Subscription } from 'rxjs';
import { filter } from 'rxjs/operators';

@Component({
  selector: 'app-root',
  standalone: true,
  imports: [
    CommonModule,
    RouterOutlet,
    RouterModule,
    MatToolbarModule,
    MatButtonModule,
    MatIconModule,
    MatMenuModule,
    MatBadgeModule,
    MatDividerModule,
    MatSnackBarModule
  ],
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.scss']
})
export class AppComponent implements OnInit, OnDestroy {
  title = 'Magazin Calculatoare';
  isLoggedIn = false;
  username: string | null = null;
  userRole: string | null = null;

  private authSubscription!: Subscription;
  private routerSubscription!: Subscription;

  public authService = inject(AuthService);
  private router = inject(Router);
  private inactivityService = inject(InactivityService);
  private snackBar = inject(MatSnackBar);

  hideToolbar = false;

  ngOnInit(): void {
    this.authSubscription = this.authService.user$.subscribe(user => {
      this.isLoggedIn = !!user;
      this.username = user ? user.username : null;
      this.userRole = this.authService.role;
      
      if (this.isLoggedIn) {
        this.inactivityService.startWatching();
      } else {
        this.inactivityService.stopWatching();
      }
    });

    this.isLoggedIn = this.authService.isLoggedIn();
    if (this.isLoggedIn) {
      const currentUser = this.authService.getCurrentUser();
      this.username = currentUser ? currentUser.username : null;
      this.userRole = this.authService.role;
    }

    this.routerSubscription = this.router.events.pipe(
      filter(event => event instanceof NavigationEnd)
    ).subscribe(event => {
      if (event instanceof NavigationEnd) {
        this.hideToolbar = event.urlAfterRedirects === '/login' || event.urlAfterRedirects.startsWith('/signup');
      }
    });
  }

  navigateToProducts(): void {
    if (!this.authService.isLoggedIn()) {
      this.snackBar.open('Trebuie să fii autentificat pentru a vedea produsele.', 'Login', {
        duration: 5000,
      }).onAction().subscribe(() => {
        this.router.navigate(['/login'], { queryParams: { returnUrl: '/products-list' } });
      });
    } else {
      this.router.navigate(['/products-list']);
    }
  }

  private clearNonPersistentAuth(): void {
    if (!this.authService.isLoggedIn()) {
      this.authService.logout();
    }
  }

  logout(): void {
    this.authService.logout();
  }

  ngOnDestroy(): void {
    if (this.authSubscription) {
      this.authSubscription.unsubscribe();
    }
    if (this.routerSubscription) {
      this.routerSubscription.unsubscribe();
    }
    this.inactivityService.stopWatching();
  }
}
</file>

<file path="frontend/src/app/features/products/product-detail/product-detail.component.html">
<!-- src/app/features/products/product-detail/product-detail.component.html -->
<div class="product-detail-container">
  <button mat-stroked-button routerLink="/admin/products" *ngIf="isAdminView && authService.role === 'admin'" class="back-button">
    <mat-icon>arrow_back</mat-icon> Înapoi la Listă Produse (Admin)
  </button>
  <button mat-stroked-button routerLink="/products" *ngIf="!isAdminView" class="back-button">
    <mat-icon>arrow_back</mat-icon> Înapoi la Produse
  </button>

  <div *ngIf="isLoading" class="loading-indicator">
    <mat-spinner diameter="60"></mat-spinner>
    <p>Se încarcă detaliile produsului...</p>
  </div>

  <div *ngIf="error && !isLoading" class="error-message">
    <p>{{ error }}</p>
    <button mat-stroked-button color="warn" (click)="loadProductDetails()">Reîncearcă</button>
  </div>

  <div *ngIf="product && !isLoading" class="product-content">
    <mat-card class="product-card">
      <mat-card-header class="product-header">
        <div class="header-text">
          <mat-card-title>{{ product.name | titlecase }}</mat-card-title>
          <mat-card-subtitle *ngIf="product.categoryName">Categorie: {{ product.categoryName }}</mat-card-subtitle>
        </div>
        <div class="header-actions" *ngIf="isAdminView && authService.role === 'admin'">
          <button mat-flat-button color="primary" [routerLink]="['/admin/products/edit', product.id]">
            <mat-icon>edit</mat-icon> Editează
          </button>
          <button mat-flat-button color="warn" (click)="deleteProduct()">
            <mat-icon>delete</mat-icon> Șterge
          </button>
        </div>
      </mat-card-header>

      <div class="product-main-info">
        <!-- Secțiunea Imagine - COMENTATĂ TEMPORAR -->
        <!--
        <div class="image-container">
          <img *ngIf="product.imageBase64" [src]="product.imageBase64" [alt]="product.name" class="product-image">
          <div *ngIf="!product.imageBase64" class="no-image-placeholder">
            <mat-icon>photo_camera</mat-icon>
            <span>Imagine indisponibilă</span>
          </div>
        </div>
        -->
        <div class="details-container">
          <p class="price">{{ product.price | currency:'RON':'symbol':'1.2-2' }}</p>
          <p class="stock" [ngClass]="{'in-stock': product.stockQuantity > 0, 'out-of-stock': product.stockQuantity === 0}">
            Stoc: {{ product.stockQuantity > 0 ? product.stockQuantity + ' buc.' : 'Indisponibil' }}
          </p>
          <div class="description" *ngIf="product.description">
            <h4>Descriere:</h4>
            <p [innerHTML]="product.description | nl2br"></p>
          </div>
          <button *ngIf="!isAdminView" mat-raised-button color="accent" class="add-to-cart-button" 
                  [disabled]="product.stockQuantity === 0 || isLoading"
                  (click)="addToCart()">
            <mat-icon>add_shopping_cart</mat-icon> Adaugă în Coș
          </button>
        </div>
      </div>
      <div class="rating-info" *ngIf="product.averageRating !== undefined">
  <app-star-rating 
    [rating]="product.averageRating" 
    [readonly]="true"
    [showText]="true"
    [reviewCount]="product.reviewCount">
  </app-star-rating>
</div>
      <mat-card-content *ngIf="product.specifications && product.specifications.length > 0" class="specifications-section">
        <mat-divider></mat-divider>
        <h3>Specificații Tehnice</h3>
        <mat-list role="list">
          <mat-list-item *ngFor="let spec of product.specifications" role="listitem" class="specification-item">
            <span matListItemTitle class="spec-name">{{ spec.name || 'Specificație' }}:</span>
            <span matListItemLine class="spec-value">{{ spec.value }} {{ spec.unit || '' }}</span>
          </mat-list-item>
        </mat-list>
      </mat-card-content>
    </mat-card>
  </div>
</div>
<app-review-list [productId]="productId"></app-review-list>
</file>

<file path="frontend/src/app/features/products/product-detail/product-detail.component.scss">
.product-detail-container {
  padding: 20px;
  max-width: 900px;
  margin: 20px auto;
}

.back-button {
  margin-bottom: 20px;
  mat-icon {
    margin-right: 8px;
  }
}

.loading-indicator,
.error-message {
  text-align: center;
  padding: 40px 20px;
  mat-spinner {
    margin: 0 auto 15px auto;
  }
}

.product-card {
  width: 100%;
}

.product-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  padding-bottom: 16px;

  .header-text {
    flex-grow: 1;
  }
  .header-actions {
    display: flex;
    gap: 10px;
    flex-shrink: 0;
  }
}

.product-main-info {
  display: flex;
  gap: 24px;
  margin-top: 16px;
  margin-bottom: 24px;

  @media (max-width: 768px) {
    flex-direction: column;
  }

  .details-container {
    flex: 1 1 60%;
    display: flex;
    flex-direction: column;

    .price {
      font-size: 2em;
      font-weight: bold;
      margin-bottom: 8px;
    }
    
    .stock {
      font-size: 1em;
      margin-bottom: 16px;
      &.in-stock { color: #4CAF50; }
      &.out-of-stock { color: #F44336; }
    }
    
    .description {
      margin-bottom: 20px;
      h4 {
        margin-bottom: 8px;
        font-size: 1.1em;
        font-weight: 500;
      }
      p {
        line-height: 1.6;
        opacity: 0.87;
        white-space: pre-wrap;
      }
    }
    
    .add-to-cart-button {
      margin-top: auto;
      width: 100%;
      max-width: 250px;
      padding: 10px 0;
      font-size: 1em;
      mat-icon {
        margin-right: 8px;
      }
    }
  }
}

.rating-info {
  margin: 20px 0;
}

.specifications-section {
  padding-top: 16px;
  h3 {
    margin-bottom: 12px;
    font-size: 1.2em;
    font-weight: 500;
    opacity: 0.87;
  }
  .specification-item {
    border-bottom: 1px dotted rgba(0,0,0,0.12);
    padding: 8px 0;
    &:last-child {
      border-bottom: none;
    }
    .spec-name {
      font-weight: 500;
      display: inline-block;
      min-width: 150px;
    }
    .spec-value {
      opacity: 0.87;
    }
  }
}
</file>

<file path="frontend/src/app/features/products/product-detail/product-detail.component.ts">
import { Component, OnInit, inject, Pipe, PipeTransform } from '@angular/core';
import { CommonModule, CurrencyPipe, TitleCasePipe } from '@angular/common';
import { ActivatedRoute, Router, RouterModule } from '@angular/router';
import { MatCardModule } from '@angular/material/card';
import { MatListModule } from '@angular/material/list';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar';
import { MatChipsModule } from '@angular/material/chips';
import { MatDividerModule } from '@angular/material/divider';
import { DomSanitizer, SafeHtml } from '@angular/platform-browser';

import { Product } from '../../../shared/models/product.model';
import { ProductService } from '../product.service';
import { AuthService } from '../../../auth/auth.service';
import { CartService } from '../../shopping-cart/cart.service';
import { AddToCartRequest } from '../../../shared/models/cart.model';
import { ReviewListComponent } from '../../reviews/review-list/review-list.component';
import { StarRatingComponent } from '../../../shared/components/star-rating/star-rating.component';

// Pipe custom pentru nl2br
@Pipe({
  name: 'nl2br',
  standalone: true
})
export class Nl2brPipe implements PipeTransform {
  constructor(private sanitizer: DomSanitizer) {}
  transform(value: string | null | undefined): SafeHtml {
    if (!value) return '';
    return this.sanitizer.bypassSecurityTrustHtml(value.replace(/\n/g, '<br/>'));
  }
}

@Component({
  selector: 'app-product-detail',
  standalone: true,
  imports: [
    CommonModule,
    RouterModule,
    MatCardModule,
    MatListModule,
    MatButtonModule,
    MatIconModule,
    MatProgressSpinnerModule,
    MatSnackBarModule,
    MatChipsModule,
    MatDividerModule,
    CurrencyPipe,
    TitleCasePipe,
    Nl2brPipe,
    ReviewListComponent,
    StarRatingComponent
  ],
  templateUrl: './product-detail.component.html',
  styleUrls: ['./product-detail.component.scss']
})
export class ProductDetailComponent implements OnInit {
  product: Product | null = null;
  isLoading = true;
  error: string | null = null;
  productId!: number;
  isAdminView = false;

  private route = inject(ActivatedRoute);
  private router = inject(Router);
  private productService = inject(ProductService);
  private snackBar = inject(MatSnackBar);
  public authService = inject(AuthService);
  private cartService = inject(CartService);

  ngOnInit(): void {
    const idFromRoute = this.route.snapshot.paramMap.get('id');
    if (idFromRoute) {
      this.productId = +idFromRoute;
      if (!isNaN(this.productId) && this.productId > 0) {
        this.loadProductDetails();
        this.isAdminView = this.router.url.includes('/admin/');
      } else {
        this.handleInvalidId();
      }
    } else {
      this.handleInvalidId();
    }
  }

  private handleInvalidId(): void {
    this.isLoading = false;
    this.error = 'ID produs invalid.';
    this.snackBar.open(this.error, 'Închide', { duration: 3000 });
    this.router.navigate(['/']);
  }

  loadProductDetails(): void {
    this.isLoading = true;
    this.error = null;
    this.productService.getById(this.productId).subscribe({
      next: (data) => {
        this.product = data;
        this.isLoading = false;
      },
      error: (err) => {
        this.isLoading = false;
        this.error = 'Nu s-au putut încărca detaliile produsului.';
        const errMsg = err.error?.message || err.message || 'Eroare necunoscută.';
        this.snackBar.open(`${this.error} ${errMsg}`, 'Închide', { duration: 5000 });
        console.error(err);
        this.router.navigate(['/']);
      }
    });
  }

  deleteProduct(): void {
    if (!this.product || typeof this.product.id === 'undefined') return;
    const confirmation = window.confirm('Sunteți sigur că doriți să ștergeți acest produs?');
    if (confirmation) {
      this.isLoading = true;
      this.productService.delete(this.product.id).subscribe({
        next: () => {
          this.isLoading = false;
          this.snackBar.open('Produs șters cu succes!', 'OK', { duration: 3000 });
          this.router.navigate(['/admin/products']);
        },
        error: (err) => {
          this.isLoading = false;
          this.snackBar.open('Eroare la ștergerea produsului.', 'Închide', { duration: 5000 });
          console.error(err);
        }
      });
    }
  }

  addToCart(): void {
    if (!this.authService.isLoggedIn()) {
      this.snackBar.open('Trebuie să fii autentificat pentru a adăuga produse în coș.', 'Login', {
        duration: 5000,
      }).onAction().subscribe(() => {
        this.router.navigate(['/login'], { queryParams: { returnUrl: this.router.url } });
      });
      return;
    }

    // AICI ESTE CORECȚIA: Verificăm și dacă produsul are un ID.
    if (!this.product || typeof this.product.id === 'undefined') {
      this.snackBar.open('Detaliile produsului sunt incomplete. Vă rugăm reîncercați.', 'Închide', { duration: 3000 });
      return;
    }

    const request: AddToCartRequest = {
      productId: this.product.id, // Acum TypeScript știe sigur că `this.product.id` este un număr.
      quantity: 1
    };

    this.isLoading = true;
    this.cartService.addToCart(request).subscribe({
      next: () => {
        this.isLoading = false;
        this.snackBar.open(`"${this.product?.name}" a fost adăugat în coș!`, 'OK', {
          duration: 3000,
        });
      },
      error: (err) => {
        this.isLoading = false;
        const errorMessage = err.error?.message || 'A apărut o eroare la adăugarea produsului în coș.';
        this.snackBar.open(errorMessage, 'Închide', {
          duration: 5000
        });
        console.error('Error adding to cart:', err);
      }
    });
  }
}
</file>

<file path="frontend/src/app/features/user-dashboard/user-dashboard.component.scss">
.user-dashboard-container {
  height: calc(100vh - 64px); 
  display: flex;
}

.user-sidenav {
  width: 240px;
  border-right: 1px solid rgba(0,0,0,0.12);

  .sidenav-header {
    padding: 16px;
    border-bottom: 1px solid rgba(0,0,0,0.12);
    display: flex;
    align-items: center;
    gap: 10px;

    mat-icon {
      color: var(--mdc-theme-primary, #673ab7);
    }
    h3 {
      margin: 0;
      font-weight: 500;
    }
  }

  a[mat-list-item] {
    border-left: 4px solid transparent;
    transition: background-color 0.3s, border-left-color 0.3s;
    &:hover { 
      background-color: rgba(0,0,0,0.04); 
    }
    &.active-link {
      background-color: rgba(103, 58, 183, 0.1);
      border-left-color: var(--mdc-theme-primary, #673ab7);
      font-weight: 500;
      mat-icon { 
        color: var(--mdc-theme-primary, #673ab7); 
      }
    }
  }
}

:host ::ng-deep .mat-drawer-content {
  padding: 0;
  overflow: auto;
}

.user-content {
  flex: 1;
  overflow: auto;
}

.section-title {
  font-size: 2rem;
  font-weight: bold;
  margin-bottom: 40px;
  text-align: left;
}

.loading-indicator {
  display: flex;
  justify-content: center;
  padding: 40px;
}

/* Hero Section */
.hero-section {
  min-height: 60vh;
  padding: 40px;
  display: flex;
  align-items: center;
  position: relative;
  background: linear-gradient(135deg, rgba(0,0,0,0.05) 0%, rgba(0,0,0,0.1) 100%);
  
  .hero-overlay {
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    background: linear-gradient(to right, rgba(255,255,255,0.3) 30%, rgba(255,255,255,0.1) 60%, transparent 100%);
  }
  
  .hero-content {
    position: relative;
    z-index: 2;
    max-width: 1200px;
    margin: 0 auto;
    width: 100%;
    
    .text-content {
      max-width: 50%;
      h1 { 
        font-size: 3rem; 
        font-weight: bold; 
      }
      p { 
        font-size: 1.1rem; 
        line-height: 1.6; 
        margin: 20px 0 30px; 
      }
      button {
        padding: 10px 30px;
        font-size: 1rem;
        font-weight: bold;
      }
    }
  }
}

/* Products Section */
.selection-section {
  padding: 60px 40px;
}

.product-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
  gap: 30px;
}

.product-card {
  transition: transform 0.2s ease, box-shadow 0.2s ease;
  cursor: pointer;

  &:hover {
    transform: translateY(-8px);
    box-shadow: 0 8px 20px rgba(0,0,0,0.15);
  }

  .product-image-container {
    height: 200px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(0,0,0,0.05);
    mat-icon { 
      font-size: 60px; 
      width: 60px; 
      height: 60px; 
      opacity: 0.3;
    }
  }

  mat-card-header {
    justify-content: center;
    text-align: center;
  }
  
  mat-card-title {
    font-size: 1.1rem;
  }
  
  mat-card-content {
    text-align: center;
    .product-price { 
      font-size: 1.1rem; 
      font-weight: bold; 
      margin-top: 5px; 
    }
  }

  mat-card-actions {
    justify-content: center;
    padding: 0 16px 16px;
  }
}

/* Social Section */
.social-section {
  padding: 60px 40px;
  background-color: rgba(0,0,0,0.05);
  .social-icons {
    display: flex;
    justify-content: center;
    gap: 20px;
    .social-icon-box {
      width: 120px;
      height: 120px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 4rem;
      font-weight: bold;
      text-decoration: none;
      transition: background-color 0.2s;
      border: 2px solid currentColor;
      border-radius: 8px;
      &:hover { 
        background-color: rgba(0,0,0,0.05); 
      }
    }
  }
}
</file>

<file path="frontend/angular.json">
{
  "$schema": "./node_modules/@angular/cli/lib/config/schema.json",
  "version": 1,
  "newProjectRoot": "projects",
  "projects": {
    "magazin-calculatoare": {
      "projectType": "application",
      "schematics": {
        "@schematics/angular:component": {
          "style": "scss"
        }
      },
      "root": "",
      "sourceRoot": "src",
      "prefix": "app",
      "architect": {
        "build": {
          "builder": "@angular-devkit/build-angular:application",
          "options": {
            "outputPath": "dist/magazin-calculatoare",
            "index": "src/index.html",
            "browser": "src/main.ts",
            "polyfills": [
              "zone.js"
            ],
            "tsConfig": "tsconfig.app.json",
            "inlineStyleLanguage": "scss",
            "assets": [
              {
                "glob": "**/*",
                "input": "public"
              }
            ],
            "styles": [
              "@angular/material/prebuilt-themes/indigo-pink.css",
              "src/styles.scss"
             
            ],
            "scripts": [],
            "server": "src/main.server.ts",
            "outputMode": "server",
            "ssr": {
              "entry": "src/server.ts"
            }
          },
          "configurations": {
            "production": {
              "budgets": [
                {
                  "type": "initial",
                  "maximumWarning": "500kB",
                  "maximumError": "1MB"
                },
                {
                  "type": "anyComponentStyle",
                  "maximumWarning": "4kB",
                  "maximumError": "8kB"
                }
              ],
              "outputHashing": "all"
            },
            "development": {
              "optimization": false,
              "extractLicenses": false,
              "sourceMap": true
            }
          },
          "defaultConfiguration": "production"
        },
        "serve": {
          "builder": "@angular-devkit/build-angular:dev-server",
          "configurations": {
            "production": {
              "buildTarget": "magazin-calculatoare:build:production"
            },
            "development": {
              "buildTarget": "magazin-calculatoare:build:development",
              "proxyConfig": "proxy.conf.json"
            }
          },
          "defaultConfiguration": "development"
        },
        "extract-i18n": {
          "builder": "@angular-devkit/build-angular:extract-i18n"
        },
        "test": {
          "builder": "@angular-devkit/build-angular:karma",
          "options": {
            "polyfills": [
              "zone.js",
              "zone.js/testing"
            ],
            "tsConfig": "tsconfig.spec.json",
            "inlineStyleLanguage": "scss",
            "assets": [
              {
                "glob": "**/*",
                "input": "public"
              }
            ],
            "styles": [
              "src/themes/dark-blue-theme.scss",
              "src/styles.scss"
            ],
            "scripts": []
          }
        }
      }
    }
  },
  "cli": {
    "analytics": false
  }
}
</file>

<file path="frontend/src/app/login/login.component.scss">
.login-container {
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: calc(100vh - 128px); 
  padding: 20px;
}

.login-card {
  width: 100%;
  max-width: 400px;
  padding: 20px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  border-radius: 8px;
  // Remove dark background - let Material theme handle it
}

mat-card-header {
  text-align: center;
  padding-bottom: 20px;
  mat-card-title {
    font-size: 1.8em;
  }
  mat-card-subtitle {
    font-size: 1em;
    opacity: 0.7;
  }
}

.full-width {
  width: 100%;
  margin-bottom: 18px;
}

.remember-me-checkbox {
  margin-bottom: 20px;
  display: block;
}

.login-button {
  padding: 10px 0;
  font-size: 1.05em;
  display: flex;
  align-items: center;
  justify-content: center;

  .button-spinner {
    margin-right: 8px;
  }
}

.login-card-actions-center {
  display: flex;
  justify-content: center;
  margin-top: 16px;
  padding-top: 16px;
  border-top: 1px solid rgba(0,0,0,0.12);
}

.signup-link {
  text-align: center;
  font-size: 0.9em;
  opacity: 0.7;
  a {
    color: var(--mdc-theme-primary, #673ab7);
    text-decoration: none;
    font-weight: 500;
    &:hover {
      text-decoration: underline;
    }
  }
}

mat-form-field .mat-icon-button[matSuffix] {
  display: flex;
  align-items: center;
  justify-content: center;
}
</file>

<file path="frontend/src/app/app.routes.ts">
import { Routes } from '@angular/router';

// Componenta noua pentru pagina principala
import { HomePageComponent } from './features/home/home-page/home-page.component';

// Componente pentru autentificare si dashboard-uri
import { LoginComponent } from './login/login.component';
import { AdminDashboardComponent } from './features/admin-dashboard/admin-dashboard.component';

// Componente publice
import { ProductListComponent } from './features/products/product-list/product-list.component';
import { ProductDetailComponent } from './features/products/product-detail/product-detail.component';

// Componente pentru sectiuni specifice (Admin & User)
import { AdminCategoryListComponent } from './features/admin/admin-categories/admin-category-list/admin-category-list.component';
import { AdminCategoryFormComponent } from './features/admin/admin-categories/admin-category-form/admin-category-form.component';
import { AdminOrderListComponent } from './features/admin/admin-orders/admin-order-list/admin-order-list.component';
import { AdminOrderDetailComponent } from './features/admin/admin-orders/admin-order-detail/admin-order-detail.component';
import { AdminSpecDefListComponent } from './features/admin/admin-specifications/admin-spec-def-list/admin-spec-def-list.component';
import { AdminSpecDefFormComponent } from './features/admin/admin-specifications/admin-spec-def-form/admin-spec-def-form.component';
import { AdminUserListComponent } from './features/admin/admin-users/admin-user-list/admin-user-list.component';
import { AdminUserFormComponent } from './features/admin/admin-users/admin-user-form/admin-user-form.component';
import { ProductFormComponent } from './features/products/product-form/product-form.component';
import { UserOrderHistoryComponent } from './features/user-dashboard/user-order-history/user-order-history.component';
import { SignupComponent } from './signup/signup.component';
import { ReportsComponent } from './features/admin/reports/reports.component';


// Guards pentru securizarea rutelor
import { userGuard } from './auth/user.guard';
import { adminGuard } from './auth/admin.guard';

import { ShoppingCartComponent } from './features/shopping-cart/shopping-cart.component';
import { CheckoutComponent } from './features/checkout/checkout.component';
import { UserProductListComponent } from './features/products/user-product-list/user-product-list.component';
import { UserProfileComponent } from './features/user-profile/user-profile.component';

export const routes: Routes = [
  // Pagina principala (default), publica
  { path: '', component: HomePageComponent, title: 'VipeX Technology' },

  // Ruta de autentificare
  { path: 'login', component: LoginComponent, title: 'Autentificare' },
  
  // Rutele de detalii produs și catalog rămân publice
  { path: 'products-list', component: UserProductListComponent, title: 'Catalog Produse' }, // Ruta pentru tabelul vechi
  { path: 'products/:id', component: ProductDetailComponent, title: 'Detalii Produs' },

   // Ruta pentru coșul de cumpărături
  { path: 'cart', component: ShoppingCartComponent, canActivate: [userGuard], title: 'Coș de Cumpărături' },
  // Ruta pentru finalizarea comenzii
  { path: 'checkout', component: CheckoutComponent, canActivate: [userGuard], title: 'Finalizare Comandă' },
  
  // Rute protejate pentru Utilizator (fără un dashboard-wrapper)
  { path: 'my-orders', component: UserOrderHistoryComponent, canActivate: [userGuard], title: 'Comenzile Mele' },
  // { path: 'my-profile', component: UserProfileComponent, canActivate: [userGuard], title: 'Profilul Meu' },
  { path: 'signup', component: SignupComponent, title: 'Înregistrare' },
 { path: 'my-profile', component: UserProfileComponent, canActivate: [userGuard], title: 'Profilul Meu' },

  // Rute protejate pentru Administrator
  {
    path: 'admin',
    component: AdminDashboardComponent,
    canActivate: [adminGuard],
    children: [
      { path: '', redirectTo: 'products', pathMatch: 'full' },
      { path: 'products', children: [
          { path: '', component: ProductListComponent, title: 'Administrare Produse' },
          { path: 'new', component: ProductFormComponent, title: 'Adaugă Produs' },
          { path: 'edit/:id', component: ProductFormComponent, title: 'Editează Produs' },
      ]},
      { path: 'categories', children: [
          { path: '', component: AdminCategoryListComponent, title: 'Administrare Categorii' },
          { path: 'new', component: AdminCategoryFormComponent, title: 'Adaugă Categorie' },
          { path: 'edit/:id', component: AdminCategoryFormComponent, title: 'Editează Categorie' },
      ]},
      { path: 'orders', children: [
          { path: '', component: AdminOrderListComponent, title: 'Administrare Comenzi' },
          { path: ':id', component: AdminOrderDetailComponent, title: 'Detalii Comandă' },
      ]},
      { path: 'specification-definitions', children: [
          { path: '', component: AdminSpecDefListComponent, title: 'Definiții Specificații' },
          { path: 'new', component: AdminSpecDefFormComponent, title: 'Adaugă Definiție' },
          { path: 'edit/:id', component: AdminSpecDefFormComponent, title: 'Editează Definiție' },
      ]},
      { path: 'users', children: [
          { path: '', component: AdminUserListComponent, title: 'Administrare Utilizatori' },
          { path: 'edit/:id', component: AdminUserFormComponent, title: 'Editează Utilizator' },
      ]},
       { path: 'reports', component: ReportsComponent, title: 'Rapoarte' },
    ]
  },

  // Orice altceva redirecționează la pagina principală
  { path: '**', redirectTo: '', pathMatch: 'full' }
];
</file>

</files>
