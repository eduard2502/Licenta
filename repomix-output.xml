This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
backend/.gitattributes
backend/.gitignore
backend/.mvn/wrapper/maven-wrapper.properties
backend/mvnw
backend/mvnw.cmd
backend/pom.xml
backend/src/main/java/com/magazincomputere/magazin_api/config/SecurityConfig.java
backend/src/main/java/com/magazincomputere/magazin_api/config/WebConfig.java
backend/src/main/java/com/magazincomputere/magazin_api/controller/AngularForwardController.java
backend/src/main/java/com/magazincomputere/magazin_api/controller/AuthController.java
backend/src/main/java/com/magazincomputere/magazin_api/controller/CategoryController.java
backend/src/main/java/com/magazincomputere/magazin_api/controller/CustomerController.java
backend/src/main/java/com/magazincomputere/magazin_api/controller/OrderController.java
backend/src/main/java/com/magazincomputere/magazin_api/controller/ProductController.java
backend/src/main/java/com/magazincomputere/magazin_api/controller/ReportController.java
backend/src/main/java/com/magazincomputere/magazin_api/controller/SpecificationController.java
backend/src/main/java/com/magazincomputere/magazin_api/controller/UserController.java
backend/src/main/java/com/magazincomputere/magazin_api/dto/CategoryDto.java
backend/src/main/java/com/magazincomputere/magazin_api/dto/CustomerDto.java
backend/src/main/java/com/magazincomputere/magazin_api/dto/JwtResponse.java
backend/src/main/java/com/magazincomputere/magazin_api/dto/LoginRequest.java
backend/src/main/java/com/magazincomputere/magazin_api/dto/MessageResponse.java
backend/src/main/java/com/magazincomputere/magazin_api/dto/OrderDto.java
backend/src/main/java/com/magazincomputere/magazin_api/dto/OrderItemDto.java
backend/src/main/java/com/magazincomputere/magazin_api/dto/OrderStatusUpdateDto.java
backend/src/main/java/com/magazincomputere/magazin_api/dto/ProductDto.java
backend/src/main/java/com/magazincomputere/magazin_api/dto/SignupRequest.java
backend/src/main/java/com/magazincomputere/magazin_api/dto/SpecificationDefinitionDto.java
backend/src/main/java/com/magazincomputere/magazin_api/dto/SpecificationDto.java
backend/src/main/java/com/magazincomputere/magazin_api/dto/UserDto.java
backend/src/main/java/com/magazincomputere/magazin_api/exception/BadRequestException.java
backend/src/main/java/com/magazincomputere/magazin_api/exception/GlobalExceptionHandler.java
backend/src/main/java/com/magazincomputere/magazin_api/exception/ResourceNotFoundException.java
backend/src/main/java/com/magazincomputere/magazin_api/MagazinApiApplication.java
backend/src/main/java/com/magazincomputere/magazin_api/model/Category.java
backend/src/main/java/com/magazincomputere/magazin_api/model/Customer.java
backend/src/main/java/com/magazincomputere/magazin_api/model/ERole.java
backend/src/main/java/com/magazincomputere/magazin_api/model/Order.java
backend/src/main/java/com/magazincomputere/magazin_api/model/OrderItem.java
backend/src/main/java/com/magazincomputere/magazin_api/model/Product.java
backend/src/main/java/com/magazincomputere/magazin_api/model/ProductSpecificationValue.java
backend/src/main/java/com/magazincomputere/magazin_api/model/Role.java
backend/src/main/java/com/magazincomputere/magazin_api/model/SpecificationDefinition.java
backend/src/main/java/com/magazincomputere/magazin_api/model/User.java
backend/src/main/java/com/magazincomputere/magazin_api/repository/CategoryRepository.java
backend/src/main/java/com/magazincomputere/magazin_api/repository/CustomerRepository.java
backend/src/main/java/com/magazincomputere/magazin_api/repository/OrderItemRepository.java
backend/src/main/java/com/magazincomputere/magazin_api/repository/OrderRepository.java
backend/src/main/java/com/magazincomputere/magazin_api/repository/ProductRepository.java
backend/src/main/java/com/magazincomputere/magazin_api/repository/ProductSpecificationValueRepository.java
backend/src/main/java/com/magazincomputere/magazin_api/repository/RoleRepository.java
backend/src/main/java/com/magazincomputere/magazin_api/repository/SpecificationDefinitionRepository.java
backend/src/main/java/com/magazincomputere/magazin_api/repository/UserRepository.java
backend/src/main/java/com/magazincomputere/magazin_api/security/jwt/AuthEntryPointJwt.java
backend/src/main/java/com/magazincomputere/magazin_api/security/jwt/JwtAuthTokenFilter.java
backend/src/main/java/com/magazincomputere/magazin_api/security/jwt/JwtUtils.java
backend/src/main/java/com/magazincomputere/magazin_api/security/services/UserDetailsImpl.java
backend/src/main/java/com/magazincomputere/magazin_api/security/services/UserDetailsServiceImpl.java
backend/src/main/java/com/magazincomputere/magazin_api/service/CategoryService.java
backend/src/main/java/com/magazincomputere/magazin_api/service/CustomerService.java
backend/src/main/java/com/magazincomputere/magazin_api/service/OrderService.java
backend/src/main/java/com/magazincomputere/magazin_api/service/ProductService.java
backend/src/main/java/com/magazincomputere/magazin_api/service/ReportService.java
backend/src/main/java/com/magazincomputere/magazin_api/service/SpecificationService.java
backend/src/main/java/com/magazincomputere/magazin_api/service/UserService.java
backend/src/main/java/com/magazincomputere/magazin_api/util/DataInitializer.java
backend/src/main/resources/application.properties
backend/src/test/java/com/magazincomputere/magazin_api/MagazinApiApplicationTests.java
frontend/.editorconfig
frontend/.gitignore
frontend/.vscode/extensions.json
frontend/.vscode/launch.json
frontend/.vscode/tasks.json
frontend/angular.json
frontend/package.json
frontend/proxy.conf.json
frontend/README.md
frontend/src/app/app.component.html
frontend/src/app/app.component.scss
frontend/src/app/app.component.spec.ts
frontend/src/app/app.component.ts
frontend/src/app/app.config.server.ts
frontend/src/app/app.config.ts
frontend/src/app/app.routes.server.ts
frontend/src/app/app.routes.ts
frontend/src/app/auth/admin.guard.ts
frontend/src/app/auth/auth.guard.ts
frontend/src/app/auth/auth.interceptor.ts
frontend/src/app/auth/auth.service.ts
frontend/src/app/auth/user.guard.ts
frontend/src/app/features/admin-dashboard/admin-dashboard.component.html
frontend/src/app/features/admin-dashboard/admin-dashboard.component.scss
frontend/src/app/features/admin-dashboard/admin-dashboard.component.ts
frontend/src/app/features/admin/admin-categories/admin-category-form/admin-category-form.component.html
frontend/src/app/features/admin/admin-categories/admin-category-form/admin-category-form.component.scss
frontend/src/app/features/admin/admin-categories/admin-category-form/admin-category-form.component.ts
frontend/src/app/features/admin/admin-categories/admin-category-list/admin-category-list.component.html
frontend/src/app/features/admin/admin-categories/admin-category-list/admin-category-list.component.scss
frontend/src/app/features/admin/admin-categories/admin-category-list/admin-category-list.component.ts
frontend/src/app/features/admin/admin-orders/admin-order-detail/admin-order-detail.component.html
frontend/src/app/features/admin/admin-orders/admin-order-detail/admin-order-detail.component.scss
frontend/src/app/features/admin/admin-orders/admin-order-detail/admin-order-detail.component.ts
frontend/src/app/features/admin/admin-orders/admin-order-list/admin-order-list.component.html
frontend/src/app/features/admin/admin-orders/admin-order-list/admin-order-list.component.scss
frontend/src/app/features/admin/admin-orders/admin-order-list/admin-order-list.component.ts
frontend/src/app/features/admin/admin-specifications/admin-spec-def-form/admin-spec-def-form.component.html
frontend/src/app/features/admin/admin-specifications/admin-spec-def-form/admin-spec-def-form.component.scss
frontend/src/app/features/admin/admin-specifications/admin-spec-def-form/admin-spec-def-form.component.ts
frontend/src/app/features/admin/admin-specifications/admin-spec-def-list/admin-spec-def-list.component.html
frontend/src/app/features/admin/admin-specifications/admin-spec-def-list/admin-spec-def-list.component.scss
frontend/src/app/features/admin/admin-specifications/admin-spec-def-list/admin-spec-def-list.component.ts
frontend/src/app/features/admin/admin-users/admin-user-form/admin-user-form.component.html
frontend/src/app/features/admin/admin-users/admin-user-form/admin-user-form.component.scss
frontend/src/app/features/admin/admin-users/admin-user-form/admin-user-form.component.ts
frontend/src/app/features/admin/admin-users/admin-user-list/admin-user-list.component.html
frontend/src/app/features/admin/admin-users/admin-user-list/admin-user-list.component.scss
frontend/src/app/features/admin/admin-users/admin-user-list/admin-user-list.component.ts
frontend/src/app/features/admin/services/category.admin.service.ts
frontend/src/app/features/admin/services/order.admin.service.ts
frontend/src/app/features/admin/services/specification-admin.service.ts
frontend/src/app/features/admin/services/user-admin.service.ts
frontend/src/app/features/home/home-page/home-page.component.html
frontend/src/app/features/home/home-page/home-page.component.scss
frontend/src/app/features/home/home-page/home-page.component.spec.ts
frontend/src/app/features/home/home-page/home-page.component.ts
frontend/src/app/features/products/product-detail/product-detail.component.html
frontend/src/app/features/products/product-detail/product-detail.component.scss
frontend/src/app/features/products/product-detail/product-detail.component.ts
frontend/src/app/features/products/product-form/product-form.component.html
frontend/src/app/features/products/product-form/product-form.component.scss
frontend/src/app/features/products/product-form/product-form.component.ts
frontend/src/app/features/products/product-list/product-list.component.html
frontend/src/app/features/products/product-list/product-list.component.scss
frontend/src/app/features/products/product-list/product-list.component.ts
frontend/src/app/features/products/product.service.ts
frontend/src/app/features/products/products.module.ts
frontend/src/app/features/user-dashboard/services/client-order.service.ts
frontend/src/app/features/user-dashboard/user-dashboard.component.html
frontend/src/app/features/user-dashboard/user-dashboard.component.scss
frontend/src/app/features/user-dashboard/user-dashboard.component.ts
frontend/src/app/features/user-dashboard/user-order-history/user-order-history.component.html
frontend/src/app/features/user-dashboard/user-order-history/user-order-history.component.scss
frontend/src/app/features/user-dashboard/user-order-history/user-order-history.component.ts
frontend/src/app/login/login.component.html
frontend/src/app/login/login.component.scss
frontend/src/app/login/login.component.ts
frontend/src/app/shared/in-memory-data.service.ts
frontend/src/app/shared/material.module.ts
frontend/src/app/shared/models/category.model.ts
frontend/src/app/shared/models/order-item.model.ts
frontend/src/app/shared/models/order-status-update.model.ts
frontend/src/app/shared/models/order.model.ts
frontend/src/app/shared/models/product.model.ts
frontend/src/app/shared/models/specification-definition.model.ts
frontend/src/app/shared/models/specification-value.model.ts
frontend/src/app/shared/models/user.model.ts
frontend/src/app/shared/pipes/nl2br.pipe.ts
frontend/src/index.html
frontend/src/main.server.ts
frontend/src/main.ts
frontend/src/server.ts
frontend/src/styles.scss
frontend/src/themes/dark-blue-theme.scss
frontend/src/themes/dark-theme.scss
frontend/tsconfig.app.json
frontend/tsconfig.json
frontend/tsconfig.spec.json
package.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="frontend/src/app/features/home/home-page/home-page.component.html">
<div class="home-container">

  <section class="hero-section">
    <div class="hero-overlay"></div>
    <div class="hero-content">
      <div class="text-content">
        <h1>Dive into immersive gaming</h1>
        <p>Feel every explosion, every step, and every sound detail with the new VipeX gaming headsets.</p>
        <button mat-flat-button color="primary">Vezi oferta</button>
      </div>
    </div>
  </section>

  <main class="selection-section">
    <h2 class="section-title">Our selection</h2>

    <div *ngIf="isLoading" class="loading-indicator">
      <mat-spinner diameter="60"></mat-spinner>
    </div>

    <div class="product-grid" *ngIf="!isLoading && products.length > 0">
      <mat-card *ngFor="let product of products" class="product-card" [routerLink]="['/products', product.id]">
        <div class="product-image-container">
           <mat-icon>inventory_2</mat-icon>
        </div>
        <mat-card-header>
          <mat-card-title>{{ product.name }}</mat-card-title>
        </mat-card-header>
        <mat-card-content>
          <p class="product-price">{{ product.price | currency:'RON' }}</p>
        </mat-card-content>
        <mat-card-actions>
          <button mat-stroked-button color="primary">Add to cart</button>
        </mat-card-actions>
      </mat-card>
    </div>
  </main>

  <section class="social-section">
    <h2 class="section-title">Be connected. Be VipeX.</h2>
    <div class="social-icons">
      <a href="#" class="social-icon-box">X</a>
      <a href="#" class="social-icon-box">O</a>
      <a href="#" class="social-icon-box">f</a>
    </div>
  </section>

</div>
</file>

<file path="frontend/src/app/features/home/home-page/home-page.component.scss">
// src/app/features/home/home-page/home-page.component.scss
:host {
  display: block;
  background-color: #121212;
  color: #e0e0e0;
}

.section-title {
  color: #448AFF;
  font-size: 2.5rem;
  font-weight: bold;
  text-align: center;
  margin-bottom: 40px;
}

/* Stiluri Hero */
.hero-section {
  padding-top: 64px; // Compensează pentru înălțimea toolbar-ului
  min-height: 80vh;
  padding: 40px;
  display: flex;
  align-items: center;
  justify-content: center;
  position: relative;
  text-align: center;
  // Aici vei pune imaginea de fundal mai târziu
  background-color: #151515; // Culoare de rezervă

  .hero-overlay {
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    background: linear-gradient(to top, #121212 5%, rgba(18, 18, 18, 0.7) 60%, rgba(18, 18, 18, 0) 100%);
  }
  
  .hero-content {
    position: relative;
    h1 {
      font-size: 3.5rem;
      color: white;
      // MODIFICAT: Adăugare umbră pentru lizibilitate
      text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.8);
    }
    p {
      font-size: 1.2rem;
      margin: 20px 0 30px;
      // MODIFICAT: Adăugare umbră pentru lizibilitate
      text-shadow: 1px 1px 6px rgba(0, 0, 0, 0.8);
    }
    button {
      padding: 12px 35px;
      font-size: 1.1rem;
      background-color: #448AFF;
      color: white;
      font-weight: bold;
    }
  }
}

/* Restul stilurilor rămân la fel ca în răspunsul anterior */
.selection-section {
  padding: 60px 40px;
  max-width: 1400px;
  margin: 0 auto;
}

.product-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
  gap: 30px;
}

.product-card {
  background-color: #1e1e1e;
  border: 1px solid #448AFF;
  cursor: pointer;
  &:hover {
    transform: translateY(-5px);
    box-shadow: 0 5px 20px rgba(68, 138, 255, 0.25);
  }
  .product-image-container {
    height: 220px;
    background-color: #121212;
    display: flex;
    align-items: center;
    justify-content: center;
    color: #555;
    mat-icon { font-size: 70px; width: 70px; height: 70px; }
  }
  mat-card-header { justify-content: center; text-align: center; }
  mat-card-title { color: #448AFF; }
  mat-card-content { text-align: center; }
  mat-card-actions { justify-content: center; padding-bottom: 16px; }
}

.social-section {
  padding: 60px 40px;
  background-color: #1a1a1a;
  .social-icons {
    display: flex;
    justify-content: center;
    gap: 20px;
    .social-icon-box {
      width: 120px;
      height: 120px;
      background-color: #121212;
      border: 2px solid #448AFF;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 4rem;
      font-weight: bold;
      color: #448AFF;
    }
  }
}

.loading-indicator {
  display: flex;
  justify-content: center;
  padding: 40px;
}
</file>

<file path="frontend/src/app/features/home/home-page/home-page.component.spec.ts">
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { HomePageComponent } from './home-page.component';

describe('HomePageComponent', () => {
  let component: HomePageComponent;
  let fixture: ComponentFixture<HomePageComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [HomePageComponent]
    })
    .compileComponents();

    fixture = TestBed.createComponent(HomePageComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});
</file>

<file path="frontend/src/app/features/home/home-page/home-page.component.ts">
import { Component, OnInit, inject } from '@angular/core';
import { CommonModule, CurrencyPipe } from '@angular/common';
import { RouterModule } from '@angular/router';
import { MatCardModule } from '@angular/material/card';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';

import { Product } from '../../../shared/models/product.model';
import { ProductService } from '../../products/product.service';

@Component({
  selector: 'app-home-page',
  standalone: true,
  imports: [
    CommonModule,
    RouterModule,
    CurrencyPipe,
    MatCardModule,
    MatButtonModule,
    MatIconModule,
    MatProgressSpinnerModule
  ],
  templateUrl: './home-page.component.html',
  styleUrls: ['./home-page.component.scss']
})
export class HomePageComponent implements OnInit {
  products: Product[] = [];
  isLoading = true;
  error: string | null = null;

  private productService = inject(ProductService);

  ngOnInit(): void {
    this.loadProducts();
  }

  loadProducts(): void {
    this.isLoading = true;
    this.error = null;
    this.productService.getAll().subscribe({
      next: (data) => {
        this.products = data;
        this.isLoading = false;
      },
      error: (err) => {
        this.error = 'Nu s-au putut încărca produsele.';
        console.error(err);
        this.isLoading = false;
      }
    });
  }
}
</file>

<file path="frontend/src/themes/dark-blue-theme.scss">
// src/themes/dark-blue-theme.scss

@use '@angular/material' as mat;

// Includem o singură dată nucleul Angular Material.
@include mat.core();

// 1. Definește paletele de culori
$dark-primary-palette: mat.define-palette(mat.$grey-palette, 900, 800, 950);
$dark-accent-palette: mat.define-palette(mat.$blue-palette, A200, A100, A400);
$dark-warn-palette: mat.define-palette(mat.$red-palette);

// 2. Creează obiectul temei
$dark-blue-theme: mat.define-dark-theme((
  color: (
    primary: $dark-primary-palette,
    accent: $dark-accent-palette,
    warn: $dark-warn-palette,
  ),
  typography: mat.define-typography-config(),
  density: 0,
));

// 3. Aplică tema pentru toate componentele Angular Material
@include mat.all-component-themes($dark-blue-theme);


// ===================================================================
// == SUPRASCRIERE CUSTOM PENTRU COMPONENTE SPECIFICE (CEA MAI IMPORTANTĂ PARTE) ==
// ===================================================================

// Aici adăugăm regula pentru a face bara de navigare "seamless".
// Deoarece se află în același fișier cu tema, va fi aplicată corect.
.app-toolbar {
  background: rgba(18, 18, 18, 0.65) !important;
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
  box-shadow: none !important;
  border-bottom: 1px solid rgba(255, 255, 255, 0.1) !important;
}
</file>

<file path="package.json">
{
  "dependencies": {
    "repomix": "^0.3.9"
  }
}
</file>

<file path="backend/.gitattributes">
/mvnw text eol=lf
*.cmd text eol=crlf
</file>

<file path="backend/.gitignore">
HELP.md
target/
.mvn/wrapper/maven-wrapper.jar
!**/src/main/**/target/
!**/src/test/**/target/

### STS ###
.apt_generated
.classpath
.factorypath
.project
.settings
.springBeans
.sts4-cache

### IntelliJ IDEA ###
.idea
*.iws
*.iml
*.ipr

### NetBeans ###
/nbproject/private/
/nbbuild/
/dist/
/nbdist/
/.nb-gradle/
build/
!**/src/main/**/build/
!**/src/test/**/build/

### VS Code ###
.vscode/
</file>

<file path="backend/.mvn/wrapper/maven-wrapper.properties">
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
wrapperVersion=3.3.2
distributionType=only-script
distributionUrl=https://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.9.9/apache-maven-3.9.9-bin.zip
</file>

<file path="backend/mvnw">
#!/bin/sh
# ----------------------------------------------------------------------------
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
# ----------------------------------------------------------------------------

# ----------------------------------------------------------------------------
# Apache Maven Wrapper startup batch script, version 3.3.2
#
# Optional ENV vars
# -----------------
#   JAVA_HOME - location of a JDK home dir, required when download maven via java source
#   MVNW_REPOURL - repo url base for downloading maven distribution
#   MVNW_USERNAME/MVNW_PASSWORD - user and password for downloading maven
#   MVNW_VERBOSE - true: enable verbose log; debug: trace the mvnw script; others: silence the output
# ----------------------------------------------------------------------------

set -euf
[ "${MVNW_VERBOSE-}" != debug ] || set -x

# OS specific support.
native_path() { printf %s\\n "$1"; }
case "$(uname)" in
CYGWIN* | MINGW*)
  [ -z "${JAVA_HOME-}" ] || JAVA_HOME="$(cygpath --unix "$JAVA_HOME")"
  native_path() { cygpath --path --windows "$1"; }
  ;;
esac

# set JAVACMD and JAVACCMD
set_java_home() {
  # For Cygwin and MinGW, ensure paths are in Unix format before anything is touched
  if [ -n "${JAVA_HOME-}" ]; then
    if [ -x "$JAVA_HOME/jre/sh/java" ]; then
      # IBM's JDK on AIX uses strange locations for the executables
      JAVACMD="$JAVA_HOME/jre/sh/java"
      JAVACCMD="$JAVA_HOME/jre/sh/javac"
    else
      JAVACMD="$JAVA_HOME/bin/java"
      JAVACCMD="$JAVA_HOME/bin/javac"

      if [ ! -x "$JAVACMD" ] || [ ! -x "$JAVACCMD" ]; then
        echo "The JAVA_HOME environment variable is not defined correctly, so mvnw cannot run." >&2
        echo "JAVA_HOME is set to \"$JAVA_HOME\", but \"\$JAVA_HOME/bin/java\" or \"\$JAVA_HOME/bin/javac\" does not exist." >&2
        return 1
      fi
    fi
  else
    JAVACMD="$(
      'set' +e
      'unset' -f command 2>/dev/null
      'command' -v java
    )" || :
    JAVACCMD="$(
      'set' +e
      'unset' -f command 2>/dev/null
      'command' -v javac
    )" || :

    if [ ! -x "${JAVACMD-}" ] || [ ! -x "${JAVACCMD-}" ]; then
      echo "The java/javac command does not exist in PATH nor is JAVA_HOME set, so mvnw cannot run." >&2
      return 1
    fi
  fi
}

# hash string like Java String::hashCode
hash_string() {
  str="${1:-}" h=0
  while [ -n "$str" ]; do
    char="${str%"${str#?}"}"
    h=$(((h * 31 + $(LC_CTYPE=C printf %d "'$char")) % 4294967296))
    str="${str#?}"
  done
  printf %x\\n $h
}

verbose() { :; }
[ "${MVNW_VERBOSE-}" != true ] || verbose() { printf %s\\n "${1-}"; }

die() {
  printf %s\\n "$1" >&2
  exit 1
}

trim() {
  # MWRAPPER-139:
  #   Trims trailing and leading whitespace, carriage returns, tabs, and linefeeds.
  #   Needed for removing poorly interpreted newline sequences when running in more
  #   exotic environments such as mingw bash on Windows.
  printf "%s" "${1}" | tr -d '[:space:]'
}

# parse distributionUrl and optional distributionSha256Sum, requires .mvn/wrapper/maven-wrapper.properties
while IFS="=" read -r key value; do
  case "${key-}" in
  distributionUrl) distributionUrl=$(trim "${value-}") ;;
  distributionSha256Sum) distributionSha256Sum=$(trim "${value-}") ;;
  esac
done <"${0%/*}/.mvn/wrapper/maven-wrapper.properties"
[ -n "${distributionUrl-}" ] || die "cannot read distributionUrl property in ${0%/*}/.mvn/wrapper/maven-wrapper.properties"

case "${distributionUrl##*/}" in
maven-mvnd-*bin.*)
  MVN_CMD=mvnd.sh _MVNW_REPO_PATTERN=/maven/mvnd/
  case "${PROCESSOR_ARCHITECTURE-}${PROCESSOR_ARCHITEW6432-}:$(uname -a)" in
  *AMD64:CYGWIN* | *AMD64:MINGW*) distributionPlatform=windows-amd64 ;;
  :Darwin*x86_64) distributionPlatform=darwin-amd64 ;;
  :Darwin*arm64) distributionPlatform=darwin-aarch64 ;;
  :Linux*x86_64*) distributionPlatform=linux-amd64 ;;
  *)
    echo "Cannot detect native platform for mvnd on $(uname)-$(uname -m), use pure java version" >&2
    distributionPlatform=linux-amd64
    ;;
  esac
  distributionUrl="${distributionUrl%-bin.*}-$distributionPlatform.zip"
  ;;
maven-mvnd-*) MVN_CMD=mvnd.sh _MVNW_REPO_PATTERN=/maven/mvnd/ ;;
*) MVN_CMD="mvn${0##*/mvnw}" _MVNW_REPO_PATTERN=/org/apache/maven/ ;;
esac

# apply MVNW_REPOURL and calculate MAVEN_HOME
# maven home pattern: ~/.m2/wrapper/dists/{apache-maven-<version>,maven-mvnd-<version>-<platform>}/<hash>
[ -z "${MVNW_REPOURL-}" ] || distributionUrl="$MVNW_REPOURL$_MVNW_REPO_PATTERN${distributionUrl#*"$_MVNW_REPO_PATTERN"}"
distributionUrlName="${distributionUrl##*/}"
distributionUrlNameMain="${distributionUrlName%.*}"
distributionUrlNameMain="${distributionUrlNameMain%-bin}"
MAVEN_USER_HOME="${MAVEN_USER_HOME:-${HOME}/.m2}"
MAVEN_HOME="${MAVEN_USER_HOME}/wrapper/dists/${distributionUrlNameMain-}/$(hash_string "$distributionUrl")"

exec_maven() {
  unset MVNW_VERBOSE MVNW_USERNAME MVNW_PASSWORD MVNW_REPOURL || :
  exec "$MAVEN_HOME/bin/$MVN_CMD" "$@" || die "cannot exec $MAVEN_HOME/bin/$MVN_CMD"
}

if [ -d "$MAVEN_HOME" ]; then
  verbose "found existing MAVEN_HOME at $MAVEN_HOME"
  exec_maven "$@"
fi

case "${distributionUrl-}" in
*?-bin.zip | *?maven-mvnd-?*-?*.zip) ;;
*) die "distributionUrl is not valid, must match *-bin.zip or maven-mvnd-*.zip, but found '${distributionUrl-}'" ;;
esac

# prepare tmp dir
if TMP_DOWNLOAD_DIR="$(mktemp -d)" && [ -d "$TMP_DOWNLOAD_DIR" ]; then
  clean() { rm -rf -- "$TMP_DOWNLOAD_DIR"; }
  trap clean HUP INT TERM EXIT
else
  die "cannot create temp dir"
fi

mkdir -p -- "${MAVEN_HOME%/*}"

# Download and Install Apache Maven
verbose "Couldn't find MAVEN_HOME, downloading and installing it ..."
verbose "Downloading from: $distributionUrl"
verbose "Downloading to: $TMP_DOWNLOAD_DIR/$distributionUrlName"

# select .zip or .tar.gz
if ! command -v unzip >/dev/null; then
  distributionUrl="${distributionUrl%.zip}.tar.gz"
  distributionUrlName="${distributionUrl##*/}"
fi

# verbose opt
__MVNW_QUIET_WGET=--quiet __MVNW_QUIET_CURL=--silent __MVNW_QUIET_UNZIP=-q __MVNW_QUIET_TAR=''
[ "${MVNW_VERBOSE-}" != true ] || __MVNW_QUIET_WGET='' __MVNW_QUIET_CURL='' __MVNW_QUIET_UNZIP='' __MVNW_QUIET_TAR=v

# normalize http auth
case "${MVNW_PASSWORD:+has-password}" in
'') MVNW_USERNAME='' MVNW_PASSWORD='' ;;
has-password) [ -n "${MVNW_USERNAME-}" ] || MVNW_USERNAME='' MVNW_PASSWORD='' ;;
esac

if [ -z "${MVNW_USERNAME-}" ] && command -v wget >/dev/null; then
  verbose "Found wget ... using wget"
  wget ${__MVNW_QUIET_WGET:+"$__MVNW_QUIET_WGET"} "$distributionUrl" -O "$TMP_DOWNLOAD_DIR/$distributionUrlName" || die "wget: Failed to fetch $distributionUrl"
elif [ -z "${MVNW_USERNAME-}" ] && command -v curl >/dev/null; then
  verbose "Found curl ... using curl"
  curl ${__MVNW_QUIET_CURL:+"$__MVNW_QUIET_CURL"} -f -L -o "$TMP_DOWNLOAD_DIR/$distributionUrlName" "$distributionUrl" || die "curl: Failed to fetch $distributionUrl"
elif set_java_home; then
  verbose "Falling back to use Java to download"
  javaSource="$TMP_DOWNLOAD_DIR/Downloader.java"
  targetZip="$TMP_DOWNLOAD_DIR/$distributionUrlName"
  cat >"$javaSource" <<-END
	public class Downloader extends java.net.Authenticator
	{
	  protected java.net.PasswordAuthentication getPasswordAuthentication()
	  {
	    return new java.net.PasswordAuthentication( System.getenv( "MVNW_USERNAME" ), System.getenv( "MVNW_PASSWORD" ).toCharArray() );
	  }
	  public static void main( String[] args ) throws Exception
	  {
	    setDefault( new Downloader() );
	    java.nio.file.Files.copy( java.net.URI.create( args[0] ).toURL().openStream(), java.nio.file.Paths.get( args[1] ).toAbsolutePath().normalize() );
	  }
	}
	END
  # For Cygwin/MinGW, switch paths to Windows format before running javac and java
  verbose " - Compiling Downloader.java ..."
  "$(native_path "$JAVACCMD")" "$(native_path "$javaSource")" || die "Failed to compile Downloader.java"
  verbose " - Running Downloader.java ..."
  "$(native_path "$JAVACMD")" -cp "$(native_path "$TMP_DOWNLOAD_DIR")" Downloader "$distributionUrl" "$(native_path "$targetZip")"
fi

# If specified, validate the SHA-256 sum of the Maven distribution zip file
if [ -n "${distributionSha256Sum-}" ]; then
  distributionSha256Result=false
  if [ "$MVN_CMD" = mvnd.sh ]; then
    echo "Checksum validation is not supported for maven-mvnd." >&2
    echo "Please disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties." >&2
    exit 1
  elif command -v sha256sum >/dev/null; then
    if echo "$distributionSha256Sum  $TMP_DOWNLOAD_DIR/$distributionUrlName" | sha256sum -c >/dev/null 2>&1; then
      distributionSha256Result=true
    fi
  elif command -v shasum >/dev/null; then
    if echo "$distributionSha256Sum  $TMP_DOWNLOAD_DIR/$distributionUrlName" | shasum -a 256 -c >/dev/null 2>&1; then
      distributionSha256Result=true
    fi
  else
    echo "Checksum validation was requested but neither 'sha256sum' or 'shasum' are available." >&2
    echo "Please install either command, or disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties." >&2
    exit 1
  fi
  if [ $distributionSha256Result = false ]; then
    echo "Error: Failed to validate Maven distribution SHA-256, your Maven distribution might be compromised." >&2
    echo "If you updated your Maven version, you need to update the specified distributionSha256Sum property." >&2
    exit 1
  fi
fi

# unzip and move
if command -v unzip >/dev/null; then
  unzip ${__MVNW_QUIET_UNZIP:+"$__MVNW_QUIET_UNZIP"} "$TMP_DOWNLOAD_DIR/$distributionUrlName" -d "$TMP_DOWNLOAD_DIR" || die "failed to unzip"
else
  tar xzf${__MVNW_QUIET_TAR:+"$__MVNW_QUIET_TAR"} "$TMP_DOWNLOAD_DIR/$distributionUrlName" -C "$TMP_DOWNLOAD_DIR" || die "failed to untar"
fi
printf %s\\n "$distributionUrl" >"$TMP_DOWNLOAD_DIR/$distributionUrlNameMain/mvnw.url"
mv -- "$TMP_DOWNLOAD_DIR/$distributionUrlNameMain" "$MAVEN_HOME" || [ -d "$MAVEN_HOME" ] || die "fail to move MAVEN_HOME"

clean || :
exec_maven "$@"
</file>

<file path="backend/mvnw.cmd">
<# : batch portion
@REM ----------------------------------------------------------------------------
@REM Licensed to the Apache Software Foundation (ASF) under one
@REM or more contributor license agreements.  See the NOTICE file
@REM distributed with this work for additional information
@REM regarding copyright ownership.  The ASF licenses this file
@REM to you under the Apache License, Version 2.0 (the
@REM "License"); you may not use this file except in compliance
@REM with the License.  You may obtain a copy of the License at
@REM
@REM    http://www.apache.org/licenses/LICENSE-2.0
@REM
@REM Unless required by applicable law or agreed to in writing,
@REM software distributed under the License is distributed on an
@REM "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
@REM KIND, either express or implied.  See the License for the
@REM specific language governing permissions and limitations
@REM under the License.
@REM ----------------------------------------------------------------------------

@REM ----------------------------------------------------------------------------
@REM Apache Maven Wrapper startup batch script, version 3.3.2
@REM
@REM Optional ENV vars
@REM   MVNW_REPOURL - repo url base for downloading maven distribution
@REM   MVNW_USERNAME/MVNW_PASSWORD - user and password for downloading maven
@REM   MVNW_VERBOSE - true: enable verbose log; others: silence the output
@REM ----------------------------------------------------------------------------

@IF "%__MVNW_ARG0_NAME__%"=="" (SET __MVNW_ARG0_NAME__=%~nx0)
@SET __MVNW_CMD__=
@SET __MVNW_ERROR__=
@SET __MVNW_PSMODULEP_SAVE=%PSModulePath%
@SET PSModulePath=
@FOR /F "usebackq tokens=1* delims==" %%A IN (`powershell -noprofile "& {$scriptDir='%~dp0'; $script='%__MVNW_ARG0_NAME__%'; icm -ScriptBlock ([Scriptblock]::Create((Get-Content -Raw '%~f0'))) -NoNewScope}"`) DO @(
  IF "%%A"=="MVN_CMD" (set __MVNW_CMD__=%%B) ELSE IF "%%B"=="" (echo %%A) ELSE (echo %%A=%%B)
)
@SET PSModulePath=%__MVNW_PSMODULEP_SAVE%
@SET __MVNW_PSMODULEP_SAVE=
@SET __MVNW_ARG0_NAME__=
@SET MVNW_USERNAME=
@SET MVNW_PASSWORD=
@IF NOT "%__MVNW_CMD__%"=="" (%__MVNW_CMD__% %*)
@echo Cannot start maven from wrapper >&2 && exit /b 1
@GOTO :EOF
: end batch / begin powershell #>

$ErrorActionPreference = "Stop"
if ($env:MVNW_VERBOSE -eq "true") {
  $VerbosePreference = "Continue"
}

# calculate distributionUrl, requires .mvn/wrapper/maven-wrapper.properties
$distributionUrl = (Get-Content -Raw "$scriptDir/.mvn/wrapper/maven-wrapper.properties" | ConvertFrom-StringData).distributionUrl
if (!$distributionUrl) {
  Write-Error "cannot read distributionUrl property in $scriptDir/.mvn/wrapper/maven-wrapper.properties"
}

switch -wildcard -casesensitive ( $($distributionUrl -replace '^.*/','') ) {
  "maven-mvnd-*" {
    $USE_MVND = $true
    $distributionUrl = $distributionUrl -replace '-bin\.[^.]*$',"-windows-amd64.zip"
    $MVN_CMD = "mvnd.cmd"
    break
  }
  default {
    $USE_MVND = $false
    $MVN_CMD = $script -replace '^mvnw','mvn'
    break
  }
}

# apply MVNW_REPOURL and calculate MAVEN_HOME
# maven home pattern: ~/.m2/wrapper/dists/{apache-maven-<version>,maven-mvnd-<version>-<platform>}/<hash>
if ($env:MVNW_REPOURL) {
  $MVNW_REPO_PATTERN = if ($USE_MVND) { "/org/apache/maven/" } else { "/maven/mvnd/" }
  $distributionUrl = "$env:MVNW_REPOURL$MVNW_REPO_PATTERN$($distributionUrl -replace '^.*'+$MVNW_REPO_PATTERN,'')"
}
$distributionUrlName = $distributionUrl -replace '^.*/',''
$distributionUrlNameMain = $distributionUrlName -replace '\.[^.]*$','' -replace '-bin$',''
$MAVEN_HOME_PARENT = "$HOME/.m2/wrapper/dists/$distributionUrlNameMain"
if ($env:MAVEN_USER_HOME) {
  $MAVEN_HOME_PARENT = "$env:MAVEN_USER_HOME/wrapper/dists/$distributionUrlNameMain"
}
$MAVEN_HOME_NAME = ([System.Security.Cryptography.MD5]::Create().ComputeHash([byte[]][char[]]$distributionUrl) | ForEach-Object {$_.ToString("x2")}) -join ''
$MAVEN_HOME = "$MAVEN_HOME_PARENT/$MAVEN_HOME_NAME"

if (Test-Path -Path "$MAVEN_HOME" -PathType Container) {
  Write-Verbose "found existing MAVEN_HOME at $MAVEN_HOME"
  Write-Output "MVN_CMD=$MAVEN_HOME/bin/$MVN_CMD"
  exit $?
}

if (! $distributionUrlNameMain -or ($distributionUrlName -eq $distributionUrlNameMain)) {
  Write-Error "distributionUrl is not valid, must end with *-bin.zip, but found $distributionUrl"
}

# prepare tmp dir
$TMP_DOWNLOAD_DIR_HOLDER = New-TemporaryFile
$TMP_DOWNLOAD_DIR = New-Item -Itemtype Directory -Path "$TMP_DOWNLOAD_DIR_HOLDER.dir"
$TMP_DOWNLOAD_DIR_HOLDER.Delete() | Out-Null
trap {
  if ($TMP_DOWNLOAD_DIR.Exists) {
    try { Remove-Item $TMP_DOWNLOAD_DIR -Recurse -Force | Out-Null }
    catch { Write-Warning "Cannot remove $TMP_DOWNLOAD_DIR" }
  }
}

New-Item -Itemtype Directory -Path "$MAVEN_HOME_PARENT" -Force | Out-Null

# Download and Install Apache Maven
Write-Verbose "Couldn't find MAVEN_HOME, downloading and installing it ..."
Write-Verbose "Downloading from: $distributionUrl"
Write-Verbose "Downloading to: $TMP_DOWNLOAD_DIR/$distributionUrlName"

$webclient = New-Object System.Net.WebClient
if ($env:MVNW_USERNAME -and $env:MVNW_PASSWORD) {
  $webclient.Credentials = New-Object System.Net.NetworkCredential($env:MVNW_USERNAME, $env:MVNW_PASSWORD)
}
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
$webclient.DownloadFile($distributionUrl, "$TMP_DOWNLOAD_DIR/$distributionUrlName") | Out-Null

# If specified, validate the SHA-256 sum of the Maven distribution zip file
$distributionSha256Sum = (Get-Content -Raw "$scriptDir/.mvn/wrapper/maven-wrapper.properties" | ConvertFrom-StringData).distributionSha256Sum
if ($distributionSha256Sum) {
  if ($USE_MVND) {
    Write-Error "Checksum validation is not supported for maven-mvnd. `nPlease disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties."
  }
  Import-Module $PSHOME\Modules\Microsoft.PowerShell.Utility -Function Get-FileHash
  if ((Get-FileHash "$TMP_DOWNLOAD_DIR/$distributionUrlName" -Algorithm SHA256).Hash.ToLower() -ne $distributionSha256Sum) {
    Write-Error "Error: Failed to validate Maven distribution SHA-256, your Maven distribution might be compromised. If you updated your Maven version, you need to update the specified distributionSha256Sum property."
  }
}

# unzip and move
Expand-Archive "$TMP_DOWNLOAD_DIR/$distributionUrlName" -DestinationPath "$TMP_DOWNLOAD_DIR" | Out-Null
Rename-Item -Path "$TMP_DOWNLOAD_DIR/$distributionUrlNameMain" -NewName $MAVEN_HOME_NAME | Out-Null
try {
  Move-Item -Path "$TMP_DOWNLOAD_DIR/$MAVEN_HOME_NAME" -Destination $MAVEN_HOME_PARENT | Out-Null
} catch {
  if (! (Test-Path -Path "$MAVEN_HOME" -PathType Container)) {
    Write-Error "fail to move MAVEN_HOME"
  }
} finally {
  try { Remove-Item $TMP_DOWNLOAD_DIR -Recurse -Force | Out-Null }
  catch { Write-Warning "Cannot remove $TMP_DOWNLOAD_DIR" }
}

Write-Output "MVN_CMD=$MAVEN_HOME/bin/$MVN_CMD"
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/config/SecurityConfig.java">
package com.magazincomputere.magazin_api.config;

import com.magazincomputere.magazin_api.security.jwt.AuthEntryPointJwt;
import com.magazincomputere.magazin_api.security.jwt.JwtAuthTokenFilter;
import com.magazincomputere.magazin_api.security.services.UserDetailsServiceImpl;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.security.web.util.matcher.AntPathRequestMatcher;


@Configuration
@EnableWebSecurity
@EnableMethodSecurity(prePostEnabled = true) // Permite @PreAuthorize pe metode
public class SecurityConfig {

    @Autowired
    private UserDetailsServiceImpl userDetailsService;

    @Autowired
    private AuthEntryPointJwt unauthorizedHandler;

    @Bean
    public JwtAuthTokenFilter authenticationJwtTokenFilter() {
        return new JwtAuthTokenFilter();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authenticationConfiguration) throws Exception {
        return authenticationConfiguration.getAuthenticationManager();
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .cors(cors -> {}) // Utilizează configurația CORS din WebConfig sau definește una specifică aici
            .csrf(csrf -> csrf.disable()) // Dezactivează CSRF pentru API-uri stateless (comun pentru JWT)
            .exceptionHandling(exception -> exception.authenticationEntryPoint(unauthorizedHandler))
            .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS)) // API stateless
            .authorizeHttpRequests(auth -> auth
                // Permite request-uri către Swagger/OpenAPI și H2 console fără autentificare
                .requestMatchers("/swagger-ui.html", "/swagger-ui/**", "/api-docs/**", "/h2-console/**").permitAll()
                .requestMatchers("/api/auth/**").permitAll() // Endpoint-urile de autentificare

                // Reguli pentru Produse [cite: 1, 2]
                .requestMatchers(AntPathRequestMatcher.antMatcher(HttpMethod.GET, "/api/products/**")).permitAll()
                .requestMatchers(AntPathRequestMatcher.antMatcher(HttpMethod.GET, "/api/categories/**")).permitAll() // Vizualizare categorii [cite: 1]
                // Admin poate crea, actualiza, șterge produse și categorii
                .requestMatchers(AntPathRequestMatcher.antMatcher(HttpMethod.POST, "/api/products")).hasRole("ADMIN")
                .requestMatchers(AntPathRequestMatcher.antMatcher(HttpMethod.PUT, "/api/products/**")).hasRole("ADMIN")
                .requestMatchers(AntPathRequestMatcher.antMatcher(HttpMethod.DELETE, "/api/products/**")).hasRole("ADMIN")
                .requestMatchers(AntPathRequestMatcher.antMatcher(HttpMethod.POST, "/api/categories")).hasRole("ADMIN")
                .requestMatchers(AntPathRequestMatcher.antMatcher(HttpMethod.PUT, "/api/categories/**")).hasRole("ADMIN")
                .requestMatchers(AntPathRequestMatcher.antMatcher(HttpMethod.DELETE, "/api/categories/**")).hasRole("ADMIN")

                // Reguli pentru Specificații [cite: 1]
                .requestMatchers(AntPathRequestMatcher.antMatcher(HttpMethod.GET, "/api/specifications/**")).permitAll() // Toți pot vedea specificațiile
                .requestMatchers(AntPathRequestMatcher.antMatcher(HttpMethod.POST, "/api/specifications")).hasRole("ADMIN")
                .requestMatchers(AntPathRequestMatcher.antMatcher(HttpMethod.PUT, "/api/specifications/**")).hasRole("ADMIN")
                .requestMatchers(AntPathRequestMatcher.antMatcher(HttpMethod.DELETE, "/api/specifications/**")).hasRole("ADMIN")

                // Reguli pentru Comenzi [cite: 1, 2]
                .requestMatchers(AntPathRequestMatcher.antMatcher(HttpMethod.POST, "/api/orders")).hasAnyRole("USER", "ADMIN") // Finalizare comandă [cite: 2]
                .requestMatchers(AntPathRequestMatcher.antMatcher(HttpMethod.GET, "/api/orders/my-history")).hasAnyRole("USER", "ADMIN") // Istoric comenzi client [cite: 2]
                .requestMatchers(AntPathRequestMatcher.antMatcher(HttpMethod.GET, "/api/orders/**")).hasRole("ADMIN") // Admin vede toate comenzile
                .requestMatchers(AntPathRequestMatcher.antMatcher(HttpMethod.PUT, "/api/orders/**/status")).hasRole("ADMIN") // Admin schimbă starea comenzii [cite: 2]

                // Reguli pentru Utilizatori și Clienți (Gestionare Admin) [cite: 1]
                .requestMatchers(AntPathRequestMatcher.antMatcher("/api/users/**")).hasRole("ADMIN")
                .requestMatchers(AntPathRequestMatcher.antMatcher("/api/customers/**")).hasRole("ADMIN")

                // Reguli pentru Rapoarte (Admin) [cite: 1]
                .requestMatchers(AntPathRequestMatcher.antMatcher("/api/reports/**")).hasRole("ADMIN")

                // Permite toate celelalte request-uri (pentru frontend-ul Angular)
                .requestMatchers("/", "/*.html", "/*.js", "/*.css", "/*.ico", "/*.png", "/*.jpg", "/*.webmanifest", "/assets/**").permitAll()
                .anyRequest().authenticated() // Orice alt request necesită autentificare
            );

        // Necesar pentru H2 console dacă folosești Spring Security cu frame options
        http.headers(headers -> headers.frameOptions(frameOptions -> frameOptions.sameOrigin()));

        http.addFilterBefore(authenticationJwtTokenFilter(), UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/config/WebConfig.java">
package com.magazincomputere.magazin_api.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class WebConfig implements WebMvcConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/api/**") // Aplică CORS pentru toate căile sub /api
                .allowedOrigins("http://localhost:4200") // URL-ul frontend-ului Angular în dezvoltare
                .allowedMethods("GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS")
                .allowedHeaders("*")
                .allowCredentials(true);
    }
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/controller/AngularForwardController.java">
package com.magazincomputere.magazin_api.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
public class AngularForwardController {
    // Această expresie regulată este un exemplu și s-ar putea să necesite ajustări fine.
    // Scopul este să redirecționeze către index.html pentru rutele Angular,
    // cu excepția celor care încep cu /api, /swagger-ui, /api-docs, /h2-console
    // și a celor care par a fi pentru fișiere statice (conțin un punct).
    @RequestMapping(value = {"/", "/{path:^(?!api|swagger-ui|api-docs|h2-console|.*\\.).*$}/**", "/{path:^(?!api|swagger-ui|api-docs|h2-console|.*\\.).*$}"})
    public String forward() {
        return "forward:/index.html";
    }
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/controller/AuthController.java">
package com.magazincomputere.magazin_api.controller;

import com.magazincomputere.magazin_api.dto.LoginRequest;
import com.magazincomputere.magazin_api.dto.SignupRequest; // Va trebui să creezi acest DTO
import com.magazincomputere.magazin_api.dto.JwtResponse;
import com.magazincomputere.magazin_api.dto.MessageResponse;
import com.magazincomputere.magazin_api.model.ERole;
import com.magazincomputere.magazin_api.model.Role;
import com.magazincomputere.magazin_api.model.User;
import com.magazincomputere.magazin_api.repository.RoleRepository;
import com.magazincomputere.magazin_api.repository.UserRepository;
import com.magazincomputere.magazin_api.security.jwt.JwtUtils;
import com.magazincomputere.magazin_api.security.services.UserDetailsImpl;

import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.web.bind.annotation.*;

import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/auth")
public class AuthController {

    @Autowired
    AuthenticationManager authenticationManager;

    @Autowired
    UserRepository userRepository;

    @Autowired
    RoleRepository roleRepository;

    @Autowired
    PasswordEncoder encoder;

    @Autowired
    JwtUtils jwtUtils;

    @PostMapping("/login")
    public ResponseEntity<?> authenticateUser(@Valid @RequestBody LoginRequest loginRequest) {
        Authentication authentication = authenticationManager.authenticate(
                new UsernamePasswordAuthenticationToken(loginRequest.getUsername(), loginRequest.getPassword()));

        SecurityContextHolder.getContext().setAuthentication(authentication);
        String jwt = jwtUtils.generateJwtToken(authentication);

        UserDetailsImpl userDetails = (UserDetailsImpl) authentication.getPrincipal();
        List<String> roles = userDetails.getAuthorities().stream()
                .map(item -> item.getAuthority())
                .collect(Collectors.toList());

        return ResponseEntity.ok(new JwtResponse(jwt,
                                                 userDetails.getId(),
                                                 userDetails.getUsername(),
                                                 userDetails.getEmail(),
                                                 roles));
    }

    @PostMapping("/signup")
    public ResponseEntity<?> registerUser(@Valid @RequestBody SignupRequest signUpRequest) { // Creează DTO-ul SignupRequest
        if (userRepository.existsByUsername(signUpRequest.getUsername())) {
            return ResponseEntity
                    .badRequest()
                    .body(new MessageResponse("Error: Username is already taken!"));
        }

        if (userRepository.existsByEmail(signUpRequest.getEmail())) {
            return ResponseEntity
                    .badRequest()
                    .body(new MessageResponse("Error: Email is already in use!"));
        }

        // Create new user's account
        User user = new User(signUpRequest.getUsername(),
                             signUpRequest.getEmail(),
                             encoder.encode(signUpRequest.getPassword()));

        Set<String> strRoles = signUpRequest.getRoles(); // SignupRequest ar trebui să permită specificarea rolurilor
        Set<Role> roles = new HashSet<>();

        if (strRoles == null || strRoles.isEmpty()) {
            Role userRole = roleRepository.findByName(ERole.ROLE_USER)
                    .orElseThrow(() -> new RuntimeException("Error: Role USER is not found."));
            roles.add(userRole);
        } else {
            strRoles.forEach(role -> {
                switch (role.toLowerCase()) {
                    case "admin":
                        Role adminRole = roleRepository.findByName(ERole.ROLE_ADMIN)
                                .orElseThrow(() -> new RuntimeException("Error: Role ADMIN is not found."));
                        roles.add(adminRole);
                        break;
                    default:
                        Role userRole = roleRepository.findByName(ERole.ROLE_USER)
                                .orElseThrow(() -> new RuntimeException("Error: Role USER is not found."));
                        roles.add(userRole);
                }
            });
        }

        user.setRoles(roles);
        userRepository.save(user);

        return ResponseEntity.ok(new MessageResponse("User registered successfully!"));
    }
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/controller/CategoryController.java">
package com.magazincomputere.magazin_api.controller;

import com.magazincomputere.magazin_api.dto.CategoryDto;
import com.magazincomputere.magazin_api.service.CategoryService; // Va trebui să creezi CategoryService
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/categories")
public class CategoryController {

    @Autowired
    private CategoryService categoryService; // Asigură-te că ai creat CategoryService

    @GetMapping
    public List<CategoryDto> getAllCategories() { // Acces public
        return categoryService.getAllCategories();
    }

    @GetMapping("/{id}")
    public ResponseEntity<CategoryDto> getCategoryById(@PathVariable Long id) { // Acces public
        CategoryDto categoryDto = categoryService.getCategoryById(id);
        return ResponseEntity.ok(categoryDto);
    }

    @PostMapping
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<CategoryDto> createCategory(@Valid @RequestBody CategoryDto categoryDto) {
        CategoryDto createdCategory = categoryService.createCategory(categoryDto);
        return new ResponseEntity<>(createdCategory, HttpStatus.CREATED);
    }

    @PutMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<CategoryDto> updateCategory(@PathVariable Long id, @Valid @RequestBody CategoryDto categoryDto) {
        CategoryDto updatedCategory = categoryService.updateCategory(id, categoryDto);
        return ResponseEntity.ok(updatedCategory);
    }

    @DeleteMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<Void> deleteCategory(@PathVariable Long id) {
        categoryService.deleteCategory(id);
        return ResponseEntity.noContent().build();
    }
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/controller/CustomerController.java">
package com.magazincomputere.magazin_api.controller;

// import com.magazincomputere.magazin_api.dto.CustomerDto;
// import com.magazincomputere.magazin_api.service.CustomerService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/customers")
@PreAuthorize("hasRole('ADMIN')")
public class CustomerController {

    // @Autowired
    // private CustomerService customerService;

    // @GetMapping
    // public List<CustomerDto> getAllCustomers() {
    //     return customerService.findAllCustomers();
    // }

    // @GetMapping("/{id}")
    // public ResponseEntity<CustomerDto> getCustomerById(@PathVariable Long id) {
    //     return ResponseEntity.ok(customerService.findCustomerById(id));
    // }
    // TODO: Adaugă endpoint-uri pentru UPDATE, DELETE dacă este necesar
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/controller/ProductController.java">
package com.magazincomputere.magazin_api.controller;

import com.magazincomputere.magazin_api.dto.ProductDto;
import com.magazincomputere.magazin_api.service.ProductService;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize; // IMPORTĂ
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/products")
public class ProductController {

    @Autowired
    private ProductService productService;

    @GetMapping
    public List<ProductDto> getAllProducts() { // Acces public
        return productService.getAllProducts();
    }

    @GetMapping("/{id}")
    public ResponseEntity<ProductDto> getProductById(@PathVariable Long id) { // Acces public
        return ResponseEntity.ok(productService.getProductById(id));
    }

    @PostMapping
    @PreAuthorize("hasRole('ADMIN')") // Doar ADMIN poate crea produse
    public ResponseEntity<ProductDto> createProduct(@Valid @RequestBody ProductDto productDto) {
        ProductDto createdProduct = productService.createProduct(productDto);
        return new ResponseEntity<>(createdProduct, HttpStatus.CREATED);
    }

    @PutMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')") // Doar ADMIN poate actualiza produse
    public ResponseEntity<ProductDto> updateProduct(@PathVariable Long id, @Valid @RequestBody ProductDto productDto) {
        ProductDto updatedProduct = productService.updateProduct(id, productDto);
        return ResponseEntity.ok(updatedProduct);
    }

    @DeleteMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')") // Doar ADMIN poate șterge produse
    public ResponseEntity<Void> deleteProduct(@PathVariable Long id) {
        productService.deleteProduct(id);
        return ResponseEntity.noContent().build();
    }
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/controller/ReportController.java">
package com.magazincomputere.magazin_api.controller;

// import com.magazincomputere.magazin_api.dto.SalesReportDto; // DTO pentru răspunsul raportului
// import com.magazincomputere.magazin_api.service.ReportService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDate;

@RestController
@RequestMapping("/api/reports")
@PreAuthorize("hasRole('ADMIN')")
public class ReportController {

    // @Autowired
    // private ReportService reportService;

    // @GetMapping("/sales-by-category")
    // public ResponseEntity<SalesReportDto> getSalesByCategoryAndPeriod(
    //         @RequestParam Long categoryId,
    //         @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate startDate,
    //         @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate endDate) {
    //     SalesReportDto report = reportService.generateSalesByCategoryAndPeriod(categoryId, startDate, endDate);
    //     return ResponseEntity.ok(report);
    // }
    // TODO: Definește SalesReportDto și implementează logica în ReportService
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/controller/SpecificationController.java">
package com.magazincomputere.magazin_api.controller;

import com.magazincomputere.magazin_api.dto.SpecificationDefinitionDto; // Va trebui să creezi acest DTO
import com.magazincomputere.magazin_api.service.SpecificationService; // Va trebui să creezi acest serviciu
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/specifications/definitions") // Am specificat 'definitions' pentru claritate
public class SpecificationController {

    @Autowired
    private SpecificationService specificationService;

    @GetMapping
    public List<SpecificationDefinitionDto> getAllSpecificationDefinitions() { // Acces public
        return specificationService.getAllDefinitions();
    }

    @GetMapping("/{id}")
    public ResponseEntity<SpecificationDefinitionDto> getSpecificationDefinitionById(@PathVariable Long id) { // Acces public
        SpecificationDefinitionDto dto = specificationService.getDefinitionById(id);
        return ResponseEntity.ok(dto);
    }

    @PostMapping
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<SpecificationDefinitionDto> createSpecificationDefinition(@Valid @RequestBody SpecificationDefinitionDto definitionDto) {
        SpecificationDefinitionDto savedDto = specificationService.createDefinition(definitionDto);
        return ResponseEntity.status(HttpStatus.CREATED).body(savedDto);
    }

    @PutMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<SpecificationDefinitionDto> updateSpecificationDefinition(@PathVariable Long id, @Valid @RequestBody SpecificationDefinitionDto definitionDto) {
        SpecificationDefinitionDto updatedDto = specificationService.updateDefinition(id, definitionDto);
        return ResponseEntity.ok(updatedDto);
    }

    @DeleteMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<Void> deleteSpecificationDefinition(@PathVariable Long id) {
        specificationService.deleteDefinition(id);
        return ResponseEntity.noContent().build();
    }
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/controller/UserController.java">
package com.magazincomputere.magazin_api.controller;

import com.magazincomputere.magazin_api.dto.UserDto; // Va trebui să creezi acest DTO
import com.magazincomputere.magazin_api.service.UserService; // Va trebui să creezi acest serviciu
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/users")
@PreAuthorize("hasRole('ADMIN')") // Majoritatea operațiunilor sunt pentru ADMIN
public class UserController {

    @Autowired
    private UserService userService;

    @GetMapping
    public List<UserDto> getAllUsers() {
        return userService.findAllUsers();
    }

    @GetMapping("/{id}")
    public ResponseEntity<UserDto> getUserById(@PathVariable Long id) {
        UserDto userDto = userService.findUserById(id);
        return ResponseEntity.ok(userDto);
    }

    // Adminul poate crea utilizatori (sau poate fi doar prin /api/auth/signup)
    // @PostMapping
    // public ResponseEntity<UserDto> createUser(@Valid @RequestBody UserDto userDto) {
    //     UserDto createdUser = userService.createUser(userDto); // Acest serviciu ar trebui să paroleze și să seteze roluri
    //     return new ResponseEntity<>(createdUser, HttpStatus.CREATED);
    // }

    @PutMapping("/{id}")
    public ResponseEntity<UserDto> updateUser(@PathVariable Long id, @Valid @RequestBody UserDto userDto) {
        // Atenție la actualizarea parolei și a rolurilor
        UserDto updatedUser = userService.updateUser(id, userDto);
        return ResponseEntity.ok(updatedUser);
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteUser(@PathVariable Long id) {
        userService.deleteUser(id);
        return ResponseEntity.noContent().build();
    }
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/dto/CategoryDto.java">
package com.magazincomputere.magazin_api.dto;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class CategoryDto {
    private Long id;

    @NotBlank(message = "Numele categoriei este obligatoriu.")
    @Size(min = 2, max = 100, message = "Numele categoriei trebuie să aibă între 2 și 100 de caractere.")
    private String name;

    @Size(max = 1000, message = "Descrierea categoriei nu poate depăși 1000 de caractere.")
    private String description;
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/dto/CustomerDto.java">
package com.magazincomputere.magazin_api.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.Size;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class CustomerDto { // Acest DTO reflectă mai mult entitatea Customer
    private Long id;
    private Long userId; // Poate fi null dacă un client nu are cont de utilizator

    @Size(max = 100, message = "Prenumele nu poate depăși 100 de caractere.")
    private String firstName;

    @Size(max = 100, message = "Numele de familie nu poate depăși 100 de caractere.")
    private String lastName;

    @Email(message = "Formatul emailului este invalid.")
    @Size(max = 100, message = "Emailul nu poate depăși 100 de caractere.")
    private String email; // Poate fi diferit de emailul User-ului dacă e cazul

    @Size(max = 20, message = "Numărul de telefon nu poate depăși 20 de caractere.")
    private String phone;

    @Size(max = 500, message = "Adresa nu poate depăși 500 de caractere.")
    private String address;
    // Alte câmpuri relevante pentru admin
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/dto/JwtResponse.java">
package com.magazincomputere.magazin_api.dto;

import lombok.Getter;
import lombok.Setter;

import java.util.List;

@Getter
@Setter
public class JwtResponse {
    private String token;
    private String type = "Bearer";
    private Long id;
    private String username;
    private String email;
    private List<String> roles; // Lista de roluri (ex: ["ROLE_USER", "ROLE_ADMIN"])

    public JwtResponse(String accessToken, Long id, String username, String email, List<String> roles) {
        this.token = accessToken;
        this.id = id;
        this.username = username;
        this.email = email;
        this.roles = roles;
    }
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/dto/LoginRequest.java">
package com.magazincomputere.magazin_api.dto;

import jakarta.validation.constraints.NotBlank;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class LoginRequest {
    @NotBlank(message = "Numele de utilizator este obligatoriu.")
    private String username;

    @NotBlank(message = "Parola este obligatorie.")
    private String password;
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/dto/MessageResponse.java">
package com.magazincomputere.magazin_api.dto;

import lombok.Data;
import lombok.AllArgsConstructor;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class MessageResponse {
    private String message;
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/dto/OrderDto.java">
package com.magazincomputere.magazin_api.dto;

import jakarta.validation.Valid;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotEmpty;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class OrderDto {
    // Câmpuri pentru răspuns
    private Long id;
    private Long userId;
    private String username; // Numele utilizatorului care a plasat comanda
    private LocalDateTime orderDate;
    private String status;
    private BigDecimal totalAmount;

    // Câmpuri pentru request și răspuns
    @NotEmpty(message = "Comanda trebuie să conțină cel puțin un produs.")
    @Valid // Asigură validarea fiecărui OrderItemDto din listă
    private List<OrderItemDto> orderItems;

    // Informații de livrare/client (pot fi preluate parțial din profilul utilizatorului)
    @NotBlank(message = "Numele clientului este obligatoriu pentru livrare.")
    @Size(max = 100, message = "Numele clientului este prea lung.")
    private String customerName;

    @NotBlank(message = "Adresa de livrare este obligatorie.")
    @Size(max = 255, message = "Adresa de livrare este prea lungă.")
    private String shippingAddress;

    @NotBlank(message = "Emailul clientului este obligatoriu.")
    @Email(message = "Formatul emailului este invalid.")
    @Size(max = 100)
    private String customerEmail;

    @NotBlank(message = "Numărul de telefon este obligatoriu.")
    @Size(min=10, max = 20, message = "Numărul de telefon are format invalid.")
    private String customerPhone;
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/dto/OrderStatusUpdateDto.java">
package com.magazincomputere.magazin_api.dto;

import jakarta.validation.constraints.NotBlank;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class OrderStatusUpdateDto {
    @NotBlank(message = "Noua stare a comenzii este obligatorie.")
    private String newStatus;
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/dto/SignupRequest.java">
package com.magazincomputere.magazin_api.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

import java.util.Set;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class SignupRequest {
    @NotBlank(message = "Numele de utilizator este obligatoriu.")
    @Size(min = 3, max = 20, message = "Numele de utilizator trebuie să aibă între 3 și 20 de caractere.")
    private String username;

    @NotBlank(message = "Emailul este obligatoriu.")
    @Size(max = 50, message = "Emailul nu poate depăși 50 de caractere.")
    @Email(message = "Formatul emailului este invalid.")
    private String email;

    @NotBlank(message = "Parola este obligatorie.")
    @Size(min = 6, max = 40, message = "Parola trebuie să aibă între 6 și 40 de caractere.")
    private String password;

    // Frontend-ul poate trimite rolurile dorite (ex: la crearea unui admin de către alt admin)
    // Sau acest câmp poate fi ignorat la signup-ul standard al unui client, backend-ul setând rolul USER.
    private Set<String> roles;
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/dto/SpecificationDefinitionDto.java">
package com.magazincomputere.magazin_api.dto;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class SpecificationDefinitionDto {
    private Long id;

    @NotBlank(message = "Numele definiției specificației este obligatoriu.")
    @Size(max = 100)
    private String name;

    @Size(max = 50)
    private String unit; // opțional
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/dto/SpecificationDto.java">
package com.magazincomputere.magazin_api.dto;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class SpecificationDto {
    // Când se trimit datele pentru un produs, definitionId sau name+unit ar trebui să fie prezente.
    // La citire, toate ar putea fi populate.
    private Long definitionId; // ID-ul din SpecificationDefinition (pentru a lega de o definiție existentă)

    @Size(max = 100, message = "Numele specificației nu poate depăși 100 de caractere.")
    // Numele este necesar dacă definitionId nu este furnizat la creare/update specificație pentru produs
    private String name;       // Numele specificației (ex: "RAM")

    @NotBlank(message = "Valoarea specificației este obligatorie.")
    @Size(max = 255, message = "Valoarea specificației nu poate depăși 255 de caractere.")
    private String value;      // Valoarea (ex: "16GB")

    @Size(max = 50, message = "Unitatea de măsură nu poate depăși 50 de caractere.")
    private String unit;       // Opțional (ex: "GB", "MHz")
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/dto/UserDto.java">
package com.magazincomputere.magazin_api.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

import java.util.Set;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class UserDto {
    private Long id;

    // La creare/update, username-ul nu ar trebui să se schimbe ușor după creare.
    // Validările sunt mai importante pentru SignupRequestDto.
    @NotBlank(message = "Numele de utilizator este obligatoriu.")
    @Size(min = 3, max = 20)
    private String username;

    @NotBlank(message = "Emailul este obligatoriu.")
    @Size(max = 50)
    @Email(message = "Formatul emailului este invalid.")
    private String email;

    // Parola nu este expusă în DTO-urile de răspuns.
    // Pentru schimbarea parolei, se va folosi un DTO dedicat.

    private Set<String> roles; // Numele rolurilor, ex: "ROLE_ADMIN", "ROLE_USER"
                               // La update de către admin, acest câmp poate fi modificat.
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/exception/BadRequestException.java">
package com.magazincomputere.magazin_api.exception;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

@ResponseStatus(HttpStatus.BAD_REQUEST) // Returnează automat 400 Bad Request
public class BadRequestException extends RuntimeException {

    public BadRequestException(String message) {
        super(message);
    }

    public BadRequestException(String message, Throwable cause) {
        super(message, cause);
    }
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/exception/GlobalExceptionHandler.java">
package com.magazincomputere.magazin_api.exception;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.AccessDeniedException; // Pentru erori de autorizare
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.context.request.WebRequest;

import java.time.LocalDateTime; // Folosim LocalDateTime
import java.util.HashMap;
import java.util.Map;
import java.util.stream.Collectors;

@ControllerAdvice // Permite gestionarea centralizată a excepțiilor pentru toate controllerele
public class GlobalExceptionHandler {

    private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class);

    // Handler pentru excepția noastră custom ResourceNotFoundException
    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<ErrorDetails> handleResourceNotFoundException(ResourceNotFoundException ex, WebRequest request) {
        logger.warn("Resource not found: {}", ex.getMessage());
        ErrorDetails errorDetails = new ErrorDetails(
                LocalDateTime.now(),
                HttpStatus.NOT_FOUND.value(),
                "Not Found",
                ex.getMessage(),
                request.getDescription(false) // Calea cererii
        );
        return new ResponseEntity<>(errorDetails, HttpStatus.NOT_FOUND);
    }

    // Handler pentru excepția noastră custom BadRequestException
    @ExceptionHandler(BadRequestException.class)
    public ResponseEntity<ErrorDetails> handleBadRequestException(BadRequestException ex, WebRequest request) {
        logger.warn("Bad request: {}", ex.getMessage());
        ErrorDetails errorDetails = new ErrorDetails(
                LocalDateTime.now(),
                HttpStatus.BAD_REQUEST.value(),
                "Bad Request",
                ex.getMessage(),
                request.getDescription(false)
        );
        return new ResponseEntity<>(errorDetails, HttpStatus.BAD_REQUEST);
    }

    // Handler pentru excepțiile de validare (când @Valid pe un @RequestBody eșuează)
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorDetailsWithFields> handleValidationExceptions(MethodArgumentNotValidException ex, WebRequest request) {
        logger.warn("Validation error: {}", ex.getMessage());
        Map<String, String> fieldErrors = ex.getBindingResult().getFieldErrors().stream()
                .collect(Collectors.toMap(FieldError::getField,
                                          FieldError::getDefaultMessage,
                                          (existingValue, newValue) -> existingValue + "; " + newValue)); // În caz de mai multe erori pe același câmp

        ErrorDetailsWithFields errorDetails = new ErrorDetailsWithFields(
                LocalDateTime.now(),
                HttpStatus.BAD_REQUEST.value(),
                "Validation Failed",
                "Input data validation failed",
                request.getDescription(false),
                fieldErrors
        );
        return new ResponseEntity<>(errorDetails, HttpStatus.BAD_REQUEST);
    }

    // Handler pentru AccessDeniedException (când @PreAuthorize eșuează)
    @ExceptionHandler(AccessDeniedException.class)
    public ResponseEntity<ErrorDetails> handleAccessDeniedException(AccessDeniedException ex, WebRequest request) {
        logger.warn("Access denied: {}", ex.getMessage());
        ErrorDetails errorDetails = new ErrorDetails(
                LocalDateTime.now(),
                HttpStatus.FORBIDDEN.value(),
                "Forbidden",
                "Nu aveți permisiunea de a accesa această resursă.", // Mesaj mai prietenos
                request.getDescription(false)
        );
        return new ResponseEntity<>(errorDetails, HttpStatus.FORBIDDEN);
    }

    // Handler pentru IllegalArgumentException (poate fi util pentru validări de business în servicii)
    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<ErrorDetails> handleIllegalArgumentException(IllegalArgumentException ex, WebRequest request) {
        logger.warn("Illegal argument: {}", ex.getMessage());
        ErrorDetails errorDetails = new ErrorDetails(
                LocalDateTime.now(),
                HttpStatus.BAD_REQUEST.value(),
                "Bad Request",
                ex.getMessage(),
                request.getDescription(false)
        );
        return new ResponseEntity<>(errorDetails, HttpStatus.BAD_REQUEST);
    }


    // Handler generic pentru orice altă excepție neprinsă specific
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorDetails> handleGlobalException(Exception ex, WebRequest request) {
        logger.error("An unexpected error occurred: ", ex); // Loghează stack trace-ul complet pentru erori neașteptate
        ErrorDetails errorDetails = new ErrorDetails(
                LocalDateTime.now(),
                HttpStatus.INTERNAL_SERVER_ERROR.value(),
                "Internal Server Error",
                "A apărut o eroare neașteptată pe server.", // Mesaj generic pentru client
                request.getDescription(false)
        );
        return new ResponseEntity<>(errorDetails, HttpStatus.INTERNAL_SERVER_ERROR);
    }


    // Clasa internă pentru detalii eroare standard
    public static class ErrorDetails {
        private LocalDateTime timestamp;
        private int status;
        private String error;
        private String message;
        private String path;

        public ErrorDetails(LocalDateTime timestamp, int status, String error, String message, String path) {
            this.timestamp = timestamp;
            this.status = status;
            this.error = error;
            this.message = message;
            this.path = path;
        }

        // Getteri
        public LocalDateTime getTimestamp() { return timestamp; }
        public int getStatus() { return status; }
        public String getError() { return error; }
        public String getMessage() { return message; }
        public String getPath() { return path; }
    }

    // Clasa internă pentru detalii eroare cu câmpuri specifice (pentru validare)
    public static class ErrorDetailsWithFields extends ErrorDetails {
        private Map<String, String> fieldErrors;

        public ErrorDetailsWithFields(LocalDateTime timestamp, int status, String error, String message, String path, Map<String, String> fieldErrors) {
            super(timestamp, status, error, message, path);
            this.fieldErrors = fieldErrors;
        }

        // Getter
        public Map<String, String> getFieldErrors() { return fieldErrors; }
    }
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/exception/ResourceNotFoundException.java">
package com.magazincomputere.magazin_api.exception;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

@ResponseStatus(HttpStatus.NOT_FOUND) // Returnează automat 404 Not Found
public class ResourceNotFoundException extends RuntimeException {

    public ResourceNotFoundException(String message) {
        super(message);
    }

    public ResourceNotFoundException(String resourceName, String fieldName, Object fieldValue) {
        super(String.format("%s not found with %s : '%s'", resourceName, fieldName, fieldValue));
    }
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/MagazinApiApplication.java">
package com.magazincomputere.magazin_api;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class MagazinApiApplication {

	public static void main(String[] args) {
		SpringApplication.run(MagazinApiApplication.class, args);
	}

}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/model/Category.java">
package com.magazincomputere.magazin_api.model;

import jakarta.persistence.*;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode; // Pentru a gestiona corect relațiile bidirecționale
import lombok.ToString; // Pentru a gestiona corect relațiile bidirecționale

import java.util.List;

@Entity
@Table(name = "categories")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Category {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true, length = 100)
    private String name;

    @Column(length = 1000)
    private String description;

    // Relația One-to-Many cu Product (o categorie poate avea mai multe produse)
    // Comentat pentru a evita problemele de serializare ciclică dacă nu este gestionat atent în DTO-uri
    // Poți decomenta dacă ai nevoie să navighezi de la Category la Products și gestionezi DTO-urile corespunzător.
    // @OneToMany(mappedBy = "category", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    // @ToString.Exclude // Pentru a evita bucle infinite la toString
    // @EqualsAndHashCode.Exclude // Pentru a evita bucle infinite la equals/hashCode
    // private List<Product> products;
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/model/Customer.java">
package com.magazincomputere.magazin_api.model;

import jakarta.persistence.*;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.ToString;

import java.util.List;

@Entity
@Table(name = "customers")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Customer {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(length = 100)
    private String firstName;

    @Column(length = 100)
    private String lastName;

    // Emailul clientului poate fi diferit de cel al contului de utilizator,
    // sau poate fi același. Depinde de logica de business.
    @Column(unique = true, length = 100) // Poate fi null dacă un client nu are cont și face comandă ca guest
    private String email;

    @Column(length = 20)
    private String phone;

    @Lob // Pentru adrese multiple sau mai lungi
    @Column(columnDefinition = "TEXT")
    private String addressDetails; // Poate stoca adresa principală sau un JSON cu mai multe adrese

    // Relație opțională OneToOne cu User (un client poate avea un cont de utilizator)
    @OneToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", referencedColumnName = "id", unique = true) // Poate fi null
    @ToString.Exclude
    @EqualsAndHashCode.Exclude
    private User user;

    // Un client poate avea mai multe comenzi
    @OneToMany(mappedBy = "customer", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    @ToString.Exclude
    @EqualsAndHashCode.Exclude
    private List<Order> orders;
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/model/ERole.java">
package com.magazincomputere.magazin_api.model;

public enum ERole {
    ROLE_USER,  // Pentru clienți standard
    ROLE_ADMIN  // Pentru administratori
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/model/Order.java">
package com.magazincomputere.magazin_api.model;

import jakarta.persistence.*;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.ToString;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "orders") // "order" este adesea un cuvânt cheie SQL, deci "orders" e mai sigur
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Order {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    // Referință către User (dacă utilizatorul este logat) sau Customer (dacă informațiile sunt separate)
    // Alege una dintre următoarele două sau gestionează ambele dacă permiți comenzi guest
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id") // Poate fi null dacă se permite comandă fără cont și se folosește Customer
    @ToString.Exclude
    @EqualsAndHashCode.Exclude
    private User user;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "customer_id", nullable = false) // O comandă trebuie să aibă un client asociat
    @ToString.Exclude
    @EqualsAndHashCode.Exclude
    private Customer customer;

    @Column(nullable = false)
    private LocalDateTime orderDate;

    @Column(nullable = false, length = 50)
    private String status; // Ex: PENDING_PAYMENT, PROCESSING, SHIPPED, DELIVERED, CANCELED, APPROVED

    @Column(nullable = false, precision = 12, scale = 2)
    private BigDecimal totalAmount;

    // Informații denormalizate pentru livrare, chiar dacă există în Customer/User,
    // pentru a păstra adresa exactă la momentul comenzii.
    @Column(nullable = false, length = 255)
    private String shippingAddress;

    @Column(nullable = false, length = 100)
    private String shippingCustomerName;

    @Column(nullable = false, length = 100)
    private String shippingCustomerEmail;

    @Column(nullable = false, length = 20)
    private String shippingCustomerPhone;

    @OneToMany(mappedBy = "order", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    @ToString.Exclude
    @EqualsAndHashCode.Exclude
    private List<OrderItem> orderItems = new ArrayList<>();

    @PrePersist
    protected void onCreate() {
        orderDate = LocalDateTime.now();
        // Poți seta un status inițial aici, de ex. "PENDING_PAYMENT"
        if (status == null) {
            status = "PENDING_CONFIRMATION";
        }
    }
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/model/ProductSpecificationValue.java">
package com.magazincomputere.magazin_api.model;

import jakarta.persistence.*;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.ToString;

@Entity
@Table(name = "product_specification_values", uniqueConstraints = {
    @UniqueConstraint(columnNames = {"product_id", "specification_definition_id"})
})
@Data
@NoArgsConstructor
@AllArgsConstructor
public class ProductSpecificationValue {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "product_id", nullable = false)
    @ToString.Exclude
    @EqualsAndHashCode.Exclude
    private Product product;

    @ManyToOne(fetch = FetchType.EAGER)
    @JoinColumn(name = "specification_definition_id", nullable = false)
    private SpecificationDefinition specificationDefinition;

    @Column(name = "specification_value", nullable = false, length = 255) // AM SCHIMBAT NUMELE COLOANEI AICI
    private String value;
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/model/SpecificationDefinition.java">
package com.magazincomputere.magazin_api.model;

import jakarta.persistence.*;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

@Entity
@Table(name = "specification_definitions")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class SpecificationDefinition {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true, length = 100)
    private String name; // Ex: "Procesor", "RAM", "Culoare"

    @Column(length = 50)
    private String unit; // Ex: "GB", "MHz", "inch" (opțional)
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/model/User.java">
package com.magazincomputere.magazin_api.model;

import jakarta.persistence.*;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.ToString;

import java.util.HashSet;
import java.util.Set;
import java.util.List; // Pentru comenzi

@Entity
@Table(name = "users", uniqueConstraints = {
        @UniqueConstraint(columnNames = "username"),
        @UniqueConstraint(columnNames = "email")
})
@Data
@NoArgsConstructor
@AllArgsConstructor
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true, length = 50)
    private String username;

    @Column(nullable = false, unique = true, length = 100)
    private String email;

    @Column(nullable = false, length = 100) // Lungime pentru parola encodată
    private String password;

    @ManyToMany(fetch = FetchType.EAGER) // EAGER pentru a încărca rolurile odată cu utilizatorul
    @JoinTable(name = "user_roles",
            joinColumns = @JoinColumn(name = "user_id"),
            inverseJoinColumns = @JoinColumn(name = "role_id"))
    private Set<Role> roles = new HashSet<>();

    // Relația cu comenzile (un utilizator poate avea mai multe comenzi)
    // @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    // @ToString.Exclude
    // @EqualsAndHashCode.Exclude
    // private List<Order> orders;

    // Relația cu Customer (dacă un User este și Customer)
    // @OneToOne(mappedBy = "user", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    // @ToString.Exclude
    // @EqualsAndHashCode.Exclude
    // private Customer customer;

    public User(String username, String email, String password) {
        this.username = username;
        this.email = email;
        this.password = password;
    }
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/repository/CategoryRepository.java">
package com.magazincomputere.magazin_api.repository;

import com.magazincomputere.magazin_api.model.Category;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface CategoryRepository extends JpaRepository<Category, Long> {
    // Găsește o categorie după nume (util pentru a evita duplicate)
    Optional<Category> findByNameIgnoreCase(String name);
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/repository/CustomerRepository.java">
package com.magazincomputere.magazin_api.repository;

import com.magazincomputere.magazin_api.model.Customer;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface CustomerRepository extends JpaRepository<Customer, Long> {
    // Găsește un client după email (dacă emailul este unic și folosit pentru identificare)
    Optional<Customer> findByEmail(String email);

    // Găsește un client după ID-ul utilizatorului asociat
    Optional<Customer> findByUserId(Long userId);
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/repository/OrderItemRepository.java">
// src/main/java/com/magazincomputere/magazin_api/repository/OrderItemRepository.java
package com.magazincomputere.magazin_api.repository;

import com.magazincomputere.magazin_api.model.OrderItem;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

// import java.util.List; // Decomentează dacă adaugi metode custom

@Repository
public interface OrderItemRepository extends JpaRepository<OrderItem, Long> {

    // Spring Data JPA va furniza automat implementările pentru metodele CRUD de bază
    // (save, findById, findAll, delete, etc.) pentru entitatea OrderItem.

    // Poți adăuga metode custom de interogare aici dacă este necesar în viitor.
    // De exemplu, dacă ai vrea să găsești toate articolele unei anumite comenzi
    // direct prin acest repository (deși acest lucru este de obicei gestionat
    // prin colecția `orderItems` din entitatea `Order`):
    // List<OrderItem> findByOrderId(Long orderId);

    // Sau pentru a găsi articolele care conțin un anumit produs (snapshot ID):
    // List<OrderItem> findByProductIdSnapshot(Long productIdSnapshot);
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/repository/ProductRepository.java">
package com.magazincomputere.magazin_api.repository;

import com.magazincomputere.magazin_api.model.Product;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor; // Pentru căutare/filtrare complexă
import org.springframework.stereotype.Repository;

import java.math.BigDecimal;
import java.util.List;

@Repository
public interface ProductRepository extends JpaRepository<Product, Long>, JpaSpecificationExecutor<Product> {

    // Găsește produse după ID-ul categoriei
    List<Product> findByCategoryId(Long categoryId);

    // Găsește produse al căror nume conține un anumit string (case-insensitive)
    List<Product> findByNameContainingIgnoreCase(String name);

    // Găsește produse într-un interval de preț
    List<Product> findByPriceBetween(BigDecimal minPrice, BigDecimal maxPrice);

    // Găsește produse după ID categorie și într-un interval de preț
    List<Product> findByCategoryIdAndPriceBetween(Long categoryId, BigDecimal minPrice, BigDecimal maxPrice);

    // Poți adăuga aici și alte metode de interogare bazate pe convențiile de numire Spring Data JPA
    // sau folosind @Query pentru interogări JPQL sau SQL native mai complexe.
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/repository/ProductSpecificationValueRepository.java">
package com.magazincomputere.magazin_api.repository;

import com.magazincomputere.magazin_api.model.ProductSpecificationValue;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface ProductSpecificationValueRepository extends JpaRepository<ProductSpecificationValue, Long> {
    // Găsește toate valorile specificațiilor pentru un anumit produs
    List<ProductSpecificationValue> findByProductId(Long productId);

    // Găsește toate valorile pentru o anumită definiție de specificație
    List<ProductSpecificationValue> findBySpecificationDefinitionId(Long definitionId);

    // Șterge toate valorile specificațiilor pentru un produs (util la actualizarea produsului)
    void deleteByProductId(Long productId);
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/repository/RoleRepository.java">
package com.magazincomputere.magazin_api.repository;

import com.magazincomputere.magazin_api.model.ERole;
import com.magazincomputere.magazin_api.model.Role;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface RoleRepository extends JpaRepository<Role, Integer> {
    // Găsește un rol după numele său (enum)
    Optional<Role> findByName(ERole name);
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/repository/SpecificationDefinitionRepository.java">
package com.magazincomputere.magazin_api.repository;

import com.magazincomputere.magazin_api.model.SpecificationDefinition;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface SpecificationDefinitionRepository extends JpaRepository<SpecificationDefinition, Long> {
    // Găsește o definiție de specificație după nume (util pentru a evita duplicate)
    Optional<SpecificationDefinition> findByNameIgnoreCase(String name);
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/repository/UserRepository.java">
package com.magazincomputere.magazin_api.repository;

import com.magazincomputere.magazin_api.model.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    // Găsește un utilizator după username (pentru login și verificare existență)
    Optional<User> findByUsername(String username);

    // Verifică dacă un utilizator există după username
    Boolean existsByUsername(String username);

    // Verifică dacă un utilizator există după email
    Boolean existsByEmail(String email);
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/security/jwt/AuthEntryPointJwt.java">
package com.magazincomputere.magazin_api.security.jwt;

import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.stereotype.Component;

import java.io.IOException;
import com.fasterxml.jackson.databind.ObjectMapper; // Pentru a scrie un răspuns JSON
import java.util.HashMap; // Pentru a crea un corp de răspuns JSON
import java.util.Map; // Pentru a crea un corp de răspuns JSON


@Component
public class AuthEntryPointJwt implements AuthenticationEntryPoint {
    private static final Logger logger = LoggerFactory.getLogger(AuthEntryPointJwt.class);

    @Override
    public void commence(HttpServletRequest request, HttpServletResponse response,
                         AuthenticationException authException) throws IOException, ServletException {
        logger.error("Unauthorized error: {}", authException.getMessage());
        // Trimite un răspuns JSON mai prietenos în loc de eroarea default
        response.setContentType("application/json");
        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);

        final Map<String, Object> body = new HashMap<>();
        body.put("status", HttpServletResponse.SC_UNAUTHORIZED);
        body.put("error", "Unauthorized");
        body.put("message", authException.getMessage());
        body.put("path", request.getServletPath());

        final ObjectMapper mapper = new ObjectMapper();
        mapper.writeValue(response.getOutputStream(), body);
    }
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/security/jwt/JwtAuthTokenFilter.java">
package com.magazincomputere.magazin_api.security.jwt;

import com.magazincomputere.magazin_api.security.services.UserDetailsServiceImpl;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component; // Adaugă @Component pentru a fi un bean gestionat de Spring
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;

@Component // Important pentru ca Spring să poată injecta această clasă în SecurityConfig
public class JwtAuthTokenFilter extends OncePerRequestFilter {
    @Autowired
    private JwtUtils jwtUtils;

    @Autowired
    private UserDetailsServiceImpl userDetailsService;

    private static final Logger logger = LoggerFactory.getLogger(JwtAuthTokenFilter.class);

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException {
        try {
            String jwt = jwtUtils.parseJwt(request);
            if (jwt != null && jwtUtils.validateJwtToken(jwt)) {
                String username = jwtUtils.getUserNameFromJwtToken(jwt);

                UserDetails userDetails = userDetailsService.loadUserByUsername(username);
                UsernamePasswordAuthenticationToken authentication =
                        new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());
                authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));

                SecurityContextHolder.getContext().setAuthentication(authentication);
            }
        } catch (Exception e) {
            logger.error("Cannot set user authentication: {}", e.getMessage());
        }

        filterChain.doFilter(request, response);
    }
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/security/jwt/JwtUtils.java">
package com.magazincomputere.magazin_api.security.jwt; // Asigură-te că pachetul e corect

import com.magazincomputere.magazin_api.security.services.UserDetailsImpl;
import io.jsonwebtoken.*; // Importurile principale JJWT
// Nu mai importăm io.jsonwebtoken.security.Keys pentru această versiune veche
import jakarta.servlet.http.HttpServletRequest;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.Authentication;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;

import javax.crypto.spec.SecretKeySpec; // Necesar pentru crearea cheii în versiuni mai vechi
import java.security.Key; // Interfața Key
import java.util.Base64; // Pentru decodarea cheii dacă e stocată ca Base64
import java.util.Date;

@Component
public class JwtUtils {
    private static final Logger logger = LoggerFactory.getLogger(JwtUtils.class);

    @Value("${app.jwtSecret}")
    private String jwtSecretString; // Asigură-te că e un string simplu sau gestionează decodarea Base64 aici

    @Value("${app.jwtExpirationMs}")
    private int jwtExpirationMs;

    // Metodă adaptată pentru crearea cheii cu JJWT 0.11.x
    private Key getSigningKey() {
        // Dacă jwtSecretString este encodat Base64, va trebui să-l decodezi:
        // byte[] keyBytes = Base64.getDecoder().decode(this.jwtSecretString);
        // Altfel, dacă e un string simplu:
        byte[] keyBytes = jwtSecretString.getBytes();
        // Folosește SignatureAlgorithm.HS512.getJcaName() pentru a obține numele algoritmului
        return new SecretKeySpec(keyBytes, SignatureAlgorithm.HS512.getJcaName());
    }

    public String generateJwtToken(Authentication authentication) {
        UserDetailsImpl userPrincipal = (UserDetailsImpl) authentication.getPrincipal();
        return buildToken(userPrincipal.getUsername());
    }

    public String generateTokenFromUsername(String username) {
        return buildToken(username);
    }

    private String buildToken(String subject) {
         return Jwts.builder()
                 .setSubject(subject)
                 .setIssuedAt(new Date())
                 .setExpiration(new Date((new Date()).getTime() + jwtExpirationMs))
                 .signWith(SignatureAlgorithm.HS512, getSigningKey()) // Sintaxa pentru 0.11.x
                 .compact();
    }

    public String getUserNameFromJwtToken(String token) {
        // Sintaxa pentru 0.11.x - FĂRĂ parserBuilder()
        return Jwts.parser()
                   .setSigningKey(getSigningKey())
                   .parseClaimsJws(token)
                   .getBody()
                   .getSubject();
    }

    public boolean validateJwtToken(String authToken) {
        try {
            // Sintaxa pentru 0.11.x - FĂRĂ parserBuilder()
            Jwts.parser().setSigningKey(getSigningKey()).parseClaimsJws(authToken);
            return true;
        } catch (io.jsonwebtoken.SignatureException e) { // Folosește io.jsonwebtoken.SignatureException
            logger.error("Invalid JWT signature: {}", e.getMessage());
        } catch (MalformedJwtException e) {
            logger.error("Invalid JWT token: {}", e.getMessage());
        } catch (ExpiredJwtException e) {
            logger.error("JWT token is expired: {}", e.getMessage());
        } catch (UnsupportedJwtException e) {
            logger.error("JWT token is unsupported: {}", e.getMessage());
        } catch (IllegalArgumentException e) {
            logger.error("JWT claims string is empty: {}", e.getMessage());
        }
        return false;
    }

    public String parseJwt(HttpServletRequest request) {
        String headerAuth = request.getHeader("Authorization");
        if (StringUtils.hasText(headerAuth) && headerAuth.startsWith("Bearer ")) {
            return headerAuth.substring(7);
        }
        return null;
    }
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/security/services/UserDetailsImpl.java">
package com.magazincomputere.magazin_api.security.services;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.magazincomputere.magazin_api.model.User;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import java.util.Collection;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

public class UserDetailsImpl implements UserDetails {
    private static final long serialVersionUID = 1L;

    private Long id;
    private String username;
    private String email;
    @JsonIgnore
    private String password;

    private Collection<? extends GrantedAuthority> authorities;

    public UserDetailsImpl(Long id, String username, String email, String password,
                           Collection<? extends GrantedAuthority> authorities) {
        this.id = id;
        this.username = username;
        this.email = email;
        this.password = password;
        this.authorities = authorities;
    }

    public static UserDetailsImpl build(User user) {
        List<GrantedAuthority> authorities = user.getRoles().stream()
                .map(role -> new SimpleGrantedAuthority(role.getName().name()))
                .collect(Collectors.toList());

        return new UserDetailsImpl(
                user.getId(),
                user.getUsername(),
                user.getEmail(),
                user.getPassword(),
                authorities);
    }

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return authorities;
    }

    public Long getId() {
        return id;
    }

    public String getEmail() {
        return email;
    }

    @Override
    public String getPassword() {
        return password;
    }

    @Override
    public String getUsername() {
        return username;
    }

    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

    @Override
    public boolean isAccountNonLocked() {
        return true;
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

    @Override
    public boolean isEnabled() {
        return true;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        UserDetailsImpl user = (UserDetailsImpl) o;
        return Objects.equals(id, user.id);
    }
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/security/services/UserDetailsServiceImpl.java">
package com.magazincomputere.magazin_api.security.services;

import com.magazincomputere.magazin_api.model.User;
import com.magazincomputere.magazin_api.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class UserDetailsServiceImpl implements UserDetailsService {
    @Autowired
    UserRepository userRepository;

    @Override
    @Transactional
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        User user = userRepository.findByUsername(username)
                .orElseThrow(() -> new UsernameNotFoundException("User Not Found with username: " + username));

        return UserDetailsImpl.build(user);
    }
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/service/CategoryService.java">
package com.magazincomputere.magazin_api.service;

import com.magazincomputere.magazin_api.dto.CategoryDto;
import com.magazincomputere.magazin_api.exception.ResourceNotFoundException;
import com.magazincomputere.magazin_api.model.Category;
import com.magazincomputere.magazin_api.repository.CategoryRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.stream.Collectors;

@Service
public class CategoryService {

    @Autowired
    private CategoryRepository categoryRepository;

    // --- Metode de conversie DTO <-> Entity ---
    private CategoryDto convertToDto(Category category) {
        CategoryDto dto = new CategoryDto();
        dto.setId(category.getId());
        dto.setName(category.getName());
        dto.setDescription(category.getDescription());
        return dto;
    }

    // Această metodă modifică direct obiectul 'category' pasat
    private void updateEntityFromDto(CategoryDto categoryDto, Category category) {
        category.setName(categoryDto.getName());
        category.setDescription(categoryDto.getDescription());
    }
    // --- Sfârșit metode de conversie ---

    @Transactional(readOnly = true)
    public List<CategoryDto> getAllCategories() {
        return categoryRepository.findAll().stream()
                .map(this::convertToDto)
                .collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public CategoryDto getCategoryById(Long id) {
        Category category = categoryRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Category", "id", id));
        return convertToDto(category);
    }

    @Transactional
    public CategoryDto createCategory(CategoryDto categoryDto) {
        categoryRepository.findByNameIgnoreCase(categoryDto.getName()).ifPresent(existingCategory -> {
            throw new IllegalArgumentException("Category with name '" + existingCategory.getName() + "' already exists.");
        });
        Category category = new Category();
        updateEntityFromDto(categoryDto, category); // Folosim metoda care nu returnează pentru claritate
        Category savedCategory = categoryRepository.save(category);
        return convertToDto(savedCategory);
    }

    @Transactional
    public CategoryDto updateCategory(Long id, CategoryDto categoryDto) {
        // Pasul 1: Găsește entitatea existentă
        Category existingCategory = categoryRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Category", "id", id));

        // Pasul 2: Verifică dacă noul nume este deja folosit de altă categorie
        // Folosim o variabilă finală sau effectively final pentru ID-ul categoriei existente în lambda
        final Long existingCategoryId = existingCategory.getId();
        categoryRepository.findByNameIgnoreCase(categoryDto.getName()).ifPresent(catWithSameName -> {
            if (!catWithSameName.getId().equals(existingCategoryId)) {
                throw new IllegalArgumentException("Another category with name '" + catWithSameName.getName() + "' already exists.");
            }
        });

        // Pasul 3: Actualizează câmpurile entității existente cu datele din DTO
        // Nu re-atribuim existingCategory, ci îi modificăm starea.
        updateEntityFromDto(categoryDto, existingCategory);

        // Pasul 4: Salvează entitatea actualizată
        Category updatedCategory = categoryRepository.save(existingCategory);

        // Pasul 5: Converteste entitatea actualizată în DTO și returneaz-o
        return convertToDto(updatedCategory);
    }

    @Transactional
    public void deleteCategory(Long id) {
        Category category = categoryRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Category", "id", id));
        
        // TODO: Adaugă logica de verificare dacă există produse în această categorie înainte de ștergere
        // De exemplu: if (!productRepository.findByCategoryId(id).isEmpty()) { throw new BadRequestException("Cannot delete category with products."); }
        categoryRepository.delete(category);
    }
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/service/CustomerService.java">
package com.magazincomputere.magazin_api.service;

import com.magazincomputere.magazin_api.dto.CustomerDto;
import com.magazincomputere.magazin_api.exception.ResourceNotFoundException;
import com.magazincomputere.magazin_api.model.Customer;
import com.magazincomputere.magazin_api.repository.CustomerRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.stream.Collectors;

@Service
public class CustomerService {

    @Autowired
    private CustomerRepository customerRepository;
    // @Autowired private UserRepository userRepository; // Dacă e nevoie să legi de User

    private CustomerDto convertToDto(Customer customer) {
        CustomerDto dto = new CustomerDto();
        dto.setId(customer.getId());
        if (customer.getUser() != null) {
            dto.setUserId(customer.getUser().getId());
        }
        dto.setFirstName(customer.getFirstName());
        dto.setLastName(customer.getLastName());
        dto.setEmail(customer.getEmail());
        dto.setPhone(customer.getPhone());
        dto.setAddress(customer.getAddressDetails());
        return dto;
    }

    private Customer convertToEntity(CustomerDto dto, Customer customer) {
        // Nu setăm User aici, se face la creare/asociere
        customer.setFirstName(dto.getFirstName());
        customer.setLastName(dto.getLastName());
        customer.setEmail(dto.getEmail());
        customer.setPhone(dto.getPhone());
        customer.setAddressDetails(dto.getAddress());
        return customer;
    }

    @Transactional(readOnly = true)
    public List<CustomerDto> findAllCustomers() {
        return customerRepository.findAll().stream().map(this::convertToDto).collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public CustomerDto findCustomerById(Long id) {
        Customer customer = customerRepository.findById(id)
            .orElseThrow(() -> new ResourceNotFoundException("Customer not found with id: " + id));
        return convertToDto(customer);
    }

    // Crearea de Customer se poate face și implicit la prima comandă a unui User,
    // sau explicit de către un admin.
    // @Transactional
    // public CustomerDto createCustomer(CustomerDto customerDto) {
    //     Customer customer = new Customer();
    //     // Dacă se trimite userId, asociază-l
    //     if (customerDto.getUserId() != null) {
    //         User user = userRepository.findById(customerDto.getUserId()).orElse(null);
    //         customer.setUser(user);
    //     }
    //     customer = convertToEntity(customerDto, customer);
    //     return convertToDto(customerRepository.save(customer));
    // }

    // @Transactional
    // public CustomerDto updateCustomer(Long id, CustomerDto customerDto) {
    //     Customer existingCustomer = customerRepository.findById(id)
    //         .orElseThrow(() -> new ResourceNotFoundException("Customer not found with id: " + id));
    //     existingCustomer = convertToEntity(customerDto, existingCustomer);
    //     return convertToDto(customerRepository.save(existingCustomer));
    // }

    // @Transactional
    // public void deleteCustomer(Long id){
    //      if(!customerRepository.existsById(id)){
    //          throw new ResourceNotFoundException("Customer not found with id: " + id);
    //      }
    //      // Verifică dacă clientul are comenzi înainte de ștergere
    //      customerRepository.deleteById(id);
    // }

}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/service/ReportService.java">
package com.magazincomputere.magazin_api.service;

// import com.magazincomputere.magazin_api.dto.SalesReportDto; // DTO pentru răspunsul raportului
// import com.magazincomputere.magazin_api.dto.SalesReportItemDto; // DTO pentru fiecare item din raport
// import com.magazincomputere.magazin_api.repository.OrderRepository;
// import com.magazincomputere.magazin_api.repository.CategoryRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDate;
// import java.util.List;
// import java.math.BigDecimal;

@Service
public class ReportService {

    // @Autowired
    // private OrderRepository orderRepository;
    // @Autowired
    // private CategoryRepository categoryRepository;

    // @Transactional(readOnly = true)
    // public SalesReportDto generateSalesByCategoryAndPeriod(Long categoryId, LocalDate startDate, LocalDate endDate) {
    //     // Verifică dacă categoria există
    //     // Category category = categoryRepository.findById(categoryId)
    //     // .orElseThrow(() -> new ResourceNotFoundException("Category not found: " + categoryId));

    //     // Logica de interogare a comenzilor pentru categoria și perioada specificată.
    //     // Aceasta poate implica o interogare JPQL custom în OrderRepository
    //     // sau procesarea datelor în Java după preluarea lor.
    //     // List<Order> orders = orderRepository.findOrdersByProductCategoryAndDateRange(categoryId, startDate.atStartOfDay(), endDate.plusDays(1).atStartOfDay());

    //     // Construiește DTO-ul de răspuns
    //     // SalesReportDto report = new SalesReportDto();
    //     // report.setCategoryName(category.getName());
    //     // report.setStartDate(startDate);
    //     // report.setEndDate(endDate);
    //     // ... calculează totalVânzări, numărComenzi, detaliiProduseVândute etc.

    //     // return report;
    //     return null; // Placeholder
    // }
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/service/SpecificationService.java">
package com.magazincomputere.magazin_api.service;

import com.magazincomputere.magazin_api.dto.SpecificationDefinitionDto;
import com.magazincomputere.magazin_api.exception.ResourceNotFoundException;
import com.magazincomputere.magazin_api.model.SpecificationDefinition;
import com.magazincomputere.magazin_api.repository.SpecificationDefinitionRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.stream.Collectors;

@Service
public class SpecificationService {

    @Autowired
    private SpecificationDefinitionRepository definitionRepository;

    private SpecificationDefinitionDto convertToDto(SpecificationDefinition definition) {
        return new SpecificationDefinitionDto(definition.getId(), definition.getName(), definition.getUnit());
    }

    // Metodă pentru a actualiza câmpurile unei entități existente dintr-un DTO
    private void updateEntityFromDto(SpecificationDefinitionDto dto, SpecificationDefinition definition) {
        definition.setName(dto.getName());
        definition.setUnit(dto.getUnit());
    }

    @Transactional(readOnly = true)
    public List<SpecificationDefinitionDto> getAllDefinitions() {
        return definitionRepository.findAll().stream().map(this::convertToDto).collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public SpecificationDefinitionDto getDefinitionById(Long id) {
        SpecificationDefinition def = definitionRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("SpecificationDefinition", "id", id));
        return convertToDto(def);
    }

    @Transactional
    public SpecificationDefinitionDto createDefinition(SpecificationDefinitionDto definitionDto) {
         definitionRepository.findByNameIgnoreCase(definitionDto.getName()).ifPresent(existingDef -> {
            throw new IllegalArgumentException("Specification definition with name '" + existingDef.getName() + "' already exists.");
        });
        SpecificationDefinition definition = new SpecificationDefinition();
        updateEntityFromDto(definitionDto, definition); // Folosim metoda care nu returnează pentru claritate
        SpecificationDefinition saved = definitionRepository.save(definition);
        return convertToDto(saved);
    }

    @Transactional
    public SpecificationDefinitionDto updateDefinition(Long id, SpecificationDefinitionDto definitionDto) {
        // Pasul 1: Găsește entitatea existentă
        SpecificationDefinition existingDef = definitionRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("SpecificationDefinition", "id", id));
        
        // Pasul 2: Verifică dacă noul nume este deja folosit de altă definiție
        // Folosim o variabilă finală sau effectively final pentru ID-ul definiției existente în lambda
        final Long existingDefId = existingDef.getId();
        definitionRepository.findByNameIgnoreCase(definitionDto.getName()).ifPresent(defWithSameName -> {
            if(!defWithSameName.getId().equals(existingDefId)){
                 throw new IllegalArgumentException("Another specification definition with name '" + defWithSameName.getName() + "' already exists.");
            }
        });

        // Pasul 3: Actualizează câmpurile entității existente cu datele din DTO
        // Nu re-atribuim existingDef, ci îi modificăm starea.
        updateEntityFromDto(definitionDto, existingDef);

        // Pasul 4: Salvează entitatea actualizată
        SpecificationDefinition updated = definitionRepository.save(existingDef);

        // Pasul 5: Converteste entitatea actualizată în DTO și returneaz-o
        return convertToDto(updated);
    }

    @Transactional
    public void deleteDefinition(Long id) {
        SpecificationDefinition definition = definitionRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("SpecificationDefinition", "id", id));
        
        // TODO: Verifică dacă această definiție este folosită în ProductSpecificationValue înainte de ștergere.
        // De exemplu: if (!productSpecificationValueRepository.findBySpecificationDefinitionId(id).isEmpty()) {
        // throw new BadRequestException("Cannot delete specification definition that is in use by products.");
        // }
        definitionRepository.delete(definition);
    }
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/service/UserService.java">
package com.magazincomputere.magazin_api.service;

import com.magazincomputere.magazin_api.dto.UserDto;
import com.magazincomputere.magazin_api.exception.ResourceNotFoundException;
import com.magazincomputere.magazin_api.model.User; // Importă și Role, ERole
import com.magazincomputere.magazin_api.model.Role;
import com.magazincomputere.magazin_api.model.ERole;
import com.magazincomputere.magazin_api.repository.UserRepository;
import com.magazincomputere.magazin_api.repository.RoleRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

@Service
public class UserService {

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private RoleRepository roleRepository;

    @Autowired
    private PasswordEncoder passwordEncoder; // Injectează pentru a parola parolele

    private UserDto convertToDto(User user) {
        UserDto dto = new UserDto();
        dto.setId(user.getId());
        dto.setUsername(user.getUsername());
        dto.setEmail(user.getEmail());
        if (user.getRoles() != null) {
            dto.setRoles(user.getRoles().stream().map(role -> role.getName().name()).collect(Collectors.toSet()));
        }
        return dto;
    }

    // Notă: Nu vom avea convertToEntity care primește parola în clar aici
    // Crearea utilizatorilor se face prin AuthController/Signup sau un DTO specific.
    // Actualizarea parolei ar trebui să aibă un endpoint și DTO dedicat.

    @Transactional(readOnly = true)
    public List<UserDto> findAllUsers() {
        return userRepository.findAll().stream().map(this::convertToDto).collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public UserDto findUserById(Long id) {
        User user = userRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("User not found with id: " + id));
        return convertToDto(user);
    }

    @Transactional
    public UserDto updateUser(Long id, UserDto userDto) {
        User existingUser = userRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("User not found with id: " + id));

        // Nu permitem schimbarea username-ului prin acest DTO general
        // existingUser.setUsername(userDto.getUsername()); // Comentat intenționat

        existingUser.setEmail(userDto.getEmail());

        if (userDto.getRoles() != null && !userDto.getRoles().isEmpty()) {
            Set<Role> newRoles = new HashSet<>();
            userDto.getRoles().forEach(roleName -> {
                ERole eRole = ERole.valueOf(roleName); // Presupune că rolurile din DTO sunt valide
                Role role = roleRepository.findByName(eRole)
                        .orElseThrow(() -> new RuntimeException("Error: Role " + roleName + " is not found."));
                newRoles.add(role);
            });
            existingUser.setRoles(newRoles);
        }

        User updatedUser = userRepository.save(existingUser);
        return convertToDto(updatedUser);
    }

    @Transactional
    public void deleteUser(Long id) {
        if (!userRepository.existsById(id)) {
            throw new ResourceNotFoundException("User not found with id: " + id);
        }
        // TODO: Adaugă logica de verificare a dependențelor (comenzi, etc.) înainte de ștergere
        userRepository.deleteById(id);
    }
}
</file>

<file path="backend/src/test/java/com/magazincomputere/magazin_api/MagazinApiApplicationTests.java">
package com.magazincomputere.magazin_api;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class MagazinApiApplicationTests {

	@Test
	void contextLoads() {
	}

}
</file>

<file path="frontend/.editorconfig">
# Editor configuration, see https://editorconfig.org
root = true

[*]
charset = utf-8
indent_style = space
indent_size = 2
insert_final_newline = true
trim_trailing_whitespace = true

[*.ts]
quote_type = single
ij_typescript_use_double_quotes = false

[*.md]
max_line_length = off
trim_trailing_whitespace = false
</file>

<file path="frontend/.gitignore">
# See https://docs.github.com/get-started/getting-started-with-git/ignoring-files for more about ignoring files.

# Compiled output
/dist
/tmp
/out-tsc
/bazel-out

# Node
/node_modules
npm-debug.log
yarn-error.log

# IDEs and editors
.idea/
.project
.classpath
.c9/
*.launch
.settings/
*.sublime-workspace

# Visual Studio Code
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json
.history/*

# Miscellaneous
/.angular/cache
.sass-cache/
/connect.lock
/coverage
/libpeerconnection.log
testem.log
/typings

# System files
.DS_Store
Thumbs.db
</file>

<file path="frontend/.vscode/extensions.json">
{
  // For more information, visit: https://go.microsoft.com/fwlink/?linkid=827846
  "recommendations": ["angular.ng-template"]
}
</file>

<file path="frontend/.vscode/launch.json">
{
  // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
  "version": "0.2.0",
  "configurations": [
    {
      "name": "ng serve",
      "type": "chrome",
      "request": "launch",
      "preLaunchTask": "npm: start",
      "url": "http://localhost:4200/"
    },
    {
      "name": "ng test",
      "type": "chrome",
      "request": "launch",
      "preLaunchTask": "npm: test",
      "url": "http://localhost:9876/debug.html"
    }
  ]
}
</file>

<file path="frontend/.vscode/tasks.json">
{
  // For more information, visit: https://go.microsoft.com/fwlink/?LinkId=733558
  "version": "2.0.0",
  "tasks": [
    {
      "type": "npm",
      "script": "start",
      "isBackground": true,
      "problemMatcher": {
        "owner": "typescript",
        "pattern": "$tsc",
        "background": {
          "activeOnStart": true,
          "beginsPattern": {
            "regexp": "(.*?)"
          },
          "endsPattern": {
            "regexp": "bundle generation complete"
          }
        }
      }
    },
    {
      "type": "npm",
      "script": "test",
      "isBackground": true,
      "problemMatcher": {
        "owner": "typescript",
        "pattern": "$tsc",
        "background": {
          "activeOnStart": true,
          "beginsPattern": {
            "regexp": "(.*?)"
          },
          "endsPattern": {
            "regexp": "bundle generation complete"
          }
        }
      }
    }
  ]
}
</file>

<file path="frontend/proxy.conf.json">
{
  "/api": {
    "target": "http://localhost:8080",
    "secure": false,
    "changeOrigin": true,
    "logLevel": "debug"
  }
}
</file>

<file path="frontend/README.md">
# MagazinCalculatoare

This project was generated using [Angular CLI](https://github.com/angular/angular-cli) version 19.2.10.

## Development server

To start a local development server, run:

```bash
ng serve
```

Once the server is running, open your browser and navigate to `http://localhost:4200/`. The application will automatically reload whenever you modify any of the source files.

## Code scaffolding

Angular CLI includes powerful code scaffolding tools. To generate a new component, run:

```bash
ng generate component component-name
```

For a complete list of available schematics (such as `components`, `directives`, or `pipes`), run:

```bash
ng generate --help
```

## Building

To build the project run:

```bash
ng build
```

This will compile your project and store the build artifacts in the `dist/` directory. By default, the production build optimizes your application for performance and speed.

## Running unit tests

To execute unit tests with the [Karma](https://karma-runner.github.io) test runner, use the following command:

```bash
ng test
```

## Running end-to-end tests

For end-to-end (e2e) testing, run:

```bash
ng e2e
```

Angular CLI does not come with an end-to-end testing framework by default. You can choose one that suits your needs.

## Additional Resources

For more information on using the Angular CLI, including detailed command references, visit the [Angular CLI Overview and Command Reference](https://angular.dev/tools/cli) page.
</file>

<file path="frontend/src/app/app.component.spec.ts">
import { TestBed } from '@angular/core/testing';
import { AppComponent } from './app.component';

describe('AppComponent', () => {
  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [AppComponent],
    }).compileComponents();
  });

  it('should create the app', () => {
    const fixture = TestBed.createComponent(AppComponent);
    const app = fixture.componentInstance;
    expect(app).toBeTruthy();
  });

  it(`should have the 'magazin-calculatoare' title`, () => {
    const fixture = TestBed.createComponent(AppComponent);
    const app = fixture.componentInstance;
    expect(app.title).toEqual('magazin-calculatoare');
  });

  it('should render title', () => {
    const fixture = TestBed.createComponent(AppComponent);
    fixture.detectChanges();
    const compiled = fixture.nativeElement as HTMLElement;
    expect(compiled.querySelector('h1')?.textContent).toContain('Hello, magazin-calculatoare');
  });
});
</file>

<file path="frontend/src/app/app.config.server.ts">
import { mergeApplicationConfig, ApplicationConfig } from '@angular/core';
import { provideServerRendering }                     from '@angular/platform-server';
import { provideServerRouting }                      from '@angular/ssr';
import { appConfig }                                 from './app.config';
import { serverRoutes }                              from './app.routes.server';

const serverConfig: ApplicationConfig = {
  providers: [
    provideServerRendering(),
    provideServerRouting(serverRoutes)
    // **nu** importa InMemoryWebApi aici!
  ]
};

export const config = mergeApplicationConfig(appConfig, serverConfig);
</file>

<file path="frontend/src/app/app.routes.server.ts">
import { RenderMode, ServerRoute } from '@angular/ssr';

export const serverRoutes: ServerRoute[] = [
  {
    path: '**',
    renderMode: RenderMode.Prerender
  }
];
</file>

<file path="frontend/src/app/auth/auth.interceptor.ts">
// src/app/auth/auth.interceptor.ts
import { Injectable, inject } from '@angular/core';
import {
  HttpEvent,
  HttpInterceptor,
  HttpHandler,
  HttpRequest,
  HttpErrorResponse
} from '@angular/common/http';
import { Observable, throwError } from 'rxjs';
import { catchError } from 'rxjs/operators';
import { AuthService } from './auth.service'; // Asigură-te că AuthService are o metodă getToken()
import { Router } from '@angular/router';

/**
 * Interceptor HTTP pentru a adăuga automat token-ul JWT la request-urile către API-ul protejat
 * și pentru a gestiona erorile 401 (Unauthorized).
 */
@Injectable()
export class AuthInterceptor implements HttpInterceptor {
  // Folosim inject pentru a injecta dependențele într-o clasă non-componentă
  private authService = inject(AuthService);
  private router = inject(Router);

  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    const authToken = this.authService.getToken();

    // Clonează request-ul și adaugă header-ul de autorizare dacă token-ul există
    // și dacă request-ul este către API-ul tău (verifică dacă URL-ul începe cu '/api')
    // Poți face această verificare mai robustă dacă API-ul tău e pe alt domeniu.
    if (authToken && req.url.startsWith('/api')) {
      const authReq = req.clone({
        headers: req.headers.set('Authorization', `Bearer ${authToken}`)
      });

      // Trimite request-ul clonat cu header-ul de autorizare
      // și gestionează erorile specifice de autentificare
      return next.handle(authReq).pipe(
        catchError((error: HttpErrorResponse) => {
          if (error.status === 401) {
            // Eroare 401: Unauthorized (token invalid, expirat, sau lipsă permisiuni)
            // Deloghează utilizatorul și redirecționează la pagina de login.
            // Poți adăuga și un query param pentru a afișa un mesaj specific pe pagina de login.
            this.authService.logout(); // AuthService ar trebui să curețe token-ul și starea user-ului
            this.router.navigate(['/login'], { queryParams: { sessionExpired: 'true' } });
            console.error('AuthInterceptor: Unauthorized request (401). Logging out.');
          }
          // Propagă eroarea mai departe pentru a fi gestionată de alte error handlers sau în componentă.
          return throwError(() => error);
        })
      );
    }

    // Pentru request-uri care nu necesită token sau nu sunt către API-ul tău, trimite-le neschimbate.
    return next.handle(req);
  }
}
</file>

<file path="frontend/src/app/features/admin-dashboard/admin-dashboard.component.ts">
// src/app/features/admin-dashboard/admin-dashboard.component.ts
import { Component }      from '@angular/core';
import { CommonModule }   from '@angular/common';
import { RouterModule }   from '@angular/router';
import { MaterialModule } from '../../shared/material.module';
import { AuthService }    from '../../auth/auth.service';

@Component({
  selector: 'app-admin-dashboard',
  standalone: true,
  imports: [CommonModule, RouterModule, MaterialModule],
  templateUrl: './admin-dashboard.component.html',
  styleUrls: ['./admin-dashboard.component.scss']
})
export class AdminDashboardComponent {
  constructor(public auth: AuthService) {}
}
</file>

<file path="frontend/src/app/features/admin/admin-categories/admin-category-form/admin-category-form.component.html">
<div class="admin-category-form-container">
  <mat-card>
    <mat-card-header>
      <mat-card-title>{{ pageTitle }}</mat-card-title>
    </mat-card-header>
    <mat-card-content>
      <div *ngIf="isLoading" class="spinner-container">
        <mat-spinner diameter="50"></mat-spinner>
      </div>

      <form [formGroup]="categoryForm" (ngSubmit)="onSubmit()" *ngIf="!isLoading">
        <mat-form-field appearance="outline" class="full-width">
          <mat-label>Nume Categorie</mat-label>
          <input matInput formControlName="name" placeholder="Ex: Procesoare" required>
          <mat-error *ngIf="f['name'].hasError('required')">
            Numele este obligatoriu.
          </mat-error>
          <mat-error *ngIf="f['name'].hasError('minlength')">
            Numele trebuie să aibă cel puțin 2 caractere.
          </mat-error>
          <mat-error *ngIf="f['name'].hasError('maxlength')">
            Numele nu poate depăși 100 de caractere.
          </mat-error>
        </mat-form-field>

        <mat-form-field appearance="outline" class="full-width">
          <mat-label>Descriere</mat-label>
          <textarea matInput formControlName="description" placeholder="O scurtă descriere a categoriei (opțional)" rows="3"></textarea>
          <mat-error *ngIf="f['description'].hasError('maxlength')">
            Descrierea nu poate depăși 1000 de caractere.
          </mat-error>
        </mat-form-field>

        <div class="form-actions">
          <button mat-stroked-button color="warn" type="button" routerLink="/admin/categories" [disabled]="isLoading">
            <mat-icon>cancel</mat-icon> Anulează
          </button>
          <button mat-raised-button color="primary" type="submit" [disabled]="isLoading || categoryForm.invalid">
            <mat-icon>save</mat-icon> {{ submitButtonText }}
          </button>
        </div>
      </form>
    </mat-card-content>
  </mat-card>
</div>
</file>

<file path="frontend/src/app/features/admin/admin-categories/admin-category-form/admin-category-form.component.scss">
// src/app/features/admin/admin-categories/admin-category-form/admin-category-form.component.scss
.admin-category-form-container {
  padding: 20px;
  max-width: 600px;
  margin: 20px auto; // Adăugat margine sus/jos
}

mat-card-header {
  padding-bottom: 16px; // Spațiu sub titlu
}

.full-width {
  width: 100%;
  margin-bottom: 16px; // Spațiu între câmpuri
}

.spinner-container {
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 200px; // Asigură spațiu pentru spinner
}

.form-actions {
  display: flex;
  justify-content: flex-end;
  gap: 10px; // Spațiu între butoane
  margin-top: 20px;

  button {
    min-width: 120px; // Lățime minimă pentru butoane
    mat-icon {
      margin-right: 8px;
    }
  }
}

// Asigură-te că mesajele de eroare sunt vizibile
mat-error {
  font-size: 0.85em;
}
</file>

<file path="frontend/src/app/features/admin/admin-categories/admin-category-form/admin-category-form.component.ts">
// src/app/features/admin/admin-categories/admin-category-form/admin-category-form.component.ts
import { Component, OnInit, inject } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ReactiveFormsModule, FormBuilder, FormGroup, Validators } from '@angular/forms';
import { ActivatedRoute, Router, RouterModule } from '@angular/router';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { MatButtonModule } from '@angular/material/button';
import { MatCardModule } from '@angular/material/card';
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { MatIconModule } from '@angular/material/icon';
import { HttpErrorResponse } from '@angular/common/http'; // Import HttpErrorResponse

import { Category } from '../../../../shared/models/category.model';
// Calea corectă și numele fișierului serviciului
import { CategoryAdminService } from '../../services/category.admin.service'; // <<<--- CALE ȘI NUME FIȘIER CORECTATE

@Component({
  selector: 'app-admin-category-form',
  standalone: true,
  imports: [
    CommonModule,
    RouterModule,
    ReactiveFormsModule,
    MatFormFieldModule,
    MatInputModule,
    MatButtonModule,
    MatCardModule,
    MatSnackBarModule,
    MatProgressSpinnerModule,
    MatIconModule
  ],
  templateUrl: './admin-category-form.component.html',
  styleUrls: ['./admin-category-form.component.scss']
})
export class AdminCategoryFormComponent implements OnInit {
  categoryForm!: FormGroup;
  isEditMode = false;
  categoryId?: number;
  isLoading = false;
  pageTitle = 'Adaugă Categorie Nouă';
  submitButtonText = 'Salvează';
  error: string | null = null; // Adăugat pentru a stoca mesajul de eroare

  private fb = inject(FormBuilder);
  private categoryService = inject(CategoryAdminService);
  private route = inject(ActivatedRoute);
  private router = inject(Router);
  private snackBar = inject(MatSnackBar);

  ngOnInit(): void {
    this.categoryForm = this.fb.group({
      name: ['', [Validators.required, Validators.minLength(2), Validators.maxLength(100)]],
      description: ['', [Validators.maxLength(1000)]]
    });

    const idFromRoute = this.route.snapshot.paramMap.get('id');
    if (idFromRoute) {
      this.categoryId = +idFromRoute;
      if (!isNaN(this.categoryId) && this.categoryId > 0) {
        this.isEditMode = true;
        this.pageTitle = 'Editează Categorie';
        this.submitButtonText = 'Actualizează';
        this.loadCategoryData(this.categoryId);
      } else {
        this.handleInvalidId('ID categorie invalid din rută.');
      }
    }
  }

  loadCategoryData(id: number): void {
    this.isLoading = true;
    this.categoryService.getById(id).subscribe({
      next: (category: Category) => { // <<<--- TIPARE EXPLICITĂ PENTRU 'category'
        this.categoryForm.patchValue(category);
        this.isLoading = false;
      },
      error: (err: HttpErrorResponse) => this.handleLoadError('Eroare la încărcarea datelor categoriei.', err) // <<<--- TIPARE EXPLICITĂ ȘI REFACUT
    });
  }

  onSubmit(): void {
    if (this.categoryForm.invalid) {
      this.snackBar.open('Formular invalid. Vă rugăm corectați erorile.', 'OK', { duration: 3000 });
      this.categoryForm.markAllAsTouched();
      return;
    }

    this.isLoading = true;
    const categoryData: Category = this.categoryForm.value;

    if (this.isEditMode && this.categoryId) {
      this.categoryService.update(this.categoryId, categoryData).subscribe({
        next: () => {
          this.isLoading = false;
          this.snackBar.open('Categorie actualizată cu succes!', 'OK', { duration: 3000 });
          this.router.navigate(['/admin/categories']);
        },
        error: (err: HttpErrorResponse) => this.handleSubmitError('Eroare la actualizarea categoriei.', err) // <<<--- TIPARE EXPLICITĂ ȘI REFACUT
      });
    } else {
      this.categoryService.create(categoryData).subscribe({
        next: () => {
          this.isLoading = false;
          this.snackBar.open('Categorie creată cu succes!', 'OK', { duration: 3000 });
          this.router.navigate(['/admin/categories']);
        },
        error: (err: HttpErrorResponse) => this.handleSubmitError('Eroare la crearea categoriei.', err) // <<<--- TIPARE EXPLICITĂ ȘI REFACUT
      });
    }
  }

  private handleInvalidId(message: string): void {
    this.isLoading = false;
    this.error = message; // Setează mesajul de eroare
    this.snackBar.open(this.error, 'Închide', { duration: 3000 });
    this.router.navigate(['/admin/categories']);
  }

  private handleLoadError(message: string, err: HttpErrorResponse): void {
    this.isLoading = false;
    // Extrage mesajul de eroare din răspunsul backend-ului dacă există
    const serverErrorMessage = err.error?.message || err.message || 'Eroare necunoscută de la server.';
    this.error = `${message} ${serverErrorMessage}`;
    this.snackBar.open(this.error, 'Închide', { duration: 5000 });
    console.error('Eroare la încărcare:', err);
    this.router.navigate(['/admin/categories']);
  }

  private handleSubmitError(message: string, err: HttpErrorResponse): void {
    this.isLoading = false;
    const serverErrorMessage = err.error?.message || err.message || 'Eroare necunoscută de la server.';
    this.snackBar.open(`${message} ${serverErrorMessage}`, 'Închide', { duration: 5000 });
    console.error('Eroare la submit:', err);
  }


  get f() { return this.categoryForm.controls; }
}
</file>

<file path="frontend/src/app/features/admin/admin-categories/admin-category-list/admin-category-list.component.html">
<!-- src/app/features/admin/admin-categories/admin-category-list/admin-category-list.component.html -->
<div class="admin-category-list-container">
  <div class="header">
    <h2>Administrare Categorii</h2>
    <button mat-raised-button color="primary" routerLink="/admin/categories/new">
      <mat-icon>add</mat-icon> Adaugă Categorie Nouă
    </button>
  </div>

  <div *ngIf="isLoading" class="loading-indicator">
    <p>Se încarcă categoriile...</p>
    <!-- Poți adăuga un spinner Angular Material aici -->
    <!-- <mat-spinner diameter="40"></mat-spinner> -->
  </div>

  <div *ngIf="error && !isLoading" class="error-message">
    <p>{{ error }}</p>
    <button mat-stroked-button color="warn" (click)="loadCategories()">Reîncearcă</button>
  </div>

  <div *ngIf="!isLoading && !error && categories.length === 0" class="no-data">
    <p>Nu există categorii definite.</p>
  </div>

  <mat-list *ngIf="!isLoading && !error && categories.length > 0" role="list">
    <h3 mat-subheader>Categorii Existente</h3>
    <mat-list-item *ngFor="let category of categories" role="listitem" class="category-item">
      <mat-icon matListItemIcon>folder_open</mat-icon>
      <span matListItemTitle>{{ category.name }}</span>
      <span matListItemLine class="description">{{ category.description || 'Fără descriere' }}</span>
      <span matListItemMeta class="actions">
        <button mat-icon-button color="primary" [routerLink]="['/admin/categories/edit', category.id]" aria-label="Editează categoria">
          <mat-icon>edit</mat-icon>
        </button>
        <button mat-icon-button color="warn" (click)="deleteCategory(category.id!)" [disabled]="isLoading" aria-label="Șterge categoria">
          <mat-icon>delete</mat-icon>
        </button>
      </span>
    </mat-list-item>
  </mat-list>
</div>
</file>

<file path="frontend/src/app/features/admin/admin-categories/admin-category-list/admin-category-list.component.scss">
// src/app/features/admin/admin-categories/admin-category-list/admin-category-list.component.scss
.admin-category-list-container {
  padding: 20px;
  max-width: 800px;
  margin: 20px auto; // Centrare și spațiere
  background-color: #fff; // Fundal alb pentru container
  border-radius: 8px; // Colțuri rotunjite
  box-shadow: 0 2px 10px rgba(0,0,0,0.1); // Umbră subtilă
}

.header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 24px; // Spațiu mai mare sub header
  padding-bottom: 16px; // Spațiu sub textul header-ului
  border-bottom: 1px solid #e0e0e0; // Linie de separare

  h2 {
    margin: 0;
    font-size: 1.6em; // Mărime font mai mare pentru titlu
    color: #3f51b5; // Culoarea primară Material
  }
  button[mat-raised-button] mat-icon {
    margin-right: 8px;
  }
}

.loading-indicator,
.error-message,
.no-data {
  text-align: center;
  padding: 30px 20px; // Padding mai mare
  margin-top: 20px;
  color: #757575;
  font-size: 1.1em;

  mat-spinner { // Dacă adaugi un spinner
    margin: 0 auto 15px auto;
  }
}

.error-message {
  color: #d32f2f; // Un roșu mai închis pentru erori
  background-color: #ffebee; // Fundal deschis roșu pentru erori
  border: 1px solid #ffcdd2;
  border-radius: 4px;
  p {
    margin-bottom: 10px;
  }
}

.no-data {
  color: #616161;
}

mat-list {
  padding-top: 0; // Elimină padding-ul default al listei
}

h3[mat-subheader] {
  font-size: 1.2em;
  font-weight: 500;
  color: rgba(0,0,0,0.67);
  margin-bottom: 8px;
}

.category-item {
  border-bottom: 1px solid #f0f0f0; // Separator mai fin
  padding: 12px 0; // Padding vertical pentru itemi

  &:last-child {
    border-bottom: none;
  }

  &:hover {
    background-color: #f9f9f9; // Efect subtil la hover
  }

  mat-icon[matListItemIcon] {
    color: #757575; // Culoare pentru iconița de folder
  }

  .description {
    font-size: 0.9em;
    color: #616161;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 400px; // Ajustează după nevoie, sau folosește display: -webkit-box pentru clamp pe mai multe rânduri
    padding-left: 16px; // Spațiu față de titlu dacă sunt pe același rând vizual
  }

  .actions {
    button[mat-icon-button] {
      margin-left: 8px;
    }
  }
}
</file>

<file path="frontend/src/app/features/admin/admin-categories/admin-category-list/admin-category-list.component.ts">
// src/app/features/admin/admin-categories/admin-category-list/admin-category-list.component.ts
import { Component, OnInit, inject } from '@angular/core';
import { CommonModule } from '@angular/common';
import { RouterModule } from '@angular/router';
import { MatListModule } from '@angular/material/list';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar';
import { MatDialog, MatDialogModule } from '@angular/material/dialog';
// Importă un dialog de confirmare generic dacă ai unul, sau creează unul simplu.
// import { ConfirmDialogComponent } from '../../../../shared/components/confirm-dialog/confirm-dialog.component';


import { Category } from '../../../../shared/models/category.model';
import { CategoryAdminService } from '../../services/category.admin.service'; // Asigură-te că numele serviciului este corect

@Component({
  selector: 'app-admin-category-list',
  standalone: true,
  imports: [
    CommonModule,
    RouterModule,
    MatListModule,
    MatButtonModule,
    MatIconModule,
    MatSnackBarModule,
    MatDialogModule
  ],
  templateUrl: './admin-category-list.component.html',
  styleUrls: ['./admin-category-list.component.scss']
})
export class AdminCategoryListComponent implements OnInit {
  categories: Category[] = [];
  isLoading = true;
  error: string | null = null;

  private categoryService = inject(CategoryAdminService);
  private snackBar = inject(MatSnackBar);
  // private dialog = inject(MatDialog); // Decomentează dacă folosești MatDialog

  ngOnInit(): void {
    this.loadCategories();
  }

  /**
   * Încarcă lista de categorii de la server.
   */
  loadCategories(): void {
    this.isLoading = true;
    this.error = null;
    this.categoryService.getAll().subscribe({
      next: (data) => {
        this.categories = data;
        this.isLoading = false;
      },
      error: (err) => {
        this.error = 'Nu s-au putut încărca categoriile.';
        const errMsg = err.error?.message || err.message || 'Eroare necunoscută.';
        console.error('Eroare la încărcarea categoriilor:', err);
        this.isLoading = false;
        this.snackBar.open(`${this.error} ${errMsg}`, 'Închide', { duration: 5000 });
      }
    });
  }

  /**
   * Șterge o categorie după o confirmare.
   * @param categoryId ID-ul categoriei de șters.
   */
  deleteCategory(categoryId: number): void {
    // TODO: Implementează un dialog de confirmare (MatDialog) înainte de ștergere.
    // Exemplu simplu cu window.confirm, dar MatDialog e preferat:
    const confirmation = window.confirm('Sunteți sigur că doriți să ștergeți această categorie? Această acțiune nu poate fi anulată.');
    if (confirmation) {
      this.isLoading = true; // Indică începerea operației
      this.categoryService.delete(categoryId).subscribe({
        next: () => {
          this.isLoading = false;
          this.snackBar.open('Categorie ștearsă cu succes!', 'OK', { duration: 3000 });
          this.loadCategories(); // Reîncarcă lista pentru a reflecta ștergerea
        },
        error: (err) => {
          this.isLoading = false;
          const errMsg = err.error?.message || err.message || 'Eroare la ștergerea categoriei.';
          this.snackBar.open(errMsg, 'Închide', { duration: 5000 });
          console.error('Eroare la ștergerea categoriei:', err);
        }
      });
    }
  }
}
</file>

<file path="frontend/src/app/features/admin/admin-orders/admin-order-detail/admin-order-detail.component.html">
<div class="admin-order-detail-container">
  <button mat-stroked-button routerLink="/admin/orders" class="back-button">
    <mat-icon>arrow_back</mat-icon> Înapoi la Listă Comenzi
  </button>

  <div *ngIf="isLoading" class="loading-indicator">
    <mat-spinner diameter="50"></mat-spinner>
    <p>Se încarcă detaliile comenzii...</p>
  </div>

  <div *ngIf="error && !isLoading" class="error-message">
    <p>{{ error }}</p>
    <button mat-stroked-button color="warn" (click)="loadOrderDetails()">Reîncearcă</button>
  </div>

  <div *ngIf="order && !isLoading" class="order-details">
    <mat-card class="order-summary-card">
      <mat-card-header>
        <mat-card-title>Comanda #{{ order.id }}</mat-card-title>
        <mat-card-subtitle>Plasată la: {{ order.orderDate | date:'dd/MM/yyyy HH:mm:ss' }}</mat-card-subtitle>
      </mat-card-header>
      <mat-card-content>
        <div class="info-grid">
          <div><strong>Client:</strong> {{ order.customerName }}</div>
          <div><strong>Email:</strong> {{ order.customerEmail }}</div>
          <div><strong>Telefon:</strong> {{ order.customerPhone }}</div>
          <div><strong>Utilizator (ID):</strong> {{ order.userId || 'N/A (Guest)' }}</div>
          <div class="full-width"><strong>Adresă Livrare:</strong> {{ order.shippingAddress }}</div>
        </div>
        <mat-divider></mat-divider>
        <div class="status-total">
            <mat-chip-listbox aria-label="Status comandă">
                <mat-chip selected [ngClass]="'status-chip-' + order.status.toLowerCase()">
                    Status: {{ formatStatus(order.status) }}
                </mat-chip>
            </mat-chip-listbox>
          <h3>Total Comandă: {{ order.totalAmount | currency:'RON':'symbol':'1.2-2' }}</h3>
        </div>
      </mat-card-content>
    </mat-card>

    <mat-card class="order-items-card">
      <mat-card-header>
        <mat-card-title>Articole Comandate</mat-card-title>
      </mat-card-header>
      <mat-card-content>
        <mat-list role="list" class="order-items-list">
          <mat-list-item *ngFor="let item of order.orderItems" role="listitem" class="order-item-detail">
            <!-- Secțiunea Imagine Articol - COMENTATĂ TEMPORAR -->
            <!--
            <img matListItemAvatar *ngIf="item.productImageBase64Snapshot" [src]="item.productImageBase64Snapshot" [alt]="item.productNameSnapshot || 'Imagine produs'" class="item-image-small">
            <mat-icon matListItemAvatar *ngIf="!item.productImageBase64Snapshot">inventory_2</mat-icon>
            -->
            <mat-icon matListItemAvatar>inventory_2</mat-icon> <!-- Placeholder generic -->

            <span matListItemTitle>{{ item.productNameSnapshot }} (ID: {{ item.productId }})</span>
            <span matListItemLine>
              Cantitate: {{ item.quantity }} x {{ item.priceAtPurchase | currency:'RON':'symbol':'1.2-2' }}
            </span>
            <span matListItemMeta class="item-subtotal-small">
              Subtotal: {{ calculateItemSubtotal(item) | currency:'RON':'symbol':'1.2-2' }}
            </span>
          </mat-list-item>
        </mat-list>
      </mat-card-content>
    </mat-card>

    <mat-card class="status-update-card">
      <mat-card-header>
        <mat-card-title>Actualizează Status Comandă</mat-card-title>
      </mat-card-header>
      <mat-card-content>
        <form [formGroup]="statusUpdateForm" (ngSubmit)="onUpdateStatus()">
          <mat-form-field appearance="outline" class="full-width">
            <mat-label>Status Nou</mat-label>
            <mat-select formControlName="newStatus" required>
              <mat-option *ngFor="let status of availableStatuses" [value]="status">
                {{ formatStatus(status) }}
              </mat-option>
            </mat-select>
            <mat-error *ngIf="statusUpdateForm.get('newStatus')?.hasError('required')">
              Selectați un status.
            </mat-error>
          </mat-form-field>
          <button mat-raised-button color="primary" type="submit" [disabled]="statusUpdateForm.invalid || isUpdatingStatus">
            <mat-icon *ngIf="!isUpdatingStatus">update</mat-icon>
            <mat-progress-spinner *ngIf="isUpdatingStatus" diameter="20" mode="indeterminate" style="margin-right: 8px;"></mat-progress-spinner>
            {{ isUpdatingStatus ? 'Se actualizează...' : 'Actualizează Status' }}
          </button>
        </form>
      </mat-card-content>
    </mat-card>
  </div>
</div>
</file>

<file path="frontend/src/app/features/admin/admin-orders/admin-order-detail/admin-order-detail.component.scss">
// src/app/features/admin/admin-orders/admin-order-detail/admin-order-detail.component.scss
.admin-order-detail-container {
  padding: 20px;
  max-width: 900px;
  margin: 20px auto;
}

.back-button {
  margin-bottom: 20px;
  mat-icon {
    margin-right: 8px;
  }
}

.loading-indicator,
.error-message {
  text-align: center;
  padding: 20px;
  color: #757575;
  mat-spinner {
    margin: 0 auto 10px auto;
  }
}

.error-message {
  color: #f44336;
}

.order-details {
  display: grid;
  gap: 20px;
}

mat-card {
  width: 100%;
}

mat-card-header {
  padding-bottom: 16px;
}

.info-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: 10px 20px; // Spațiu între rânduri și coloane
  margin-bottom: 16px;

  .full-width {
    grid-column: 1 / -1; // Ocupă întreaga lățime
  }

  strong {
    font-weight: 500;
  }
}

.status-total {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-top: 16px;

  h3 {
    margin: 0;
    font-size: 1.1em;
    font-weight: 500;
  }
}

.status-chip-pending_confirmation { background-color: #FFECB3 !important; color: #795548 !important; } // Amber Light
.status-chip-approved { background-color: #C8E6C9 !important; color: #2E7D32 !important; } // Green Light
.status-chip-processing { background-color: #BBDEFB !important; color: #1565C0 !important; } // Blue Light
.status-chip-shipped { background-color: #B2EBF2 !important; color: #006064 !important; } // Cyan Light
.status-chip-delivered { background-color: #DCEDC8 !important; color: #558B2F !important; } // Light Green Light
.status-chip-canceled { background-color: #FFCDD2 !important; color: #C62828 !important; } // Red Light


.order-items-card {
  .order-item {
    border-bottom: 1px solid rgba(0,0,0,0.08);
    &:last-child {
      border-bottom: none;
    }
  }
  .item-image {
    width: 50px;
    height: 50px;
    object-fit: cover;
    border-radius: 4px;
    margin-right: 16px;
  }
  .item-subtotal {
    font-weight: 500;
  }
}

.status-update-card {
  .full-width {
    width: 100%;
    margin-bottom: 16px;
  }
  button[mat-raised-button] {
    display: inline-flex;
    align-items: center;
  }
}
</file>

<file path="frontend/src/app/features/admin/admin-orders/admin-order-detail/admin-order-detail.component.ts">
// src/app/features/admin/admin-orders/admin-order-detail/admin-order-detail.component.ts
import { Component, OnInit, inject } from '@angular/core';
import { CommonModule, DatePipe, CurrencyPipe } from '@angular/common';
import { ActivatedRoute, Router, RouterModule } from '@angular/router';
import { ReactiveFormsModule, FormBuilder, FormGroup, Validators } from '@angular/forms';

import { MatCardModule } from '@angular/material/card';
import { MatListModule } from '@angular/material/list';
import { MatDividerModule } from '@angular/material/divider';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatSelectModule } from '@angular/material/select';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar';
import { MatChipsModule } from '@angular/material/chips';
import { HttpErrorResponse } from '@angular/common/http';


import { Order } from '../../../../shared/models/order.model';
import { OrderItem } from '../../../../shared/models/order-item.model'; // <<< CORECTAT
import { OrderStatusUpdate } from '../../../../shared/models/order-status-update.model'; // <<< CORECTAT
import { OrderAdminService } from '../../services/order.admin.service';

@Component({
  selector: 'app-admin-order-detail',
  standalone: true,
  imports: [
    CommonModule,
    RouterModule,
    ReactiveFormsModule,
    MatCardModule,
    MatListModule,
    MatDividerModule,
    MatFormFieldModule,
    MatSelectModule,
    MatButtonModule,
    MatIconModule,
    MatProgressSpinnerModule,
    MatSnackBarModule,
    MatChipsModule,
    DatePipe,
    CurrencyPipe
  ],
  templateUrl: './admin-order-detail.component.html',
  styleUrls: ['./admin-order-detail.component.scss']
})
export class AdminOrderDetailComponent implements OnInit {
  order: Order | null = null;
  isLoading = true;
  error: string | null = null;
  orderId!: number;

  statusUpdateForm!: FormGroup;
  availableStatuses: string[] = ['PENDING_CONFIRMATION', 'APPROVED', 'PROCESSING', 'SHIPPED', 'DELIVERED', 'CANCELED'];
  isUpdatingStatus = false;

  private route = inject(ActivatedRoute);
  private router = inject(Router);
  private orderService = inject(OrderAdminService);
  private snackBar = inject(MatSnackBar);
  private fb = inject(FormBuilder);

  ngOnInit(): void {
    const idFromRoute = this.route.snapshot.paramMap.get('id');
    if (idFromRoute) {
      this.orderId = +idFromRoute;
      if (!isNaN(this.orderId) && this.orderId > 0) {
        this.loadOrderDetails();
        this.statusUpdateForm = this.fb.group({
          newStatus: ['', Validators.required]
        });
      } else {
        this.handleInvalidId();
      }
    } else {
      this.handleInvalidId();
    }
  }

  private handleInvalidId(): void {
    this.isLoading = false;
    this.error = 'ID comandă invalid.';
    this.snackBar.open(this.error, 'Închide', { duration: 3000 });
    this.router.navigate(['/admin/orders']);
  }

  loadOrderDetails(): void {
    this.isLoading = true;
    this.error = null;
    this.orderService.getOrderById(this.orderId).subscribe({
      next: (data: Order) => { // Tipare explicită
        this.order = data;
        this.statusUpdateForm.patchValue({ newStatus: this.order.status });
        this.isLoading = false;
      },
      error: (err: HttpErrorResponse) => { // Tipare explicită
        this.error = 'Nu s-au putut încărca detaliile comenzii.';
        const errMsg = err.error?.message || err.message || 'Eroare necunoscută.';
        console.error('Eroare la încărcarea detaliilor comenzii:', err);
        this.isLoading = false;
        this.snackBar.open(`${this.error} ${errMsg}`, 'Închide', { duration: 5000 });
      }
    });
  }

  onUpdateStatus(): void {
    if (this.statusUpdateForm.invalid || !this.order) {
      this.snackBar.open('Vă rugăm selectați un status valid.', 'OK', { duration: 3000 });
      return;
    }

    this.isUpdatingStatus = true;
    const statusUpdate: OrderStatusUpdate = this.statusUpdateForm.value;

    this.orderService.updateOrderStatus(this.orderId, statusUpdate).subscribe({
      next: (updatedOrder: Order) => { // Tipare explicită
        this.order = updatedOrder;
        this.statusUpdateForm.patchValue({ newStatus: updatedOrder.status });
        this.isUpdatingStatus = false;
        this.snackBar.open('Statusul comenzii a fost actualizat cu succes!', 'OK', { duration: 3000 });
      },
      error: (err: HttpErrorResponse) => { // Tipare explicită
        this.isUpdatingStatus = false;
        const errorMessage = err.error?.message || err.message || 'Eroare la actualizarea statusului comenzii.';
        this.snackBar.open(errorMessage, 'Închide', { duration: 5000 });
        console.error(err);
      }
    });
  }

  formatStatus(status: string): string {
    if (!status) return '';
    return status.replace(/_/g, ' ').toLowerCase().replace(/\b\w/g, l => l.toUpperCase());
  }

  calculateItemSubtotal(item: OrderItem): number {
    return (item.priceAtPurchase || 0) * item.quantity;
  }
}
</file>

<file path="frontend/src/app/features/admin/admin-orders/admin-order-list/admin-order-list.component.html">
<!-- src/app/features/admin/admin-orders/admin-order-list/admin-order-list.component.html -->
<div class="admin-order-list-container">
  <div class="header">
    <h2>Administrare Comenzi</h2>
  </div>

  <div class="filters-container">
    <mat-form-field appearance="outline" class="filter-field">
      <mat-label>Filtrează comenzi (ex: nume client, ID)</mat-label>
      <input matInput (keyup)="applyFilter($event)" placeholder="Caută...">
      <mat-icon matSuffix>search</mat-icon>
    </mat-form-field>

    <mat-form-field appearance="outline" class="status-filter-field">
      <mat-label>Filtrează după Status</mat-label>
      <mat-select [(ngModel)]="statusFilter" (selectionChange)="onStatusFilterChange()">
        <mat-option value="ALL">Toate Statusurile</mat-option>
        <!-- Se iterează peste getter-ul statusesForFilterDropdown -->
        <mat-option *ngFor="let status of statusesForFilterDropdown" [value]="status">
          {{ formatStatus(status) }}
        </mat-option>
      </mat-select>
    </mat-form-field>
  </div>

  <div *ngIf="isLoading" class="loading-indicator">
    <mat-spinner diameter="50"></mat-spinner>
    <p>Se încarcă comenzile...</p>
  </div>

  <div *ngIf="error && !isLoading" class="error-message">
    <p>{{ error }}</p>
    <button mat-stroked-button color="warn" (click)="loadOrders()">Reîncearcă</button>
  </div>

  <div *ngIf="!isLoading && !error && dataSource.data.length === 0" class="no-data">
    <p>Nu există comenzi care să corespundă filtrelor selectate sau nu există comenzi înregistrate.</p>
  </div>

  <div class="table-container" *ngIf="!isLoading && !error && dataSource.data.length > 0">
    <table mat-table [dataSource]="dataSource" matSort class="mat-elevation-z8">

      <!-- ID Column -->
      <ng-container matColumnDef="id">
        <th mat-header-cell *matHeaderCellDef mat-sort-header> ID Comandă </th>
        <td mat-cell *matCellDef="let order"> #{{order.id}} </td>
      </ng-container>

      <!-- Customer Name Column -->
      <ng-container matColumnDef="customerName">
        <th mat-header-cell *matHeaderCellDef mat-sort-header> Nume Client </th>
        <td mat-cell *matCellDef="let order"> {{order.customerName}} </td>
      </ng-container>

      <!-- Order Date Column -->
      <ng-container matColumnDef="orderDate">
        <th mat-header-cell *matHeaderCellDef mat-sort-header> Data Comenzii </th>
        <td mat-cell *matCellDef="let order"> {{order.orderDate | date:'dd/MM/yyyy HH:mm'}} </td>
      </ng-container>

      <!-- Total Amount Column -->
      <ng-container matColumnDef="totalAmount">
        <th mat-header-cell *matHeaderCellDef mat-sort-header> Suma Totală </th>
        <td mat-cell *matCellDef="let order"> {{order.totalAmount | currency:'RON':'symbol':'1.2-2'}} </td>
      </ng-container>

      <!-- Status Column -->
      <ng-container matColumnDef="status">
        <th mat-header-cell *matHeaderCellDef mat-sort-header> Status </th>
        <td mat-cell *matCellDef="let order" [ngClass]="'status-' + order.status.toLowerCase().replace('_', '-')">
          {{ formatStatus(order.status) }}
        </td>
      </ng-container>

      <!-- Actions Column -->
      <ng-container matColumnDef="actions">
        <th mat-header-cell *matHeaderCellDef> Acțiuni </th>
        <td mat-cell *matCellDef="let order">
          <button mat-icon-button color="primary" [routerLink]="['/admin/orders', order.id]" aria-label="Vezi detalii comandă">
            <mat-icon>visibility</mat-icon>
          </button>
        </td>
      </ng-container>

      <tr mat-header-row *matHeaderRowDef="displayedColumns"></tr>
      <tr mat-row *matRowDef="let row; columns: displayedColumns;"></tr>

      <tr class="mat-row" *matNoDataRow>
        <td class="mat-cell" [attr.colspan]="displayedColumns.length">
          Nu s-au găsit comenzi care să corespundă filtrului text "{{dataSource.filter}}".
        </td>
      </tr>
    </table>

    <mat-paginator [pageSizeOptions]="[5, 10, 25, 100]" showFirstLastButtons aria-label="Selectează pagina de comenzi"></mat-paginator>
  </div>
</div>
</file>

<file path="frontend/src/app/features/admin/admin-orders/admin-order-list/admin-order-list.component.scss">
// src/app/features/admin/admin-orders/admin-order-list/admin-order-list.component.scss
.admin-order-list-container {
  padding: 20px;
  max-width: 1200px; // Lățime mai mare pentru tabele
  margin: auto;
}

.header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;

  h2 {
    margin: 0;
  }
}

.filter-field, .status-filter-field {
  width: 100%;
  max-width: 400px; // Limitează lățimea câmpului de filtrare
  margin-right: 16px; // Spațiu între filtre dacă sunt pe aceeași linie
  margin-bottom: 16px;
}

.status-filter-field {
   min-width: 200px;
}


.loading-indicator,
.error-message,
.no-data {
  text-align: center;
  padding: 20px;
  color: #757575;
  mat-spinner {
    margin: 0 auto 10px auto;
  }
}

.error-message {
  color: #f44336;
}

.table-container {
  overflow-x: auto; // Permite scroll orizontal pe ecrane mici
  margin-top: 20px;
}

table {
  width: 100%;
}

.mat-column-actions {
  width: 120px; // Spațiu pentru butoane de acțiune
  text-align: right;
}

.mat-column-id {
  width: 100px;
}
.mat-column-totalAmount {
  width: 150px;
  text-align: right;
}
.mat-column-status {
  width: 200px;
  font-weight: 500;
}

// Stiluri pentru statusuri (opțional, pentru vizibilitate)
.status-pending_confirmation { color: #FFC107; } // Amber
.status-approved { color: #4CAF50; } // Green
.status-processing { color: #2196F3; } // Blue
.status-shipped { color: #00BCD4; } // Cyan
.status-delivered { color: #8BC34A; } // Light Green
.status-canceled { color: #F44336; } // Red

.mat-row:hover {
  background-color: rgba(0,0,0,0.04);
}
</file>

<file path="frontend/src/app/features/admin/admin-orders/admin-order-list/admin-order-list.component.ts">
// src/app/features/admin/admin-orders/admin-order-list/admin-order-list.component.ts
import { Component, OnInit, inject, ViewChild, AfterViewInit } from '@angular/core';
import { CommonModule, DatePipe } from '@angular/common';
import { RouterModule } from '@angular/router';
import { MatTableDataSource, MatTableModule } from '@angular/material/table';
import { MatPaginator, MatPaginatorModule } from '@angular/material/paginator';
import { MatSort, MatSortModule } from '@angular/material/sort';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { MatSelectModule } from '@angular/material/select';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar';
import { FormsModule } from '@angular/forms'; // Pentru ngModel

import { Order } from '../../../../shared/models/order.model';
import { OrderAdminService } from '../../services/order.admin.service';

@Component({
  selector: 'app-admin-order-list',
  standalone: true,
  imports: [
    CommonModule,
    RouterModule,
    FormsModule, // Adăugat FormsModule pentru ngModel
    MatTableModule,
    MatPaginatorModule,
    MatSortModule,
    MatFormFieldModule,
    MatInputModule,
    MatSelectModule,
    MatButtonModule,
    MatIconModule,
    MatProgressSpinnerModule,
    MatSnackBarModule,
    DatePipe
  ],
  templateUrl: './admin-order-list.component.html',
  styleUrls: ['./admin-order-list.component.scss']
})
export class AdminOrderListComponent implements OnInit, AfterViewInit {
  displayedColumns: string[] = ['id', 'customerName', 'orderDate', 'totalAmount', 'status', 'actions'];
  dataSource: MatTableDataSource<Order> = new MatTableDataSource();
  isLoading = true;
  error: string | null = null;

  statusFilter: string = ''; // Inițializat cu string gol sau 'ALL'
  // Lista completă de statusuri, inclusiv 'ALL' pentru a reseta filtrul
  readonly availableStatuses: string[] = ['PENDING_CONFIRMATION', 'APPROVED', 'PROCESSING', 'SHIPPED', 'DELIVERED', 'CANCELED', 'ALL'];

  @ViewChild(MatPaginator) paginator!: MatPaginator;
  @ViewChild(MatSort) sort!: MatSort;

  private orderService = inject(OrderAdminService);
  private snackBar = inject(MatSnackBar);

  ngOnInit(): void {
    this.loadOrders();
  }

  ngAfterViewInit(): void {
    this.dataSource.paginator = this.paginator;
    this.dataSource.sort = this.sort;
    // Custom sort pentru data și status (dacă este necesar pentru stringuri complexe)
    this.dataSource.sortingDataAccessor = (item, property) => {
      switch (property) {
        case 'orderDate': return new Date(item.orderDate || 0).getTime();
        case 'status': return this.formatStatus(item.status); // Sortează după statusul formatat
        default: return (item as any)[property];
      }
    };
  }

  /**
   * Getter pentru lista de statusuri care vor fi afișate în dropdown-ul de filtrare.
   * Exclude opțiunea 'ALL' din iterația directă, deoarece este gestionată separat.
   */
  get statusesForFilterDropdown(): string[] {
    return this.availableStatuses.filter(s => s !== 'ALL');
  }

  loadOrders(): void {
    this.isLoading = true;
    this.error = null;
    // Dacă statusFilter este 'ALL', trimitem undefined sau string gol la serviciu
    // pentru a prelua toate comenzile, în funcție de cum este implementat backend-ul/serviciul.
    const filterToSend = (this.statusFilter === 'ALL' || this.statusFilter === '') ? undefined : this.statusFilter;

    this.orderService.getAllOrders(filterToSend).subscribe({
      next: (data) => {
        this.dataSource.data = data;
        // Paginatorul și sortarea sunt deja setate în ngAfterViewInit
        // this.dataSource.paginator = this.paginator; // Nu este nevoie aici dacă e în ngAfterViewInit
        // this.dataSource.sort = this.sort;         // Nu este nevoie aici
        this.isLoading = false;
      },
      error: (err) => {
        this.error = 'Nu s-au putut încărca comenzile.';
        const errMsg = err.error?.message || err.message || 'Eroare necunoscută.';
        console.error('Eroare la încărcarea comenzilor:', err);
        this.isLoading = false;
        this.snackBar.open(`${this.error} ${errMsg}`, 'Închide', { duration: 5000 });
      }
    });
  }

  applyFilter(event: Event): void {
    const filterValue = (event.target as HTMLInputElement).value;
    this.dataSource.filter = filterValue.trim().toLowerCase();

    if (this.dataSource.paginator) {
      this.dataSource.paginator.firstPage();
    }
  }

  onStatusFilterChange(): void {
    this.loadOrders();
    if (this.dataSource.paginator) {
      this.dataSource.paginator.firstPage(); // Resetează paginatorul la schimbarea filtrului
    }
  }

  formatStatus(status: string): string {
    if (!status) return '';
    return status.replace(/_/g, ' ').toLowerCase().replace(/\b\w/g, l => l.toUpperCase());
  }
}
</file>

<file path="frontend/src/app/features/admin/admin-specifications/admin-spec-def-form/admin-spec-def-form.component.html">
<div class="admin-spec-def-form-container">
  <mat-card>
    <mat-card-header>
      <mat-card-title>{{ pageTitle }}</mat-card-title>
    </mat-card-header>
    <mat-card-content>
      <div *ngIf="isLoading && isEditMode" class="spinner-container">
        <mat-progress-spinner diameter="50" mode="indeterminate"></mat-progress-spinner>
        <p>Se încarcă datele...</p>
      </div>

      <form [formGroup]="specDefForm" (ngSubmit)="onSubmit()" *ngIf="!isLoading || !isEditMode">
        <mat-form-field appearance="outline" class="full-width">
          <mat-label>Nume Specificație</mat-label>
          <input matInput formControlName="name" placeholder="Ex: Procesor, Memorie RAM, Culoare" required>
          <mat-error *ngIf="f['name'].hasError('required')">Numele este obligatoriu.</mat-error>
          <mat-error *ngIf="f['name'].hasError('minlength')">Minim 2 caractere.</mat-error>
          <mat-error *ngIf="f['name'].hasError('maxlength')">Maxim 100 caractere.</mat-error>
        </mat-form-field>

        <mat-form-field appearance="outline" class="full-width">
          <mat-label>Unitate de Măsură (Opțional)</mat-label>
          <input matInput formControlName="unit" placeholder="Ex: GB, MHz, cm, kg">
           <mat-error *ngIf="f['unit'].hasError('maxlength')">Maxim 50 caractere.</mat-error>
        </mat-form-field>

        <div class="form-actions">
          <button mat-stroked-button color="warn" type="button" routerLink="/admin/specification-definitions" [disabled]="isLoading">
            <mat-icon>cancel</mat-icon> Anulează
          </button>
          <button mat-raised-button color="primary" type="submit" [disabled]="isLoading || specDefForm.invalid">
            <mat-icon *ngIf="!isLoading">save</mat-icon>
            <mat-progress-spinner *ngIf="isLoading" diameter="20" mode="indeterminate" style="margin-right: 8px; display: inline-block;"></mat-progress-spinner>
            {{ isLoading ? 'Se salvează...' : submitButtonText }}
          </button>
        </div>
      </form>
    </mat-card-content>
  </mat-card>
</div>
</file>

<file path="frontend/src/app/features/admin/admin-specifications/admin-spec-def-form/admin-spec-def-form.component.scss">
// src/app/features/admin/admin-specifications/admin-spec-def-form/admin-spec-def-form.component.scss
.admin-spec-def-form-container {
  padding: 20px;
  max-width: 600px;
  margin: 20px auto;
}

mat-card-header {
  padding-bottom: 16px;
}

.full-width {
  width: 100%;
  margin-bottom: 16px;
}

.spinner-container {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  min-height: 150px;
  p {
    margin-top: 10px;
    color: #757575;
  }
}

.form-actions {
  display: flex;
  justify-content: flex-end;
  gap: 10px;
  margin-top: 20px;
  button {
    min-width: 120px;
    mat-icon {
      margin-right: 8px;
    }
  }
}

mat-error {
  font-size: 0.85em;
}
</file>

<file path="frontend/src/app/features/admin/admin-specifications/admin-spec-def-form/admin-spec-def-form.component.ts">
// src/app/features/admin/admin-specifications/admin-spec-def-form/admin-spec-def-form.component.ts
import { Component, OnInit, inject } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ReactiveFormsModule, FormBuilder, FormGroup, Validators } from '@angular/forms';
import { ActivatedRoute, Router, RouterModule } from '@angular/router';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { MatButtonModule } from '@angular/material/button';
import { MatCardModule } from '@angular/material/card';
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { MatIconModule } from '@angular/material/icon';

import { SpecificationDefinition } from '../../../../shared/models/specification-definition.model';
import { SpecificationAdminService } from '../../services/specification-admin.service';

@Component({
  selector: 'app-admin-spec-def-form',
  standalone: true,
  imports: [
    CommonModule,
    RouterModule,
    ReactiveFormsModule,
    MatFormFieldModule,
    MatInputModule,
    MatButtonModule,
    MatCardModule,
    MatSnackBarModule,
    MatProgressSpinnerModule,
    MatIconModule
  ],
  templateUrl: './admin-spec-def-form.component.html',
  styleUrls: ['./admin-spec-def-form.component.scss']
})
export class AdminSpecDefFormComponent implements OnInit {
  specDefForm!: FormGroup;
  isEditMode = false;
  specDefId?: number;
  isLoading = false;
  pageTitle = 'Adaugă Definiție Specificație';
  submitButtonText = 'Salvează Definiție';

  private fb = inject(FormBuilder);
  private specAdminService = inject(SpecificationAdminService);
  private route = inject(ActivatedRoute);
  private router = inject(Router);
  private snackBar = inject(MatSnackBar);

  ngOnInit(): void {
    this.specDefForm = this.fb.group({
      name: ['', [Validators.required, Validators.minLength(2), Validators.maxLength(100)]],
      unit: ['', [Validators.maxLength(50)]] // Unitatea este opțională
    });

    const idFromRoute = this.route.snapshot.paramMap.get('id');
    if (idFromRoute) {
      this.specDefId = +idFromRoute;
      if (!isNaN(this.specDefId) && this.specDefId > 0) {
        this.isEditMode = true;
        this.pageTitle = 'Editează Definiție Specificație';
        this.submitButtonText = 'Actualizează Definiție';
        this.loadSpecDefData(this.specDefId);
      } else {
        this.handleInvalidId('ID definiție specificație invalid din rută.');
      }
    }
  }

  loadSpecDefData(id: number): void {
    this.isLoading = true;
    this.specAdminService.getDefinitionById(id).subscribe({
      next: (specDef) => {
        this.specDefForm.patchValue(specDef);
        this.isLoading = false;
      },
      error: (err) => this.handleLoadError('Eroare la încărcarea datelor definiției.', err)
    });
  }

  onSubmit(): void {
    if (this.specDefForm.invalid) {
      this.snackBar.open('Formular invalid. Verificați câmpurile.', 'OK', { duration: 3000 });
      this.specDefForm.markAllAsTouched();
      return;
    }
    this.isLoading = true;
    const specDefData: SpecificationDefinition = this.specDefForm.value;

    const operation = this.isEditMode && this.specDefId
      ? this.specAdminService.updateDefinition(this.specDefId, { ...specDefData, id: this.specDefId })
      : this.specAdminService.createDefinition(specDefData as Omit<SpecificationDefinition, 'id'>);

    operation.subscribe({
      next: () => {
        this.isLoading = false;
        this.snackBar.open(`Definiție specificație ${this.isEditMode ? 'actualizată' : 'creată'} cu succes!`, 'OK', { duration: 3000 });
        this.router.navigate(['/admin/specification-definitions']);
      },
      error: (err) => this.handleSubmitError(`Eroare la ${this.isEditMode ? 'actualizarea' : 'crearea'} definiției.`, err)
    });
  }
  
  private handleInvalidId(message: string): void {
    this.isLoading = false;
    this.snackBar.open(message, 'Închide', { duration: 3000 });
    this.router.navigate(['/admin/specification-definitions']);
  }

  private handleLoadError(message: string, err: any): void {
    this.isLoading = false;
    const errMsg = err.error?.message || err.message || 'Eroare necunoscută.';
    this.snackBar.open(`${message} ${errMsg}`, 'Închide', { duration: 5000 });
    console.error(err);
    this.router.navigate(['/admin/specification-definitions']);
  }

  private handleSubmitError(message: string, err: any): void {
    this.isLoading = false;
    const errMsg = err.error?.message || err.message || 'Eroare necunoscută.';
    this.snackBar.open(`${message} ${errMsg}`, 'Închide', { duration: 5000 });
    console.error(err);
  }

  get f() { return this.specDefForm.controls; }
}
</file>

<file path="frontend/src/app/features/admin/admin-specifications/admin-spec-def-list/admin-spec-def-list.component.html">
<div class="admin-spec-def-list-container">
  <div class="header">
    <h2>Administrare Definiții Specificații</h2>
    <button mat-raised-button color="primary" routerLink="/admin/specification-definitions/new">
      <mat-icon>add_circle_outline</mat-icon> Adaugă Definiție Nouă
    </button>
  </div>

  <mat-form-field appearance="outline" class="filter-field">
    <mat-label>Filtrează definiții</mat-label>
    <input matInput (keyup)="applyFilter($event)" placeholder="Caută după nume, unitate...">
    <mat-icon matSuffix>search</mat-icon>
  </mat-form-field>

  <div *ngIf="isLoading" class="loading-indicator">
    <mat-spinner diameter="50"></mat-spinner>
    <p>Se încarcă definițiile specificațiilor...</p>
  </div>

  <div *ngIf="error && !isLoading" class="error-message">
    <p>{{ error }}</p>
    <button mat-stroked-button color="warn" (click)="loadSpecDefinitions()">Reîncearcă</button>
  </div>

  <div *ngIf="!isLoading && !error && dataSource.data.length === 0" class="no-data">
    <p>Nu există definiții de specificații.</p>
  </div>

  <div class="table-container" *ngIf="!isLoading && !error && dataSource.data.length > 0">
    <table mat-table [dataSource]="dataSource" matSort class="mat-elevation-z8">

      <ng-container matColumnDef="id">
        <th mat-header-cell *matHeaderCellDef mat-sort-header> ID </th>
        <td mat-cell *matCellDef="let specDef"> {{specDef.id}} </td>
      </ng-container>

      <ng-container matColumnDef="name">
        <th mat-header-cell *matHeaderCellDef mat-sort-header> Nume Specificație </th>
        <td mat-cell *matCellDef="let specDef"> {{specDef.name}} </td>
      </ng-container>

      <ng-container matColumnDef="unit">
        <th mat-header-cell *matHeaderCellDef mat-sort-header> Unitate </th>
        <td mat-cell *matCellDef="let specDef"> {{specDef.unit || 'N/A'}} </td>
      </ng-container>

      <ng-container matColumnDef="actions">
        <th mat-header-cell *matHeaderCellDef> Acțiuni </th>
        <td mat-cell *matCellDef="let specDef">
          <button mat-icon-button color="primary" [routerLink]="['/admin/specification-definitions/edit', specDef.id]" aria-label="Editează definiția">
            <mat-icon>edit</mat-icon>
          </button>
          <button mat-icon-button color="warn" (click)="deleteSpecDefinition(specDef.id!)" aria-label="Șterge definiția">
            <mat-icon>delete</mat-icon>
          </button>
        </td>
      </ng-container>

      <tr mat-header-row *matHeaderRowDef="displayedColumns"></tr>
      <tr mat-row *matRowDef="let row; columns: displayedColumns;"></tr>

      <tr class="mat-row" *matNoDataRow>
        <td class="mat-cell" [attr.colspan]="displayedColumns.length">
          Nu s-au găsit definiții care să corespundă filtrului "{{dataSource.filter}}".
        </td>
      </tr>
    </table>
    <mat-paginator [pageSizeOptions]="[5, 10, 25, 50]" showFirstLastButtons aria-label="Selectează pagina de definiții"></mat-paginator>
  </div>
</div>
</file>

<file path="frontend/src/app/features/admin/admin-specifications/admin-spec-def-list/admin-spec-def-list.component.scss">
// src/app/features/admin/admin-specifications/admin-spec-def-list/admin-spec-def-list.component.scss
.admin-spec-def-list-container {
  padding: 20px;
  max-width: 900px; // Lățime adecvată pentru tabel
  margin: auto;
}

.header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
  h2 {
    margin: 0;
  }
  button mat-icon {
    margin-right: 8px;
  }
}

.filter-field {
  width: 100%;
  max-width: 400px;
  margin-bottom: 20px;
}

.loading-indicator,
.error-message,
.no-data {
  text-align: center;
  padding: 20px;
  color: #757575;
  mat-spinner {
    margin: 0 auto 10px auto;
  }
}

.error-message {
  color: #f44336; // Material Red
}

.table-container {
  overflow-x: auto;
  margin-top: 10px;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

table {
  width: 100%;
}

.mat-column-actions {
  width: 120px;
  text-align: right;
}

.mat-column-id {
  max-width: 80px;
}
.mat-column-unit {
  max-width: 150px;
}

.mat-header-cell {
  font-weight: 500;
  color: rgba(0,0,0,0.67);
}

.mat-row:hover {
  background-color: rgba(0,0,0,0.03);
}

.mat-cell, .mat-header-cell {
  padding: 8px 16px;
}
</file>

<file path="frontend/src/app/features/admin/admin-specifications/admin-spec-def-list/admin-spec-def-list.component.ts">
// src/app/features/admin/admin-specifications/admin-spec-def-list/admin-spec-def-list.component.ts
import { Component, OnInit, inject, ViewChild, AfterViewInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { RouterModule } from '@angular/router';
import { MatTableDataSource, MatTableModule } from '@angular/material/table';
import { MatPaginator, MatPaginatorModule } from '@angular/material/paginator';
import { MatSort, MatSortModule } from '@angular/material/sort';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar';
import { MatDialog } from '@angular/material/dialog'; // Pentru confirmare ștergere

import { SpecificationDefinition } from '../../../../shared/models/specification-definition.model';
import { SpecificationAdminService } from '../../services/specification-admin.service';
// import { ConfirmDialogComponent } from '../../../../shared/components/confirm-dialog/confirm-dialog.component'; // Dialog de confirmare

@Component({
  selector: 'app-admin-spec-def-list',
  standalone: true,
  imports: [
    CommonModule,
    RouterModule,
    MatTableModule,
    MatPaginatorModule,
    MatSortModule,
    MatFormFieldModule,
    MatInputModule,
    MatButtonModule,
    MatIconModule,
    MatProgressSpinnerModule,
    MatSnackBarModule
  ],
  templateUrl: './admin-spec-def-list.component.html',
  styleUrls: ['./admin-spec-def-list.component.scss']
})
export class AdminSpecDefListComponent implements OnInit, AfterViewInit {
  displayedColumns: string[] = ['id', 'name', 'unit', 'actions'];
  dataSource: MatTableDataSource<SpecificationDefinition> = new MatTableDataSource();
  isLoading = true;
  error: string | null = null;

  @ViewChild(MatPaginator) paginator!: MatPaginator;
  @ViewChild(MatSort) sort!: MatSort;

  private specAdminService = inject(SpecificationAdminService);
  private snackBar = inject(MatSnackBar);
  // private dialog = inject(MatDialog); // Decomentează dacă folosești MatDialog

  ngOnInit(): void {
    this.loadSpecDefinitions();
  }

  ngAfterViewInit(): void {
    this.dataSource.paginator = this.paginator;
    this.dataSource.sort = this.sort;
  }

  loadSpecDefinitions(): void {
    this.isLoading = true;
    this.error = null;
    this.specAdminService.getAllDefinitions().subscribe({
      next: (data) => {
        this.dataSource.data = data;
        this.isLoading = false;
      },
      error: (err) => {
        this.error = 'Nu s-au putut încărca definițiile specificațiilor.';
        console.error(err);
        this.isLoading = false;
        this.snackBar.open(this.error, 'Închide', { duration: 5000 });
      }
    });
  }

  applyFilter(event: Event): void {
    const filterValue = (event.target as HTMLInputElement).value;
    this.dataSource.filter = filterValue.trim().toLowerCase();
    if (this.dataSource.paginator) {
      this.dataSource.paginator.firstPage();
    }
  }

  deleteSpecDefinition(specDefId: number): void {
    // TODO: Implementează un dialog de confirmare (MatDialog)
    const confirmation = window.confirm('Sunteți sigur că doriți să ștergeți această definiție de specificație? Aceasta ar putea afecta produsele existente.');
    if (confirmation) {
      this.specAdminService.deleteDefinition(specDefId).subscribe({
        next: () => {
          this.snackBar.open('Definiție specificație ștearsă cu succes!', 'OK', { duration: 3000 });
          this.loadSpecDefinitions(); // Reîncarcă lista
        },
        error: (err) => {
          const errMsg = err.error?.message || err.message || 'Eroare la ștergerea definiției specificației.';
          this.snackBar.open(errMsg, 'Închide', { duration: 5000 });
          console.error(err);
        }
      });
    }
  }
}
</file>

<file path="frontend/src/app/features/admin/admin-users/admin-user-form/admin-user-form.component.html">
<!-- src/app/features/admin/admin-users/admin-user-form/admin-user-form.component.html -->
<div class="admin-user-form-container">
  <mat-card>
    <mat-card-header>
      <mat-card-title>{{ pageTitle }}</mat-card-title>
      <!-- Corectat: userToEdit.username deoarece *ngIf="userToEdit" este prezent -->
      <mat-card-subtitle *ngIf="userToEdit">Modifici datele pentru: {{ userToEdit.username }}</mat-card-subtitle>
    </mat-card-header>
    <mat-card-content>
      <div *ngIf="isLoading && userId" class="spinner-container">
        <mat-progress-spinner diameter="50" mode="indeterminate"></mat-progress-spinner>
        <p>Se încarcă datele utilizatorului...</p>
      </div>

      <form [formGroup]="userForm" (ngSubmit)="onSubmit()" *ngIf="!isLoading || !userId">
        <mat-form-field appearance="outline" class="full-width">
          <mat-label>Username</mat-label>
          <input matInput formControlName="username" readonly>
          <mat-icon matSuffix>person_outline</mat-icon>
          <mat-hint>Username-ul nu poate fi modificat.</mat-hint>
        </mat-form-field>

        <mat-form-field appearance="outline" class="full-width">
          <mat-label>Adresă Email</mat-label>
          <input matInput type="email" formControlName="email" required>
          <mat-icon matSuffix>email</mat-icon>
          <mat-error *ngIf="userForm.get('email')?.hasError('required')">Email-ul este obligatoriu.</mat-error>
          <mat-error *ngIf="userForm.get('email')?.hasError('email')">Format email invalid.</mat-error>
          <mat-error *ngIf="userForm.get('email')?.hasError('maxlength')">Email-ul nu poate depăși 100 de caractere.</mat-error>
        </mat-form-field>

        <mat-form-field appearance="outline" class="full-width">
          <mat-label>Roluri Utilizator</mat-label>
          <mat-select formControlName="selectedRoles" multiple>
            <mat-option *ngFor="let role of availableRoles" [value]="role">
              {{ role.replace('ROLE_', '') }}
            </mat-option>
          </mat-select>
          <mat-error *ngIf="userForm.get('selectedRoles')?.hasError('required') && (userForm.get('selectedRoles')?.touched || userForm.get('selectedRoles')?.dirty)">
            Cel puțin un rol trebuie selectat.
          </mat-error>
           <mat-hint *ngIf="userId === currentUserId">Atenție: Nu vă puteți elimina propriul rol de Administrator.</mat-hint>
        </mat-form-field>

        <div class="form-actions">
          <button mat-stroked-button color="warn" type="button" routerLink="/admin/users" [disabled]="isLoading">
            <mat-icon>cancel</mat-icon> Anulează
          </button>
          <button mat-raised-button color="primary" type="submit" [disabled]="isLoading || userForm.invalid">
            <mat-icon *ngIf="!isLoading">save</mat-icon>
            <mat-progress-spinner *ngIf="isLoading" diameter="20" mode="indeterminate" style="margin-right: 8px; display: inline-block;"></mat-progress-spinner>
            {{ isLoading ? 'Se actualizează...' : submitButtonText }}
          </button>
        </div>
      </form>
    </mat-card-content>
  </mat-card>
</div>
</file>

<file path="frontend/src/app/features/admin/admin-users/admin-user-form/admin-user-form.component.scss">
// src/app/features/admin/admin-users/admin-user-form/admin-user-form.component.scss
.admin-user-form-container {
  padding: 20px;
  max-width: 700px; // Lățime adecvată pentru formular
  margin: 20px auto;
}

mat-card-header {
  padding-bottom: 16px;
}

.full-width {
  width: 100%;
  margin-bottom: 16px;
}

.spinner-container {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  min-height: 150px;
  p {
    margin-top: 10px;
    color: #757575;
  }
}

// Stiluri pentru grupul de checkbox-uri (dacă se alege această variantă)
.roles-checkbox-group {
  margin-bottom: 16px;
  .roles-label {
    display: block;
    margin-bottom: 8px;
    font-weight: 500;
    color: rgba(0,0,0,.54); // Culoare similară cu mat-label
  }
  .role-checkbox {
    margin-right: 16px;
  }
}


.form-actions {
  display: flex;
  justify-content: flex-end;
  gap: 10px;
  margin-top: 20px;
  button {
    min-width: 120px;
    mat-icon {
      margin-right: 8px;
    }
  }
}

mat-error {
  font-size: 0.85em;
}
</file>

<file path="frontend/src/app/features/admin/admin-users/admin-user-form/admin-user-form.component.ts">
// src/app/features/admin/admin-users/admin-user-form/admin-user-form.component.ts
import { Component, OnInit, inject } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ReactiveFormsModule, FormBuilder, FormGroup, Validators, FormControl } from '@angular/forms'; // Import FormControl
import { ActivatedRoute, Router, RouterModule } from '@angular/router';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { MatButtonModule } from '@angular/material/button';
import { MatCardModule } from '@angular/material/card';
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { MatIconModule } from '@angular/material/icon';
import { MatSelectModule } from '@angular/material/select';
import { MatCheckboxModule } from '@angular/material/checkbox';
import { HttpErrorResponse } from '@angular/common/http';


import { User, UserUpdateDto } from '../../../../shared/models/user.model';
import { UserAdminService } from '../../services/user-admin.service';
import { AuthService } from '../../../../auth/auth.service';

@Component({
  selector: 'app-admin-user-form',
  standalone: true,
  imports: [
    CommonModule,
    RouterModule,
    ReactiveFormsModule,
    MatFormFieldModule,
    MatInputModule,
    MatButtonModule,
    MatCardModule,
    MatSnackBarModule,
    MatProgressSpinnerModule,
    MatIconModule,
    MatSelectModule,
    MatCheckboxModule
  ],
  templateUrl: './admin-user-form.component.html',
  styleUrls: ['./admin-user-form.component.scss']
})
export class AdminUserFormComponent implements OnInit {
  userForm!: FormGroup;
  userId!: number;
  isLoading = false;
  pageTitle = 'Editează Utilizator';
  submitButtonText = 'Actualizează Utilizator';
  userToEdit: User | null = null;
  error: string | null = null; // Adăugat pentru a stoca mesajul de eroare

  availableRoles: string[] = ['ROLE_USER', 'ROLE_ADMIN'];
  currentUserId: number | null = null;

  private fb = inject(FormBuilder);
  private userAdminService = inject(UserAdminService);
  private route = inject(ActivatedRoute);
  private router = inject(Router);
  private snackBar = inject(MatSnackBar);
  private authService = inject(AuthService);

  ngOnInit(): void {
    this.userForm = this.fb.group({
      username: [{ value: '', disabled: true }],
      email: ['', [Validators.required, Validators.email, Validators.maxLength(100)]],
      // Folosim un FormControl care va ține un array de string-uri pentru MatSelect multiple
      selectedRoles: new FormControl([] as string[], Validators.required) // <<< CORECTAT
    });

    const idFromRoute = this.route.snapshot.paramMap.get('id');
    if (idFromRoute) {
      this.userId = +idFromRoute;
      if (!isNaN(this.userId) && this.userId > 0) {
        this.loadUserData(this.userId);
      } else {
        this.handleInvalidId('ID utilizator invalid din rută.');
      }
    } else {
      this.handleInvalidId('ID utilizator lipsă din rută.');
    }

    const currentUser = this.authService.getCurrentUser();
     if (currentUser && currentUser.id) {
        this.currentUserId = currentUser.id;
    }
  }

  loadUserData(id: number): void {
    this.isLoading = true;
    this.userAdminService.getUserById(id).subscribe({
      next: (user: User) => { // Tipare explicită
        this.userToEdit = user;
        this.userForm.patchValue({
          username: user.username,
          email: user.email,
          // Setează valoarea pentru FormControl-ul de roluri
          selectedRoles: user.roles || [] // <<< CORECTAT
        });
        this.isLoading = false;
      },
      error: (err: HttpErrorResponse) => this.handleLoadError('Eroare la încărcarea datelor utilizatorului.', err) // Tipare explicită
    });
  }

  onSubmit(): void {
    if (this.userForm.invalid) {
      this.snackBar.open('Formular invalid. Verificați câmpurile.', 'OK', { duration: 3000 });
      this.userForm.markAllAsTouched();
      return;
    }

    const selectedRolesValue = this.userForm.get('selectedRoles')?.value as string[];

    if (this.userId === this.currentUserId) {
        if (!selectedRolesValue.includes('ROLE_ADMIN')) {
            this.snackBar.open('Nu vă puteți elimina propriul rol de Administrator.', 'OK', {duration: 5000});
            return;
        }
    }

    this.isLoading = true;
    const userData: UserUpdateDto = {
      email: this.userForm.get('email')?.value,
      roles: selectedRolesValue // <<< CORECTAT: Preia valorile din FormControl
    };

    this.userAdminService.updateUser(this.userId, userData).subscribe({
      next: () => {
        this.isLoading = false;
        this.snackBar.open('Utilizator actualizat cu succes!', 'OK', { duration: 3000 });
        this.router.navigate(['/admin/users']);
      },
      error: (err: HttpErrorResponse) => this.handleSubmitError('Eroare la actualizarea utilizatorului.', err) // Tipare explicită
    });
  }
  
  private handleInvalidId(message: string): void {
    this.isLoading = false;
    this.error = message;
    this.snackBar.open(this.error, 'Închide', { duration: 3000 });
    this.router.navigate(['/admin/users']);
  }

  private handleLoadError(message: string, err: HttpErrorResponse): void {
    this.isLoading = false;
    const serverErrorMessage = err.error?.message || err.message || 'Eroare necunoscută.';
    this.error = `${message} ${serverErrorMessage}`;
    this.snackBar.open(this.error, 'Închide', { duration: 5000 });
    console.error(err);
    this.router.navigate(['/admin/users']);
  }

  private handleSubmitError(message: string, err: HttpErrorResponse): void {
    this.isLoading = false;
    const serverErrorMessage = err.error?.message || err.message || 'Eroare necunoscută.';
    this.snackBar.open(`${message} ${serverErrorMessage}`, 'Închide', { duration: 5000 });
    console.error(err);
  }

  get f() { return this.userForm.controls; }
}
</file>

<file path="frontend/src/app/features/admin/admin-users/admin-user-list/admin-user-list.component.html">
<div class="admin-user-list-container">
  <div class="header">
    <h2>Administrare Utilizatori</h2>
    <!-- <button mat-raised-button color="primary" routerLink="/admin/users/new">
      <mat-icon>person_add</mat-icon> Adaugă Utilizator Nou
    </button> -->
  </div>

  <mat-form-field appearance="outline" class="filter-field">
    <mat-label>Filtrează utilizatori</mat-label>
    <input matInput (keyup)="applyFilter($event)" placeholder="Caută după username, email...">
    <mat-icon matSuffix>search</mat-icon>
  </mat-form-field>

  <div *ngIf="isLoading" class="loading-indicator">
    <mat-spinner diameter="50"></mat-spinner>
    <p>Se încarcă utilizatorii...</p>
  </div>

  <div *ngIf="error && !isLoading" class="error-message">
    <p>{{ error }}</p>
    <button mat-stroked-button color="warn" (click)="loadUsers()">Reîncearcă</button>
  </div>

  <div *ngIf="!isLoading && !error && dataSource.data.length === 0" class="no-data">
    <p>Nu există utilizatori înregistrați sau care să corespundă filtrului.</p>
  </div>

  <div class="table-container" *ngIf="!isLoading && !error && dataSource.data.length > 0">
    <table mat-table [dataSource]="dataSource" matSort class="mat-elevation-z8">

      <ng-container matColumnDef="id">
        <th mat-header-cell *matHeaderCellDef mat-sort-header> ID </th>
        <td mat-cell *matCellDef="let user"> {{user.id}} </td>
      </ng-container>

      <ng-container matColumnDef="username">
        <th mat-header-cell *matHeaderCellDef mat-sort-header> Username </th>
        <td mat-cell *matCellDef="let user"> {{user.username}} </td>
      </ng-container>

      <ng-container matColumnDef="email">
        <th mat-header-cell *matHeaderCellDef mat-sort-header> Email </th>
        <td mat-cell *matCellDef="let user"> {{user.email}} </td>
      </ng-container>

      <ng-container matColumnDef="roles">
        <th mat-header-cell *matHeaderCellDef mat-sort-header> Roluri </th>
        <td mat-cell *matCellDef="let user">
          <mat-chip-set aria-label="Roluri utilizator">
            <mat-chip *ngFor="let role of user.roles" [color]="role === 'ROLE_ADMIN' ? 'accent' : 'primary'" selected>
              {{ role.replace('ROLE_', '') }}
            </mat-chip>
          </mat-chip-set>
        </td>
      </ng-container>

      <ng-container matColumnDef="actions">
        <th mat-header-cell *matHeaderCellDef> Acțiuni </th>
        <td mat-cell *matCellDef="let user">
          <button mat-icon-button color="primary" [routerLink]="['/admin/users/edit', user.id]" aria-label="Editează utilizatorul">
            <mat-icon>edit</mat-icon>
          </button>
          <button mat-icon-button color="warn" (click)="deleteUser(user.id!, user.username)" [disabled]="user.id === currentUserId" aria-label="Șterge utilizatorul">
            <mat-icon>delete</mat-icon>
          </button>
        </td>
      </ng-container>

      <tr mat-header-row *matHeaderRowDef="displayedColumns"></tr>
      <tr mat-row *matRowDef="let row; columns: displayedColumns;"></tr>

      <tr class="mat-row" *matNoDataRow>
        <td class="mat-cell" [attr.colspan]="displayedColumns.length">
          Nu s-au găsit utilizatori care să corespundă filtrului "{{dataSource.filter}}".
        </td>
      </tr>
    </table>
    <mat-paginator [pageSizeOptions]="[5, 10, 25, 50]" showFirstLastButtons aria-label="Selectează pagina de utilizatori"></mat-paginator>
  </div>
</div>
</file>

<file path="frontend/src/app/features/admin/admin-users/admin-user-list/admin-user-list.component.scss">
// src/app/features/admin/admin-users/admin-user-list/admin-user-list.component.scss
.admin-user-list-container {
  padding: 20px;
  max-width: 1000px; // Lățime adecvată pentru tabelul de utilizatori
  margin: auto;
}

.header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
  h2 {
    margin: 0;
  }
}

.filter-field {
  width: 100%;
  max-width: 400px;
  margin-bottom: 20px;
}

.loading-indicator,
.error-message,
.no-data {
  text-align: center;
  padding: 20px;
  color: #757575;
  mat-spinner {
    margin: 0 auto 10px auto;
  }
}

.error-message {
  color: #f44336; // Material Red
}

.table-container {
  overflow-x: auto;
  margin-top: 10px;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

table {
  width: 100%;
}

.mat-column-actions {
  width: 120px; // Spațiu pentru 2 butoane icon
  text-align: right;
}

.mat-column-id {
  max-width: 80px;
}
.mat-column-roles {
  min-width: 150px; // Asigură spațiu pentru chip-uri
  mat-chip {
    margin-right: 4px;
    margin-bottom: 4px; // Pentru cazul în care se înfășoară
    font-size: 0.85em;
    padding: 4px 8px;
    height: 24px;
  }
}


.mat-header-cell {
  font-weight: 500;
  color: rgba(0,0,0,0.67);
}

.mat-row:hover {
  background-color: rgba(0,0,0,0.03);
}

.mat-cell, .mat-header-cell {
  padding: 8px 16px;
}
</file>

<file path="frontend/src/app/features/admin/admin-users/admin-user-list/admin-user-list.component.ts">
// src/app/features/admin/admin-users/admin-user-list/admin-user-list.component.ts
import { Component, OnInit, inject, ViewChild, AfterViewInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { RouterModule } from '@angular/router';
import { MatTableDataSource, MatTableModule } from '@angular/material/table';
import { MatPaginator, MatPaginatorModule } from '@angular/material/paginator';
import { MatSort, MatSortModule } from '@angular/material/sort';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar';
import { MatChipsModule } from '@angular/material/chips'; // Pentru afișarea rolurilor
import { MatDialog } from '@angular/material/dialog';
// import { ConfirmDialogComponent } from '../../../../shared/components/confirm-dialog/confirm-dialog.component';

import { User } from '../../../../shared/models/user.model';
import { UserAdminService } from '../../services/user-admin.service';
import { AuthService } from '../../../../auth/auth.service'; // Pentru a nu permite ștergerea userului curent

@Component({
  selector: 'app-admin-user-list',
  standalone: true,
  imports: [
    CommonModule,
    RouterModule,
    MatTableModule,
    MatPaginatorModule,
    MatSortModule,
    MatFormFieldModule,
    MatInputModule,
    MatButtonModule,
    MatIconModule,
    MatProgressSpinnerModule,
    MatSnackBarModule,
    MatChipsModule
  ],
  templateUrl: './admin-user-list.component.html',
  styleUrls: ['./admin-user-list.component.scss']
})
export class AdminUserListComponent implements OnInit, AfterViewInit {
  displayedColumns: string[] = ['id', 'username', 'email', 'roles', 'actions'];
  dataSource: MatTableDataSource<User> = new MatTableDataSource();
  isLoading = true;
  error: string | null = null;
  currentUserId: number | null = null;

  @ViewChild(MatPaginator) paginator!: MatPaginator;
  @ViewChild(MatSort) sort!: MatSort;

  private userAdminService = inject(UserAdminService);
  private snackBar = inject(MatSnackBar);
  private authService = inject(AuthService); // Injectează AuthService
  // private dialog = inject(MatDialog);

  ngOnInit(): void {
    this.loadUsers();
    // Obține ID-ul utilizatorului curent pentru a preveni auto-ștergerea
    const currentUser = this.authService.getCurrentUser(); // Presupunând că AuthService are această metodă
    if (currentUser && currentUser.id) {
        this.currentUserId = currentUser.id;
    }
  }

  ngAfterViewInit(): void {
    this.dataSource.paginator = this.paginator;
    this.dataSource.sort = this.sort;
    // Custom sort pentru roluri (array de string-uri)
    this.dataSource.sortingDataAccessor = (item, property) => {
      switch (property) {
        case 'roles': return item.roles.join(', ');
        default: return (item as any)[property];
      }
    };
  }

  loadUsers(): void {
    this.isLoading = true;
    this.error = null;
    this.userAdminService.getAllUsers().subscribe({
      next: (data) => {
        this.dataSource.data = data;
        this.isLoading = false;
      },
      error: (err) => {
        this.error = 'Nu s-au putut încărca utilizatorii.';
        console.error(err);
        this.isLoading = false;
        this.snackBar.open(this.error, 'Închide', { duration: 5000 });
      }
    });
  }

  applyFilter(event: Event): void {
    const filterValue = (event.target as HTMLInputElement).value;
    this.dataSource.filter = filterValue.trim().toLowerCase();
    if (this.dataSource.paginator) {
      this.dataSource.paginator.firstPage();
    }
  }

  deleteUser(userId: number, username: string): void {
    if (userId === this.currentUserId) {
      this.snackBar.open('Nu vă puteți șterge propriul cont de administrator.', 'OK', { duration: 5000 });
      return;
    }

    // TODO: Implementează un dialog de confirmare (MatDialog)
    const confirmation = window.confirm(`Sunteți sigur că doriți să ștergeți utilizatorul "${username}"?`);
    if (confirmation) {
      this.userAdminService.deleteUser(userId).subscribe({
        next: () => {
          this.snackBar.open(`Utilizatorul "${username}" a fost șters cu succes!`, 'OK', { duration: 3000 });
          this.loadUsers(); // Reîncarcă lista
        },
        error: (err) => {
          const errMsg = err.error?.message || err.message || `Eroare la ștergerea utilizatorului "${username}".`;
          this.snackBar.open(errMsg, 'Închide', { duration: 5000 });
          console.error(err);
        }
      });
    }
  }

  formatRoles(roles: string[]): string {
    return roles.map(role => role.replace('ROLE_', '')).join(', ');
  }
}
</file>

<file path="frontend/src/app/features/admin/services/category.admin.service.ts">
// src/app/features/admin/services/category.admin.service.ts
import { Injectable } from '@angular/core';
import { HttpClient, HttpErrorResponse } from '@angular/common/http';
import { Observable, throwError } from 'rxjs';
import { catchError } from 'rxjs/operators';
import { Category } from '../../../shared/models/category.model';


@Injectable({
  providedIn: 'root'
})
export class CategoryAdminService {
  private apiUrl = '/api/categories';

  constructor(private http: HttpClient) {}

  getAll(): Observable<Category[]> {
    return this.http.get<Category[]>(this.apiUrl)
      .pipe(catchError(this.handleError));
  }

  getById(id: number): Observable<Category> {
    return this.http.get<Category>(`${this.apiUrl}/${id}`)
      .pipe(catchError(this.handleError));
  }

  create(category: Category): Observable<Category> {
    return this.http.post<Category>(this.apiUrl, category)
      .pipe(catchError(this.handleError));
  }

  update(id: number, category: Category): Observable<Category> {
    return this.http.put<Category>(`${this.apiUrl}/${id}`, category)
      .pipe(catchError(this.handleError));
  }

  delete(id: number): Observable<void> {
    return this.http.delete<void>(`${this.apiUrl}/${id}`)
      .pipe(catchError(this.handleError));
  }

  private handleError(error: HttpErrorResponse) {
  let userFriendlyErrorMessage = 'A apărut o problemă. Vă rugăm încercați din nou mai târziu.';
  let detailedErrorMessage = 'Eroare necunoscută.';

  // Verificăm mai întâi dacă 'error.error' există și este un obiect (răspuns JSON de la server)
  if (error.error && typeof error.error === 'object' && error.error !== null) {
    // Încercăm să extragem un mesaj specific din corpul erorii trimis de backend
    // Acesta ar putea fi error.error.message, error.error.error, error.error.detail etc.
    // Ajustează în funcție de structura răspunsurilor de eroare de la API-ul tău Spring Boot
    detailedErrorMessage = 
        (error.error as any).message ||         // Cel mai comun (ex: MessageResponse din Spring)
        (error.error as any).detail ||          // Alt câmp comun pentru detalii eroare
        (error.error as any).error?.message ||  // Uneori eroarea e imbricată
        JSON.stringify(error.error);            // Fallback la JSON string dacă e un obiect complex

    // Poți încerca să faci mesajul user-friendly mai specific dacă backend-ul trimite un mesaj clar
    if ((error.error as any).message && typeof (error.error as any).message === 'string') {
      userFriendlyErrorMessage = (error.error as any).message;
    }
  } else if (typeof error.error === 'string') {
    // Corpul erorii de la server este un simplu string
    detailedErrorMessage = error.error;
    userFriendlyErrorMessage = error.error; 
  } else if (error.message) {
    // Eroare client-side sau de rețea (ex: HttpErrorResponse fără error.error, dar cu error.message)
    detailedErrorMessage = error.message;
    if (error.status === 0 || error.status === -1) { // Tipic pentru erori de rețea, CORS, sau server oprit
        userFriendlyErrorMessage = 'Eroare de conexiune cu serverul. Verificați rețeaua sau dacă serverul backend rulează.';
    } else {
        userFriendlyErrorMessage = `A apărut o eroare (${error.status}): ${error.statusText}`;
    }
  } else {
    // Fallback dacă structura erorii nu este cea așteptată
    detailedErrorMessage = `Cod eroare server: ${error.status}, status text: ${error.statusText || 'Necunoscut'}`;
    userFriendlyErrorMessage = `A apărut o eroare (${error.status}). Vă rugăm încercați mai târziu.`;
  }

  console.error('------------------------------------');
  console.error(`[SERVICE ERROR ENCOUNTERED]`);
  console.error(`URL: ${error.url}`);
  console.error(`Status: ${error.status} - ${error.statusText}`);
  console.error(`User-Friendly Message: ${userFriendlyErrorMessage}`);
  console.error(`Detailed Error Message/Body: ${detailedErrorMessage}`);
  console.error('Full HttpErrorResponse Object:', error);
  console.error('------------------------------------');

  // Aruncă o eroare care va fi propagată și poate fi prinsă în componentă
  // sau de un error handler global, dacă există.
  // Pentru utilizator, mesajele sunt de obicei afișate prin MatSnackBar în componentă/serviciu.
  return throwError(() => new Error(userFriendlyErrorMessage));
}
}
</file>

<file path="frontend/src/app/features/admin/services/order.admin.service.ts">
// src/app/features/admin/services/order.admin.service.ts
import { Injectable, inject } from '@angular/core';
import { HttpClient, HttpErrorResponse, HttpParams } from '@angular/common/http';
import { Observable, throwError } from 'rxjs';
import { catchError } from 'rxjs/operators';
import { Order } from '../../../shared/models/order.model';
import { OrderStatusUpdate } from '../../../shared/models/order-status-update.model'; // <<< CORECTAT

@Injectable({
  providedIn: 'root'
})
export class OrderAdminService {
  private apiUrl = '/api/orders';

  private http = inject(HttpClient);

  getAllOrders(statusFilter?: string): Observable<Order[]> {
    let params = new HttpParams();
    if (statusFilter && statusFilter.trim() !== '') {
      params = params.set('status', statusFilter);
    }
    return this.http.get<Order[]>(this.apiUrl, { params })
      .pipe(catchError(this.handleError));
  }

  getOrderById(orderId: number): Observable<Order> {
    return this.http.get<Order>(`${this.apiUrl}/${orderId}`)
      .pipe(catchError(this.handleError));
  }

  updateOrderStatus(orderId: number, statusUpdate: OrderStatusUpdate): Observable<Order> {
    return this.http.put<Order>(`${this.apiUrl}/${orderId}/status`, statusUpdate)
      .pipe(catchError(this.handleError));
  }

private handleError(error: HttpErrorResponse) {
  let userFriendlyErrorMessage = 'A apărut o problemă. Vă rugăm încercați din nou mai târziu.';
  let detailedErrorMessage = 'Eroare necunoscută.';

  // Verificăm mai întâi dacă 'error.error' există și este un obiect (răspuns JSON de la server)
  if (error.error && typeof error.error === 'object' && error.error !== null) {
    // Încercăm să extragem un mesaj specific din corpul erorii trimis de backend
    // Acesta ar putea fi error.error.message, error.error.error, error.error.detail etc.
    // Ajustează în funcție de structura răspunsurilor de eroare de la API-ul tău Spring Boot
    detailedErrorMessage = 
        (error.error as any).message ||         // Cel mai comun (ex: MessageResponse din Spring)
        (error.error as any).detail ||          // Alt câmp comun pentru detalii eroare
        (error.error as any).error?.message ||  // Uneori eroarea e imbricată
        JSON.stringify(error.error);            // Fallback la JSON string dacă e un obiect complex

    // Poți încerca să faci mesajul user-friendly mai specific dacă backend-ul trimite un mesaj clar
    if ((error.error as any).message && typeof (error.error as any).message === 'string') {
      userFriendlyErrorMessage = (error.error as any).message;
    }
  } else if (typeof error.error === 'string') {
    // Corpul erorii de la server este un simplu string
    detailedErrorMessage = error.error;
    userFriendlyErrorMessage = error.error; 
  } else if (error.message) {
    // Eroare client-side sau de rețea (ex: HttpErrorResponse fără error.error, dar cu error.message)
    detailedErrorMessage = error.message;
    if (error.status === 0 || error.status === -1) { // Tipic pentru erori de rețea, CORS, sau server oprit
        userFriendlyErrorMessage = 'Eroare de conexiune cu serverul. Verificați rețeaua sau dacă serverul backend rulează.';
    } else {
        userFriendlyErrorMessage = `A apărut o eroare (${error.status}): ${error.statusText}`;
    }
  } else {
    // Fallback dacă structura erorii nu este cea așteptată
    detailedErrorMessage = `Cod eroare server: ${error.status}, status text: ${error.statusText || 'Necunoscut'}`;
    userFriendlyErrorMessage = `A apărut o eroare (${error.status}). Vă rugăm încercați mai târziu.`;
  }

  console.error('------------------------------------');
  console.error(`[SERVICE ERROR ENCOUNTERED]`);
  console.error(`URL: ${error.url}`);
  console.error(`Status: ${error.status} - ${error.statusText}`);
  console.error(`User-Friendly Message: ${userFriendlyErrorMessage}`);
  console.error(`Detailed Error Message/Body: ${detailedErrorMessage}`);
  console.error('Full HttpErrorResponse Object:', error);
  console.error('------------------------------------');

  // Aruncă o eroare care va fi propagată și poate fi prinsă în componentă
  // sau de un error handler global, dacă există.
  // Pentru utilizator, mesajele sunt de obicei afișate prin MatSnackBar în componentă/serviciu.
  return throwError(() => new Error(userFriendlyErrorMessage));
}
}
</file>

<file path="frontend/src/app/features/admin/services/specification-admin.service.ts">
// src/app/features/admin/services/specification-admin.service.ts
import { Injectable, inject } from '@angular/core';
import { HttpClient, HttpErrorResponse } from '@angular/common/http';
import { Observable, throwError } from 'rxjs';
import { catchError } from 'rxjs/operators';
import { SpecificationDefinition } from '../../../shared/models/specification-definition.model';

@Injectable({
  providedIn: 'root'
})
export class SpecificationAdminService {
  private apiUrl = '/api/specifications/definitions';

  private http = inject(HttpClient);

  getAllDefinitions(): Observable<SpecificationDefinition[]> {
    return this.http.get<SpecificationDefinition[]>(this.apiUrl)
      .pipe(catchError(this.handleError));
  }

  getDefinitionById(id: number): Observable<SpecificationDefinition> {
    return this.http.get<SpecificationDefinition>(`${this.apiUrl}/${id}`)
      .pipe(catchError(this.handleError));
  }

  createDefinition(definition: Omit<SpecificationDefinition, 'id'>): Observable<SpecificationDefinition> {
    return this.http.post<SpecificationDefinition>(this.apiUrl, definition)
      .pipe(catchError(this.handleError));
  }

  updateDefinition(id: number, definition: SpecificationDefinition): Observable<SpecificationDefinition> {
    return this.http.put<SpecificationDefinition>(`${this.apiUrl}/${id}`, definition)
      .pipe(catchError(this.handleError));
  }

  deleteDefinition(id: number): Observable<void> {
    return this.http.delete<void>(`${this.apiUrl}/${id}`)
      .pipe(catchError(this.handleError));
  }

private handleError(error: HttpErrorResponse) {
  let userFriendlyErrorMessage = 'A apărut o problemă. Vă rugăm încercați din nou mai târziu.';
  let detailedErrorMessage = 'Eroare necunoscută.';

  // Verificăm mai întâi dacă 'error.error' există și este un obiect (răspuns JSON de la server)
  if (error.error && typeof error.error === 'object' && error.error !== null) {
    // Încercăm să extragem un mesaj specific din corpul erorii trimis de backend
    // Acesta ar putea fi error.error.message, error.error.error, error.error.detail etc.
    // Ajustează în funcție de structura răspunsurilor de eroare de la API-ul tău Spring Boot
    detailedErrorMessage = 
        (error.error as any).message ||         // Cel mai comun (ex: MessageResponse din Spring)
        (error.error as any).detail ||          // Alt câmp comun pentru detalii eroare
        (error.error as any).error?.message ||  // Uneori eroarea e imbricată
        JSON.stringify(error.error);            // Fallback la JSON string dacă e un obiect complex

    // Poți încerca să faci mesajul user-friendly mai specific dacă backend-ul trimite un mesaj clar
    if ((error.error as any).message && typeof (error.error as any).message === 'string') {
      userFriendlyErrorMessage = (error.error as any).message;
    }
  } else if (typeof error.error === 'string') {
    // Corpul erorii de la server este un simplu string
    detailedErrorMessage = error.error;
    userFriendlyErrorMessage = error.error; 
  } else if (error.message) {
    // Eroare client-side sau de rețea (ex: HttpErrorResponse fără error.error, dar cu error.message)
    detailedErrorMessage = error.message;
    if (error.status === 0 || error.status === -1) { // Tipic pentru erori de rețea, CORS, sau server oprit
        userFriendlyErrorMessage = 'Eroare de conexiune cu serverul. Verificați rețeaua sau dacă serverul backend rulează.';
    } else {
        userFriendlyErrorMessage = `A apărut o eroare (${error.status}): ${error.statusText}`;
    }
  } else {
    // Fallback dacă structura erorii nu este cea așteptată
    detailedErrorMessage = `Cod eroare server: ${error.status}, status text: ${error.statusText || 'Necunoscut'}`;
    userFriendlyErrorMessage = `A apărut o eroare (${error.status}). Vă rugăm încercați mai târziu.`;
  }

  console.error('------------------------------------');
  console.error(`[SERVICE ERROR ENCOUNTERED]`);
  console.error(`URL: ${error.url}`);
  console.error(`Status: ${error.status} - ${error.statusText}`);
  console.error(`User-Friendly Message: ${userFriendlyErrorMessage}`);
  console.error(`Detailed Error Message/Body: ${detailedErrorMessage}`);
  console.error('Full HttpErrorResponse Object:', error);
  console.error('------------------------------------');

  // Aruncă o eroare care va fi propagată și poate fi prinsă în componentă
  // sau de un error handler global, dacă există.
  // Pentru utilizator, mesajele sunt de obicei afișate prin MatSnackBar în componentă/serviciu.
  return throwError(() => new Error(userFriendlyErrorMessage));
}
}
</file>

<file path="frontend/src/app/features/admin/services/user-admin.service.ts">
// src/app/features/admin/services/user-admin.service.ts
import { Injectable, inject } from '@angular/core';
import { HttpClient, HttpErrorResponse } from '@angular/common/http';
import { Observable, throwError } from 'rxjs';
import { catchError } from 'rxjs/operators';
import { User, UserUpdateDto } from '../../../shared/models/user.model';

@Injectable({
  providedIn: 'root'
})
export class UserAdminService {
  private apiUrl = '/api/users';

  private http = inject(HttpClient);

  getAllUsers(): Observable<User[]> {
    return this.http.get<User[]>(this.apiUrl)
      .pipe(catchError(this.handleError));
  }

  getUserById(userId: number): Observable<User> {
    return this.http.get<User>(`${this.apiUrl}/${userId}`)
      .pipe(catchError(this.handleError));
  }

  updateUser(userId: number, userData: UserUpdateDto): Observable<User> {
    return this.http.put<User>(`${this.apiUrl}/${userId}`, userData)
      .pipe(catchError(this.handleError));
  }

  deleteUser(userId: number): Observable<void> {
    return this.http.delete<void>(`${this.apiUrl}/${userId}`)
      .pipe(catchError(this.handleError));
  }

 private handleError(error: HttpErrorResponse) {
  let userFriendlyErrorMessage = 'A apărut o problemă. Vă rugăm încercați din nou mai târziu.';
  let detailedErrorMessage = 'Eroare necunoscută.';

  // Verificăm mai întâi dacă 'error.error' există și este un obiect (răspuns JSON de la server)
  if (error.error && typeof error.error === 'object' && error.error !== null) {
    // Încercăm să extragem un mesaj specific din corpul erorii trimis de backend
    // Acesta ar putea fi error.error.message, error.error.error, error.error.detail etc.
    // Ajustează în funcție de structura răspunsurilor de eroare de la API-ul tău Spring Boot
    detailedErrorMessage = 
        (error.error as any).message ||         // Cel mai comun (ex: MessageResponse din Spring)
        (error.error as any).detail ||          // Alt câmp comun pentru detalii eroare
        (error.error as any).error?.message ||  // Uneori eroarea e imbricată
        JSON.stringify(error.error);            // Fallback la JSON string dacă e un obiect complex

    // Poți încerca să faci mesajul user-friendly mai specific dacă backend-ul trimite un mesaj clar
    if ((error.error as any).message && typeof (error.error as any).message === 'string') {
      userFriendlyErrorMessage = (error.error as any).message;
    }
  } else if (typeof error.error === 'string') {
    // Corpul erorii de la server este un simplu string
    detailedErrorMessage = error.error;
    userFriendlyErrorMessage = error.error; 
  } else if (error.message) {
    // Eroare client-side sau de rețea (ex: HttpErrorResponse fără error.error, dar cu error.message)
    detailedErrorMessage = error.message;
    if (error.status === 0 || error.status === -1) { // Tipic pentru erori de rețea, CORS, sau server oprit
        userFriendlyErrorMessage = 'Eroare de conexiune cu serverul. Verificați rețeaua sau dacă serverul backend rulează.';
    } else {
        userFriendlyErrorMessage = `A apărut o eroare (${error.status}): ${error.statusText}`;
    }
  } else {
    // Fallback dacă structura erorii nu este cea așteptată
    detailedErrorMessage = `Cod eroare server: ${error.status}, status text: ${error.statusText || 'Necunoscut'}`;
    userFriendlyErrorMessage = `A apărut o eroare (${error.status}). Vă rugăm încercați mai târziu.`;
  }

  console.error('------------------------------------');
  console.error(`[SERVICE ERROR ENCOUNTERED]`);
  console.error(`URL: ${error.url}`);
  console.error(`Status: ${error.status} - ${error.statusText}`);
  console.error(`User-Friendly Message: ${userFriendlyErrorMessage}`);
  console.error(`Detailed Error Message/Body: ${detailedErrorMessage}`);
  console.error('Full HttpErrorResponse Object:', error);
  console.error('------------------------------------');

  // Aruncă o eroare care va fi propagată și poate fi prinsă în componentă
  // sau de un error handler global, dacă există.
  // Pentru utilizator, mesajele sunt de obicei afișate prin MatSnackBar în componentă/serviciu.
  return throwError(() => new Error(userFriendlyErrorMessage));
}
}
</file>

<file path="frontend/src/app/features/products/products.module.ts">
// src/app/features/products/products.module.ts
import { NgModule }            from '@angular/core';
import { CommonModule }        from '@angular/common';
import { RouterModule }        from '@angular/router';
import { ReactiveFormsModule } from '@angular/forms';

import { ProductListComponent }   from './product-list/product-list.component';
import { ProductDetailComponent } from './product-detail/product-detail.component';
import { ProductFormComponent }   from './product-form/product-form.component';

@NgModule({
  // elimină complet `declarations`
  imports: [
    CommonModule,
    RouterModule,            // pentru directivele routerLink, outlet etc.
    ReactiveFormsModule,

    // importă aici componentele standalone
    ProductListComponent,
    ProductDetailComponent,
    ProductFormComponent
  ]
})
export class ProductsModule {}
</file>

<file path="frontend/src/app/features/user-dashboard/services/client-order.service.ts">
// src/app/features/user-dashboard/services/client-order.service.ts
import { Injectable, inject } from '@angular/core';
import { HttpClient, HttpErrorResponse } from '@angular/common/http';
import { Observable, throwError } from 'rxjs';
import { catchError } from 'rxjs/operators';
import { Order } from '../../../shared/models/order.model'; // Modelul partajat

/**
 * Serviciu pentru operațiunile clientului legate de comenzi
 * (plasare comandă, vizualizare istoric).
 */
@Injectable({
  providedIn: 'root'
})
export class ClientOrderService {
  // Endpoint-ul pentru comenzile clientului (plasare, istoric propriu)
  private ordersApiUrl = '/api/orders';

  private http = inject(HttpClient);

  /**
   * Plasează o nouă comandă.
   * @param orderData Obiectul Order ce conține detaliile comenzii.
   * @returns Un Observable care emite comanda creată.
   */
  placeOrder(orderData: Order): Observable<Order> {
    // Backend-ul se așteaptă la un OrderDto.
    // Asigură-te că orderData (construit în CheckoutComponent) respectă structura.
    return this.http.post<Order>(this.ordersApiUrl, orderData)
      .pipe(catchError(this.handleError));
  }

  /**
   * Preia istoricul comenzilor pentru utilizatorul autentificat.
   * Backend-ul folosește token-ul JWT pentru a identifica utilizatorul.
   * @returns Un Observable care emite un array cu comenzile utilizatorului.
   */
  getMyOrderHistory(): Observable<Order[]> {
    return this.http.get<Order[]>(`${this.ordersApiUrl}/my-history`)
      .pipe(catchError(this.handleError));
  }

  /**
   * Preia detaliile unei comenzi specifice din istoricul utilizatorului.
   * (Opțional, dacă backend-ul oferă un astfel de endpoint specific pentru 'my-history/:id')
   * Momentan, backend-ul pare să aibă doar GET /api/orders/{id} (admin) și GET /api/orders/my-history (user)
   * @param orderId ID-ul comenzii.
   * @returns Un Observable care emite comanda găsită.
   */
  // getMyOrderById(orderId: number): Observable<Order> {
  //   return this.http.get<Order>(`${this.ordersApiUrl}/my-history/${orderId}`) // Verifică endpoint-ul în backend
  //     .pipe(catchError(this.handleError));
  // }

  private handleError(error: HttpErrorResponse) {
    let errorMessage = 'A apărut o eroare la procesarea comenzii.';
    if (error.error instanceof ErrorEvent) {
      errorMessage = `Eroare client: ${error.error.message}`;
    } else {
      errorMessage = `Cod eroare server: ${error.status}, mesaj: ${error.error?.message || error.message}`;
    }
    console.error(errorMessage, error);
    return throwError(() => new Error(errorMessage));
  }
}
</file>

<file path="frontend/src/app/features/user-dashboard/user-order-history/user-order-history.component.html">
<!-- src/app/features/user-dashboard/user-order-history/user-order-history.component.html -->
<div class="user-order-history-container">
  <div class="header">
    <h2>Comenzile Mele</h2>
  </div>

  <div *ngIf="isLoading" class="loading-indicator">
    <mat-spinner diameter="50"></mat-spinner>
    <p>Se încarcă istoricul comenzilor...</p>
  </div>

  <div *ngIf="error && !isLoading" class="error-message">
    <p>{{ error }}</p>
    <button mat-stroked-button color="warn" (click)="loadOrderHistory()">Reîncearcă</button>
  </div>

  <div *ngIf="!isLoading && !error && orders.length === 0" class="no-data">
    <p>Nu ai plasat nicio comandă încă.</p>
    <button mat-flat-button color="primary" routerLink="/products">Vezi Produse</button>
  </div>

  <mat-accordion multi="true" *ngIf="!isLoading && !error && orders.length > 0" class="order-accordion">
    <mat-expansion-panel *ngFor="let order of orders; let i = index"
                         (opened)="panelOpenState[i] = true"
                         (closed)="panelOpenState[i] = false"
                         class="order-panel">
      <mat-expansion-panel-header>
        <mat-panel-title>
          Comanda #{{ order.id }} - {{ order.orderDate | date:'dd/MM/yyyy' }}
        </mat-panel-title>
        <mat-panel-description fxLayoutAlign="space-between center">
          <span>Total: {{ order.totalAmount | currency:'RON':'symbol':'1.2-2' }}</span>
          <mat-chip-listbox aria-label="Status comandă">
            <mat-chip selected [ngClass]="'status-chip-' + order.status.toLowerCase().replace('_', '-')">
                {{ formatStatus(order.status) }}
            </mat-chip>
          </mat-chip-listbox>
        </mat-panel-description>
      </mat-expansion-panel-header>

      <div class="order-details-content">
        <h4>Detalii Comandă:</h4>
        <p><strong>Data plasării:</strong> {{ order.orderDate | date:'dd/MM/yyyy HH:mm:ss' }}</p>
        <p><strong>Nume client (livrare):</strong> {{ order.customerName }}</p>
        <p><strong>Adresă livrare:</strong> {{ order.shippingAddress }}</p>
        <p><strong>Email contact:</strong> {{ order.customerEmail }}</p>
        <p><strong>Telefon contact:</strong> {{ order.customerPhone }}</p>

        <mat-divider></mat-divider>
        <h4>Articole Comandate:</h4>
        <mat-list role="list" class="order-items-list">
          <mat-list-item *ngFor="let item of order.orderItems" role="listitem" class="order-item-detail">
            <!-- Secțiunea Imagine Articol - COMENTATĂ TEMPORAR -->
            <!--
            <img matListItemAvatar *ngIf="item.productImageBase64Snapshot" [src]="item.productImageBase64Snapshot" [alt]="item.productNameSnapshot" class="item-image-small">
            <mat-icon matListItemAvatar *ngIf="!item.productImageBase64Snapshot">inventory_2</mat-icon>
            -->
            <mat-icon matListItemAvatar>inventory_2</mat-icon> <!-- Placeholder generic -->

            <span matListItemTitle>{{ item.productNameSnapshot }} (ID: {{ item.productId }})</span>
            <span matListItemLine>
              Cantitate: {{ item.quantity }} x {{ item.priceAtPurchase | currency:'RON':'symbol':'1.2-2' }}
            </span>
            <span matListItemMeta class="item-subtotal-small">
              Subtotal: {{ calculateItemSubtotal(item) | currency:'RON':'symbol':'1.2-2' }}
            </span>
          </mat-list-item>
        </mat-list>
      </div>
    </mat-expansion-panel>
  </mat-accordion>
</div>
</file>

<file path="frontend/src/app/features/user-dashboard/user-order-history/user-order-history.component.scss">
// src/app/features/user-dashboard/user-order-history/user-order-history.component.scss
.user-order-history-container {
  padding: 20px;
  max-width: 900px;
  margin: auto;
}

.header {
  margin-bottom: 20px;
  h2 {
    margin: 0;
    font-size: 1.8em;
    color: #448AFF; // Culoarea primară
  }
}

.loading-indicator,
.error-message,
.no-data {
  text-align: center;
  padding: 20px;
  margin-top: 20px;
  color: #757575;
  mat-spinner {
    margin: 0 auto 10px auto;
  }
  button[mat-flat-button] {
    margin-top: 15px;
  }
}

.error-message {
  color: #f44336;
}

.order-accordion {
  margin-top: 10px;
}

.order-panel {
  margin-bottom: 16px;
  border-radius: 8px !important; // Suprascrie stilurile default pentru colțuri mai rotunjite
  box-shadow: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24);

  &:first-child {
      border-top-left-radius: 8px;
      border-top-right-radius: 8px;
  }
   &:last-child {
      border-bottom-left-radius: 8px;
      border-bottom-right-radius: 8px;
  }

  mat-expansion-panel-header {
    font-size: 1.05em; // Mărime font pentru header-ul panoului
  }

  mat-panel-description {
    justify-content: space-between; // Asigură spațiere între total și status
    align-items: center;
    font-size: 0.95em;
    mat-chip-listbox {
        transform: scale(0.9); // Micsorează puțin chip-ul
    }
  }
}

.status-chip-pending_confirmation { background-color: #424242 !important; color: #fff !important; }
.status-chip-approved { background-color: #1565C0 !important; color: #fff !important; } // Albastru închis
.status-chip-processing { background-color: #448AFF !important; color: #fff !important; } // Albastru accent
.status-chip-shipped { background-color: #03A9F4 !important; color: #fff !important; } // Albastru deschis
.status-chip-delivered { background-color: #009688 !important; color: #fff !important; } // Teal, merge bine cu albastru
.status-chip-canceled { background-color: #f44336 !important; color: #fff !important; } // Roșu rămâne la fel


.order-details-content {
  padding: 16px 24px 24px 24px; // Spațiere internă pentru conținutul detaliilor

  h4 {
    margin-top: 16px;
    margin-bottom: 8px;
    font-size: 1.1em;
    font-weight: 500;
    color: #448AFF; 
  }
  &:first-of-type h4 { // Primul h4 din conținut
      margin-top: 0;
  }

  p {
    margin-bottom: 6px;
    line-height: 1.5;
    strong {
      font-weight: 500;
      color: #424242; // Gri mai închis pentru etichete
    }
  }
  mat-divider {
    margin: 16px 0;
  }
}

.order-items-list {
  padding-top: 0; // Elimină padding-ul default al listei
  .order-item-detail {
    border-bottom: 1px dotted #e0e0e0;
    padding: 8px 0 !important; // Suprascrie padding-ul item-ului de listă

    &:last-child {
      border-bottom: none;
    }
  }
  .item-image-small {
    width: 40px;
    height: 40px;
    object-fit: cover;
    border-radius: 4px;
    margin-right: 16px;
  }
  .item-subtotal-small {
    font-weight: 500;
    font-size: 0.9em;
  }
}
</file>

<file path="frontend/src/app/features/user-dashboard/user-order-history/user-order-history.component.ts">
// src/app/features/user-dashboard/user-order-history/user-order-history.component.ts
import { Component, OnInit, inject } from '@angular/core';
import { CommonModule, DatePipe, CurrencyPipe } from '@angular/common';
import { RouterModule } from '@angular/router';
import { MatCardModule } from '@angular/material/card';
import { MatListModule } from '@angular/material/list';
import { MatDividerModule } from '@angular/material/divider';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar';
import { MatExpansionModule } from '@angular/material/expansion';
import { MatIconModule } from '@angular/material/icon';
import { MatChipsModule } from '@angular/material/chips';
import { HttpErrorResponse } from '@angular/common/http';


import { Order } from '../../../shared/models/order.model';
import { OrderItem } from '../../../shared/models/order-item.model'; // <<< CORECTAT
import { ClientOrderService } from '../services/client-order.service';

@Component({
  selector: 'app-user-order-history',
  standalone: true,
  imports: [
    CommonModule,
    RouterModule,
    MatCardModule,
    MatListModule,
    MatDividerModule,
    MatProgressSpinnerModule,
    MatSnackBarModule,
    MatExpansionModule,
    MatIconModule,
    MatChipsModule,
    DatePipe,
    CurrencyPipe
  ],
  templateUrl: './user-order-history.component.html',
  styleUrls: ['./user-order-history.component.scss']
})
export class UserOrderHistoryComponent implements OnInit {
  orders: Order[] = [];
  isLoading = true;
  error: string | null = null;
  panelOpenState: boolean[] = [];

  private clientOrderService = inject(ClientOrderService);
  private snackBar = inject(MatSnackBar);

  ngOnInit(): void {
    this.loadOrderHistory();
  }

  loadOrderHistory(): void {
    this.isLoading = true;
    this.error = null;
    this.clientOrderService.getMyOrderHistory().subscribe({
      next: (data: Order[]) => { // Tipare explicită
        this.orders = data.sort((a, b) => new Date(b.orderDate!).getTime() - new Date(a.orderDate!).getTime());
        this.panelOpenState = new Array(this.orders.length).fill(false);
        this.isLoading = false;
      },
      error: (err: HttpErrorResponse) => { // Tipare explicită
        this.error = 'Nu s-a putut încărca istoricul comenzilor.';
        const errMsg = err.error?.message || err.message || 'Eroare necunoscută.';
        console.error('Eroare la încărcarea istoricului comenzilor:', err);
        this.isLoading = false;
        this.snackBar.open(`${this.error} ${errMsg}`, 'Închide', { duration: 5000 });
      }
    });
  }

  formatStatus(status: string): string {
    if (!status) return '';
    return status.replace(/_/g, ' ').toLowerCase().replace(/\b\w/g, l => l.toUpperCase());
  }

  calculateItemSubtotal(item: OrderItem): number {
    return (item.priceAtPurchase || 0) * item.quantity;
  }

  togglePanel(index: number): void {
    this.panelOpenState[index] = !this.panelOpenState[index];
  }
}
</file>

<file path="frontend/src/app/shared/models/category.model.ts">
export interface Category {
  id?: number;
  name: string;
  description?: string;
}
</file>

<file path="frontend/src/app/shared/models/order-item.model.ts">
// src/app/shared/models/order-item.model.ts

export interface OrderItem {
  id?: number;
  productId: number;
  productNameSnapshot?: string;         // Corect
  //productImageBase64Snapshot?: string;  // Corect
  quantity: number;
  priceAtPurchase?: number;
  lineTotal?: number;
}
</file>

<file path="frontend/src/app/shared/models/order-status-update.model.ts">
export interface OrderStatusUpdate {
  newStatus: string;
}
</file>

<file path="frontend/src/app/shared/models/order.model.ts">
// src/app/shared/models/order.model.ts
import { OrderItem } from './order-item.model'; // <<< CORECTAT: Importă OrderItem

/**
 * Interfață pentru reprezentarea unei comenzi,
 * aliniată cu OrderDto din backend.
 */
export interface Order {
  id?: number;
  userId?: number;
  username?: string;
  orderDate?: string;
  status: string;
  totalAmount?: number;
  customerName: string;
  shippingAddress: string;
  customerEmail: string;
  customerPhone: string;
  orderItems: OrderItem[]; // Acum OrderItem este cunoscut
}
</file>

<file path="frontend/src/app/shared/models/specification-definition.model.ts">
export interface SpecificationDefinition {
  id: number;
  name: string;
  unit?: string;
}
</file>

<file path="frontend/src/app/shared/models/specification-value.model.ts">
export interface SpecificationValue {
  definitionId?: number;
  name?: string;
  value: string;
  unit?: string;
}
</file>

<file path="frontend/src/app/shared/models/user.model.ts">
export interface User {
  id: number;
  username: string;
  email: string;
  roles: string[];
}

export interface UserUpdateDto {
  email: string;
  roles: string[];
}

// Ar putea fi util să ai și un model pentru răspunsul JWT de la login
export interface JwtResponse {
    token: string;
    type?: string; // Usually 'Bearer'
    id: number;
    username: string;
    email: string;
    roles: string[];
}

// Model pentru LoginRequest (dacă vrei să-l typezi explicit în AuthService)
export interface LoginRequest {
    username?: string; // Optional dacă folosești un DTO mai generic
    password?: string;
}

// Model pentru SignupRequest (dacă vrei să-l typezi explicit în AuthService/SignupComponent)
export interface SignupRequest {
    username?: string;
    email?: string;
    password?: string;
    role?: string[]; // Poate fi un set de roluri la înregistrare
}
</file>

<file path="frontend/src/app/shared/pipes/nl2br.pipe.ts">
// src/app/shared/pipes/nl2br.pipe.ts
import { Pipe, PipeTransform } from '@angular/core';
import { DomSanitizer, SafeHtml } from '@angular/platform-browser';

@Pipe({
  name: 'nl2br',
  standalone: true // Fă-l standalone pentru importare ușoară
})
export class Nl2brPipe implements PipeTransform {
  constructor(private sanitizer: DomSanitizer) {}

  transform(value: string | null | undefined): SafeHtml {
    if (value === null || value === undefined) {
      return '';
    }
    // Înlocuiește secvențele de linie nouă (\n, \r\n, \r) cu <br />
    // și sanitizează HTML-ul rezultat pentru securitate.
    return this.sanitizer.bypassSecurityTrustHtml(value.replace(/(\r\n|\n|\r)/gm, '<br />'));
  }
}
</file>

<file path="frontend/src/index.html">
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>MagazinCalculatoare</title>
  <base href="/">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" type="image/x-icon" href="favicon.ico">
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
</head>
<body class="mat-typography">
  <app-root></app-root>
</body>
</html>
</file>

<file path="frontend/src/main.server.ts">
import { bootstrapApplication } from '@angular/platform-browser';
import { AppComponent } from './app/app.component';
import { config } from './app/app.config.server';

const bootstrap = () => bootstrapApplication(AppComponent, config);

export default bootstrap;
</file>

<file path="frontend/src/main.ts">
import { bootstrapApplication } from '@angular/platform-browser';
import { AppComponent }         from './app/app.component';
import { appConfig }            from './app/app.config';

bootstrapApplication(AppComponent, appConfig)
  .catch(err => console.error('Bootstrap error:', err));
</file>

<file path="frontend/src/server.ts">
import {
  AngularNodeAppEngine,
  createNodeRequestHandler,
  isMainModule,
  writeResponseToNodeResponse,
} from '@angular/ssr/node';
import express from 'express';
import { dirname, resolve } from 'node:path';
import { fileURLToPath } from 'node:url';

const serverDistFolder = dirname(fileURLToPath(import.meta.url));
const browserDistFolder = resolve(serverDistFolder, '../browser');

const app = express();
const angularApp = new AngularNodeAppEngine();

/**
 * Example Express Rest API endpoints can be defined here.
 * Uncomment and define endpoints as necessary.
 *
 * Example:
 * ```ts
 * app.get('/api/**', (req, res) => {
 *   // Handle API request
 * });
 * ```
 */

/**
 * Serve static files from /browser
 */
app.use(
  express.static(browserDistFolder, {
    maxAge: '1y',
    index: false,
    redirect: false,
  }),
);

/**
 * Handle all other requests by rendering the Angular application.
 */
app.use('/**', (req, res, next) => {
  angularApp
    .handle(req)
    .then((response) =>
      response ? writeResponseToNodeResponse(response, res) : next(),
    )
    .catch(next);
});

/**
 * Start the server if this module is the main entry point.
 * The server listens on the port defined by the `PORT` environment variable, or defaults to 4000.
 */
if (isMainModule(import.meta.url)) {
  const port = process.env['PORT'] || 4000;
  app.listen(port, () => {
    console.log(`Node Express server listening on http://localhost:${port}`);
  });
}

/**
 * Request handler used by the Angular CLI (for dev-server and during build) or Firebase Cloud Functions.
 */
export const reqHandler = createNodeRequestHandler(app);
</file>

<file path="frontend/src/styles.scss">
/* src/styles.scss */

// Stiluri globale de bază
body {
  background: #121212;
  color: #e0e0e0;
  font-family: Roboto, sans-serif;
  margin: 0;
}

// Am eliminat complet regula pentru .app-toolbar de aici.
</file>

<file path="frontend/src/themes/dark-theme.scss">
// src/themes/dark-theme.scss
@use '@angular/material' as mat;

/* 1. Palete */
$primary-palette : mat.define-palette(mat.$grey-palette, 900);      // negru/gri închis
$accent-palette  : mat.define-palette(mat.$blue-palette, 500);      // albastru mediu
$warn-palette    : mat.define-palette(mat.$red-palette);

/* 2. Dark theme */
$dark-theme: mat.define-dark-theme((
  color: (
    primary: $primary-palette,
    accent:  $accent-palette,
    warn:    $warn-palette
  )
));

/* 3. Include Material core & theme */
@include mat.core();
@include mat.all-component-themes($dark-theme);

/* 4. Override-uri globale */
body {
  background: mat.get-color-from-palette($primary-palette, 900);
  color:      mat.get-color-from-palette($primary-palette, 50);
  font-family: Roboto, sans-serif;
}
a, button.mat-button, button.mat-raised-button {
  color: mat.get-color-from-palette($accent-palette, 200);
}
</file>

<file path="frontend/tsconfig.app.json">
/* To learn more about Typescript configuration file: https://www.typescriptlang.org/docs/handbook/tsconfig-json.html. */
/* To learn more about Angular compiler options: https://angular.dev/reference/configs/angular-compiler-options. */
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "outDir": "./out-tsc/app",
    "types": [
      "node"
    ]
  },
  "files": [
    "src/main.ts",
    "src/main.server.ts",
    "src/server.ts"
  ],
  "include": [
    "src/**/*.d.ts"
  ]
}
</file>

<file path="frontend/tsconfig.json">
/* To learn more about Typescript configuration file: https://www.typescriptlang.org/docs/handbook/tsconfig-json.html. */
/* To learn more about Angular compiler options: https://angular.dev/reference/configs/angular-compiler-options. */
{
  "compileOnSave": false,
  "compilerOptions": {
    "outDir": "./dist/out-tsc",
    "strict": true,
    "noImplicitOverride": true,
    "noPropertyAccessFromIndexSignature": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "skipLibCheck": true,
    "isolatedModules": true,
    "esModuleInterop": true,
    "experimentalDecorators": true,
    "moduleResolution": "bundler",
    "importHelpers": true,
    "target": "ES2022",
    "module": "ES2022"
  },
  "angularCompilerOptions": {
    "enableI18nLegacyMessageIdFormat": false,
    "strictInjectionParameters": true,
    "strictInputAccessModifiers": true,
    "strictTemplates": true
  }
}
</file>

<file path="frontend/tsconfig.spec.json">
/* To learn more about Typescript configuration file: https://www.typescriptlang.org/docs/handbook/tsconfig-json.html. */
/* To learn more about Angular compiler options: https://angular.dev/reference/configs/angular-compiler-options. */
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "outDir": "./out-tsc/spec",
    "types": [
      "jasmine"
    ]
  },
  "include": [
    "src/**/*.spec.ts",
    "src/**/*.d.ts"
  ]
}
</file>

<file path="backend/pom.xml">
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
                             https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.2.5</version>
        <relativePath/>
    </parent>

    <groupId>com.magazincomputere</groupId>
    <artifactId>magazin-api</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>magazin-api</name>
    <description>API pentru Magazin Computere</description>

    <properties>
        <java.version>17</java.version>
        <!-- păstrăm doar springdoc aici; jjwt îl setăm direct în dependențe -->
        <springdoc.version>2.3.0</springdoc.version>
    </properties>

    <dependencies>
        <!-- Spring Boot starters – toate pe 3.2.5 -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
            <version>3.2.5</version>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
            <version>3.2.5</version>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
            <version>3.2.5</version>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
            <version>3.2.5</version>
        </dependency>

        <!-- Baze de date -->
        <dependency>
            <groupId>com.h2database</groupId>
            <artifactId>h2</artifactId>
            <version>2.2.224</version>
            <scope>runtime</scope>
        </dependency>

        <dependency>
            <groupId>com.mysql</groupId>
            <artifactId>mysql-connector-j</artifactId>
            <version>8.3.0</version>
            <scope>runtime</scope>
        </dependency>

        <!-- Utility -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>1.18.32</version>
            <optional>true</optional>
        </dependency>

        <!-- JJWT 0.12.6 -->
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-api</artifactId>
            <version>0.11.5</version>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-impl</artifactId>
            <version>0.11.5</version>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-jackson</artifactId>
            <version>0.11.5</version>
            <scope>runtime</scope>
        </dependency>

        <!-- SpringDoc OpenAPI (lasă proprietatea) -->
        <dependency>
            <groupId>org.springdoc</groupId>
            <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
            <version>${springdoc.version}</version>
        </dependency>

        <!-- Teste -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <version>3.2.5</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-test</artifactId>
            <version>6.2.4</version>
            <scope>test</scope>
        </dependency>
        <dependency>
    <groupId>org.postgresql</groupId>
    <artifactId>postgresql</artifactId>
    <scope>runtime</scope>
</dependency>
<dependency>
    <groupId>com.mysql</groupId>
    <artifactId>mysql-connector-j</artifactId>
    <scope>runtime</scope>
</dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <excludes>
                        <exclude>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                        </exclude>
                    </excludes>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/controller/OrderController.java">
// src/main/java/com/magazincomputere/magazin_api/controller/OrderController.java
package com.magazincomputere.magazin_api.controller;

import com.magazincomputere.magazin_api.dto.OrderDto;
import com.magazincomputere.magazin_api.dto.OrderStatusUpdateDto; // Asigură-te că acest DTO este importat
import com.magazincomputere.magazin_api.model.User; // Nu este folosit direct, dar poate rămâne
import com.magazincomputere.magazin_api.repository.UserRepository; // Nu este folosit direct, dar poate rămâne
import com.magazincomputere.magazin_api.security.services.UserDetailsImpl;
import com.magazincomputere.magazin_api.service.OrderService;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/orders")
@CrossOrigin(origins = "*", maxAge = 3600)
public class OrderController {

    @Autowired
    private OrderService orderService;

    // @Autowired // Nu este folosit direct aici, poate fi eliminat dacă nu e necesar pentru altceva
    // private UserRepository userRepository;

    @PostMapping
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<OrderDto> createOrder(@Valid @RequestBody OrderDto orderDto) {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        UserDetailsImpl userDetails = (UserDetailsImpl) authentication.getPrincipal();
        Long userId = userDetails.getId();

        OrderDto createdOrder = orderService.createOrder(orderDto, userId);
        return new ResponseEntity<>(createdOrder, HttpStatus.CREATED);
    }

    @GetMapping("/my-history")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<List<OrderDto>> getMyOrderHistory() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        UserDetailsImpl userDetails = (UserDetailsImpl) authentication.getPrincipal();
        Long userId = userDetails.getId();
        // Folosește numele corect al metodei din OrderService
        List<OrderDto> orders = orderService.getOrdersByUser(userId); // <<< CORECTAT AICI
        return ResponseEntity.ok(orders);
    }

    @GetMapping
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<List<OrderDto>> getAllOrders(@RequestParam(required = false) String status) {
        List<OrderDto> orders = orderService.getAllOrders(status);
        return ResponseEntity.ok(orders);
    }

    @GetMapping("/{orderId}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<OrderDto> getOrderById(@PathVariable Long orderId) {
        OrderDto orderDto = orderService.getOrderById(orderId);
        return ResponseEntity.ok(orderDto);
    }

    @PutMapping("/{orderId}/status")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<OrderDto> updateOrderStatus(
            @PathVariable Long orderId,
            @Valid @RequestBody OrderStatusUpdateDto statusUpdateDto) { // <<< CORECTAT AICI: Primește DTO-ul
        // Transmite DTO-ul la serviciu
        OrderDto updatedOrder = orderService.updateOrderStatus(orderId, statusUpdateDto); // <<< CORECTAT AICI
        return ResponseEntity.ok(updatedOrder);
    }
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/dto/OrderItemDto.java">
// src/main/java/com/magazincomputere/magazin_api/dto/OrderItemDto.java
package com.magazincomputere.magazin_api.dto;

import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotNull;
import lombok.Data;
import java.math.BigDecimal;

@Data
public class OrderItemDto {
    private Long id;

    @NotNull(message = "ID-ul produsului este obligatoriu")
    private Long productId; // ID-ul produsului original

    private String productNameSnapshot;
    // private String productImageBase64Snapshot; // COMENTAT TEMPORAR

    @NotNull(message = "Cantitatea este obligatorie")
    @Min(value = 1, message = "Cantitatea trebuie să fie cel puțin 1")
    private Integer quantity;

    private BigDecimal priceAtPurchase;
    private BigDecimal lineTotal;
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/dto/ProductDto.java">
// src/main/java/com/magazincomputere/magazin_api/dto/ProductDto.java
package com.magazincomputere.magazin_api.dto;

import jakarta.validation.constraints.*;
import lombok.Data;
import java.util.List;
import java.math.BigDecimal;


@Data
public class ProductDto {
    private Long id;

    @NotBlank(message = "Numele produsului este obligatoriu")
    @Size(min = 3, max = 255, message = "Numele produsului trebuie să aibă între 3 și 255 de caractere")
    private String name;

    private String description;

    @NotNull(message = "Prețul este obligatoriu")
    @DecimalMin(value = "0.01", message = "Prețul trebuie să fie pozitiv")
    private BigDecimal price;

    @NotNull(message = "Cantitatea în stoc este obligatorie")
    @Min(value = 0, message = "Stocul nu poate fi negativ")
    private Integer stockQuantity;

    // private String imageBase64; // COMENTAT TEMPORAR

    @NotNull(message = "ID-ul categoriei este obligatoriu")
    private Long categoryId;
    private String categoryName;

    private List<SpecificationDto> specifications;
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/model/OrderItem.java">
// src/main/java/com/magazincomputere/magazin_api/model/OrderItem.java
package com.magazincomputere.magazin_api.model;

import java.math.BigDecimal;

import jakarta.persistence.*;
import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Entity
@Table(name = "order_items")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class OrderItem {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "order_id", nullable = false)
    private Order order;

    @NotNull(message = "ID-ul produsului este obligatoriu pentru un articol de comandă")
    @Column(nullable = false)
    private Long productIdSnapshot;

    @NotNull(message = "Numele produsului este obligatoriu")
    @Column(nullable = false)
    private String productNameSnapshot;

    // @Lob
    // @Column(columnDefinition = "TEXT")
    // private String productImageBase64Snapshot; // COMENTAT TEMPORAR

    @NotNull(message = "Cantitatea este obligatorie")
    @Min(value = 1, message = "Cantitatea trebuie să fie cel puțin 1")
    @Column(nullable = false)
    private Integer quantity;

    @NotNull(message = "Prețul la achiziție este obligatoriu")
    @Column(nullable = false)
    private BigDecimal priceAtPurchase;

    @NotNull(message = "Totalul liniei este obligatoriu")
    @Column(nullable = false)
    private BigDecimal lineTotal;
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/model/Product.java">
// src/main/java/com/magazincomputere/magazin_api/model/Product.java
package com.magazincomputere.magazin_api.model;

import jakarta.persistence.*;
import jakarta.validation.constraints.DecimalMin;
import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.math.BigDecimal;
import java.util.List;

@Entity
@Table(name = "products")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class Product {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @NotBlank(message = "Numele produsului este obligatoriu")
    @Size(min = 3, max = 255, message = "Numele produsului trebuie să aibă între 3 și 255 de caractere")
    @Column(nullable = false)
    private String name;

    @Column(columnDefinition = "TEXT")
    private String description;

    @NotNull(message = "Prețul este obligatoriu")
    @DecimalMin(value = "0.01", message = "Prețul trebuie să fie pozitiv")
    @Column(nullable = false)
   private BigDecimal price;

    @NotNull(message = "Cantitatea în stoc este obligatorie")
    @Min(value = 0, message = "Stocul nu poate fi negativ")
    @Column(nullable = false)
    private Integer stockQuantity;

    // @Lob // Adnotarea @Lob este importantă pentru câmpuri mari de tip TEXT în unele baze de date
    // @Column(columnDefinition = "TEXT") // Asigură-te că tipul de coloană este adecvat pentru base64
    // private String imageBase64; // COMENTAT TEMPORAR

    @ManyToOne(fetch = FetchType.EAGER)
    @JoinColumn(name = "category_id", nullable = false)
    @NotNull(message = "Categoria este obligatorie")
    private Category category;

    @OneToMany(mappedBy = "product", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private List<ProductSpecificationValue> specifications;

    public Product(Long id) {
        this.id = id;
    }
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/model/Role.java">
// src/main/java/com/magazincomputere/magazin_api/model/Role.java
package com.magazincomputere.magazin_api.model;

import jakarta.persistence.*;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import org.hibernate.annotations.JdbcTypeCode; // << IMPORTĂ ACEASTA
import org.hibernate.type.SqlTypes;           // << IMPORTĂ ACEASTA

@Entity
@Table(name = "roles")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Role {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;

    @Enumerated(EnumType.STRING)
    @JdbcTypeCode(SqlTypes.VARCHAR) // << ADAUGĂ ACEASTĂ ADNOTARE
    @Column(length = 20, unique = true, nullable = false)
    private ERole name;
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/repository/OrderRepository.java">
// src/main/java/com/magazincomputere/magazin_api/repository/OrderRepository.java
package com.magazincomputere.magazin_api.repository;

import com.magazincomputere.magazin_api.model.Order;
import com.magazincomputere.magazin_api.model.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface OrderRepository extends JpaRepository<Order, Long> {

    /**
     * Găsește toate comenzile pentru un utilizator specific, ordonate descrescător după data comenzii.
     * @param user Utilizatorul pentru care se caută comenzile.
     * @return O listă de comenzi.
     */
    List<Order> findByUserOrderByOrderDateDesc(User user);

    /**
     * Găsește toate comenzile cu un anumit status, ordonate descrescător după data comenzii.
     * @param status Statusul comenzii.
     * @return O listă de comenzi.
     */
    List<Order> findByStatusOrderByOrderDateDesc(String status);

    /**
     * Găsește toate comenzile, ordonate descrescător după data comenzii.
     * @return O listă cu toate comenzile ordonate.
     */
    List<Order> findAllByOrderByOrderDateDesc();

    // Poți adăuga și alte metode custom de interogare aici dacă este necesar.
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/service/OrderService.java">
// src/main/java/com/magazincomputere/magazin_api/service/OrderService.java
package com.magazincomputere.magazin_api.service;

import com.magazincomputere.magazin_api.dto.OrderDto;
import com.magazincomputere.magazin_api.dto.OrderItemDto;
import com.magazincomputere.magazin_api.dto.OrderStatusUpdateDto;
import com.magazincomputere.magazin_api.exception.BadRequestException;
import com.magazincomputere.magazin_api.exception.ResourceNotFoundException;
import com.magazincomputere.magazin_api.model.*;
import com.magazincomputere.magazin_api.repository.*;
import jakarta.transaction.Transactional;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

@Service
public class OrderService {

    @Autowired
    private OrderRepository orderRepository;

    // @Autowired // Comentat - presupunem salvare prin cascadă din Order
    // private OrderItemRepository orderItemRepository; 

    @Autowired
    private ProductRepository productRepository;

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private CustomerRepository customerRepository;

    private OrderDto convertToDto(Order order) {
        OrderDto orderDto = new OrderDto();
        orderDto.setId(order.getId());
        if (order.getUser() != null) {
            orderDto.setUserId(order.getUser().getId());
            orderDto.setUsername(order.getUser().getUsername());
        } else if (order.getCustomer() != null) {
             orderDto.setUsername(order.getCustomer().getFirstName() + " " + order.getCustomer().getLastName());
        }
        orderDto.setOrderDate(order.getOrderDate());
        orderDto.setStatus(order.getStatus());
        orderDto.setTotalAmount(order.getTotalAmount()); // Direct BigDecimal to BigDecimal


        orderDto.setCustomerName(order.getShippingCustomerName());
        orderDto.setShippingAddress(order.getShippingAddress());
        orderDto.setCustomerEmail(order.getShippingCustomerEmail());
        orderDto.setCustomerPhone(order.getShippingCustomerPhone());

        if (order.getOrderItems() != null) {
            orderDto.setOrderItems(order.getOrderItems().stream()
                    .map(this::convertOrderItemToDto)
                    .collect(Collectors.toList()));
        }
        return orderDto;
    }

    private OrderItemDto convertOrderItemToDto(OrderItem orderItem) {
        OrderItemDto dto = new OrderItemDto();
        dto.setId(orderItem.getId());
        dto.setProductId(orderItem.getProductIdSnapshot());
        dto.setProductNameSnapshot(orderItem.getProductNameSnapshot());
        dto.setQuantity(orderItem.getQuantity());
        dto.setPriceAtPurchase(orderItem.getPriceAtPurchase()); // Direct BigDecimal to BigDecimal
        dto.setLineTotal(orderItem.getLineTotal()); // Direct BigDecimal to BigDecimal
        return dto;
    }


    @Transactional
    public OrderDto createOrder(OrderDto orderDto, Long userId) {
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new ResourceNotFoundException("User not found with id: " + userId));

        Customer customer = customerRepository.findByUserId(userId).orElseGet(() -> {
            Customer newCustomer = new Customer();
            newCustomer.setUser(user);
            newCustomer.setEmail(orderDto.getCustomerEmail());
            String[] nameParts = orderDto.getCustomerName().split(" ", 2);
            newCustomer.setFirstName(nameParts.length > 0 ? nameParts[0] : orderDto.getCustomerName());
            if (nameParts.length > 1) newCustomer.setLastName(nameParts[1]); else newCustomer.setLastName("");
            newCustomer.setPhone(orderDto.getCustomerPhone());
            newCustomer.setAddressDetails(orderDto.getShippingAddress());
            return customerRepository.save(newCustomer);
        });

        Order order = new Order();
        order.setUser(user);
        order.setCustomer(customer);
        order.setShippingCustomerName(orderDto.getCustomerName());
        order.setShippingAddress(orderDto.getShippingAddress());
        order.setShippingCustomerEmail(orderDto.getCustomerEmail());
        order.setShippingCustomerPhone(orderDto.getCustomerPhone());

        List<OrderItem> orderItemsList = new ArrayList<>();
        BigDecimal totalOrderAmount = BigDecimal.ZERO;

        if (orderDto.getOrderItems() == null || orderDto.getOrderItems().isEmpty()) {
            throw new BadRequestException("Order must contain at least one item.");
        }

        for (OrderItemDto itemDto : orderDto.getOrderItems()) {
            Product product = productRepository.findById(itemDto.getProductId())
                    .orElseThrow(() -> new ResourceNotFoundException("Product not found with id: " + itemDto.getProductId()));

            if (product.getStockQuantity() < itemDto.getQuantity()) {
                throw new BadRequestException("Insufficient stock for product: " + product.getName());
            }

            OrderItem orderItem = new OrderItem();
            orderItem.setOrder(order);
            orderItem.setProductIdSnapshot(product.getId());
            orderItem.setProductNameSnapshot(product.getName());
            orderItem.setQuantity(itemDto.getQuantity());
            
            // Acum `product.getPrice()` este deja BigDecimal
            BigDecimal itemPrice = product.getPrice(); 
            orderItem.setPriceAtPurchase(itemPrice); // Setează direct BigDecimal

            BigDecimal quantity = new BigDecimal(itemDto.getQuantity());
            BigDecimal lineTotal = itemPrice.multiply(quantity); 
            
            orderItem.setLineTotal(lineTotal); // Setează direct BigDecimal

            orderItemsList.add(orderItem);
            totalOrderAmount = totalOrderAmount.add(lineTotal);

            product.setStockQuantity(product.getStockQuantity() - itemDto.getQuantity());
            productRepository.save(product);
        }

        order.setOrderItems(orderItemsList);
        order.setTotalAmount(totalOrderAmount); // Setează direct BigDecimal

        Order savedOrder = orderRepository.save(order);
        return convertToDto(savedOrder);
    }

    public List<OrderDto> getOrdersByUser(Long userId) {
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new ResourceNotFoundException("User not found with id: " + userId));
        return orderRepository.findByUserOrderByOrderDateDesc(user)
                .stream()
                .map(this::convertToDto)
                .collect(Collectors.toList());
    }

    public List<OrderDto> getAllOrders(String status) {
        List<Order> orders;
        if (status != null && !status.trim().isEmpty()) {
            orders = orderRepository.findByStatusOrderByOrderDateDesc(status);
        } else {
            orders = orderRepository.findAllByOrderByOrderDateDesc();
        }
        return orders.stream().map(this::convertToDto).collect(Collectors.toList());
    }
     public OrderDto getOrderById(Long orderId) {
        Order order = orderRepository.findById(orderId)
                .orElseThrow(() -> new ResourceNotFoundException("Order not found with id: " + orderId));
        return convertToDto(order);
    }

    @Transactional
    public OrderDto updateOrderStatus(Long orderId, OrderStatusUpdateDto statusUpdateDto) {
        Order order = orderRepository.findById(orderId)
                .orElseThrow(() -> new ResourceNotFoundException("Order not found with id: " + orderId));

        // TODO: Adaugă validare pentru tranzițiile de status permise, dacă e necesar
        order.setStatus(statusUpdateDto.getNewStatus().toUpperCase());
        Order updatedOrder = orderRepository.save(order);
        return convertToDto(updatedOrder);
    }
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/service/ProductService.java">
package com.magazincomputere.magazin_api.service;

import com.magazincomputere.magazin_api.dto.ProductDto;
import com.magazincomputere.magazin_api.dto.SpecificationDto;
import com.magazincomputere.magazin_api.exception.ResourceNotFoundException;
import com.magazincomputere.magazin_api.model.Category;
import com.magazincomputere.magazin_api.model.Product;
import com.magazincomputere.magazin_api.model.ProductSpecificationValue;
import com.magazincomputere.magazin_api.model.SpecificationDefinition;
import com.magazincomputere.magazin_api.repository.CategoryRepository;
import com.magazincomputere.magazin_api.repository.ProductRepository;
import com.magazincomputere.magazin_api.repository.ProductSpecificationValueRepository;
import com.magazincomputere.magazin_api.repository.SpecificationDefinitionRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

@Service
public class ProductService {

    @Autowired
    private ProductRepository productRepository;
    @Autowired
    private CategoryRepository categoryRepository;
    @Autowired
    private SpecificationDefinitionRepository specificationDefinitionRepository;
    @Autowired
    private ProductSpecificationValueRepository productSpecificationValueRepository; // Adăugat

    private ProductDto convertToDto(Product product) {
        ProductDto dto = new ProductDto();
        dto.setId(product.getId());
        dto.setName(product.getName());
        dto.setDescription(product.getDescription());
        dto.setPrice(product.getPrice());
        dto.setStockQuantity(product.getStockQuantity());
      //  dto.setImageBase64(product.getImageBase64());
        if (product.getCategory() != null) {
            dto.setCategoryId(product.getCategory().getId());
            dto.setCategoryName(product.getCategory().getName());
        }
        if (product.getSpecifications() != null) {
            dto.setSpecifications(product.getSpecifications().stream().map(specVal ->
                new SpecificationDto(
                    specVal.getSpecificationDefinition().getId(),
                    specVal.getSpecificationDefinition().getName(),
                    specVal.getValue(),
                    specVal.getSpecificationDefinition().getUnit()
                )
            ).collect(Collectors.toList()));
        }
        return dto;
    }

    private Product convertToEntity(ProductDto productDto, Product product) {
        product.setName(productDto.getName());
        product.setDescription(productDto.getDescription());
        product.setPrice(productDto.getPrice());
        product.setStockQuantity(productDto.getStockQuantity());
       // product.setImageBase64(productDto.getImageBase64());

        if (productDto.getCategoryId() != null) {
            Category category = categoryRepository.findById(productDto.getCategoryId())
                    .orElseThrow(() -> new ResourceNotFoundException("Category not found with id: " + productDto.getCategoryId()));
            product.setCategory(category);
        } else {
            product.setCategory(null);
        }

        // Gestionare specificații
        // Șterge specificațiile vechi (o abordare simplă; poate fi optimizată)
        if (product.getId() != null) { // Doar pentru update
             product.getSpecifications().clear(); // Va declanșa orphanRemoval dacă e configurat
             // Alternativ, iterează și șterge manual dacă orphanRemoval nu e suficient:
             // productSpecificationValueRepository.deleteAll(product.getSpecifications());
        }


        if (productDto.getSpecifications() != null) {
            List<ProductSpecificationValue> newSpecValues = new ArrayList<>();
            for (SpecificationDto specDto : productDto.getSpecifications()) {
                SpecificationDefinition def;
                if (specDto.getDefinitionId() != null) {
                    def = specificationDefinitionRepository.findById(specDto.getDefinitionId())
                        .orElseThrow(() -> new ResourceNotFoundException("SpecificationDefinition not found with id: " + specDto.getDefinitionId()));
                } else if (specDto.getName() != null && !specDto.getName().trim().isEmpty()){
                    // Caută sau creează o nouă definiție de specificație dacă se trimite numele
                    def = specificationDefinitionRepository.findByNameIgnoreCase(specDto.getName().trim())
                        .orElseGet(() -> {
                            SpecificationDefinition newDef = new SpecificationDefinition();
                            newDef.setName(specDto.getName().trim());
                            newDef.setUnit(specDto.getUnit()); // Salvează și unitatea dacă e trimisă
                            return specificationDefinitionRepository.save(newDef);
                        });
                } else {
                    throw new IllegalArgumentException("Specification must have a definitionId or a name.");
                }

                ProductSpecificationValue specValue = new ProductSpecificationValue();
                specValue.setProduct(product); // Asociază cu produsul curent
                specValue.setSpecificationDefinition(def);
                specValue.setValue(specDto.getValue());
                newSpecValues.add(specValue);
            }
             product.setSpecifications(newSpecValues); // Setează noua listă
        } else {
             product.setSpecifications(new ArrayList<>()); // Sau lasă null dacă este permis
        }
        return product;
    }
    // Restul metodelor (getAllProducts, getProductById, createProduct, updateProduct, deleteProduct)
    // rămân ca în exemplul anterior, dar vor beneficia de noile metode de conversie.
    // Asigură-te că createProduct și updateProduct apelează corect convertToEntity.

    @Transactional(readOnly = true)
    public List<ProductDto> getAllProducts() {
        return productRepository.findAll().stream()
                .map(this::convertToDto)
                .collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public ProductDto getProductById(Long id) {
        Product product = productRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Product not found with id: " + id));
        return convertToDto(product);
    }

    @Transactional
    public ProductDto createProduct(ProductDto productDto) {
        Product product = new Product();
        product = convertToEntity(productDto, product); // Se mapează și specificațiile
        Product savedProduct = productRepository.save(product);
        return convertToDto(savedProduct);
    }

    @Transactional
    public ProductDto updateProduct(Long id, ProductDto productDto) {
        Product existingProduct = productRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Product not found with id: " + id));

        // Salvează referința la specificațiile vechi înainte de a le curăța din entitate
        // pentru a le șterge explicit dacă orphanRemoval nu funcționează cum te aștepți
        // sau dacă vrei control mai fin. Această parte poate fi complexă.
        // O strategie simplă este ca convertToEntity să gestioneze curățarea și adăugarea.

        existingProduct = convertToEntity(productDto, existingProduct);
        Product updatedProduct = productRepository.save(existingProduct);
        return convertToDto(updatedProduct);
    }

    @Transactional
    public void deleteProduct(Long id) {
        if (!productRepository.existsById(id)) {
            throw new ResourceNotFoundException("Product not found with id: " + id);
        }
        productRepository.deleteById(id);
    }
}
</file>

<file path="backend/src/main/java/com/magazincomputere/magazin_api/util/DataInitializer.java">
// src/main/java/com/magazincomputere/magazin_api/util/DataInitializer.java
package com.magazincomputere.magazin_api.util;

import com.magazincomputere.magazin_api.model.ERole;
import com.magazincomputere.magazin_api.model.Role;
import com.magazincomputere.magazin_api.repository.RoleRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.CommandLineRunner;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Component;

/**
 * Această componentă rulează o singură dată la pornirea aplicației.
 * Scopul său este să inițializeze datele esențiale în baza de date,
 * cum ar fi rolurile de utilizator.
 */
@Component
public class DataInitializer implements CommandLineRunner {

    @Autowired
    private RoleRepository roleRepository;

    @Autowired
    private PasswordEncoder passwordEncoder;

    /**
     * Această metodă va fi executată la pornirea aplicației Spring Boot.
     */
    @Override
    public void run(String... args) throws Exception {
        
        // ==============================================================================
        // == GENERAREA HASH-URILOR PENTRU PAROLE (SCOP TEMPORAR) ==
        // ==============================================================================
        System.out.println("====================================================================");
        System.out.println("Parola pentru 'admin123' encodata: " + passwordEncoder.encode("admin123"));
        System.out.println("Parola pentru 'user123' encodata: " + passwordEncoder.encode("user123"));
        System.out.println("====================================================================");
        // ==============================================================================


        // ==============================================================================
        // == INIȚIALIZAREA ROLURILOR ÎN BAZA DE DATE ==
        // ==============================================================================
        try {
            // Verifică dacă rolul ROLE_USER există
            if (roleRepository.findByName(ERole.ROLE_USER).isEmpty()) {
                // Creează un obiect Role folosind constructorul fără argumente
                Role userRole = new Role();
                // Setează numele rolului
                userRole.setName(ERole.ROLE_USER);
                // Salvează obiectul în baza de date
                roleRepository.save(userRole); // <<< CORECTAT
                System.out.println("Rolul ROLE_USER a fost adăugat în baza de date.");
            }

            // Verifică dacă rolul ROLE_ADMIN există
            if (roleRepository.findByName(ERole.ROLE_ADMIN).isEmpty()) {
                // Creează un obiect Role folosind constructorul fără argumente
                Role adminRole = new Role();
                // Setează numele rolului
                adminRole.setName(ERole.ROLE_ADMIN);
                // Salvează obiectul în baza de date
                roleRepository.save(adminRole); // <<< CORECTAT
                System.out.println("Rolul ROLE_ADMIN a fost adăugat în baza de date.");
            }
        } catch (Exception e) {
            System.err.println("Eroare la inițializarea rolurilor: " + e.getMessage());
        }
    }
}
</file>

<file path="backend/src/main/resources/application.properties">
# Server Port
server.port=8080

# MySQL Datasource Configuration
# Înlocuiește 'magazin_computere_db' cu numele bazei tale de date create în MySQL Workbench.
# Înlocuiește 'root' și 'parola_ta_mysql' cu userul și parola ta MySQL.
spring.datasource.url=jdbc:mysql://localhost:3306/licenta?useSSL=false&serverTimezone=UTC&allowPublicKeyRetrieval=true
spring.datasource.username=root
spring.datasource.password=wx9ec8rv7
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

# JPA and Hibernate Configuration for MySQL
# Pentru MySQL 8+, dialectul este org.hibernate.dialect.MySQLDialect sau org.hibernate.dialect.MySQL8Dialect (mai nou)
# Pentru versiuni mai vechi de MySQL (ex: 5.7), poți folosi org.hibernate.dialect.MySQL57Dialect
spring.jpa.database-platform=org.hibernate.dialect.MySQLDialect

# Strategia DDL (Data Definition Language)
# RECOMANDAT: 'validate' - Hibernate verifică dacă schema din DB corespunde cu entitățile. Eșuează la pornire dacă sunt nepotriviri.
# SAU: 'none' - Hibernate nu face nimic cu schema. Tu ești responsabil pentru crearea și actualizarea ei manuală.
# EVITĂ: 'update' pe termen lung sau în producție cu MySQL, deoarece poate fi imprevizibil.
# NICIODATĂ: 'create' sau 'create-drop' dacă vrei să păstrezi datele între reporniri.
spring.jpa.hibernate.ddl-auto=validate

# Afișare SQL generat de Hibernate (util pentru debugging)
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true
# spring.jpa.properties.hibernate.use_sql_comments=true # Opțional, adaugă comentarii în SQL-ul logat

# JWT Properties (rămân la fel)
app.jwtSecret=ThisIsMySuperLongAndVerySecureSecretKeyForMagazinComputereLicentaProject2025
app.jwtExpirationMs=86400000

# SpringDoc OpenAPI (Swagger UI) (rămân la fel)
springdoc.api-docs.path=/api-docs
springdoc.swagger-ui.path=/swagger-ui.html
springdoc.swagger-ui.operationsSorter=method
springdoc.swagger-ui.tagsSorter=alpha
# springdoc.swagger-ui.doc-expansion=none # Opțional, controlează cum se expandează documentația

# H2 Console (dezactivează-l când folosești MySQL sau PostgreSQL)
spring.h2.console.enabled=false
# spring.h2.console.path=/h2-console
# spring.h2.console.settings.trace=false
# spring.h2.console.settings.web-allow-others=false
</file>

<file path="frontend/src/app/app.component.html">
<mat-toolbar color="primary" class="app-toolbar" *ngIf="!hideToolbar">
  <button mat-icon-button routerLink="/" aria-label="Pagina principală">
    <mat-icon>storefront</mat-icon>
  </button>
  <span class="app-title" routerLink="/">{{ title }}</span>

  <span class="toolbar-spacer"></span>

  <button mat-button routerLink="/products-list">
    <mat-icon>list_alt</mat-icon> Produse
  </button>

  <button mat-icon-button routerLink="/cart" aria-label="Coș de cumpărături">
    <mat-icon>shopping_cart</mat-icon>
  </button>

  <ng-container *ngIf="!isLoggedIn">
    <button mat-stroked-button routerLink="/login" class="auth-button">
      <mat-icon>login</mat-icon> Autentificare
    </button>
  </ng-container>

  <ng-container *ngIf="isLoggedIn">
    <button mat-button [matMenuTriggerFor]="userMenu" class="user-menu-button">
      <mat-icon>account_circle</mat-icon>
      <span>{{ username || 'Cont' }}</span>
      <mat-icon>arrow_drop_down</mat-icon>
    </button>
    <mat-menu #userMenu="matMenu">
      <button mat-menu-item routerLink="/my-profile" *ngIf="userRole === 'user'">
        <mat-icon>manage_accounts</mat-icon> Profilul Meu
      </button>
      <button mat-menu-item routerLink="/my-orders" *ngIf="userRole === 'user'">
        <mat-icon>history</mat-icon> Comenzile Mele
      </button>
      <button mat-menu-item routerLink="/admin" *ngIf="userRole === 'admin'">
        <mat-icon>admin_panel_settings</mat-icon> Panou Admin
      </button>
      <mat-divider></mat-divider>
      <button mat-menu-item (click)="logout()">
        <mat-icon>logout</mat-icon> Deconectare
      </button>
    </mat-menu>
  </ng-container>
</mat-toolbar>

<div class="main-content">
  <router-outlet></router-outlet>
</div>
</file>

<file path="frontend/src/app/app.component.scss">
/* src/app/app.component.scss */

// Am mutat stilurile pentru .app-toolbar în fișierul global styles.scss
// pentru a ne asigura că suprascriu corect tema Angular Material.

.app-toolbar {
  .app-title {
    margin-left: 8px;
    cursor: pointer;
    font-size: 1.25em;
  }

  .toolbar-spacer {
    flex: 1 1 auto;
  }

  button[mat-button], button[mat-stroked-button], button[mat-icon-button] {
    margin: 0 4px;
  }
}
</file>

<file path="frontend/src/app/app.component.ts">
// src/app/app.component.ts
import { Component, inject, OnInit, OnDestroy } from '@angular/core';
import { CommonModule } from '@angular/common';
import { RouterOutlet, RouterModule, Router, NavigationEnd } from '@angular/router';
import { MatToolbarModule } from '@angular/material/toolbar';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatMenuModule } from '@angular/material/menu';
import { MatBadgeModule } from '@angular/material/badge';
import { MatDividerModule } from '@angular/material/divider'; // <<< CORECTAT: Import MatDividerModule

import { AuthService } from './auth/auth.service';
// import { ShoppingCartService } from './features/shopping-cart/shopping-cart.service';
import { Subscription } from 'rxjs';
import { filter } from 'rxjs/operators';

@Component({
  selector: 'app-root',
  standalone: true,
  imports: [
    CommonModule,
    RouterOutlet,
    RouterModule,
    MatToolbarModule,
    MatButtonModule,
    MatIconModule,
    MatMenuModule,
    MatBadgeModule,
    MatDividerModule // <<< CORECTAT: Adaugă MatDividerModule aici
  ],
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.scss']
})
export class AppComponent implements OnInit, OnDestroy {
  title = 'Magazin Calculatoare';
  isLoggedIn = false;
  username: string | null = null;
  userRole: string | null = null;
  // cartItemCount = 0;

  private authSubscription!: Subscription;
  private routerSubscription!: Subscription;
  // private cartSubscription!: Subscription;

  public authService = inject(AuthService);
  private router = inject(Router);
  // private shoppingCartService = inject(ShoppingCartService);

  hideToolbar = false;

  ngOnInit(): void {
    this.authSubscription = this.authService.user$.subscribe(user => {
      this.isLoggedIn = !!user;
      this.username = user ? user.username : null;
      this.userRole = this.authService.role;
    });

    this.isLoggedIn = this.authService.isLoggedIn();
    if (this.isLoggedIn) {
        const currentUser = this.authService.getCurrentUser();
        this.username = currentUser ? currentUser.username : null;
        this.userRole = this.authService.role;
    }

    this.routerSubscription = this.router.events.pipe(
      filter(event => event instanceof NavigationEnd)
    ).subscribe(event => {
      if (event instanceof NavigationEnd) {
        this.hideToolbar = event.urlAfterRedirects === '/login' || event.urlAfterRedirects.startsWith('/signup');
      }
    });

    // this.cartSubscription = this.shoppingCartService.getCartItemCount().subscribe(count => {
    //   this.cartItemCount = count;
    // });
  }

  logout(): void {
    this.authService.logout();
  }

  ngOnDestroy(): void {
    if (this.authSubscription) {
      this.authSubscription.unsubscribe();
    }
    if (this.routerSubscription) {
      this.routerSubscription.unsubscribe();
    }
    // if (this.cartSubscription) {
    //   this.cartSubscription.unsubscribe();
    // }
  }
}
</file>

<file path="frontend/src/app/app.config.ts">
// src/app/app.config.ts
import { ApplicationConfig, importProvidersFrom } from '@angular/core';
import { provideRouter, withComponentInputBinding, withInMemoryScrolling, withViewTransitions } from '@angular/router';
import { provideHttpClient, withFetch, withInterceptors, withInterceptorsFromDi, HTTP_INTERCEPTORS } from '@angular/common/http';
import { provideAnimations } from '@angular/platform-browser/animations';

// Comentează sau elimină HttpClientInMemoryWebApiModule pentru a folosi backend-ul real
// import { HttpClientInMemoryWebApiModule } from 'angular-in-memory-web-api';
// import { InMemoryDataService } from './shared/in-memory-data.service'; // Comentat

import { routes } from './app.routes';
import { AuthInterceptor } from './auth/auth.interceptor'; // <<<--- CALE CORECTATĂ

export const appConfig: ApplicationConfig = {
  providers: [
    provideRouter(
      routes,
      withComponentInputBinding(),
      withInMemoryScrolling({
        scrollPositionRestoration: 'enabled',
        anchorScrolling: 'enabled',
      }),
      withViewTransitions()
    ),

    provideAnimations(),

    provideHttpClient(
      withFetch(),
      withInterceptorsFromDi()
    ),

    { provide: HTTP_INTERCEPTORS, useClass: AuthInterceptor, multi: true },

    /*
    importProvidersFrom(
      HttpClientInMemoryWebApiModule.forRoot(InMemoryDataService, {
        dataEncapsulation: false,
        passThruUnknownUrl: true,
        delay: 300
      })
    )
    */
  ]
};
</file>

<file path="frontend/src/app/app.routes.ts">
import { Routes } from '@angular/router';

// Componenta noua pentru pagina principala
import { HomePageComponent } from './features/home/home-page/home-page.component';

// Componente pentru autentificare si dashboard-uri
import { LoginComponent } from './login/login.component';
import { AdminDashboardComponent } from './features/admin-dashboard/admin-dashboard.component';

// Componente publice
import { ProductListComponent } from './features/products/product-list/product-list.component';
import { ProductDetailComponent } from './features/products/product-detail/product-detail.component';

// Componente pentru sectiuni specifice (Admin & User)
import { AdminCategoryListComponent } from './features/admin/admin-categories/admin-category-list/admin-category-list.component';
import { AdminCategoryFormComponent } from './features/admin/admin-categories/admin-category-form/admin-category-form.component';
import { AdminOrderListComponent } from './features/admin/admin-orders/admin-order-list/admin-order-list.component';
import { AdminOrderDetailComponent } from './features/admin/admin-orders/admin-order-detail/admin-order-detail.component';
import { AdminSpecDefListComponent } from './features/admin/admin-specifications/admin-spec-def-list/admin-spec-def-list.component';
import { AdminSpecDefFormComponent } from './features/admin/admin-specifications/admin-spec-def-form/admin-spec-def-form.component';
import { AdminUserListComponent } from './features/admin/admin-users/admin-user-list/admin-user-list.component';
import { AdminUserFormComponent } from './features/admin/admin-users/admin-user-form/admin-user-form.component';
import { ProductFormComponent } from './features/products/product-form/product-form.component';
import { UserOrderHistoryComponent } from './features/user-dashboard/user-order-history/user-order-history.component';

// Guards pentru securizarea rutelor
import { userGuard } from './auth/user.guard';
import { adminGuard } from './auth/admin.guard';

export const routes: Routes = [
  // Pagina principala (default), publica
  { path: '', component: HomePageComponent, title: 'VipeX Technology' },

  // Ruta de autentificare
  { path: 'login', component: LoginComponent, title: 'Autentificare' },
  
  // Rutele de detalii produs și catalog rămân publice
  { path: 'products-list', component: ProductListComponent, title: 'Catalog Produse' }, // Ruta pentru tabelul vechi
  { path: 'products/:id', component: ProductDetailComponent, title: 'Detalii Produs' },

  // Rute protejate pentru Utilizator (fără un dashboard-wrapper)
  { path: 'my-orders', component: UserOrderHistoryComponent, canActivate: [userGuard], title: 'Comenzile Mele' },
  // { path: 'my-profile', component: UserProfileComponent, canActivate: [userGuard], title: 'Profilul Meu' },

  // Rute protejate pentru Administrator
  {
    path: 'admin',
    component: AdminDashboardComponent,
    canActivate: [adminGuard],
    children: [
      { path: '', redirectTo: 'products', pathMatch: 'full' },
      { path: 'products', children: [
          { path: '', component: ProductListComponent, title: 'Administrare Produse' },
          { path: 'new', component: ProductFormComponent, title: 'Adaugă Produs' },
          { path: 'edit/:id', component: ProductFormComponent, title: 'Editează Produs' },
      ]},
      { path: 'categories', children: [
          { path: '', component: AdminCategoryListComponent, title: 'Administrare Categorii' },
          { path: 'new', component: AdminCategoryFormComponent, title: 'Adaugă Categorie' },
          { path: 'edit/:id', component: AdminCategoryFormComponent, title: 'Editează Categorie' },
      ]},
      { path: 'orders', children: [
          { path: '', component: AdminOrderListComponent, title: 'Administrare Comenzi' },
          { path: ':id', component: AdminOrderDetailComponent, title: 'Detalii Comandă' },
      ]},
      { path: 'specification-definitions', children: [
          { path: '', component: AdminSpecDefListComponent, title: 'Definiții Specificații' },
          { path: 'new', component: AdminSpecDefFormComponent, title: 'Adaugă Definiție' },
          { path: 'edit/:id', component: AdminSpecDefFormComponent, title: 'Editează Definiție' },
      ]},
      { path: 'users', children: [
          { path: '', component: AdminUserListComponent, title: 'Administrare Utilizatori' },
          { path: 'edit/:id', component: AdminUserFormComponent, title: 'Editează Utilizator' },
      ]}
    ]
  },

  // Orice altceva redirecționează la pagina principală
  { path: '**', redirectTo: '', pathMatch: 'full' }
];
</file>

<file path="frontend/src/app/auth/admin.guard.ts">
// src/app/auth/admin.guard.ts
import { inject } from '@angular/core';
import { CanActivateFn, Router, UrlTree, ActivatedRouteSnapshot, RouterStateSnapshot } from '@angular/router';
import { AuthService } from './auth.service';

export const adminGuard: CanActivateFn = (route: ActivatedRouteSnapshot, state: RouterStateSnapshot): boolean | UrlTree => {
  const authService = inject(AuthService);
  const router = inject(Router);

  if (authService.isLoggedIn() && authService.role === 'admin') {
    return true;
  } else if (authService.isLoggedIn() && authService.role !== 'admin') {
    // Utilizator logat dar nu e admin, redirecționează la pagina lui de user
    console.warn('AdminGuard: User is logged in but not an admin. Redirecting to /user');
    return router.createUrlTree(['/user']); // Sau o pagină 'unauthorized' dedicată
  } else {
    // Utilizator nelogat
    console.warn('AdminGuard: User not logged in. Redirecting to /login with returnUrl:', state.url);
    return router.createUrlTree(['/login'], { queryParams: { returnUrl: state.url } });
  }
};
</file>

<file path="frontend/src/app/auth/auth.guard.ts">
// src/app/auth/auth.guard.ts
import { inject } from '@angular/core';
import { CanActivateFn, Router, UrlTree, ActivatedRouteSnapshot, RouterStateSnapshot } from '@angular/router';
import { AuthService } from './auth.service';
// Nu mai este nevoie de Observable, map, tap dacă nu facem operații asincrone complexe aici

export const authGuard: CanActivateFn = (route: ActivatedRouteSnapshot, state: RouterStateSnapshot): boolean | UrlTree => {
  const authService = inject(AuthService);
  const router = inject(Router);

  if (authService.isLoggedIn()) {
    return true;
  } else {
    // Redirecționează la pagina de login, salvând URL-ul curent pentru redirectare după login
    console.warn('AuthGuard: User not logged in. Redirecting to /login with returnUrl:', state.url);
    return router.createUrlTree(['/login'], { queryParams: { returnUrl: state.url } });
  }
};
</file>

<file path="frontend/src/app/auth/auth.service.ts">
// src/app/auth/auth.service.ts
import { Injectable, Inject, PLATFORM_ID, inject } from '@angular/core';
import { isPlatformBrowser } from '@angular/common';
import { Router } from '@angular/router';
import { HttpClient, HttpErrorResponse, HttpResponse } from '@angular/common/http'; // Import HttpClient
import { Observable, BehaviorSubject, throwError, of } from 'rxjs';
import { catchError, map, tap } from 'rxjs/operators';
import { User, JwtResponse, LoginRequest, SignupRequest } from '../shared/models/user.model'; // Asigură-te că JwtResponse și LoginRequest sunt definite în user.model.ts

export type Role = 'admin' | 'user'; // Tipul Role poate rămâne

// Definim o interfață internă pentru utilizatorul stocat, care poate include token-ul
interface StoredUser extends User {
  token?: string;
}

@Injectable({ providedIn: 'root' })
export class AuthService {
  private apiUrl = '/api/auth'; // URL-ul de bază pentru autentificare
  private currentUserSubject: BehaviorSubject<StoredUser | null>;
  public user$: Observable<StoredUser | null>;

  // Variabile pentru stocarea cheilor în localStorage/sessionStorage
  private readonly TOKEN_KEY = 'authToken';
  private readonly USER_KEY = 'currentUserDetails';


  constructor(
    private router: Router,
    private http: HttpClient, // Injectează HttpClient
    @Inject(PLATFORM_ID) private platformId: Object
  ) {
    let initialUser: StoredUser | null = null;
    if (isPlatformBrowser(this.platformId)) {
      const storedToken = localStorage.getItem(this.TOKEN_KEY);
      const storedUserJson = localStorage.getItem(this.USER_KEY);
      if (storedToken && storedUserJson) {
        try {
          initialUser = JSON.parse(storedUserJson) as StoredUser;
          initialUser.token = storedToken; // Adaugă token-ul la obiectul user
        } catch (e) {
          console.error('Eroare la parsarea datelor utilizatorului din localStorage', e);
          localStorage.removeItem(this.TOKEN_KEY);
          localStorage.removeItem(this.USER_KEY);
        }
      }
    }
    this.currentUserSubject = new BehaviorSubject<StoredUser | null>(initialUser);
    this.user$ = this.currentUserSubject.asObservable();
  }

  /**
   * Metodă pentru login.
   * @param username Numele de utilizator.
   * @param password Parola.
   * @returns Un Observable care emite true la succes, false la eșec.
   */
  login(username: string, password: string): Observable<boolean> {
    const loginRequest: LoginRequest = { username, password };
    return this.http.post<JwtResponse>(`${this.apiUrl}/login`, loginRequest)
      .pipe(
        tap(response => {
          // Stochează token-ul și detaliile utilizatorului
          if (response && response.token && response.username) {
            const userDetails: StoredUser = {
              id: response.id,
              username: response.username,
              email: response.email,
              roles: response.roles,
              token: response.token // Include token-ul aici pentru coerență, dar îl stocăm separat
            };
            if (isPlatformBrowser(this.platformId)) {
              localStorage.setItem(this.TOKEN_KEY, response.token);
              localStorage.setItem(this.USER_KEY, JSON.stringify(userDetails));
            }
            this.currentUserSubject.next(userDetails);
          } else {
            // Dacă răspunsul nu este cel așteptat, considerăm login-ul eșuat
            this.handleLoginError(new Error('Răspuns invalid de la server la login.'));
          }
        }),
        map(response => !!(response && response.token)), // Returnează true dacă există token
        catchError(error => {
          this.handleLoginError(error);
          return of(false); // Returnează false în caz de eroare
        })
      );
  }

  /**
   * Metodă pentru signup (înregistrare).
   * @param signupData Datele pentru înregistrare.
   * @returns Un Observable cu răspunsul de la server (ex: MessageResponse).
   */
  signup(signupData: SignupRequest): Observable<any> { // Tipul răspunsului poate varia
    return this.http.post<any>(`${this.apiUrl}/signup`, signupData)
      .pipe(
        catchError(this.handleError) // Poți avea un handler specific pentru signup dacă e nevoie
      );
  }


  private handleLoginError(error: HttpErrorResponse | Error): void { // Acceptă și Error pentru cazuri non-HTTP
    let detailedErrorMessage = 'Eroare necunoscută la login.';
    let userFriendlyMessage = 'Autentificare eșuată. Verificați credențialele sau încercați mai târziu.';

    if (error instanceof HttpErrorResponse) {
        if (error.error && typeof error.error === 'object' && error.error !== null) {
            detailedErrorMessage = (error.error as any).message || JSON.stringify(error.error);
            if ((error.error as any).message) {
                userFriendlyMessage = (error.error as any).message; // Folosește mesajul de la server dacă e relevant
            }
        } else if (typeof error.error === 'string') {
            detailedErrorMessage = error.error;
            userFriendlyMessage = error.error;
        } else {
            detailedErrorMessage = `Status: ${error.status}, Mesaj: ${error.message}`;
        }
         if (error.status === 401) { // Unauthorized
            userFriendlyMessage = 'Nume de utilizator sau parolă incorectă.';
        } else if (error.status === 0 || error.status === -1) {
            userFriendlyMessage = 'Eroare de conexiune cu serverul de autentificare.';
        }

    } else if (error instanceof Error) { // Eroare non-HTTP pasată manual
        detailedErrorMessage = error.message;
        userFriendlyMessage = error.message; // Poate fi un mesaj specific cum ar fi "Răspuns invalid"
    }

    console.error('------------------------------------');
    console.error('[LOGIN ERROR] Mesaj detaliat:', detailedErrorMessage);
    console.error('Obiect eroare complet:', error);
    console.error('------------------------------------');

    // Curăță starea de autentificare
    if (isPlatformBrowser(this.platformId)) {
        localStorage.removeItem(this.TOKEN_KEY);
        localStorage.removeItem(this.USER_KEY);
    }
    this.currentUserSubject.next(null);

    // Nu arunca o eroare aici dacă vrei ca Observable-ul de login să returneze false
    // și să gestionezi afișarea mesajului în componentă sau în subscribe-ul din AuthService.login
    // Dacă arunci eroarea, subscribe-ul din login va intra pe ramura 'error'.
}


  logout(): void {
    if (isPlatformBrowser(this.platformId)) {
      localStorage.removeItem(this.TOKEN_KEY);
      localStorage.removeItem(this.USER_KEY);
    }
    this.currentUserSubject.next(null);
    this.router.navigate(['/login']);
  }

  isLoggedIn(): boolean {
    if (isPlatformBrowser(this.platformId)) {
      return !!localStorage.getItem(this.TOKEN_KEY) && !!this.currentUserSubject.value;
    }
    return false;
  }

  get role(): Role | null {
    const user = this.currentUserSubject.value;
    if (user && user.roles && user.roles.length > 0) {
      // Presupunem că un utilizator are un singur rol principal relevant pentru guard-uri
      // sau că primul rol este cel mai important. Adaptează logica dacă e necesar.
      if (user.roles.includes('ROLE_ADMIN')) {
        return 'admin';
      }
      if (user.roles.includes('ROLE_USER')) {
        return 'user';
      }
    }
    return null;
  }

  getCurrentUser(): StoredUser | null {
    return this.currentUserSubject.value;
  }

  getToken(): string | null {
    if (isPlatformBrowser(this.platformId)) {
      return localStorage.getItem(this.TOKEN_KEY);
    }
    return null;
  }

  private handleError(error: HttpErrorResponse) {
  let userFriendlyErrorMessage = 'A apărut o problemă. Vă rugăm încercați din nou mai târziu.';
  let detailedErrorMessage = 'Eroare necunoscută.';

  // Verificăm mai întâi dacă 'error.error' există și este un obiect (răspuns JSON de la server)
  if (error.error && typeof error.error === 'object' && error.error !== null) {
    // Încercăm să extragem un mesaj specific din corpul erorii trimis de backend
    // Acesta ar putea fi error.error.message, error.error.error, error.error.detail etc.
    // Ajustează în funcție de structura răspunsurilor de eroare de la API-ul tău Spring Boot
    detailedErrorMessage = 
        (error.error as any).message ||         // Cel mai comun (ex: MessageResponse din Spring)
        (error.error as any).detail ||          // Alt câmp comun pentru detalii eroare
        (error.error as any).error?.message ||  // Uneori eroarea e imbricată
        JSON.stringify(error.error);            // Fallback la JSON string dacă e un obiect complex

    // Poți încerca să faci mesajul user-friendly mai specific dacă backend-ul trimite un mesaj clar
    if ((error.error as any).message && typeof (error.error as any).message === 'string') {
      userFriendlyErrorMessage = (error.error as any).message;
    }
  } else if (typeof error.error === 'string') {
    // Corpul erorii de la server este un simplu string
    detailedErrorMessage = error.error;
    userFriendlyErrorMessage = error.error; 
  } else if (error.message) {
    // Eroare client-side sau de rețea (ex: HttpErrorResponse fără error.error, dar cu error.message)
    detailedErrorMessage = error.message;
    if (error.status === 0 || error.status === -1) { // Tipic pentru erori de rețea, CORS, sau server oprit
        userFriendlyErrorMessage = 'Eroare de conexiune cu serverul. Verificați rețeaua sau dacă serverul backend rulează.';
    } else {
        userFriendlyErrorMessage = `A apărut o eroare (${error.status}): ${error.statusText}`;
    }
  } else {
    // Fallback dacă structura erorii nu este cea așteptată
    detailedErrorMessage = `Cod eroare server: ${error.status}, status text: ${error.statusText || 'Necunoscut'}`;
    userFriendlyErrorMessage = `A apărut o eroare (${error.status}). Vă rugăm încercați mai târziu.`;
  }

  console.error('------------------------------------');
  console.error(`[SERVICE ERROR ENCOUNTERED]`);
  console.error(`URL: ${error.url}`);
  console.error(`Status: ${error.status} - ${error.statusText}`);
  console.error(`User-Friendly Message: ${userFriendlyErrorMessage}`);
  console.error(`Detailed Error Message/Body: ${detailedErrorMessage}`);
  console.error('Full HttpErrorResponse Object:', error);
  console.error('------------------------------------');

  // Aruncă o eroare care va fi propagată și poate fi prinsă în componentă
  // sau de un error handler global, dacă există.
  // Pentru utilizator, mesajele sunt de obicei afișate prin MatSnackBar în componentă/serviciu.
  return throwError(() => new Error(userFriendlyErrorMessage));
}
}
</file>

<file path="frontend/src/app/auth/user.guard.ts">
// src/app/auth/user.guard.ts
import { inject } from '@angular/core';
import { CanActivateFn, Router, UrlTree, ActivatedRouteSnapshot, RouterStateSnapshot } from '@angular/router';
import { AuthService } from './auth.service';

export const userGuard: CanActivateFn = (route: ActivatedRouteSnapshot, state: RouterStateSnapshot): boolean | UrlTree => {
  const authService = inject(AuthService);
  const router = inject(Router);

  if (authService.isLoggedIn() && authService.role === 'user') {
    return true;
  } else if (authService.isLoggedIn() && authService.role !== 'user') {
    // Utilizator logat dar nu e 'user' (ex: admin)
    console.warn('UserGuard: User is logged in but not a regular user. Role:', authService.role);
    if (authService.role === 'admin') {
      // Poți decide să permiți adminilor accesul sau să îi redirecționezi
      // return true; // Permite adminului să acceseze și paginile de user
      return router.createUrlTree(['/admin']); // Redirecționează adminul la panoul său
    }
    // Alt rol necunoscut, redirecționează la login
    return router.createUrlTree(['/login'], { queryParams: { returnUrl: state.url } });
  } else {
    // Utilizator nelogat
    console.warn('UserGuard: User not logged in. Redirecting to /login with returnUrl:', state.url);
    return router.createUrlTree(['/login'], { queryParams: { returnUrl: state.url } });
  }
};
</file>

<file path="frontend/src/app/features/admin-dashboard/admin-dashboard.component.html">
<mat-sidenav-container class="admin-dashboard-container">
  <mat-sidenav #sidenav mode="side" opened class="admin-sidenav">
    <div class="sidenav-header">
      <h3>Panou Admin</h3>
    </div>
    <mat-nav-list>
      <a mat-list-item routerLink="/admin/products" routerLinkActive="active-link">
        <mat-icon matListItemIcon>inventory_2</mat-icon>
        <span matListItemTitle>Produse</span>
      </a>
      <a mat-list-item routerLink="/admin/categories" routerLinkActive="active-link">
        <mat-icon matListItemIcon>category</mat-icon>
        <span matListItemTitle>Categorii</span>
      </a>
      <a mat-list-item routerLink="/admin/orders" routerLinkActive="active-link">
        <mat-icon matListItemIcon>shopping_cart</mat-icon>
        <span matListItemTitle>Comenzi</span>
      </a>
      <a mat-list-item routerLink="/admin/specification-definitions" routerLinkActive="active-link">
        <mat-icon matListItemIcon>tune</mat-icon>
        <span matListItemTitle>Def. Specificații</span>
      </a>
      <a mat-list-item routerLink="/admin/users" routerLinkActive="active-link"> <mat-icon matListItemIcon>people</mat-icon>
        <span matListItemTitle>Utilizatori</span>
      </a>
      <!--
      <a mat-list-item routerLink="/admin/reports" routerLinkActive="active-link">
        <mat-icon matListItemIcon>assessment</mat-icon>
        <span matListItemTitle>Rapoarte</span>
      </a>
      -->
      <mat-divider></mat-divider>
      <a mat-list-item (click)="auth.logout()">
        <mat-icon matListItemIcon>logout</mat-icon>
        <span matListItemTitle>Deconectare</span>
      </a>
    </mat-nav-list>
  </mat-sidenav>

  <mat-sidenav-content class="admin-content">
    <router-outlet></router-outlet>
  </mat-sidenav-content>
</mat-sidenav-container>
</file>

<file path="frontend/src/app/features/admin-dashboard/admin-dashboard.component.scss">
// src/app/features/admin-dashboard/admin-dashboard.component.scss

.admin-dashboard-container {
  height: 100vh; // Ocupă întreaga înălțime a viewport-ului
  display: flex;
}

.admin-sidenav {
  width: 250px; // Lățime fixă pentru sidenav
  background-color: #f5f5f5; // O culoare de fundal neutră
  border-right: 1px solid rgba(0, 0, 0, 0.12);

  .sidenav-header {
    padding: 16px;
    text-align: center;
    border-bottom: 1px solid rgba(0, 0, 0, 0.12);
    h3 {
      margin: 0;
      font-size: 1.2em;
      color: #3f51b5; // Culoarea primară Material
    }
  }

  mat-nav-list {
    padding-top: 8px;
  }

  a[mat-list-item] {
    color: rgba(0, 0, 0, 0.87);
    border-left: 4px solid transparent; // Pentru indicatorul active-link
    transition: background-color 0.3s, border-left-color 0.3s;

    &:hover {
      background-color: rgba(0, 0, 0, 0.04);
    }

    &.active-link {
      background-color: rgba(63, 81, 181, 0.1); // O nuanță a culorii primare
      color: #3f51b5; // Culoarea primară
      border-left-color: #3f51b5;
      font-weight: 500;

      mat-icon {
        color: #3f51b5;
      }
    }

    mat-icon[matListItemIcon] {
      margin-right: 16px;
      color: rgba(0,0,0,0.54);
    }
  }

  mat-divider {
    margin: 8px 0;
  }
}

.admin-content {
  flex-grow: 1; // Ocupă spațiul rămas
  padding: 20px; // Spațiere internă pentru conținut
  overflow-y: auto; // Scroll dacă conținutul depășește înălțimea
  background-color: #fafafa; // Un fundal foarte deschis pentru conținut
}

// Stiluri opționale pentru toolbar dacă îl adaugi în admin-content
// mat-toolbar {
//   position: sticky;
//   top: 0;
//   z-index: 1000; // Asigură-te că e deasupra altor elemente
// }
</file>

<file path="frontend/src/app/features/products/product-detail/product-detail.component.html">
<!-- src/app/features/products/product-detail/product-detail.component.html -->
<div class="product-detail-container">
  <button mat-stroked-button routerLink="/admin/products" *ngIf="isAdminView && authService.role === 'admin'" class="back-button">
    <mat-icon>arrow_back</mat-icon> Înapoi la Listă Produse (Admin)
  </button>
  <button mat-stroked-button routerLink="/products" *ngIf="!isAdminView" class="back-button">
    <mat-icon>arrow_back</mat-icon> Înapoi la Produse
  </button>

  <div *ngIf="isLoading" class="loading-indicator">
    <mat-spinner diameter="60"></mat-spinner>
    <p>Se încarcă detaliile produsului...</p>
  </div>

  <div *ngIf="error && !isLoading" class="error-message">
    <p>{{ error }}</p>
    <button mat-stroked-button color="warn" (click)="loadProductDetails()">Reîncearcă</button>
  </div>

  <div *ngIf="product && !isLoading" class="product-content">
    <mat-card class="product-card">
      <mat-card-header class="product-header">
        <div class="header-text">
          <mat-card-title>{{ product.name | titlecase }}</mat-card-title>
          <mat-card-subtitle *ngIf="product.categoryName">Categorie: {{ product.categoryName }}</mat-card-subtitle>
        </div>
        <div class="header-actions" *ngIf="isAdminView && authService.role === 'admin'">
          <button mat-flat-button color="primary" [routerLink]="['/admin/products/edit', product.id]">
            <mat-icon>edit</mat-icon> Editează
          </button>
          <button mat-flat-button color="warn" (click)="deleteProduct()">
            <mat-icon>delete</mat-icon> Șterge
          </button>
        </div>
      </mat-card-header>

      <div class="product-main-info">
        <!-- Secțiunea Imagine - COMENTATĂ TEMPORAR -->
        <!--
        <div class="image-container">
          <img *ngIf="product.imageBase64" [src]="product.imageBase64" [alt]="product.name" class="product-image">
          <div *ngIf="!product.imageBase64" class="no-image-placeholder">
            <mat-icon>photo_camera</mat-icon>
            <span>Imagine indisponibilă</span>
          </div>
        </div>
        -->
        <div class="details-container">
          <p class="price">{{ product.price | currency:'RON':'symbol':'1.2-2' }}</p>
          <p class="stock" [ngClass]="{'in-stock': product.stockQuantity > 0, 'out-of-stock': product.stockQuantity === 0}">
            Stoc: {{ product.stockQuantity > 0 ? product.stockQuantity + ' buc.' : 'Indisponibil' }}
          </p>
          <div class="description" *ngIf="product.description">
            <h4>Descriere:</h4>
            <p [innerHTML]="product.description | nl2br"></p>
          </div>
          <button *ngIf="!isAdminView" mat-raised-button color="accent" class="add-to-cart-button" [disabled]="product.stockQuantity === 0">
            <mat-icon>add_shopping_cart</mat-icon> Adaugă în Coș
          </button>
        </div>
      </div>
      
      <mat-card-content *ngIf="product.specifications && product.specifications.length > 0" class="specifications-section">
        <mat-divider></mat-divider>
        <h3>Specificații Tehnice</h3>
        <mat-list role="list">
          <mat-list-item *ngFor="let spec of product.specifications" role="listitem" class="specification-item">
            <span matListItemTitle class="spec-name">{{ spec.name || 'Specificație' }}:</span>
            <span matListItemLine class="spec-value">{{ spec.value }} {{ spec.unit || '' }}</span>
          </mat-list-item>
        </mat-list>
      </mat-card-content>
    </mat-card>
  </div>
</div>
</file>

<file path="frontend/src/app/features/products/product-detail/product-detail.component.scss">
// src/app/features/products/product-detail/product-detail.component.scss
.product-detail-container {
  padding: 20px;
  max-width: 900px;
  margin: 20px auto;
}

.back-button {
  margin-bottom: 20px;
  mat-icon {
    margin-right: 8px;
  }
}

.loading-indicator,
.error-message {
  text-align: center;
  padding: 40px 20px;
  color: #757575;
  mat-spinner {
    margin: 0 auto 15px auto;
  }
}

.error-message {
  color: #f44336;
}

.product-card {
  width: 100%;
}

.product-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  padding-bottom: 16px;

  .header-text {
    flex-grow: 1;
  }
  .header-actions {
    display: flex;
    gap: 10px;
    flex-shrink: 0;
  }
}

.product-main-info {
  display: flex;
  gap: 24px;
  margin-top: 16px;
  margin-bottom: 24px;

  @media (max-width: 768px) {
    flex-direction: column;
  }

  .image-container {
    flex: 1 1 40%;
    max-width: 400px;
    display: flex;
    justify-content: center;
    align-items: center;
    border: 1px solid #e0e0e0;
    border-radius: 8px;
    padding: 10px;
    background-color: #f9f9f9;
    min-height: 200px; // Asigură o înălțime minimă

    .product-image {
      max-width: 100%;
      max-height: 350px;
      object-fit: contain;
      border-radius: 4px;
    }
    .no-image-placeholder {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #bdbdbd;
      height: 200px;
      mat-icon {
        font-size: 48px;
        width: 48px;
        height: 48px;
      }
      span {
        margin-top: 8px;
      }
    }
  }

  .details-container {
    flex: 1 1 60%;
    display: flex;
    flex-direction: column;

     .price {
      font-size: 2em;
      font-weight: bold;
      color: #448AFF; // MODIFICAT: Albastru accent
      margin-bottom: 8px;
    }
    .stock {
      font-size: 1em;
      margin-bottom: 16px;
      &.in-stock { color: #448AFF; } // MODIFICAT: Albastru în loc de verde
      &.out-of-stock { color: #F44336; }
    }
    .description {
      margin-bottom: 20px;
      h4 {
        margin-bottom: 8px;
        font-size: 1.1em;
        font-weight: 500;
      }
      p {
        line-height: 1.6;
        color: #424242;
        white-space: pre-wrap; // Păstrează spațiile și rândurile noi din text
      }
    }
    .add-to-cart-button {
      margin-top: auto;
      width: 100%;
      max-width: 250px;
      padding: 10px 0;
      font-size: 1em;
      mat-icon {
        margin-right: 8px;
      }
    }
  }
}

.specifications-section {
  padding-top: 16px;
  h3 {
    margin-bottom: 12px;
    font-size: 1.2em;
    font-weight: 500;
    color: rgba(0,0,0,0.77);
  }
  .specification-item {
    border-bottom: 1px dotted #e0e0e0;
    padding: 8px 0;
    &:last-child {
      border-bottom: none;
    }
    .spec-name {
      font-weight: 500;
      color: #333;
      display: inline-block;
      min-width: 150px; // Aliniere
    }
    .spec-value {
      color: #555;
    }
  }
  // Dacă specificațiile sunt într-o listă Material
  mat-list-item {
    .spec-name {
       min-width: auto; // Resetează dacă e în listă
    }
  }
}
</file>

<file path="frontend/src/app/features/products/product-detail/product-detail.component.ts">
// src/app/features/products/product-detail/product-detail.component.ts
import { Component, OnInit, inject, Pipe, PipeTransform } from '@angular/core';
import { CommonModule, CurrencyPipe, TitleCasePipe } from '@angular/common';
import { ActivatedRoute, Router, RouterModule } from '@angular/router';
import { MatCardModule } from '@angular/material/card';
import { MatListModule } from '@angular/material/list';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar';
import { MatChipsModule } from '@angular/material/chips';
import { MatDividerModule } from '@angular/material/divider';
import { DomSanitizer, SafeHtml } from '@angular/platform-browser';


import { Product } from '../../../shared/models/product.model';
import { ProductService } from '../product.service';
import { AuthService } from '../../../auth/auth.service';

// Pipe custom pentru nl2br
@Pipe({
  name: 'nl2br',
  standalone: true
})
export class Nl2brPipe implements PipeTransform {
  constructor(private sanitizer: DomSanitizer) {}
  transform(value: string | null | undefined): SafeHtml {
    if (!value) return '';
    // Înlocuiește \n cu <br> și sanitizează HTML-ul
    return this.sanitizer.bypassSecurityTrustHtml(value.replace(/\n/g, '<br/>'));
  }
}

@Component({
  selector: 'app-product-detail',
  standalone: true,
  imports: [
    CommonModule,
    RouterModule,
    MatCardModule,
    MatListModule,
    MatButtonModule,
    MatIconModule,
    MatProgressSpinnerModule,
    MatSnackBarModule,
    MatChipsModule,
    MatDividerModule,
    CurrencyPipe,
    TitleCasePipe,
    Nl2brPipe // Importă pipe-ul custom
  ],
  templateUrl: './product-detail.component.html',
  styleUrls: ['./product-detail.component.scss']
})
export class ProductDetailComponent implements OnInit {
  product: Product | null = null;
  isLoading = true;
  error: string | null = null;
  productId!: number;
  isAdminView = false;

  private route = inject(ActivatedRoute);
  private router = inject(Router);
  private productService = inject(ProductService);
  private snackBar = inject(MatSnackBar);
  public authService = inject(AuthService);

  ngOnInit(): void {
    const idFromRoute = this.route.snapshot.paramMap.get('id');
    if (idFromRoute) {
      this.productId = +idFromRoute;
      if (!isNaN(this.productId) && this.productId > 0) {
        this.loadProductDetails();
        this.isAdminView = this.router.url.includes('/admin/products/edit/') || this.router.url.endsWith(`/admin/products/${this.productId}`); // Detectează ruta de admin specifică
      } else {
        this.handleInvalidId();
      }
    } else {
      this.handleInvalidId();
    }
  }

  private handleInvalidId(): void {
    this.isLoading = false;
    this.error = 'ID produs invalid.';
    this.snackBar.open(this.error, 'Închide', { duration: 3000 });
    this.router.navigate(['/']);
  }

  loadProductDetails(): void {
    this.isLoading = true;
    this.error = null;
    this.productService.getById(this.productId).subscribe({
      next: (data) => {
        this.product = data;
        this.isLoading = false;
      },
      error: (err) => {
        this.isLoading = false;
        this.error = 'Nu s-au putut încărca detaliile produsului.';
        const errMsg = err.error?.message || err.message || 'Eroare necunoscută.';
        this.snackBar.open(`${this.error} ${errMsg}`, 'Închide', { duration: 5000 });
        console.error(err);
        if (this.isAdminView) {
          this.router.navigate(['/admin/products']);
        } else {
           this.router.navigate(['/products']); // Redirecționează la lista publică de produse
        }
      }
    });
  }
  
  deleteProduct(): void {
    if (!this.product || !this.product.id) return;
    const confirmation = window.confirm('Sunteți sigur că doriți să ștergeți acest produs?');
    if (confirmation) {
      this.isLoading = true;
      this.productService.delete(this.product.id).subscribe({
        next: () => {
          this.isLoading = false;
          this.snackBar.open('Produs șters cu succes!', 'OK', { duration: 3000 });
          this.router.navigate(['/admin/products']);
        },
        error: (err) => {
          this.isLoading = false;
          this.snackBar.open('Eroare la ștergerea produsului.', 'Închide', { duration: 5000 });
          console.error(err);
        }
      });
    }
  }

  // Adaugă o metodă pentru a obține numele definiției specificației dacă nu este direct în `product.specifications`
  // Acest lucru ar necesita ca `ProductDto` din backend să includă și numele definiției, nu doar `definitionId`.
  // Modelul actual `SpecificationValue` are `name` și `unit` opționale, care ar trebui populate în `ProductFormComponent`
  // la selectarea unei `SpecificationDefinition` sau la încărcarea produsului.
  // Backend-ul ar trebui să returneze aceste detalii în `ProductDto.specifications`.

  // Dacă `product.specifications` conține deja `name` și `unit` pentru fiecare specificație (ceea ce ar fi ideal),
  // atunci template-ul HTML este corect.
}
</file>

<file path="frontend/src/app/features/products/product-form/product-form.component.html">
<!-- src/app/features/products/product-form/product-form.component.html -->
<div class="admin-product-form-container">
  <mat-card>
    <mat-card-header>
      <mat-card-title>{{ pageTitle }}</mat-card-title>
    </mat-card-header>
    <mat-card-content>
      <div *ngIf="isLoading && isEditMode" class="spinner-container">
        <mat-progress-spinner diameter="50" mode="indeterminate"></mat-progress-spinner>
        <p>Se încarcă datele produsului...</p>
      </div>

      <form [formGroup]="productForm" (ngSubmit)="onSubmit()" *ngIf="!isLoading || !isEditMode">
        <mat-form-field appearance="outline" class="full-width">
          <mat-label>Nume Produs</mat-label>
          <input matInput formControlName="name" required>
          <mat-error *ngIf="f['name'].hasError('required')">Numele este obligatoriu.</mat-error>
          <mat-error *ngIf="f['name'].hasError('minlength')">Minim 3 caractere.</mat-error>
        </mat-form-field>

        <mat-form-field appearance="outline" class="full-width">
          <mat-label>Descriere</mat-label>
          <textarea matInput formControlName="description" rows="4"></textarea>
        </mat-form-field>

        <div class="form-row">
          <mat-form-field appearance="outline" class="form-row-item">
            <mat-label>Preț (RON)</mat-label>
            <input matInput type="number" formControlName="price" required min="0.01" step="0.01">
            <mat-error *ngIf="f['price'].hasError('required')">Prețul este obligatoriu.</mat-error>
            <mat-error *ngIf="f['price'].hasError('min')">Prețul trebuie să fie pozitiv.</mat-error>
            <mat-error *ngIf="f['price'].hasError('pattern')">Format preț invalid (ex: 123.45).</mat-error>
          </mat-form-field>

          <mat-form-field appearance="outline" class="form-row-item">
            <mat-label>Cantitate Stoc</mat-label>
            <input matInput type="number" formControlName="stockQuantity" required min="0">
            <mat-error *ngIf="f['stockQuantity'].hasError('required')">Stocul este obligatoriu.</mat-error>
            <mat-error *ngIf="f['stockQuantity'].hasError('min')">Stocul nu poate fi negativ.</mat-error>
             <mat-error *ngIf="f['stockQuantity'].hasError('pattern')">Stocul trebuie să fie un număr întreg.</mat-error>
          </mat-form-field>
        </div>

        <mat-form-field appearance="outline" class="full-width">
          <mat-label>Categorie</mat-label>
          <mat-select formControlName="categoryId" required>
            <mat-option *ngFor="let category of categories$ | async" [value]="category.id">
              {{ category.name }}
            </mat-option>
          </mat-select>
          <mat-error *ngIf="f['categoryId'].hasError('required')">Categoria este obligatorie.</mat-error>
        </mat-form-field>

        <!-- Secțiunea de Încărcare Imagine - COMENTATĂ TEMPORAR -->
        <!--
        <div class="image-upload-section">
          <label for="productImageInput" class="image-label">Imagine Produs:</label>
          <input type="file" id="productImageInput" (change)="onFileSelected($event)" accept="image/png, image/jpeg, image/webp">
          <div *ngIf="imagePreview" class="image-preview-container">
            <img [src]="imagePreview" alt="Previzualizare imagine" class="image-preview">
            <button mat-icon-button color="warn" (click)="clearImage()" type="button" aria-label="Șterge imaginea">
              <mat-icon>delete_forever</mat-icon>
            </button>
          </div>
        </div>
        <mat-divider></mat-divider>
        -->

        <div formArrayName="specifications" class="specifications-section">
          <h3>Specificații Produs</h3>
          <div *ngFor="let specGroup of specificationsFormArray.controls; let i = index" [formGroupName]="i" class="specification-item">
            <mat-form-field appearance="outline" class="spec-name-select">
              <mat-label>Specificație</mat-label>
              <mat-select formControlName="definitionId" required>
                <mat-option *ngFor="let def of specDefinitions$ | async" [value]="def.id">
                  {{ def.name }} {{ def.unit ? '(' + def.unit + ')' : '' }}
                </mat-option>
              </mat-select>
               <mat-error *ngIf="specGroup.get('definitionId')?.hasError('required')">Selectați o specificație.</mat-error>
            </mat-form-field>

            <mat-form-field appearance="outline" class="spec-value-input">
              <mat-label>Valoare</mat-label>
              <input matInput formControlName="value" required>
              <mat-error *ngIf="specGroup.get('value')?.hasError('required')">Valoarea este obligatorie.</mat-error>
            </mat-form-field>

            <button mat-icon-button color="warn" type="button" (click)="removeSpecification(i)" aria-label="Șterge specificația">
              <mat-icon>remove_circle_outline</mat-icon>
            </button>
          </div>
          <button mat-stroked-button color="accent" type="button" (click)="addSpecification()" class="add-spec-button">
            <mat-icon>add</mat-icon> Adaugă Specificație
          </button>
        </div>

        <mat-divider></mat-divider>
        <div class="form-actions">
          <button mat-stroked-button color="warn" type="button" routerLink="/admin/products" [disabled]="isLoading">
            <mat-icon>cancel</mat-icon> Anulează
          </button>
          <button mat-raised-button color="primary" type="submit" [disabled]="isLoading || productForm.invalid">
             <mat-icon *ngIf="!isLoading">save</mat-icon>
             <mat-progress-spinner *ngIf="isLoading" diameter="20" mode="indeterminate" style="margin-right: 8px; display: inline-block;"></mat-progress-spinner>
            {{ isLoading ? 'Se salvează...' : submitButtonText }}
          </button>
        </div>
      </form>
    </mat-card-content>
  </mat-card>
</div>
</file>

<file path="frontend/src/app/features/products/product-form/product-form.component.scss">
// src/app/features/products/product-form/product-form.component.scss
.admin-product-form-container {
  padding: 20px;
  max-width: 800px;
  margin: 20px auto;
}

mat-card-header {
  padding-bottom: 16px;
}

.full-width {
  width: 100%;
  margin-bottom: 16px;
}

.form-row {
  display: flex;
  gap: 16px;
  margin-bottom: 16px;
  .form-row-item {
    flex: 1;
  }
}

.spinner-container {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  min-height: 200px;
  p {
    margin-top: 10px;
    color: #757575;
  }
}

.image-upload-section {
  margin-top: 16px;
  margin-bottom: 16px;
  .image-label {
    display: block;
    margin-bottom: 8px;
    font-weight: 500;
  }
  input[type="file"] {
    margin-bottom: 10px;
    display: block; // Asigură că ocupă lățimea necesară
  }
  .image-preview-container {
    margin-top: 10px;
    position: relative;
    display: inline-block;
    border: 1px solid #eee;
    padding: 5px;
    border-radius: 4px;
    background-color: #f9f9f9; // Un fundal deschis pentru previzualizare
  }
  .image-preview {
    max-width: 200px;
    max-height: 200px;
    display: block;
    border-radius: 4px;
  }
  button[mat-icon-button] {
    position: absolute;
    top: -15px; // Ajustează pentru o poziționare mai bună
    right: -15px;
    background-color: white; // Asigură vizibilitatea pe imagine
    border-radius: 50%;
    box-shadow: 0 1px 3px rgba(0,0,0,0.2); // O umbră subtilă
  }
}

.specifications-section {
  margin-top: 20px;
  margin-bottom: 20px;
  padding: 16px;
  border: 1px solid #e0e0e0;
  border-radius: 8px;
  background-color: #f9f9f9;


  h3 {
    margin-top:0;
    margin-bottom: 16px;
    font-size: 1.1em;
    color: rgba(0,0,0,0.77);
  }
  .specification-item {
    display: flex;
    align-items: flex-start; // Aliniază la început pentru a gestiona erorile
    gap: 10px;
    margin-bottom: 12px;
    padding-bottom: 12px;
    border-bottom: 1px dotted #ccc;


    &:last-child {
      margin-bottom: 0;
      padding-bottom: 0;
      border-bottom: none;
    }

    .spec-name-select {
      flex: 2;
    }
    .spec-value-input {
      flex: 3;
    }
    button[mat-icon-button] {
      flex-shrink: 0;
      margin-top: 8px; // Aliniază butonul mai bine cu câmpurile
    }
  }
  .add-spec-button {
    margin-top: 10px;
    mat-icon {
      margin-right: 8px;
    }
  }
}

.form-actions {
  display: flex;
  justify-content: flex-end;
  gap: 10px;
  margin-top: 24px;
  button {
    min-width: 120px;
    mat-icon {
      margin-right: 8px;
    }
  }
}

mat-error {
  font-size: 0.85em;
}
</file>

<file path="frontend/src/app/features/products/product-form/product-form.component.ts">
// src/app/features/products/product-form/product-form.component.ts
import { Component, OnInit, inject } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ReactiveFormsModule, FormBuilder, FormGroup, Validators, FormArray } from '@angular/forms';
import { ActivatedRoute, Router, RouterModule } from '@angular/router';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { MatButtonModule } from '@angular/material/button';
import { MatCardModule } from '@angular/material/card';
import { MatSelectModule } from '@angular/material/select';
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { MatIconModule } from '@angular/material/icon';
import { MatDividerModule } from '@angular/material/divider';
import { HttpErrorResponse } from '@angular/common/http';

import { Product, SpecificationValue } from '../../../shared/models/product.model';
import { Category } from '../../../shared/models/category.model';
import { SpecificationDefinition } from '../../../shared/models/specification-definition.model';

import { ProductService } from '../product.service';
import { CategoryAdminService } from '../../admin/services/category.admin.service';
import { SpecificationAdminService } from '../../admin/services/specification-admin.service';
import { Observable, of } from 'rxjs';
import { catchError } from 'rxjs/operators';

@Component({
  selector: 'app-product-form',
  standalone: true,
  imports: [
    CommonModule, RouterModule, ReactiveFormsModule, MatFormFieldModule, MatInputModule,
    MatButtonModule, MatCardModule, MatSelectModule, MatSnackBarModule,
    MatProgressSpinnerModule, MatIconModule, MatDividerModule
  ],
  templateUrl: './product-form.component.html',
  styleUrls: ['./product-form.component.scss']
})
export class ProductFormComponent implements OnInit {
  productForm!: FormGroup;
  isEditMode = false;
  productId?: number;
  isLoading = false;
  pageTitle = 'Adaugă Produs Nou';
  submitButtonText = 'Salvează Produs';
  error: string | null = null;

  categories$: Observable<Category[]> = of([]);
  specDefinitions$: Observable<SpecificationDefinition[]> = of([]);
  
  // imagePreview: string | ArrayBuffer | null = null; // COMENTAT TEMPORAR

  private fb = inject(FormBuilder);
  private productService = inject(ProductService);
  private categoryAdminService = inject(CategoryAdminService);
  private specAdminService = inject(SpecificationAdminService);
  private route = inject(ActivatedRoute);
  private router = inject(Router);
  private snackBar = inject(MatSnackBar);

  ngOnInit(): void {
    this.productForm = this.fb.group({
      name: ['', [Validators.required, Validators.minLength(3), Validators.maxLength(255)]],
      description: ['', [Validators.maxLength(5000)]],
      price: [null, [Validators.required, Validators.min(0.01), Validators.pattern(/^\d+(\.\d{1,2})?$/)]],
      stockQuantity: [0, [Validators.required, Validators.min(0), Validators.pattern(/^[0-9]*$/)]],
      // imageBase64: [null], // COMENTAT TEMPORAR
      categoryId: [null, Validators.required],
      specifications: this.fb.array([])
    });

    this.loadDropdownData();

    const idFromRoute = this.route.snapshot.paramMap.get('id');
    if (idFromRoute) {
      this.productId = +idFromRoute;
      if (!isNaN(this.productId) && this.productId > 0) {
        this.isEditMode = true;
        this.pageTitle = 'Editează Produs';
        this.submitButtonText = 'Actualizează Produs';
        this.loadProductData(this.productId);
      } else {
        this.handleInvalidId('ID produs invalid din rută.');
      }
    }
  }

  loadDropdownData(): void {
    this.categories$ = this.categoryAdminService.getAll().pipe(
      catchError(err => {
        this.snackBar.open('Eroare la încărcarea categoriilor.', 'OK', { duration: 3000 });
        console.error(err);
        return of([]);
      })
    );
    this.specDefinitions$ = this.specAdminService.getAllDefinitions().pipe(
      catchError(err => {
        this.snackBar.open('Eroare la încărcarea definițiilor de specificații.', 'OK', { duration: 3000 });
        console.error(err);
        return of([]);
      })
    );
  }

  loadProductData(id: number): void {
    this.isLoading = true;
    this.productService.getById(id).subscribe({
      next: (product: Product) => {
        this.productForm.patchValue({
          name: product.name,
          description: product.description,
          price: product.price,
          stockQuantity: product.stockQuantity,
          categoryId: product.categoryId,
        });
        // if (product.imageBase64) { // COMENTAT TEMPORAR
        //   this.imagePreview = product.imageBase64; 
        //   this.productForm.get('imageBase64')?.setValue(product.imageBase64, { emitEvent: false });
        // } // COMENTAT TEMPORAR
        this.specificationsFormArray.clear();
        product.specifications?.forEach(spec => this.addSpecification(spec));
        this.isLoading = false;
      },
      error: (err: HttpErrorResponse) => this.handleLoadError('Eroare la încărcarea datelor produsului.', err)
    });
  }

  get specificationsFormArray(): FormArray {
    return this.productForm.get('specifications') as FormArray;
  }

  createSpecificationGroup(spec?: SpecificationValue): FormGroup {
    return this.fb.group({
      definitionId: [spec?.definitionId || null, Validators.required],
      value: [spec?.value || '', Validators.required],
    });
  }

  addSpecification(spec?: SpecificationValue): void {
    this.specificationsFormArray.push(this.createSpecificationGroup(spec));
  }

  removeSpecification(index: number): void {
    this.specificationsFormArray.removeAt(index);
  }

  /* // COMENTAT TEMPORAR - Funcționalitatea pentru imagini
  onFileSelected(event: Event): void {
    const file = (event.target as HTMLInputElement).files?.[0];
    if (file) {
      const reader = new FileReader();
      reader.onload = () => {
        this.imagePreview = reader.result;
        this.productForm.patchValue({ imageBase64: reader.result as string });
        this.productForm.get('imageBase64')?.markAsDirty(); 
      };
      reader.readAsDataURL(file);
    }
  }

  clearImage(): void {
    this.imagePreview = null;
    this.productForm.patchValue({ imageBase64: null });
    this.productForm.get('imageBase64')?.markAsDirty();
    const fileInput = document.getElementById('productImageInput') as HTMLInputElement;
    if (fileInput) {
      fileInput.value = '';
    }
  }
  */

  onSubmit(): void {
    if (this.productForm.invalid) {
      this.snackBar.open('Formular invalid. Verificați câmpurile.', 'OK', { duration: 3000 });
      this.productForm.markAllAsTouched();
      return;
    }
    this.isLoading = true;
    const formValue = this.productForm.getRawValue();
    const productData: Product = {
        ...formValue,
        // imageBase64: formValue.imageBase64, // COMENTAT TEMPORAR
        specifications: formValue.specifications.map((spec: any) => ({
            definitionId: spec.definitionId,
            value: spec.value
        }))
    };
    // if (productData.imageBase64 === '') { // COMENTAT TEMPORAR
    //     productData.imageBase64 = null;    // COMENTAT TEMPORAR
    // } // COMENTAT TEMPORAR


    const operation = this.isEditMode && this.productId
      ? this.productService.update(this.productId, productData)
      : this.productService.create(productData);

    operation.subscribe({
      next: () => {
        this.isLoading = false;
        this.snackBar.open(`Produs ${this.isEditMode ? 'actualizat' : 'creat'} cu succes!`, 'OK', { duration: 3000 });
        this.router.navigate(['/admin/products']);
      },
      error: (err: HttpErrorResponse) => this.handleSubmitError(`Eroare la ${this.isEditMode ? 'actualizarea' : 'crearea'} produsului.`, err)
    });
  }
  
  private handleInvalidId(message: string): void {
    this.isLoading = false;
    this.error = message;
    this.snackBar.open(this.error, 'Închide', { duration: 3000 });
    this.router.navigate(['/admin/products']);
  }

  private handleLoadError(message: string, err: HttpErrorResponse): void {
    this.isLoading = false;
    const serverErrorMessage = err.error?.message || err.message || 'Eroare necunoscută.';
    this.error = `${message} ${serverErrorMessage}`;
    this.snackBar.open(this.error, 'Închide', { duration: 5000 });
    console.error(err);
    this.router.navigate(['/admin/products']);
  }

  private handleSubmitError(message: string, err: HttpErrorResponse): void {
    this.isLoading = false;
    const serverErrorMessage = err.error?.message || err.message || 'Eroare necunoscută.';
    this.snackBar.open(`${message} ${serverErrorMessage}`, 'Închide', { duration: 5000 });
    console.error(err);
  }

  get f() { return this.productForm.controls; }
}
</file>

<file path="frontend/src/app/features/products/product-list/product-list.component.html">
<div class="admin-product-list-container">
  <div class="header">
    <h2>Administrare Produse</h2>
    <button mat-raised-button color="primary" routerLink="/admin/products/new">
      <mat-icon>add_circle_outline</mat-icon> Adaugă Produs Nou
    </button>
  </div>

  <mat-form-field appearance="outline" class="filter-field">
    <mat-label>Filtrează produse</mat-label>
    <input matInput (keyup)="applyFilter($event)" placeholder="Caută după nume, categorie...">
    <mat-icon matSuffix>search</mat-icon>
  </mat-form-field>

  <div *ngIf="isLoading" class="loading-indicator">
    <mat-spinner diameter="50"></mat-spinner>
    <p>Se încarcă produsele...</p>
  </div>

  <div *ngIf="error && !isLoading" class="error-message">
    <p>{{ error }}</p>
    <button mat-stroked-button color="warn" (click)="loadProducts()">Reîncearcă</button>
  </div>

  <div *ngIf="!isLoading && !error && dataSource.data.length === 0" class="no-data">
    <p>Nu există produse definite sau care să corespundă filtrului.</p>
  </div>

  <div class="table-container" *ngIf="!isLoading && !error && dataSource.data.length > 0">
    <table mat-table [dataSource]="dataSource" matSort class="mat-elevation-z8">

      <ng-container matColumnDef="id">
        <th mat-header-cell *matHeaderCellDef mat-sort-header> ID </th>
        <td mat-cell *matCellDef="let product"> {{product.id}} </td>
      </ng-container>

      <ng-container matColumnDef="name">
        <th mat-header-cell *matHeaderCellDef mat-sort-header> Nume Produs </th>
        <td mat-cell *matCellDef="let product"> {{product.name}} </td>
      </ng-container>

      <ng-container matColumnDef="categoryName">
        <th mat-header-cell *matHeaderCellDef mat-sort-header> Categorie </th>
        <td mat-cell *matCellDef="let product"> {{product.categoryName || 'N/A'}} </td>
      </ng-container>

      <ng-container matColumnDef="price">
        <th mat-header-cell *matHeaderCellDef mat-sort-header> Preț </th>
        <td mat-cell *matCellDef="let product"> {{product.price | currency:'RON':'symbol':'1.2-2'}} </td>
      </ng-container>

      <ng-container matColumnDef="stockQuantity">
        <th mat-header-cell *matHeaderCellDef mat-sort-header> Stoc </th>
        <td mat-cell *matCellDef="let product"> {{product.stockQuantity}} buc. </td>
      </ng-container>

      <ng-container matColumnDef="actions">
        <th mat-header-cell *matHeaderCellDef> Acțiuni </th>
        <td mat-cell *matCellDef="let product">
          <button mat-icon-button color="primary" [routerLink]="['/admin/products/edit', product.id]" aria-label="Editează produsul">
            <mat-icon>edit</mat-icon>
          </button>
          <button mat-icon-button routerLink="/products/{{product.id}}" aria-label="Vezi detalii publice produs">
             <mat-icon>visibility</mat-icon>
          </button>
          <button mat-icon-button color="warn" (click)="deleteProduct(product.id!)" aria-label="Șterge produsul">
            <mat-icon>delete</mat-icon>
          </button>
        </td>
      </ng-container>

      <tr mat-header-row *matHeaderRowDef="displayedColumns"></tr>
      <tr mat-row *matRowDef="let row; columns: displayedColumns;"></tr>

      <tr class="mat-row" *matNoDataRow>
        <td class="mat-cell" [attr.colspan]="displayedColumns.length">
          Nu s-au găsit produse care să corespundă filtrului "{{dataSource.filter}}".
        </td>
      </tr>
    </table>
    <mat-paginator [pageSizeOptions]="[5, 10, 20, 50]" showFirstLastButtons aria-label="Selectează pagina de produse"></mat-paginator>
  </div>
</div>
</file>

<file path="frontend/src/app/features/products/product-list/product-list.component.scss">
// src/app/features/products/product-list/product-list.component.scss
.admin-product-list-container {
  padding: 20px;
  max-width: 1200px;
  margin: auto;
}

.header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
  h2 {
    margin: 0;
  }
  button mat-icon {
    margin-right: 8px;
  }
}

.filter-field {
  width: 100%;
  max-width: 500px;
  margin-bottom: 20px;
}

.loading-indicator,
.error-message,
.no-data {
  text-align: center;
  padding: 20px;
  color: #757575;
  mat-spinner {
    margin: 0 auto 10px auto;
  }
}

.error-message {
  color: #f44336;
}

.table-container {
  overflow-x: auto;
  margin-top: 10px;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

table {
  width: 100%;
}

.mat-column-actions {
  width: 150px;
  text-align: right;
}

.mat-column-id {
  max-width: 80px;
}
.mat-column-price, .mat-column-stockQuantity {
  max-width: 120px;
  text-align: right;
}
.mat-header-cell {
  font-weight: 500;
  color: rgba(0,0,0,0.67);
}

.mat-row:hover {
  background-color: rgba(0,0,0,0.03);
}

.mat-cell, .mat-header-cell {
  padding: 8px 16px;
}
</file>

<file path="frontend/src/app/features/products/product-list/product-list.component.ts">
// src/app/features/products/product-list/product-list.component.ts
import { Component, OnInit, inject, ViewChild, AfterViewInit } from '@angular/core';
import { CommonModule, CurrencyPipe } from '@angular/common';
import { RouterModule } from '@angular/router';
import { MatTableDataSource, MatTableModule } from '@angular/material/table';
import { MatPaginator, MatPaginatorModule } from '@angular/material/paginator';
import { MatSort, MatSortModule } from '@angular/material/sort';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar';
import { MatDialog } from '@angular/material/dialog';

import { Product } from '../../../shared/models/product.model';
import { ProductService } from '../product.service';

@Component({
  selector: 'app-product-list',
  standalone: true,
  imports: [
    CommonModule,
    RouterModule,
    MatTableModule,
    MatPaginatorModule,
    MatSortModule,
    MatFormFieldModule,
    MatInputModule,
    MatButtonModule,
    MatIconModule,
    MatProgressSpinnerModule,
    MatSnackBarModule,
    CurrencyPipe
  ],
  templateUrl: './product-list.component.html',
  styleUrls: ['./product-list.component.scss']
})
export class ProductListComponent implements OnInit, AfterViewInit {
  displayedColumns: string[] = ['id', 'name', 'categoryName', 'price', 'stockQuantity', 'actions'];
  dataSource: MatTableDataSource<Product> = new MatTableDataSource();
  isLoading = true;
  error: string | null = null;

  @ViewChild(MatPaginator) paginator!: MatPaginator;
  @ViewChild(MatSort) sort!: MatSort;

  private productService = inject(ProductService);
  private snackBar = inject(MatSnackBar);

  ngOnInit(): void {
    this.loadProducts();
  }

  ngAfterViewInit(): void {
    this.dataSource.paginator = this.paginator;
    this.dataSource.sort = this.sort;
     // Custom sort pentru categoryName, care e un string
    this.dataSource.sortingDataAccessor = (item, property) => {
      switch (property) {
        case 'categoryName': return item.categoryName || '';
        default: return (item as any)[property];
      }
    };
  }

  loadProducts(): void {
    this.isLoading = true;
    this.error = null;
    this.productService.getAll().subscribe({
      next: (data) => {
        this.dataSource.data = data;
        this.isLoading = false;
      },
      error: (err) => {
        this.error = 'Nu s-au putut încărca produsele.';
        console.error(err);
        this.isLoading = false;
        this.snackBar.open(this.error, 'Închide', { duration: 5000 });
      }
    });
  }

  applyFilter(event: Event): void {
    const filterValue = (event.target as HTMLInputElement).value;
    this.dataSource.filter = filterValue.trim().toLowerCase();
    if (this.dataSource.paginator) {
      this.dataSource.paginator.firstPage();
    }
  }

  deleteProduct(productId: number): void {
    const confirmation = window.confirm('Sunteți sigur că doriți să ștergeți acest produs?');
    if (confirmation) {
      this.productService.delete(productId).subscribe({
        next: () => {
          this.snackBar.open('Produs șters cu succes!', 'OK', { duration: 3000 });
          this.loadProducts();
        },
        error: (err) => {
          this.snackBar.open('Eroare la ștergerea produsului.', 'Închide', { duration: 5000 });
          console.error(err);
        }
      });
    }
  }
}
</file>

<file path="frontend/src/app/features/products/product.service.ts">
// src/app/features/products/product.service.ts
import { Injectable, inject } from '@angular/core';
import { HttpClient, HttpErrorResponse } from '@angular/common/http';
import { Observable, throwError } from 'rxjs';
import { catchError } from 'rxjs/operators';
import { Product } from '../../shared/models/product.model';

@Injectable({
  providedIn: 'root'
})
export class ProductService {
  private apiUrl = '/api/products';

  private http = inject(HttpClient);

  getAll(): Observable<Product[]> {
    return this.http.get<Product[]>(this.apiUrl)
      .pipe(catchError(this.handleError));
  }

  getById(id: number): Observable<Product> {
    return this.http.get<Product>(`${this.apiUrl}/${id}`)
      .pipe(catchError(this.handleError));
  }

  create(product: Product): Observable<Product> {
    return this.http.post<Product>(this.apiUrl, product)
      .pipe(catchError(this.handleError));
  }

  update(id: number, product: Product): Observable<Product> {
    return this.http.put<Product>(`${this.apiUrl}/${id}`, product)
      .pipe(catchError(this.handleError));
  }

  delete(id: number): Observable<void> {
    return this.http.delete<void>(`${this.apiUrl}/${id}`)
      .pipe(catchError(this.handleError));
  }

 private handleError(error: HttpErrorResponse) {
  let userFriendlyErrorMessage = 'A apărut o problemă. Vă rugăm încercați din nou mai târziu.';
  let detailedErrorMessage = 'Eroare necunoscută.';

  if (error.error) {
    // Caz 1: Eroare este un HttpErrorResponse cu un obiect 'error'
    if (typeof error.error === 'object' && error.error !== null) {
      // Încercăm să extragem un mesaj specific din corpul erorii trimis de backend
      // Acesta ar putea fi error.error.message, error.error.error, error.error.detail, etc.
      // Ajustează în funcție de structura răspunsurilor de eroare de la API-ul tău Spring Boot
      detailedErrorMessage = (error.error as any).message ||  // Cel mai comun
                             (error.error as any).error?.message || // Uneori e imbricat
                             (error.error as any).detail ||
                             JSON.stringify(error.error); // Fallback la JSON string dacă e un obiect complex

      // Poți încerca să faci mesajul user-friendly mai specific dacă backend-ul trimite un mesaj clar
      if ((error.error as any).message && typeof (error.error as any).message === 'string') {
        userFriendlyErrorMessage = (error.error as any).message;
      }

    } else if (typeof error.error === 'string') {
      // Caz 2: Corpul erorii este un simplu string
      detailedErrorMessage = error.error;
      userFriendlyErrorMessage = error.error; // Poate fi afișat direct dacă e relevant
    }
  } else if (error.message) {
    // Caz 3: Eroare client-side sau de rețea (ex: HttpErrorResponse fără error.error, dar cu error.message)
    detailedErrorMessage = error.message;
    if (error.status === 0 || error.status === -1) { // Tipic pentru erori de rețea sau CORS
        userFriendlyErrorMessage = 'Eroare de conexiune cu serverul. Verificați rețeaua.';
    } else {
        userFriendlyErrorMessage = 'A apărut o eroare la procesarea cererii.';
    }
  }

  // Logare detaliată în consola dezvoltatorului
  console.error('------------------------------------');
  console.error(`[SERVICE ERROR] Status: ${error.status} - URL: ${error.url}`);
  console.error('Mesaj detaliat:', detailedErrorMessage);
  console.error('Obiect eroare complet:', error);
  console.error('------------------------------------');

  // Aruncă o eroare care va fi propagată și poate fi prinsă în componentă
  // sau de un error handler global, dacă există.
  // Pentru utilizator, mesajele sunt de obicei afișate prin MatSnackBar în componentă/serviciu.
  return throwError(() => new Error(userFriendlyErrorMessage)); // Trimite un mesaj mai general către UI
}
}
</file>

<file path="frontend/src/app/features/user-dashboard/user-dashboard.component.html">
<mat-sidenav-container class="user-dashboard-container">
  <mat-sidenav #sidenav mode="side" opened class="user-sidenav">
    <div class="sidenav-header">
      <mat-icon>account_circle</mat-icon>
      <h3>Salut, {{ authService.getCurrentUser()?.username || 'Client' }}!</h3>
    </div>
    <mat-nav-list>
      <a mat-list-item routerLink="/user/profile" routerLinkActive="active-link">
        <mat-icon matListItemIcon>person</mat-icon>
        <span matListItemTitle>Profilul Meu</span>
      </a>
      <a mat-list-item routerLink="/user/orders" routerLinkActive="active-link">
        <mat-icon matListItemIcon>history</mat-icon>
        <span matListItemTitle>Comenzile Mele</span>
      </a>
      <a mat-list-item routerLink="/products" routerLinkActive="active-link">
        <mat-icon matListItemIcon>storefront</mat-icon>
        <span matListItemTitle>Vezi Produse</span>
      </a>
      <mat-divider></mat-divider>
      <a mat-list-item (click)="authService.logout()">
        <mat-icon matListItemIcon>logout</mat-icon>
        <span matListItemTitle>Deconectare</span>
      </a>
    </mat-nav-list>
  </mat-sidenav>

  <mat-sidenav-content class="user-content">

    <div *ngIf="router.url === '/user' || router.url === '/user/'">

      <section class="hero-section">
        <div class="hero-overlay"></div>
        <div class="hero-content">
          <div class="text-content">
            <h1>Dive into immersive gaming</h1>
            <p>Feel every explosion, every step, and every sound detail with the new VipeX gaming headsets.</p>
            <button mat-flat-button color="primary">Buy now</button>
          </div>
        </div>
      </section>

      <section class="selection-section">
        <h2 class="section-title">Our selection</h2>

        <div *ngIf="isLoadingRecommendations" class="loading-indicator">
          <mat-spinner diameter="60"></mat-spinner>
        </div>

        <div class="product-grid" *ngIf="!isLoadingRecommendations && recommendedProducts.length > 0">
          <mat-card *ngFor="let product of recommendedProducts" class="product-card" [routerLink]="['/products', product.id]">
            
            <div class="product-image-container">
               <mat-icon>inventory_2</mat-icon>
            </div>
      
            <mat-card-header>
              <mat-card-title>{{ product.name }}</mat-card-title>
            </mat-card-header>
            <mat-card-content>
              <p class="product-price">{{ product.price | currency:'RON':'symbol':'1.2-2' }}</p>
            </mat-card-content>
            <mat-card-actions>
              <button mat-stroked-button color="primary" (click)="$event.stopPropagation()">Add to cart</button>
            </mat-card-actions>
          </mat-card>
        </div>
      </section>

      <section class="social-section">
        <h2 class="section-title">Be connected. Be VipeX.</h2>
        <div class="social-icons">
          <a href="#" class="social-icon-box">X</a>
          <a href="#" class="social-icon-box">O</a>
          <a href="#" class="social-icon-box">f</a>
          <a href="#" class="social-icon-box">B</a>
        </div>
      </section>
    </div>

    <router-outlet></router-outlet>
    
  </mat-sidenav-content>
</mat-sidenav-container>
</file>

<file path="frontend/src/app/features/user-dashboard/user-dashboard.component.scss">
/* src/app/features/user-dashboard/user-dashboard.component.scss */

// Stiluri pentru containerul principal și meniul lateral
.user-dashboard-container {
  height: calc(100vh - 64px); 
  display: flex;
}

.user-sidenav {
  width: 240px;
  background-color: #1e1e1e; // Fundal mai închis pentru meniu
  border-right: 1px solid #444;

  .sidenav-header {
    padding: 16px;
    border-bottom: 1px solid #444;
    display: flex;
    align-items: center;
    gap: 10px;

    mat-icon {
      color: #4CAF50; // Accent verde
    }
    h3 {
      margin: 0;
      font-weight: 500;
    }
  }

  a[mat-list-item] {
    color: #ccc;
    border-left: 4px solid transparent;
    transition: background-color 0.3s, border-left-color 0.3s;
    &:hover { background-color: #2a2a2a; }
    &.active-link {
      background-color: rgba(76, 175, 80, 0.1);
      color: #4CAF50;
      border-left-color: #4CAF50;
      font-weight: 500;
      mat-icon { color: #4CAF50; }
    }
  }
}

// Resetează padding-ul default
:host ::ng-deep .mat-drawer-content {
  padding: 0;
  overflow: auto;
}

// Stiluri pentru conținutul principal nou
.user-content {
  background-color: #121212;
  color: #e0e0e0;
}

.section-title {
  color: #4CAF50;
  font-size: 2rem;
  font-weight: bold;
  margin-bottom: 40px;
  text-align: left;
}

.loading-indicator {
  display: flex;
  justify-content: center;
  padding: 40px;
}

/* === Secțiunea Hero === */
.hero-section {
  min-height: 60vh;
  padding: 40px;
  display: flex;
  align-items: center;
  position: relative;
  
  .hero-overlay {
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    background: linear-gradient(to right, #121212 30%, rgba(18, 18, 18, 0.7) 60%, rgba(18, 18, 18, 0) 100%);
  }
  
  .hero-content {
    position: relative;
    z-index: 2;
    max-width: 1200px;
    margin: 0 auto;
    width: 100%;
    
    .text-content {
      max-width: 50%;
      h1 { font-size: 3rem; font-weight: bold; color: white; }
      p { font-size: 1.1rem; line-height: 1.6; margin: 20px 0 30px; }
      button {
        padding: 10px 30px;
        font-size: 1rem;
        background-color: #4CAF50;
        color: #121212;
        font-weight: bold;
      }
    }
  }
}

/* === Secțiunea de Produse === */
.selection-section {
  padding: 60px 40px;
}

.product-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
  gap: 30px;
}

.product-card {
  background-color: #1e1e1e;
  color: #fff;
  border: 1px solid #4CAF50;
  transition: transform 0.2s ease, box-shadow 0.2s ease;
  cursor: pointer;

  &:hover {
    transform: translateY(-8px);
    box-shadow: 0 8px 20px rgba(76, 175, 80, 0.25);
  }

  .product-image-container {
    height: 200px;
    background-color: #121212;
    display: flex;
    align-items: center;
    justify-content: center;
    color: #555;
    mat-icon { font-size: 60px; width: 60px; height: 60px; }
  }

  mat-card-header {
    justify-content: center;
    text-align: center;
  }
  
  mat-card-title {
    color: #4CAF50;
    font-size: 1.1rem;
  }
  
  mat-card-content {
    text-align: center;
    .product-price { font-size: 1.1rem; font-weight: bold; margin-top: 5px; }
  }

  mat-card-actions {
    justify-content: center;
    padding: 0 16px 16px;
    button { border: 1px solid #4CAF50; color: #4CAF50; }
  }
}

/* === Secțiunea Social Media === */
.social-section {
  padding: 60px 40px;
  background-color: #1a1a1a;
  .social-icons {
    display: flex;
    justify-content: center;
    gap: 20px;
    .social-icon-box {
      width: 120px;
      height: 120px;
      background-color: #121212;
      border: 2px solid #4CAF50;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 4rem;
      font-weight: bold;
      color: #4CAF50;
      text-decoration: none;
      transition: background-color 0.2s;
      &:hover { background-color: #2a2a2a; }
    }
  }
}
</file>

<file path="frontend/src/app/features/user-dashboard/user-dashboard.component.ts">
// src/app/features/user-dashboard/user-dashboard.component.ts
import { Component, OnInit, inject } from '@angular/core';
import { CommonModule, CurrencyPipe } from '@angular/common'; // CurrencyPipe pentru preț
import { Router, RouterModule, RouterOutlet } from '@angular/router'; // Router pentru a verifica URL-ul curent
import { MatSidenavModule } from '@angular/material/sidenav';
import { MatListModule } from '@angular/material/list';
import { MatIconModule } from '@angular/material/icon';
import { MatButtonModule } from '@angular/material/button';
import { MatCardModule } from '@angular/material/card'; // Pentru produsele recomandate
import { MatDividerModule } from '@angular/material/divider';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { AuthService } from '../../auth/auth.service';
import { Product } from '../../shared/models/product.model'; // Modelul de produs
import { ProductService } from '../products/product.service'; // Serviciul de produse

@Component({
  selector: 'app-user-dashboard',
  standalone: true,
  imports: [
    CommonModule,
    RouterModule,
    RouterOutlet,
    MatSidenavModule,
    MatListModule,
    MatIconModule,
    MatButtonModule,
    MatCardModule,
    MatDividerModule,
    CurrencyPipe,
    MatProgressSpinnerModule
  ],
  templateUrl: './user-dashboard.component.html',
  styleUrls: ['./user-dashboard.component.scss']
})
export class UserDashboardComponent implements OnInit {
  public authService = inject(AuthService); // Public pentru a fi accesibil în template
  public router = inject(Router); // Public pentru a verifica URL-ul
  private productService = inject(ProductService);

  recommendedProducts: Product[] = [];
  isLoadingRecommendations = false;

  ngOnInit(): void {
    this.loadRecommendedProducts();
  }

  loadRecommendedProducts(): void {
    this.isLoadingRecommendations = true;
    // Exemplu: preia primele câteva produse sau o listă specială de recomandări
    this.productService.getAll().subscribe({ // S-ar putea să vrei un endpoint dedicat pentru recomandări
      next: (products) => {
        this.recommendedProducts = products.slice(0, 4); // Afișează primele 4 ca exemplu
        this.isLoadingRecommendations = false;
      },
      error: (err) => {
        console.error('Eroare la încărcarea produselor recomandate:', err);
        this.isLoadingRecommendations = false;
      }
    });
  }
}
</file>

<file path="frontend/src/app/login/login.component.html">
<!-- src/app/login/login.component.html -->
<div class="login-container">
  <mat-card class="login-card">
    <mat-card-header>
      <mat-card-title>Autentificare</mat-card-title>
      <mat-card-subtitle>Intră în contul tău</mat-card-subtitle>
    </mat-card-header>
    <mat-card-content>
      <form [formGroup]="loginForm" (ngSubmit)="onSubmit()">
        <mat-form-field appearance="outline" class="full-width">
          <mat-label>Nume de Utilizator</mat-label>
          <input matInput formControlName="username" placeholder="Ex: ion.popescu" required>
          <mat-icon matSuffix>person_outline</mat-icon>
          <mat-error *ngIf="f['username'].hasError('required')">
            Numele de utilizator este obligatoriu.
          </mat-error>
          <mat-error *ngIf="f['username'].hasError('minlength')">
            Numele de utilizator trebuie să aibă cel puțin 3 caractere.
          </mat-error>
        </mat-form-field>

        <mat-form-field appearance="outline" class="full-width">
          <mat-label>Parolă</mat-label>
          <input matInput [type]="hidePassword ? 'password' : 'text'" formControlName="password" required>
          <button mat-icon-button matSuffix (click)="togglePasswordVisibility()" type="button" [attr.aria-label]="'Ascunde/Arată parola'" [attr.aria-pressed]="hidePassword">
            <mat-icon>{{hidePassword ? 'visibility_off' : 'visibility'}}</mat-icon>
          </button>
          <mat-error *ngIf="f['password'].hasError('required')">
            Parola este obligatorie.
          </mat-error>
          <mat-error *ngIf="f['password'].hasError('minlength')">
            Parola trebuie să aibă cel puțin 6 caractere.
          </mat-error>
        </mat-form-field>

        <button mat-raised-button color="primary" type="submit" class="full-width login-button" [disabled]="isLoading || loginForm.invalid">
          <mat-spinner *ngIf="isLoading" diameter="20" mode="indeterminate" class="button-spinner"></mat-spinner>
          <span *ngIf="!isLoading">Intră în Cont</span>
        </button>
      </form>
    </mat-card-content>
    <mat-card-actions class="login-card-actions-center"> <!-- Am adăugat o clasă pentru centrare CSS -->
      <p class="signup-link">
        Nu ai cont? <a routerLink="/signup">Înregistrează-te aici!</a>
      </p>
    </mat-card-actions>
  </mat-card>
</div>
</file>

<file path="frontend/src/app/login/login.component.scss">
// src/app/login/login.component.scss
.login-container {
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: calc(100vh - 128px); 
  padding: 20px;
  background-color: #f5f5f5;
}

.login-card {
  width: 100%;
  max-width: 400px;
  padding: 20px;
  background-color: #1e1e1e; // Fundal mai închis pentru card
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3) !important;
  border-radius: 8px;
}

mat-card-header {
  text-align: center;
  padding-bottom: 20px;
  mat-card-title {
    font-size: 1.8em;
    color: #448AFF; // MODIFICAT: Albastru accent
  }
  mat-card-subtitle {
    font-size: 1em;
    color: #aaa;
  }
}

.full-width {
  width: 100%;
  margin-bottom: 18px;
}

.login-button {
  padding: 10px 0;
  font-size: 1.05em;
  display: flex;
  align-items: center;
  justify-content: center;

  .button-spinner {
    margin-right: 8px;
  }
}

// Scoate align="center" din HTML și folosește CSS
.login-card-actions-center {
  display: flex; // Adaugă flex pentru a putea centra
  justify-content: center; // Centrează conținutul pe orizontală
  margin-top: 16px;
  padding-top: 16px;
  border-top: 1px solid #eee;
}

.signup-link {
  text-align: center; // Redundant dacă .login-card-actions-center este flex și centrează
  font-size: 0.9em;
  color: #555;
  a {
    color: #448AFF; // MODIFICAT: Albastru accent
    text-decoration: none;
    font-weight: 500;
    &:hover {
      text-decoration: underline;
    }
  }
}

mat-form-field .mat-icon-button[matSuffix] {
  display: flex;
  align-items: center;
  justify-content: center;
}
</file>

<file path="frontend/src/app/login/login.component.ts">
// src/app/login/login.component.ts
import { Component, OnInit, inject } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ReactiveFormsModule, FormBuilder, FormGroup, Validators } from '@angular/forms';
import { Router, RouterModule, ActivatedRoute } from '@angular/router'; // ActivatedRoute pentru returnUrl
import { MatCardModule } from '@angular/material/card';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';


import { AuthService } from '../auth/auth.service'; // Serviciul de autentificare

@Component({
  selector: 'app-login',
  standalone: true,
  imports: [
    CommonModule,
    RouterModule, // Pentru link-ul de înregistrare
    ReactiveFormsModule,
    MatCardModule,
    MatFormFieldModule,
    MatInputModule,
    MatButtonModule,
    MatIconModule,
    MatSnackBarModule,
    MatProgressSpinnerModule
  ],
  templateUrl: './login.component.html',
  styleUrls: ['./login.component.scss']
})
export class LoginComponent implements OnInit {
  loginForm!: FormGroup;
  isLoading = false;
  hidePassword = true;
  private returnUrl: string = '/'; // Default redirect URL

  private fb = inject(FormBuilder);
  public authService = inject(AuthService); // Public pentru a fi accesibil în template (ex: pentru link signup)
  private router = inject(Router);
  private route = inject(ActivatedRoute); // Pentru a prelua returnUrl
  private snackBar = inject(MatSnackBar);

  ngOnInit(): void {
    this.loginForm = this.fb.group({
      username: ['', [Validators.required, Validators.minLength(3)]],
      password: ['', [Validators.required, Validators.minLength(6)]]
    });

    // Preia URL-ul de redirectare din query params, dacă există
    this.returnUrl = this.route.snapshot.queryParams['returnUrl'] || '/';

    // Dacă utilizatorul este deja logat, redirecționează-l
    if (this.authService.isLoggedIn()) {
        const userRole = this.authService.role;
        if (userRole === 'admin') {
            this.router.navigate(['/admin']);
        } else if (userRole === 'user') {
            this.router.navigate(['/user']);
        } else {
            this.router.navigate([this.returnUrl]); // Sau o pagină default
        }
    }
  }

  onSubmit(): void {
    if (this.loginForm.invalid) {
      this.snackBar.open('Nume de utilizator sau parolă invalidă.', 'OK', { duration: 3000 });
      this.loginForm.markAllAsTouched();
      return;
    }

    this.isLoading = true;
    const { username, password } = this.loginForm.value;

    this.authService.login(username, password).subscribe({
      next: (success) => {
        this.isLoading = false;
        if (success) {
          this.snackBar.open('Autentificare reușită!', 'OK', { duration: 2000 });
          const userRole = this.authService.role; // Preia rolul după login reușit
          
          // Redirecționează în funcție de rol sau la returnUrl
          if (this.returnUrl && this.returnUrl !== '/') {
            this.router.navigateByUrl(this.returnUrl);
          } else if (userRole === 'admin') {
            this.router.navigate(['/admin']);
          } else if (userRole === 'user') {
            this.router.navigate(['/user']);
          } else {
            this.router.navigate(['/']); // Fallback la pagina principală
          }
        } else {
          // AuthService gestionează deja afișarea erorii prin snackbar în cazul în care login-ul eșuează
          // dar putem adăuga un mesaj generic aici dacă metoda login returnează doar boolean
          // this.snackBar.open('Autentificare eșuată. Verificați credențialele.', 'Închide', { duration: 3000 });
        }
      },
      error: (err) => {
        // AuthService ar trebui să gestioneze eroarea și să afișeze un snackbar
        // Dacă nu, o facem aici.
        this.isLoading = false;
        const errorMessage = err.error?.message || err.message || 'Autentificare eșuată. Vă rugăm încercați din nou.';
        this.snackBar.open(errorMessage, 'Închide', { duration: 5000 });
        console.error('Login error:', err);
      }
    });
  }

  togglePasswordVisibility(): void {
    this.hidePassword = !this.hidePassword;
  }

  get f() { return this.loginForm.controls; }
}
</file>

<file path="frontend/src/app/shared/in-memory-data.service.ts">
// src/app/shared/in-memory-data.service.ts
import { Injectable } from '@angular/core';
import { InMemoryDbService, RequestInfo } from 'angular-in-memory-web-api';
import { Observable } from 'rxjs';
import { Product } from './models/product.model'; // Asigură-te că modelul Product e corect
// Importă și alte modele dacă vrei să le mock-uiești (Category, etc.)

@Injectable({
  providedIn: 'root'
})
export class InMemoryDataService implements InMemoryDbService {
  createDb(reqInfo?: RequestInfo): {} | Observable<{}> | Promise<{}> {
    const products: Product[] = [
      // Date mock pentru produse (folosește modelul Product actualizat)
      {
        id: 1,
        name: 'Laptop Gaming X1',
        description: 'Un laptop puternic pentru jocuri și sarcini intensive.',
        price: 5500.99,
        stockQuantity: 15,
        categoryId: 1, // Presupunând că există o categorie cu ID 1
        categoryName: 'Laptopuri',
        imageBase64: null, // Sau un string base64 valid
        specifications: [
          { definitionId: 1, name: 'Procesor', value: 'Intel Core i7-12700H', unit: '' },
          { definitionId: 2, name: 'RAM', value: '16', unit: 'GB' },
          { definitionId: 3, name: 'Stocare SSD', value: '1', unit: 'TB' }
        ]
      },
      {
        id: 2,
        name: 'Monitor LED UltraWide',
        description: 'Monitor curbat pentru o experiență vizuală imersivă.',
        price: 1800.00,
        stockQuantity: 25,
        categoryId: 2, // Presupunând că există o categorie cu ID 2
        categoryName: 'Monitoare',
        imageBase64: null,
        specifications: [
          { definitionId: 4, name: 'Diagonală', value: '34', unit: 'inch' },
          { definitionId: 5, name: 'Rezoluție', value: '3440x1440', unit: 'pixeli' }
        ]
      },
      // Adaugă mai multe produse mock aici
    ];

    const categories = [
        { id: 1, name: 'Laptopuri', description: 'Portabile performante'},
        { id: 2, name: 'Monitoare', description: 'Display-uri pentru PC'},
        { id: 3, name: 'Componente PC', description: 'Piese pentru asamblare PC'}
    ];

    const specificationDefinitions = [
        {id: 1, name: 'Procesor', unit: ''},
        {id: 2, name: 'RAM', unit: 'GB'},
        {id: 3, name: 'Stocare SSD', unit: 'TB'},
        {id: 4, name: 'Diagonală', unit: 'inch'},
        {id: 5, name: 'Rezoluție', unit: 'pixeli'},
        {id: 6, name: 'Tip Placă Video', unit: ''},
    ];


    // Returnează un obiect cu colecțiile tale. Numele proprietăților
    // (ex: 'products') vor fi folosite ca segmente de URL pentru API-ul mock.
    return { products, categories, specificationDefinitions /* , alteColecții */ };
  }

  // Suprascrie genId pentru a te asigura că un produs nou primește un ID.
  // Dacă colecția este goală, această metodă returnează numărul inițial (11).
  // Dacă colecția nu este goală, metoda returnează cel mai mare ID + 1.
  genId<T extends { id?: number }>(collection: T[], collectionName: string): number {
    // Verifică dacă `id` este definit și este un număr pentru fiecare element
    const validIds = collection.map(item => item.id).filter(id => typeof id === 'number') as number[];
    return validIds.length > 0 ? Math.max(...validIds) + 1 : 1;
  }
}
</file>

<file path="frontend/src/app/shared/material.module.ts">
// src/app/shared/material.module.ts
import { NgModule } from '@angular/core';
import { MatButtonModule } from '@angular/material/button';
import { MatCardModule } from '@angular/material/card';
import { MatCheckboxModule } from '@angular/material/checkbox';
import { MatChipsModule } from '@angular/material/chips';
import { MatDialogModule } from '@angular/material/dialog';
import { MatDividerModule } from '@angular/material/divider';
import { MatExpansionModule } from '@angular/material/expansion';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatIconModule } from '@angular/material/icon';
import { MatInputModule } from '@angular/material/input';
import { MatListModule } from '@angular/material/list';
import { MatMenuModule } from '@angular/material/menu';
import { MatPaginatorModule } from '@angular/material/paginator';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { MatSelectModule } from '@angular/material/select';
import { MatSidenavModule } from '@angular/material/sidenav';
import { MatSnackBarModule } from '@angular/material/snack-bar';
import { MatSortModule } from '@angular/material/sort';
import { MatTableModule } from '@angular/material/table';
import { MatToolbarModule } from '@angular/material/toolbar';
import { MatTooltipModule } from '@angular/material/tooltip'; // Util pentru hint-uri

const materialModules = [
  MatButtonModule,
  MatCardModule,
  MatCheckboxModule,
  MatChipsModule,
  MatDialogModule,
  MatDividerModule,
  MatExpansionModule,
  MatFormFieldModule,
  MatIconModule,
  MatInputModule,
  MatListModule,
  MatMenuModule,
  MatPaginatorModule,
  MatProgressSpinnerModule,
  MatSelectModule,
  MatSidenavModule,
  MatSnackBarModule,
  MatSortModule,
  MatTableModule,
  MatToolbarModule,
  MatTooltipModule,
];

@NgModule({
  imports: materialModules,
  exports: materialModules
})
export class MaterialModule { }
</file>

<file path="frontend/src/app/shared/models/product.model.ts">
import { SpecificationValue } from "./specification-value.model";

export interface Product {
  id?: number;
  name: string;
  description?: string;
  price: number;
  stockQuantity: number;
 // imageBase64?: string | null;
  categoryId: number;
  categoryName?: string;
  specifications?: SpecificationValue[];
}

export type { SpecificationValue };
</file>

<file path="frontend/angular.json">
{
  "$schema": "./node_modules/@angular/cli/lib/config/schema.json",
  "version": 1,
  "newProjectRoot": "projects",
  "projects": {
    "magazin-calculatoare": {
      "projectType": "application",
      "schematics": {
        "@schematics/angular:component": {
          "style": "scss"
        }
      },
      "root": "",
      "sourceRoot": "src",
      "prefix": "app",
      "architect": {
        "build": {
          "builder": "@angular-devkit/build-angular:application",
          "options": {
            "outputPath": "dist/magazin-calculatoare",
            "index": "src/index.html",
            "browser": "src/main.ts",
            "polyfills": [
              "zone.js"
            ],
            "tsConfig": "tsconfig.app.json",
            "inlineStyleLanguage": "scss",
            "assets": [
              {
                "glob": "**/*",
                "input": "public"
              }
            ],
            "styles": [
              "@angular/material/prebuilt-themes/azure-blue.css",
              "src/styles.scss"
            ],
            "scripts": [],
            "server": "src/main.server.ts",
            "outputMode": "server",
            "ssr": {
              "entry": "src/server.ts"
            }
          },
          "configurations": {
            "production": {
              "budgets": [
                {
                  "type": "initial",
                  "maximumWarning": "500kB",
                  "maximumError": "1MB"
                },
                {
                  "type": "anyComponentStyle",
                  "maximumWarning": "4kB",
                  "maximumError": "8kB"
                }
              ],
              "outputHashing": "all"
            },
            "development": {
              "optimization": false,
              "extractLicenses": false,
              "sourceMap": true
            }
          },
          "defaultConfiguration": "production"
        },
        "serve": {
          "builder": "@angular-devkit/build-angular:dev-server",
          "configurations": {
            "production": {
              "buildTarget": "magazin-calculatoare:build:production"
            },
            "development": {
              "buildTarget": "magazin-calculatoare:build:development",
              "proxyConfig": "proxy.conf.json"
            }
          },
          "defaultConfiguration": "development"
        },
        "extract-i18n": {
          "builder": "@angular-devkit/build-angular:extract-i18n"
        },
        "test": {
          "builder": "@angular-devkit/build-angular:karma",
          "options": {
            "polyfills": [
              "zone.js",
              "zone.js/testing"
            ],
            "tsConfig": "tsconfig.spec.json",
            "inlineStyleLanguage": "scss",
            "assets": [
              {
                "glob": "**/*",
                "input": "public"
              }
            ],
            "styles": [
              "src/themes/dark-blue-theme.scss",
              "src/styles.scss"
            ],
            "scripts": []
          }
        }
      }
    }
  },
  "cli": {
    "analytics": false
  }
}
</file>

<file path="frontend/package.json">
{
  "name": "magazin-calculatoare",
  "version": "0.0.0",
  "scripts": {
    "ng": "ng",
    "start": "ng serve",
    "build": "ng build",
    "watch": "ng build --watch --configuration development",
    "test": "ng test",
    "serve:ssr:magazin-calculatoare": "node dist/magazin-calculatoare/server/server.mjs",

    "//": "--- Scripturi adăugate pentru a rula backend și frontend simultan ---",
    "start:backend": "cd ../backend && mvn spring-boot:run",
    "start:frontend": "ng serve",
    "dev": "concurrently \"npm:start:frontend\" \"npm:start:backend\""
  },
  "private": true,
  "dependencies": {
    "@angular/animations": "19.2.9",
    "@angular/cdk": "^19.2.11",
    "@angular/common": "^19.2.0",
    "@angular/compiler": "^19.2.0",
    "@angular/core": "^19.2.0",
    "@angular/forms": "^19.2.0",
    "@angular/material": "^19.2.11",
    "@angular/platform-browser": "^19.2.0",
    "@angular/platform-browser-dynamic": "^19.2.0",
    "@angular/platform-server": "^19.2.0",
    "@angular/router": "^19.2.0",
    "@angular/ssr": "^19.2.10",
    "angular-in-memory-web-api": "^0.19.0",
    "express": "^4.18.2",
    "rxjs": "~7.8.0",
    "tslib": "^2.3.0",
    "zone.js": "~0.15.0"
  },
  "devDependencies": {
    "@angular-devkit/build-angular": "^19.2.10",
    "@angular/cli": "^19.2.10",
    "@angular/compiler-cli": "^19.2.0",
    "@types/express": "^4.17.17",
    "@types/jasmine": "~5.1.0",
    "@types/node": "^18.18.0",
    "concurrently": "^9.1.2",
    "jasmine-core": "~5.6.0",
    "karma": "~6.4.0",
    "karma-chrome-launcher": "~3.2.0",
    "karma-coverage": "~2.2.0",
    "karma-jasmine": "~5.1.0",
    "karma-jasmine-html-reporter": "~2.1.0",
    "ts-node": "^10.9.2",
    "typescript": "~5.7.2"
  }
}
</file>

</files>
